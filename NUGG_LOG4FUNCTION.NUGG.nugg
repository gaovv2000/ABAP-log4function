<?xml version="1.0" encoding="iso-8859-1"?>
<nugget name="LOG4FUNCTION.NUGG">
 <FUGR SPRAS="E" AREA="ZLOGS_MAINT" AREAT="Extended Table Maintenance (Generated)">
  <mainprogram NAME="SAPLZLOGS_MAINT" SQLX="X" DBAPL="S" DBNA="D$" SUBC="F" APPL="S" CNAM="GAOWW" CDAT="20160527" UNAM="GAOWW" UDAT="20160527" VERN="000003" RMAND="000" RLOAD="E" FIXPT="X" SDATE="20160527" STIME="101128" IDATE="20160527" ITIME="101128" LDBNAME="D$S" UCCHECK="X">
   <textPool/>
   <dynpros>
    <dynpro PROG="SAPLZLOGS_MAINT" DNUM="0001" FNUM="0001" BZMX="61 " BZBR="69 " MILI="192 " MICO="37 " MALI="0 " MACO="0 " NOLI="61 " NOCO="83 " VALP="0 " CUAN="G" SPRA="E" DGEN="20160527" TGEN="101128" DTEXT="View maint: Overview screen ZTBCLOGS_ACT">
     <dynprofield FNAM="TCTRL_ZTBCLOGS_ACT" DIDX="003B" FLG1="F8" FLG2="FC" FLG3="00" FILL="T" FMB1="00" FMB2="00" LENG="2C" LINE="01" COLN="02" LTYP="E" LANF="65" LBLK="01" LREP="01" AUTH="101" AGLT="00" ADEZ="00"/>
     <dynprofield FNAM="VIM_FRAME_FIELD" DIDX="003C" FLG1="80" FLG2="02" FLG3="88" FMB1="30" FMB2="40" LENG="3C" LINE="01" COLN="00" LTYP="T" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AGLT="00" ADEZ="00" STXT="____________________________________________________________"/>
     <dynprofield FNAM="*ZTBCLOGS_ACT-NAME" DIDX="001E" FLG1="20" FLG2="00" FLG3="00" FMB1="30" FMB2="A0" LENG="28" LINE="01" COLN="01" LTYP="T" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" ITYP="3" AGLT="00" ADEZ="00" STXT="Function Module"/>
     <dynprofield FNAM="*ZTBCLOGS_ACT-ACTIVE" DIDX="0006" FLG1="30" FLG2="00" FLG3="00" FMB1="30" FMB2="88" LENG="28" LINE="01" COLN="02" LTYP="T" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" ITYP="4" AGLT="00" ADEZ="00" STXT="Active" RES1="X"/>
     <dynprofield FNAM="VIM_MARKED" DIDX="0001" FLG1="80" FLG2="00" FLG3="88" FILL="C" FMB1="00" FMB2="20" LENG="01" LINE="01" COLN="00" LTYP="T" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="102" AGLT="00" ADEZ="00" STXT="_"/>
     <dynprofield FNAM="ZTBCLOGS_ACT-NAME" DIDX="001E" FLG1="B0" FLG2="00" FLG3="80" FMB1="30" FMB2="20" LENG="1E" LINE="01" COLN="01" LTYP="T" LANF="65" LBLK="01" LREP="01" PAID="LIB" TYPE="CHAR" GRP1="KEY" ITYP="C" AGLT="1E" ADEZ="00" STXT="______________________________"/>
     <dynprofield FNAM="ZTBCLOGS_ACT-ACTIVE" DIDX="0006" FLG1="B0" FLG2="00" FLG3="81" FILL="C" FMB1="00" FMB2="08" LENG="01" LINE="01" COLN="02" LTYP="T" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="103" ITYP="C" AGLT="01" ADEZ="00" STXT="_" RES1="X"/>
     <dynprofield FNAM="VIM_POSI_PUSH" DIDX="0014" FLG1="80" FLG2="00" FLG3="88" FILL="P" FMB1="30" FMB2="00" LENG="14" LINE="3D" COLN="14" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="104" AGLT="00" ADEZ="00" STXT="____________________" RES1="                                                                                                                                                                        POSI"/>
     <dynprofield FNAM="VIM_POSITION_INFO" DIDX="001E" FLG1="80" FLG2="02" FLG3="88" FMB1="33" FMB2="00" LENG="1E" LINE="3D" COLN="29" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AGLT="00" ADEZ="00" STXT="______________________________"/>
     <dynprofield FNAM="OK_CODE" DIDX="0014" FLG1="80" FLG2="10" FLG3="08" FMB1="00" FMB2="00" LENG="14" LINE="FF" COLN="01" LTYP="O" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AGLT="00" ADEZ="00" STXT="____________________"/>
     <dynproflowsource>PROCESS BEFORE OUTPUT.
 MODULE LISTE_INITIALISIEREN.
 LOOP AT EXTRACT WITH CONTROL
  TCTRL_ZTBCLOGS_ACT CURSOR NEXTLINE.
   MODULE LISTE_SHOW_LISTE.
 ENDLOOP.
*
PROCESS AFTER INPUT.
 MODULE LISTE_EXIT_COMMAND AT EXIT-COMMAND.
 MODULE LISTE_BEFORE_LOOP.
 LOOP AT EXTRACT.
   MODULE LISTE_INIT_WORKAREA.
   CHAIN.
    FIELD ZTBCLOGS_ACT-NAME .
    FIELD ZTBCLOGS_ACT-ACTIVE .
    MODULE SET_UPDATE_FLAG ON CHAIN-REQUEST.
   ENDCHAIN.
   FIELD VIM_MARKED MODULE LISTE_MARK_CHECKBOX.
   CHAIN.
    FIELD ZTBCLOGS_ACT-NAME .
    MODULE LISTE_UPDATE_LISTE.
   ENDCHAIN.
 ENDLOOP.
 MODULE LISTE_AFTER_LOOP.</dynproflowsource>
    </dynpro>
   </dynpros>
   <source>*---------------------------------------------------------------------*
*    generated viewmaintenance function pool
*   generation date: 27.05.2016 at 10:11:28 by user GAOWW
*   view maintenance generator version: #001407#
*---------------------------------------------------------------------*
*******************************************************************
*   System-defined Include-files.                                 *
*******************************************************************
  INCLUDE LZLOGS_MAINTTOP.                   &quot; Global Data
  INCLUDE LZLOGS_MAINTUXX.                   &quot; Function Modules

*******************************************************************
*   include-files generated by view maintenance tool              *
*******************************************************************

*      view related include-files   (never change, please)        *
  INCLUDE LZLOGS_MAINTF00                         . &quot; subprograms
  INCLUDE LZLOGS_MAINTI00                         . &quot; PAI modules

*      general include-files        (never change, please)        *
  INCLUDE LSVIMFXX                                . &quot; subprograms
  INCLUDE LSVIMOXX                                . &quot; PBO modules
  INCLUDE LSVIMIXX                                . &quot; PAI modules

*******************************************************************
*   User-defined Include-files (if necessary).                    *
*******************************************************************
* INCLUDE LZLOGS_MAINTF...                   &quot; Subprograms
* INCLUDE LZLOGS_MAINTO...                   &quot; PBO-Modules
* INCLUDE LZLOGS_MAINTI...                   &quot; PAI-Modules</source>
  </mainprogram>
  <includeprograms>
   <include NAME="LSVIMDAT" SQLX="X" VARCL="X" SUBC="I" APPL="S" CNAM="SAP" CDAT="19950113" UNAM="SAP" UDAT="20080721" VERN="000075" LEVL="30A" RMAND="000" RLOAD="D" SDATE="20080721" STIME="122420" IDATE="20080721" ITIME="122421">
    <include_source>TABLES: e070, e071k, e071, tadir, dderr, tddat, objh.

TYPE-POOLS: cxtab, cmpwl, vimty, slctr, trwbo, scpr, slis, szadr.

CLASS: cl_abap_char_utilities DEFINITION LOAD.

* Adresspflege Übergangslösung anfang
TABLES: sadr, sadr2, sadr3, sadr4, sadr5.
DATA: sadr_keylen  TYPE i,             &quot;key length of table SADR
      sadr_namtab_read TYPE c.                              &quot;flag:

* Adresspflege Übergangslösung ende

DATA: maint_stat LIKE vimstatus.

FIELD-SYMBOLS: &lt;vim_ctotal&gt; TYPE ANY, &lt;vim_cextract&gt; TYPE ANY,
               &lt;vim_xtotal&gt; TYPE x, &lt;vim_xextract&gt; TYPE x,
               &lt;vim_total_struc&gt; TYPE ANY,
               &lt;vim_extract_struc&gt; TYPE ANY,
               &lt;vim_tot_txt_struc&gt; TYPE ANY,
               &lt;vim_ext_txt_struc&gt; TYPE ANY.
FIELD-SYMBOLS: &lt;f1&gt; TYPE ANY, &lt;name&gt; TYPE ANY, &lt;table1&gt; TYPE ANY,
               &lt;table2&gt; TYPE ANY, &lt;orig_key&gt; TYPE x,
               &lt;client&gt; TYPE ANY, &lt;vim_total_key&gt; TYPE ANY,
               &lt;vim_extract_key&gt; TYPE ANY,
               &lt;vim_xtotal_key&gt; TYPE x,
               &lt;vim_xextract_key&gt; TYPE x,
               &lt;vim_client_initial&gt; TYPE ANY.
* unicode
FIELD-SYMBOLS: &lt;table1_x&gt; TYPE x,
               &lt;table2_x&gt; TYPE x,
               &lt;f1_x&gt; TYPE x,
               &lt;table1_wa&gt; TYPE ANY,
               &lt;table1_wax&gt; TYPE x,
               &lt;f1_wax&gt; TYPE x,
               &lt;vim_corr_keyx&gt; TYPE x,
               &lt;initial_x&gt; TYPE x.
FIELD-SYMBOLS: &lt;mark&gt; TYPE ANY, &lt;action&gt; TYPE ANY,
               &lt;xmark&gt; TYPE ANY, &lt;xact&gt; TYPE ANY, &lt;initial&gt; TYPE ANY,
               &lt;status&gt; STRUCTURE vimstatus DEFAULT maint_stat,
               &lt;address_number&gt; TYPE ANY,
               &lt;user_exit_field&gt; TYPE ANY,                  &quot;#EC *
               &lt;replace_field&gt; TYPE ANY,
               &lt;vim_begdate&gt;     LIKE sy-datum,
               &lt;vim_new_begdate&gt; LIKE sy-datum,
               &lt;vim_enddate&gt;     LIKE sy-datum.
FIELD-SYMBOLS: &lt;vim_enddate_mask&gt; TYPE ANY,
               &lt;vim_mainkey_mask&gt; TYPE ANY,
               &lt;vim_prtfky_wa&gt; TYPE ANY, &lt;vim_prtfky_extract&gt; TYPE ANY,
               &lt;vim_prtfky_total&gt; TYPE ANY,
               &lt;vim_begdate_mask&gt; TYPE ANY,
               &lt;vim_collapsed_keyx&gt; TYPE x,
               &lt;vim_collapsed_logkeyx&gt; TYPE x.
FIELD-SYMBOLS: &lt;vim_collapsed_key_afx&gt; TYPE x,
               &lt;vim_merged_keyx&gt; TYPE x,
               &lt;vim_total_address_number&gt; TYPE ANY,
               &lt;vim_addr_handle_x&gt; TYPE x.
* Unicode
FIELD-SYMBOLS:
  &lt;vim_h_mkey&gt; TYPE x, &lt;vim_h_old_mkey&gt; TYPE x,
  &lt;vim_h_coll_mkey&gt; TYPE x, &lt;vim_h_merged_key&gt; TYPE x,
  &lt;vim_h_coll_bfkey&gt; TYPE x, &lt;vim_h_coll_logkey&gt; TYPE x,
  &lt;vim_f1_beforex&gt; TYPE x, &lt;vim_f1_afterx&gt; TYPE x,
  &lt;vim_mkey_beforex&gt; TYPE x, &lt;vim_mkey_afterx&gt; TYPE x.
FIELD-SYMBOLS:
  &lt;vim_tot_mkey_beforex&gt; TYPE x, &lt;vim_tot_mkey_afterx&gt; TYPE x,
  &lt;vim_ext_mkey_beforex&gt; TYPE x, &lt;vim_ext_mkey_afterx&gt; TYPE x,
  &lt;vim_old_mkey_beforex&gt; TYPE x, &lt;vim_old_mkey_afterx&gt; TYPE x,
  &lt;vim_collapsed_mkey_bfx&gt; TYPE x.
* for downward-compatibility only:
FIELD-SYMBOLS:
  &lt;vim_f1_before&gt;, &lt;vim_f1_after&gt;,
  &lt;vim_mkey_before&gt;, &lt;vim_mkey_after&gt;,
  &lt;vim_tot_mkey_before&gt;, &lt;vim_tot_mkey_after&gt;,
  &lt;vim_ext_mkey_before&gt;, &lt;vim_ext_mkey_after&gt;,
  &lt;vim_old_mkey_before&gt;, &lt;vim_old_mkey_after&gt;,
  &lt;vim_collapsed_key_af&gt;, &lt;vim_collapsed_logkey&gt;,
  &lt;vim_merged_key&gt;, &lt;vim_collapsed_key&gt;.
*
FIELD-SYMBOLS: &lt;subsetfield&gt; TYPE ANY,
               &lt;rdonlyfield&gt; TYPE ANY,                      &quot;#EC *
               &lt;value&gt; TYPE ANY,
               &lt;state&gt; STRUCTURE vimstatus DEFAULT maint_stat,
               &lt;vim_tctrl&gt; TYPE cxtab_control, &lt;vim_sellist&gt; TYPE table,
               &lt;vim_ck_sellist&gt; TYPE table,
               &lt;vim_field_value&gt; TYPE ANY,                  &quot;#EC *
               &lt;vim_scrform_name&gt; TYPE ANY,
               &lt;vim_auth_sellist&gt; TYPE table.
FIELD-SYMBOLS: &lt;table1_text&gt; TYPE ANY, &lt;table1_xtext&gt; TYPE x,
               &lt;total_text&gt; TYPE ANY, &lt;extract_text&gt; TYPE ANY,
               &lt;vim_xtotal_text&gt; TYPE x, &lt;vim_xextract_text&gt; TYPE x,
               &lt;action_text&gt; TYPE ANY,
               &lt;xact_text&gt; TYPE ANY,
               &lt;extract_enti&gt; TYPE ANY, &lt;vim_xextract_enti&gt; TYPE x,
               &lt;textkey&gt; TYPE ANY, &lt;initial_textkey&gt; TYPE ANY,
               &lt;textkey_x&gt; TYPE x, &lt;initial_textkey_x&gt; TYPE x,
               &lt;text_initial&gt; TYPE ANY, &lt;text_initial_x&gt; TYPE x,
               &lt;vim_text_enddate&gt; TYPE ANY.
FIELD-SYMBOLS: &lt;vim_texttab&gt; TYPE table,               &quot;SW Texttransl ..
*                            Type VIM_TAB_US/ .. /VIM_TAB_UL
               &lt;vim_read_langus&gt; TYPE table. &quot;SW Texttransl
*----------------------------------------------------------------------*
* Declaration of types                                                 *
*----------------------------------------------------------------------*
TYPES: vim_ko200_tab_type TYPE TABLE OF ko200.
TYPES: BEGIN OF state_vector,
         type(1)   TYPE c,             &quot; E=Einstufig Z=Zweistufig
         action(1) TYPE c,             &quot; S=Anz., U=Änd., A=Hinzuf., T=Tr
         mode(1)   TYPE c,             &quot; L=Liste, D=Detail
         data(1)   TYPE c, &quot; G=gesamt, X=Extract, D=Geloeschte
         mark(1)   TYPE c,             &quot; M=Markiert,  =Nicht Markiert
         delete(1) TYPE c,             &quot; D=Gelöscht,  =Nicht Gelöscht
         fill1(1)  TYPE c,             &quot;filler, not used
         fill2(1)  TYPE c,                                  &quot;     - &quot; -
       END OF state_vector.
TYPES: vim_tabkey TYPE tabl4096,
       BEGIN OF vim_tabkey_c,
        line(255) TYPE c,
       END OF vim_tabkey_c.
TYPES: BEGIN OF vim_ck_selcond,
         field LIKE vimnamtab-bastabfld,
         operator(2) TYPE c,
         hk1(1) TYPE c,
         value LIKE vimsellist-value,
         hk2(1) TYPE c,
         and LIKE vimsellist-and_or,
       END OF vim_ck_selcond.
TYPES: vimexclfldtab TYPE STANDARD TABLE OF vimexclfld
                          WITH DEFAULT KEY  INITIAL SIZE 10,
       BEGIN OF vimexclfldtabsline,
         viewname LIKE tvdir-tabname,
         excl_pos_tab TYPE vimexclfldtab,
         excl_rpl_tab TYPE vimexclfldtab,
         excl_que_tab TYPE vimexclfldtab,
       END OF vimexclfldtabsline,
       vimexclfldtabs TYPE SORTED TABLE OF vimexclfldtabsline
                           WITH UNIQUE KEY viewname,
       BEGIN OF vim_delim_entr_tl, &quot;indizes of delim. entries
         index1 TYPE i,            &quot;entries with mainkey in total
         index2 TYPE i,
         index3 TYPE i,            &quot;current entry in extract in
                                   &quot;collapsed mode
         index_corr(1) TYPE c,
       END OF vim_delim_entr_tl.
TYPES: BEGIN OF vim_collapsed_mkeys_tl,&quot;collapsed mainkeys
         mkey_bf TYPE vim_tabkey_c,
         mainkey TYPE vim_tabkey_c,
         log_key TYPE vim_tabkey_c,
       END OF vim_collapsed_mkeys_tl,
       BEGIN OF vim_merged_entr_tl,    &quot;merged entries
         new_key TYPE vim_tabkey,
         merged_key TYPE vim_tabkey,
         new_begdate TYPE d,
         new_enddate TYPE d,
         merged_begdate TYPE d,
         merged_enddate TYPE d,
       END OF vim_merged_entr_tl.
TYPES: BEGIN OF vim_ale_keyspec_objs,
         oname LIKE objh-objectname,
         otype LIKE objh-objecttype,
       END OF vim_ale_keyspec_objs,
       vim_flds_tab_type TYPE TABLE OF fieldname,           &quot;fieldlist
       vimnamtab_type TYPE TABLE OF vimnamtab.

* Definitionen für Texterfassung in mehreren Sprachen  &quot;SW Texttransl ..
CONSTANTS:
      ultra_short_tab TYPE i VALUE 32,
      very_short_tab TYPE i VALUE 48,
      short_tab TYPE i VALUE 64,
      middle_tab TYPE i VALUE 128,
      long_tab TYPE i VALUE 256,
      very_long_tab TYPE i VALUE 512,
      ultra_long_tab TYPE i VALUE 4096,
      vim_max_keylen_show TYPE i VALUE 120,
      vim_max_textfields TYPE i VALUE 8,   &quot;Anzahl Textfelder auf D0100
      vim_max_keyfields TYPE i VALUE 10.   &quot;  &quot;    Keyfelder   &quot;     &quot;

TYPES: vim_line_ul(ultra_long_tab)  TYPE c,
       vim_line_vl(very_long_tab)   TYPE c,
       vim_line_l(long_tab)         TYPE c,
       vim_line_m(middle_tab)       TYPE c,
       vim_line_s(short_tab)        TYPE c,
       vim_line_vs(very_short_tab)  TYPE c,
       vim_line_us(ultra_short_tab) TYPE c,

       vim_tab_ul  TYPE vim_line_ul OCCURS 0,
       vim_tab_vl  TYPE vim_line_vl OCCURS 0,
       vim_tab_l   TYPE vim_line_l OCCURS 0,
       vim_tab_m   TYPE vim_line_m OCCURS 0,
       vim_tab_s   TYPE vim_line_s OCCURS 0,
       vim_tab_vs  TYPE vim_line_vs OCCURS 0,
       vim_tab_us  TYPE vim_line_us OCCURS 0.

TYPES: BEGIN OF vim_variable_tab,
         valid_idx LIKE sy-index,      &quot; Index der gefüllten Tabelle
         tab_us TYPE vim_tab_us,       &quot; falls benutzt -&gt; valid_idx = 2
         tab_vs TYPE vim_tab_vs,       &quot;     &quot;                &quot;     = 3
         tab_s  TYPE vim_tab_s,
         tab_m  TYPE vim_tab_m,
         tab_l  TYPE vim_tab_l,
         tab_vl TYPE vim_tab_vl,
         tab_ul TYPE vim_tab_ul,
        END OF vim_variable_tab.

TYPES: BEGIN OF vim_tabdata_record,
         viewname   LIKE tvdir-tabname,
         sel_langus LIKE t002-spras OCCURS 0,
         all_langus(1) TYPE c,
         tabdata    TYPE vim_variable_tab,
       END OF vim_tabdata_record.

* lok. Hilfsvariable für Absprung in Langtextpflege über User-Exit
DATA: vim_internal_ltext_call(1) TYPE c.              &quot;.. SW Texttransl

* flags for ALS activation status
DATA: als_active(25) TYPE c,
      als_enabled(25) TYPE c.
* ALS declarations
DATA: als_sel_langus LIKE H_T002 OCCURS 0 WITH HEADER LINE,
      als_langus_selected(1) TYPE c.

*----------------------------------------------------------------------*
* Declaration of constants                                             *
*----------------------------------------------------------------------*
CONSTANTS:
      read(4) TYPE c VALUE &apos;READ&apos;,
      edit(4) TYPE c VALUE &apos;EDIT&apos;,
      read_and_edit(4) TYPE c VALUE &apos;RDED&apos;,
      vim_read_text(4) TYPE c VALUE &apos;RTXT&apos;,                 &quot;SW Textimp
        &quot; FCODE: Einlesen + zusätzl. Lesen der Texttab in allen Sprachen
      save(4) TYPE c VALUE &apos;SAVE&apos;,
      reset_list(4) TYPE c VALUE &apos;ORGL&apos;,
      reset_entry(4) TYPE c VALUE &apos;ORGD&apos;,
      switch_to_show_mode(4) TYPE c VALUE &apos;ANZG&apos;,
      switch_to_update_mode(4) TYPE c VALUE &apos;AEND&apos;.
CONSTANTS:
      switch_transp_to_upd_mode(4) TYPE c VALUE &apos;TRAE&apos;,
      get_another_view(4) TYPE c VALUE &apos;ATAB&apos;,
      back(4) TYPE c VALUE &apos;BACK&apos;,
      end(4) TYPE c VALUE &apos;ENDE&apos;,
      canc(4) TYPE c VALUE &apos;ABR &apos;,
      transport(4) VALUE &apos;TRSP&apos;,
      subset(1) TYPE c VALUE &apos;S&apos;,
      authority TYPE sychar01 VALUE &apos;A&apos;,
      ddic_marks(2)   TYPE c VALUE &apos;XB&apos;, &quot;ddic marks for ddic-flag
      vim_subset_marks(2) TYPE c VALUE &apos;SB&apos;, &quot;subset marks for ddic-flag
      vim_subset_marks_mult(4) TYPE c VALUE &apos;SBMA&apos;. &quot;including authority
CONSTANTS:                                                     &quot;and mult
      rdonly(1) TYPE c VALUE &apos;R&apos;,
      vim_hidden(1) TYPE c VALUE &apos;H&apos;,
      adrnbr(1) TYPE c VALUE &apos;A&apos;,
      usrexi(1) TYPE c VALUE &apos;X&apos;,
      client_length LIKE sy-fdpos VALUE &apos;3&apos;, &quot;in characters
      vim_datum_length LIKE sy-fdpos VALUE &apos;8&apos;,
      vim_spras_length LIKE sy-fdpos VALUE &apos;1&apos;,
      fname_length  TYPE i VALUE &apos;30&apos;, &quot;max. fieldname length
      compl_form_offs LIKE sy-fdpos VALUE &apos;6&apos;,
      corr_form_offs LIKE sy-fdpos VALUE &apos;11&apos;.
CONSTANTS:
      transporter LIKE tadir-pgmid VALUE &apos;R3TR&apos;, &quot;name of transport pgm
      transp_object LIKE tadir-object VALUE &apos;TABU&apos;, &quot;object to transport
      vim_view_type LIKE e071k-mastertype VALUE &apos;VDAT&apos;,
      vim_clus_type LIKE e071k-mastertype VALUE &apos;CDAT&apos;,
      vim_tran_type LIKE e071k-mastertype VALUE &apos;TDAT&apos;,
      vim_deleted_key LIKE tadir-pgmid VALUE &apos;(DL)&apos;,
      vim_unlockable_object LIKE e071k-mastertype VALUE &apos;(UO)&apos;,
      vim_lockable_object LIKE e071k-mastertype VALUE &apos;(LO)&apos;,
      vim_long_objname LIKE e071k-objname VALUE &apos;(?TABKEY?)&apos;.
CONSTANTS:
      vim_71k_name_length TYPE i VALUE &apos;30&apos;,
      vim_transport_denied(1) TYPE c VALUE &apos;V&apos;,
      bc_transport_denied(1) TYPE c VALUE &apos;Y&apos;, &quot;No trsp at bc_set act.
      sortflag_with_existency LIKE e071k-sortflag VALUE &apos;2&apos;,
      sortflag_without_existency LIKE e071k-sortflag VALUE &apos;3&apos;,
      e071_objfunc LIKE e071-objfunc VALUE &apos;K&apos;,
      state_vect_prefix(7) TYPE c VALUE &apos;STATUS_&apos;,
      state_vect_prefix_length TYPE i VALUE &apos;7&apos;,
      sap_cust_classes(2) TYPE c VALUE &apos;EG&apos;,    &quot;tabclasses to check
      sap_only_classes(1) TYPE c VALUE &apos;S&apos;,                 &quot;      -&quot;-
      sap_cust_ctrl_classes(1) TYPE c VALUE &apos;E&apos;,            &quot;      -&quot;-
      no_transport_classes(1) TYPE c VALUE &apos;L&apos;,             &quot;       -&quot;-
      no_transport_log_classes(1) TYPE c VALUE &apos;W&apos;,&quot;   -&quot;-
      application_delivery_classes(1) TYPE c VALUE &apos;A&apos;.
CONSTANTS:
      customizing_delivery_classes(3) TYPE c VALUE &apos;CEG&apos;,
      nbrd_texts_prefix(10) TYPE c VALUE &apos;SVIM_TEXT_&apos;,
      nbrd_texts_prefix_length TYPE i VALUE &apos;10&apos;,
      master_fpool(8) TYPE c VALUE &apos;SAPLSVIM&apos;,
      vim_position_info_len TYPE i VALUE &apos;30&apos;, &quot;length of dynpro field
      vim_position_info_lg1 TYPE i VALUE &apos;13&apos;, &quot;length of &apos;Eintrag&apos;
      vim_position_info_lg2 TYPE i VALUE &apos;6&apos;,  &quot;length of &apos;von&apos;
      vim_position_info_lg3 TYPE i VALUE &apos;10&apos;, &quot;max length of entry nbr.
      vim_reset(1) TYPE c VALUE &apos;O&apos;.
CONSTANTS:
      vim_replace(1) TYPE c VALUE &apos;R&apos;,
      vim_upgrade(1) TYPE c VALUE &apos;U&apos;,
      vim_direct_upgrade(1) TYPE c VALUE &apos;C&apos;,
      vim_undelete(1) TYPE c VALUE &apos;D&apos;,
      vim_delimit(1) TYPE c VALUE &apos;G&apos;,
      vim_delete(1) TYPE c VALUE &apos;L&apos;,
      vim_extedit(1) TYPE c VALUE &apos;E&apos;,
      vim_import(1) TYPE c VALUE &apos;I&apos;,
      vim_import_no_dialog TYPE c VALUE &apos;D&apos;,
      vim_import_with_dialog TYPE c VALUE &apos;H&apos;.
CONSTANTS:
      vim_time_dep_dpl_modif_form(30) TYPE c
                                  VALUE &apos;TIME_DEPENDENT_DISPLAY_MODIF&apos;,
      vim_view(1) TYPE c VALUE &apos;V&apos;,    &quot;OBJH-type for views
      vim_tabl(1) TYPE c VALUE &apos;S&apos;,    &quot;OBJH-type for tables
      vim_clst(1) TYPE c VALUE &apos;C&apos;,    &quot;OBJH-type for clusters
      vim_tran(1) TYPE c VALUE &apos;T&apos;,    &quot;OBJH-type for transact.
      vim_logo(1) TYPE c VALUE &apos;L&apos;,    &quot;OBJH-type for TLOGO-obj.
      vim_cust(4) TYPE c VALUE &apos;CUST&apos;, &quot;OBJ-category CUST
      vim_syst(4) TYPE c VALUE &apos;SYST&apos;. &quot;OBJ-category SYST
CONSTANTS:
      vim_cust_syst(4) TYPE c VALUE &apos;CUSY&apos;,    &quot;OBJ-category CUSY
      vim_appl(4) TYPE c VALUE &apos;APPL&apos;, &quot;OBJ-category APPL
      vim_noact(1) TYPE c VALUE &apos;N&apos;,   &quot;client state: no action
      vim_log(1)   TYPE c VALUE &apos;1&apos;,   &quot;client state: log chngs.
      vim_locked(1) TYPE c VALUE &apos;2&apos;,  &quot;client state: no chngs.
      vim_local_clnt(1) TYPE c VALUE &apos;3&apos;,      &quot;client state: no transp.
      vim_nocliindep_cust(1) TYPE c VALUE &apos;1&apos;, &quot;client state: ....
      vim_noreposichanges(1) TYPE c VALUE &apos;2&apos;, &quot;client state: ....
      vim_noreposiandcust(1) TYPE c VALUE &apos;3&apos;. &quot;client state: ....
CONSTANTS:
      vim_frm_text_upd_flag(19) TYPE c VALUE &apos;SET_TXT_UPDATE_FLAG&apos;,
      vim_frm_fill_textkey(19) TYPE c VALUE &apos;FILL_TEXTTAB_KEY_UC&apos;,
*      vim_frm_fill_textkey(16) TYPE c VALUE &apos;FILL_TEXTTAB_KEY&apos;,
      vim_max_trsp_keylength TYPE i VALUE &apos;120&apos;,
      vim_max_trsp_identical_key TYPE i VALUE &apos;119&apos;,
      vim_char_inttypes(5) TYPE c VALUE &apos;CDNST&apos;, &quot;char types for transp.
      vim_not_importable TYPE objimp VALUE &apos;1&apos;.

CONSTANTS:
* Type
  einstufig(1)       TYPE c VALUE &apos;E&apos;,
  zweistufig(1)      TYPE c VALUE &apos;Z&apos;,
* Action
  anzeigen(1)        TYPE c VALUE &apos;S&apos;,
  aendern(1)         TYPE c VALUE &apos;U&apos;,
  vim_ds_loeschen(1) TYPE c VALUE &apos;D&apos;,             &quot;MF BCSet-DS loeschen
  hinzufuegen(1)     TYPE c VALUE &apos;A&apos;,
  kopieren(1)        TYPE c VALUE &apos;C&apos;,
  profil_hinzufuegen TYPE c VALUE &apos;R&apos;,                      &quot;UFprofile
  transportieren(1)  TYPE c VALUE &apos;T&apos;,
  pruefen(1)         TYPE c VALUE &apos;P&apos;,
  zurueckholen(1)    TYPE c VALUE &apos;Z&apos;,
  task_add(1)        TYPE c VALUE &apos;E&apos;,
  task_del(1)        TYPE c VALUE &apos;F&apos;.
* Data
CONSTANTS:
  gesamtdaten(1)     TYPE c VALUE &apos;G&apos;,
  auswahldaten(1)    TYPE c VALUE &apos;X&apos;,
* Mark
  markiert(1)        TYPE c VALUE &apos;M&apos;,
  nicht_markiert(1)  TYPE c VALUE &apos; &apos;,
* Mode
  detail_bild(1)     TYPE c VALUE &apos;D&apos;,
  list_bild(1)       TYPE c VALUE &apos;L&apos;,
* Delete
  geloescht(1)       TYPE c VALUE &apos;D&apos;,
  nicht_geloescht(1) TYPE c VALUE &apos; &apos;,
* selected
  by_field_contents(1) TYPE c VALUE &apos;I&apos;,
* time dependent objects: display mode
  expanded(1)          TYPE c VALUE &apos; &apos;,
  collapsed(1)         TYPE c VALUE &apos;C&apos;,
  collapsed_displd(1)  TYPE c VALUE &apos;D&apos;.
* others
CONSTANTS:
  update_geloescht(1) TYPE c VALUE &apos;Y&apos;,
  neuer_geloescht(1)  TYPE c VALUE &apos;X&apos;,
  dummy_geloescht(1)  TYPE c VALUE &apos;Z&apos;,
  neuer_eintrag(1)    TYPE c VALUE &apos;N&apos;,
  uebergehen(1)       TYPE c VALUE &apos;*&apos;,
  leer(1)             TYPE c VALUE &apos;L&apos;,
  original(1)         TYPE c VALUE &apos; &apos;,
  bcset_only(1)       TYPE c VALUE &apos;B&apos;.      &quot;Show only data from bcset

CONSTANTS: vim_scrform_domain LIKE dd03p-domname VALUE &apos;TDFORM&apos;,
           vim_delim_date_domain LIKE dd03p-domname VALUE &apos;DATUM&apos;,
           vim_begdate_dtel1 LIKE dd03p-rollname VALUE &apos;BEGDATUM&apos;,
           vim_begdate_dtel2 LIKE dd03p-rollname VALUE &apos;BEGDA&apos;,
           vim_begdate_dtel3 LIKE dd03p-rollname VALUE &apos;ISH_BEGDT&apos;,
           vim_begdate_dtel4 LIKE dd03p-rollname VALUE &apos;VIM_BEGDA&apos;,
           vim_enddate_dtel1 LIKE dd03p-rollname VALUE &apos;ENDDATUM&apos;,
           vim_enddate_dtel2 LIKE dd03p-rollname VALUE &apos;ENDDA&apos;,
           vim_enddate_dtel3 LIKE dd03p-rollname VALUE &apos;ISH_ENDDT&apos;,
           vim_enddate_dtel4 LIKE dd03p-rollname VALUE &apos;VIM_ENDDA&apos;.
CONSTANTS: BEGIN OF vim_adrnbr_domains,
             dom1 LIKE dd03p-domname VALUE &apos;ADRNR&apos;,
             dom2 LIKE dd03p-domname VALUE &apos;CADRNR&apos;,
             dom3 LIKE dd03p-domname VALUE &apos;AD_ADDRNUM&apos;,
           END OF vim_adrnbr_domains,
           vim_addr_e071k_master TYPE sobj_name VALUE &apos;ADDRESS&apos;,
                                                &quot;UF688403/2000
           vim_addr_e071k_master_46 TYPE sobj_name VALUE &apos;ADDRESS_4.6&apos;.
&quot;UF688403/2000


CONSTANTS: vim_sbscr_prog LIKE d020s-prog VALUE &apos;SAPLSVCM&apos;,
           vim_sbscr_dnum LIKE d020s-dnum VALUE &apos;0101&apos;,
           vim_locked_in_corr LIKE vimstatus-corr_nbr VALUE &apos;LOCKED&apos;,
           vim_dummy_mainkey TYPE c VALUE &apos;K&apos;,
           vim_no_mkey_not_procsd(1) TYPE c VALUE &apos;X&apos;,
           vim_no_mkey_procsd_patt(2) TYPE c VALUE &apos;XY&apos;,
           vim_no_mkey_not_procsd_patt(2) TYPE c VALUE &apos;YX&apos;,
           vim_source_entry(1) TYPE c VALUE &apos;O&apos;,
           vim_clidep(1) TYPE x VALUE &apos;02&apos;,
           vim_auth_initial_check(1) TYPE c VALUE &apos;I&apos;,
           vim_auth_switch_to_update_mode(1) TYPE c VALUE &apos;U&apos;,
           vim_auth_requested_check(1) TYPE c VALUE &apos;R&apos;.

CONSTANTS: vim_tb_read_single_form(23) TYPE c
                                  VALUE &apos;TABLE_READ_SINGLE_ENTRY&apos;.
DATA:      compl_formname(30) TYPE c VALUE &apos;COMPL_&apos;,
           corr_formname(30) TYPE c VALUE &apos;CORR_MAINT_&apos;,
           BEGIN OF vim_read_single_form,
            prefix(18) TYPE c VALUE &apos;READ_SINGLE_ENTRY_&apos;,
            viewname LIKE tvdir-tabname,
           END OF vim_read_single_form,
           BEGIN OF vim_read_single_form_40,
            prefix(12) TYPE c VALUE &apos;READ_SINGLE_&apos;,
            viewname LIKE tvdir-tabname,
           END OF vim_read_single_form_40.

* state fields
DATA: status TYPE state_vector,
* BEGIN OF STATUS,
*   TYPE(1)   TYPE C VALUE &apos;2&apos;,        &quot; E=Einstufig Z=Zweistufig
*   ACTION(1) TYPE C VALUE &apos;U&apos;,   &quot; S=Anz., U=Änd., A=Hinzuf.,T=Tr
*   MODE(1)   TYPE C VALUE &apos;L&apos;,   &quot; L=Liste, D=Detail
*   DATA(1)   TYPE C VALUE &apos;G&apos;,   &quot; G=gesamt, X=Extract, D=Geloeschte
*   MARK(1)   TYPE C VALUE &apos; &apos;,        &quot; M=Markiert,  =Nicht Markiert
*   DELETE(1) TYPE C VALUE &apos; &apos;,        &quot; D=Gelöscht,  =Nicht Gelöscht
*   FILL1(1)  TYPE C VALUE &apos; &apos;,        &quot;filler, not used
*   FILL2(1)  TYPE C VALUE &apos; &apos;,        &quot;     - &quot; -
* END OF STATUS,

  BEGIN OF title,
   action(1) TYPE c VALUE &apos;U&apos;,    &quot; S=Anzeigen, U=Ändern, H=Hinzufügen
   mode(1)   TYPE c VALUE &apos;L&apos;,         &quot; L=Liste, D=Detail
   data(1)   TYPE c VALUE &apos;G&apos;,    &quot; G=Gesamt, X=Extrakt, D=Geloeschte
  END OF title.

* data containers and description
************************************************************************
DATA:  vim_for_alignment_only TYPE f,   &quot;never remove!!!
       vim_view_wax TYPE tabl8000,
       vim_ctabkeylen TYPE sy-fleng.    &quot;key length in characters

* other fields
DATA:
  vim_ale_keyspec_check(1) TYPE c,     &quot;Flag: .......
  vim_sync_keyspec_check(1) TYPE c,     &quot;Flag: keys locked by sync
  vim_sync_key_lock(1) TYPE c,  &quot;Flag: current dataset locked by sync
  vim_sync_key_lock_del(1) TYPE c, &quot;Flag: current dataset locked by sync
  vim_sctm_sourcesys TYPE logsys, &quot;Logic system to maintain locked data
  vim_ale_keyspec_objtab TYPE vim_ale_keyspec_objs OCCURS 1
                              WITH HEADER LINE,
  vim_delim_expa_excluded(1) TYPE c,   &quot;Flag: .....
  vim_auth_event(1) TYPE c,
  vim_auth_action(1) TYPE c.
DATA:
  vim_auth_rc LIKE sy-subrc, &quot;0-ok, 4-show only, 8-no_authority-&gt;exit
  vim_auth_msgid LIKE sy-msgid,
  vim_auth_msgno LIKE sy-msgno,
  vim_auth_msgv1 LIKE sy-msgv1,
  vim_auth_msgv2 LIKE sy-msgv2,
  vim_auth_msgv3 LIKE sy-msgv3,
  vim_auth_msgv4 LIKE sy-msgv4,
  vim_no_warning_for_cliindep(1) TYPE c, &quot;Flag: ......
  vim_begdate_is_ro(1) TYPE c, &quot;Flag: nokey-datefield is readonly
  vim_addr_field_selection LIKE addr1_fsel-fisel,  &quot;for ADDR_DIALOG_PREPA
  vim_addr_keywords LIKE addr1_keyw,    &quot;  - &quot; -
  vim_addr_titlebar LIKE sy-title,     &quot;  - &quot; -
  vim_addr_chng_deflt_comm_types LIKE addr_comm,   &quot;  - &quot; -
  vim_addr_frame_text LIKE addr_frame,  &quot;  - &quot; -
  vim_addr_excluded_functions LIKE vimexclfun     &quot;  - &quot; -
                              OCCURS 0 WITH HEADER LINE,
  vim_upgr_address_number LIKE addr1_sel-addrnumber.
DATA:
  vim_skip_adr_maint TYPE xfeld,                            &quot;UF120400
  vim_texttab_is_ro(1) TYPE c,
  vim_system_type(10) TYPE c,          &quot;SAP/CUSTOMER
  vim_nbr_of_scrfrm_pointers TYPE i,
  vim_enq_s_u_rc LIKE sy-subrc,
  vim_addr_e071k_tab LIKE TABLE OF e071k INITIAL SIZE 0,
  vim_addr_e071_tab LIKE TABLE OF e071 INITIAL SIZE 0,
  vim_tsadrv LIKE tsadrv,              &quot;Addresses: TSADRV-entry
  vim_addr_group LIKE tsadrv-addr_group,
  vim_addr_basetable LIKE dd03l-tabname,
  vim_addr_bastab_field LIKE dd03l-fieldname.
DATA:
  vim_show_consistency_alert(1) TYPE c VALUE &apos;X&apos;,
  vim_import_testmode(1) TYPE c,
  vim_import_forcemode(1) TYPE c,
  vim_import_profile(1) TYPE c,        &quot;Profilimport
  vim_profile_errorkey LIKE scpracpr-tablekey,
  vim_abort_saving(1) TYPE c,          &quot; &apos;X&apos; -&gt; Sichern abbrechen
  vim_import_no_message(1) TYPE c,
  vim_single_entry_function TYPE vimty_tcode,
  vim_single_entry_ins_key_input LIKE tvdir-flag,
  vim_import_mode_active(1) TYPE c.
DATA:
  vim_last_logged_message TYPE vimty_message,
  vim_copy_call_level TYPE i,
  vim_nr_entries_to_copy TYPE i,       &quot;SW 510129/1999
  vim_no_dialog(1) TYPE c,             &quot;flag:......
  vim_modify_screen(1) TYPE c,         &quot;Modul-lokales Flag
  vim_object LIKE vimdesc-viewname,
  vim_objfield LIKE vimnamtab-viewfield,
  vim_results_of_ext_mod LIKE vimmodres,
  vim_called_by_cluster(1) TYPE c,
  vim_calling_cluster TYPE vcl_name,
  vim_enqueue_range(1) TYPE c,
  vim_view_name LIKE vimdesc-viewname.
DATA:
  replace_mode(1) TYPE c,
  vim_restore_mode(1) TYPE c,
  vim_external_mode(1) TYPE c,
  vim_extcopy_mode(1) TYPE c,
  vim_special_mode(1) TYPE c,          &quot;O-reset,R-replace,U-upgrade
  vim_special_adjust_mode(1) TYPE c,
  vim_adjust_middle_level_mode(1) TYPE c,
  maint_mode TYPE c,
  update_flag(1) TYPE c VALUE &apos; &apos;,
  adrnbr_roflag(1) TYPE c VALUE &apos; &apos;.
DATA:
  block_sw    TYPE c VALUE &apos; &apos;,
  block_1     LIKE sy-tabix,
  block_2     LIKE sy-tabix,
  liste       LIKE d020s-dnum,
  detail      LIKE d020s-dnum,
  returncode  LIKE ocus-returncode,
  viewtitle   LIKE ocus-tabtitle,
  tablen      LIKE ocus-tablen,
  keylen      LIKE ocus-keylen,
  anzahl      TYPE i,
  answer(1)   TYPE c,
  neuer(1)    TYPE c VALUE &apos;N&apos;,
  ok_code     LIKE sy-ucomm,           &quot;(4) type c,    SW, wg Controls
  function    LIKE sy-ucomm,           &quot;(4) type c,
  relation(2) TYPE c VALUE &apos;EQ&apos;,
  counter LIKE sy-fdpos.
DATA:
  mark_extract TYPE i,
  mark_total   TYPE i,
  l LIKE sy-tabix,
  o TYPE i,
  old_nl LIKE sy-tabix,                                     &quot;GKPR - 0001009660
  pos TYPE i,
  refcnt TYPE i,
  newcnt TYPE i,
  orgcnt TYPE i,
  last_view_info LIKE dd02v-tabname,
  vim_last_objh_view LIKE dd02v-tabname,
  vim_act_dynp_view LIKE dd02v-tabname,
  vim_ale_edit_lock(1) TYPE c,                              &quot;flag:.....
  vim_sync_edit_lock(1) TYPE c,
  vim_ale_msgid LIKE sy-msgid,
  vim_ale_msgno LIKE sy-msgno,
  vim_ale_msgv1 LIKE sy-msgv1,
  vim_ale_msgv2 LIKE sy-msgv2,
  vim_ale_msgv3 LIKE sy-msgv3,
  vim_ale_msgv4 LIKE sy-msgv4.
DATA:
  last_corr_number LIKE e070-trkorr,
  fill_extr_first_proc TYPE c,       &quot;flag: Fill_extract first time proc
* F(30) TYPE C,  &quot;4.0 name extension &quot;max. Länge ABAP-Feldnamen: 30 Zchn
  f LIKE d021s-fnam,
* SUBSETID_RECEIVED TYPE C,          &quot;flag: subset ID already received
  e071k_tab_modified TYPE c,                                &quot;flag:
  sel_field_for_replace(30) TYPE c,    &quot;field selected for replace
*  sel_field_for_replace_l(30) TYPE c,  &quot;field selected for replace long
* XB H655767
  sel_field_for_replace_l(40) type c,  &quot;field selected for replace long
* CORR_NBR LIKE TADIR-KORRNUM,       &quot;current corr.nbr
  corr_nbr LIKE e070-trkorr,           &quot;current corr.nbr
  master_type LIKE tadir-object VALUE &apos;TABU&apos;, &quot;master object to transp.
  master_name LIKE tadir-obj_name,     &quot;name of object to transport
  vim_client_state LIKE t000-cccoractiv,   &quot; state of client for transport
  get_corr_keytab(1) TYPE c,           &quot;Flag: keytab is to read
  last_ext_modif_view LIKE tvdir-tabname,                   &quot;flag:
  deta_mark_safe(1) TYPE c,
  ignored_entries_exist(1) TYPE c,                          &quot;flag:
  corr_action(1) TYPE c,             &quot;current action for UPDATE_CORR_KEY
  replace_texttable_field(1) TYPE c, &quot;flag: replace function for textfld
  nbrd_texts_alr_read(1) TYPE c.     &quot;flag: texts from SVIM already read
DATA:
  svim_text_001(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_002(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_003(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_004(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_005(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_006(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_007(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_008(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_009(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_010(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_011(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_012(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_013(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_014(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_015(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_016(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_017(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_018(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_019(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_020(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_021(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_022(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_023(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_024(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_025(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_026(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_027(13) TYPE c,            &quot;numbered text of SVIM
  svim_text_028(06) TYPE c,            &quot;numbered text of SVIM
  svim_text_029(20) TYPE c,            &quot;numbered text of SVIM
  svim_text_030(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_031(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_032(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_033(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_034(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_035(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_036(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_037(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_038(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_039(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_040(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_041(20) TYPE c,            &quot;numbered text of SVIM
  svim_text_042(20) TYPE c,            &quot;numbered text of SVIM
  svim_text_043(40) TYPE c,            &quot;numbered text of SVIM
  svim_text_044(40) TYPE c,            &quot;numbered text of SVIM
  svim_text_045(20) TYPE c,            &quot;numbered text of SVIM
  svim_text_046(20) TYPE c,            &quot;numbered text of SVIM
  svim_text_104(19) TYPE c,            &quot;numbered text of SVIM
  svim_text_p01(20) TYPE c,            &quot;numbered text of SVIM
  svim_text_p02(20) TYPE c,            &quot;numbered text of SVIM
  svim_text_p03(20) TYPE c,            &quot;numbered text of SVIM
  svim_text_prb(40) TYPE c,            &quot;numbered text of SVIM
  svim_text_prc(40) TYPE c,            &quot;numbered text of SVIM
  svim_text_pre(40) TYPE c,            &quot;numbered text of SVIM
  svim_text_prf(70) TYPE c,            &quot;numbered text of SVIM
  svim_text_prg(70) TYPE c,            &quot;numbered text of SVIM
  svim_text_pri(40) TYPE c,            &quot;numbered text of SVIM
  svim_text_prj(40) TYPE c.            &quot;numbered text of SVIM
DATA:
      TCTRL_MEREP_801T TYPE TABLE OF merep_801T,
      TCTRL_MEREP_807 TYPE TABLE OF merep_807.
DATA:
  vim_marked(1) TYPE c,                &quot;mark-checkbox field
  vim_frame_field LIKE dd25v-ddtext,   &quot;name of frame (subset fields only)
  vim_position_info(42) TYPE c,        &quot;field for &apos;entry x of y&apos;
  vim_position_info_mask(42) TYPE c, &quot;mask for field for &apos;entry x of y&apos;
  vim_fpool_name LIKE trdir-name,
  vim_posi_push(25) TYPE c,          &quot;push button to posit on list scrn
  temporal_delimitation_happened TYPE c,                    &quot;flag: ....
  vim_mkey_after_exists(1) TYPE c,                          &quot;flag: ....
  vim_no_mainkey_exists(1) TYPE c,                          &quot;flag: ....
  nbr_of_added_dummy_entries TYPE i,   &quot;for function NEWL: ...
  vim_next_screen LIKE tvdir-liste,    &quot;next screen number
  vim_leave_screen(1) TYPE c,          &quot;flag: leave screen necessary
  vim_prtfky_assigned(1) TYPE c,                            &quot;flag...
* VIM_EXTRACT_MODIFIED(1) TYPE C,    &quot;flag...
  vim_temp_delim_alr_checked(1) TYPE c,                     &quot;flag...
  vim_ignore_collapsed_mainkeys(1) TYPE c,                  &quot;flag...
  vim_corr_obj_viewname LIKE tvdir-tabname.
DATA:
  vim_last_source_system LIKE tadir-srcsystem,
  vim_slct_functiontext(40) TYPE c,&quot;HCG HW711274 Cust.Mess. 140253 2004
  vim_comp_menue_text(40) TYPE c,
  vim_key_alr_checked(1) TYPE c,       &quot;flag: .....
  vim_keyrange_alr_checked(1) TYPE c,  &quot;flag: .....
  vim_prt_fky_flds_updated(1) TYPE c,  &quot;flag: .....
  vim_exit_11_12_active(1) TYPE c,     &quot;flag: .....
  BEGIN OF vim_default_rfc_dest,       &quot;global vector for default
    viewname LIKE tvdir-tabname,       &quot;RFC-destination
    rfcdest LIKE rfcdes-rfcdest,
  END OF vim_default_rfc_dest.
DATA:
  BEGIN OF vim_default_upgr_clnt,      &quot;global vector for default
    viewname LIKE tvdir-tabname,        &quot;client for upgrade
    client LIKE sy-mandt,
  END OF vim_default_upgr_clnt,
  vim_title_name LIKE vimdesc-ddtext,
  vim_tabctrl_active(1) TYPE c,
  vim_tc_cols TYPE cxtab_column,
  vim_local_char1(1) TYPE c.           &quot;Modul-lok. Hilfsvariable

* data for time-dependent routines (VCX)
FIELD-SYMBOLS: &lt;key_date&gt; TYPE ANY.
DATA: BEGIN OF d0001_field_tab OCCURS 10,
        begin TYPE d, end TYPE d, mark(1) TYPE c,
      END OF d0001_field_tab,
      d0001_cursor TYPE i,
      BEGIN OF d0001_status,
        type(1)   TYPE c,
        action(1) TYPE c,
        mode(1)   TYPE c,
        data(1)   TYPE c,
        mark(1)   TYPE c,
        delete(1) TYPE c,
        fill1(1)  TYPE c,              &quot;filler, not used
        fill2(1)  TYPE c,                                   &quot;     - &quot; -
        spec_mode TYPE c,
      END OF d0001_status.
DATA: d0001_input_flag(1) TYPE c,
      vim_mainkey TYPE vim_tabkey_c,   &quot;field for mainkey (prt. forkey)
      current_date TYPE d,
      date_to_delimit TYPE d,
      date_to_posit TYPE d,
      vim_old_viewkey TYPE vim_tabkey_c,
      date_safe TYPE d,
      vim_old_st_selected(1) TYPE c,
      BEGIN OF vim_memory_id_1,  &quot;memory-ID for vim_collapsed_entries
        viewname LIKE vimdesc-viewname,
        user     LIKE sy-uname,
      END OF vim_memory_id_1.
DATA: BEGIN OF vim_memory_id_2,  &quot;memory-ID for date subscreen data
        viewname LIKE vimdesc-viewname,
        user     LIKE sy-uname,
      END OF vim_memory_id_2,
      vim_date_mask(8) TYPE c VALUE &apos;++++++++&apos;,
      vim_coll_mkeys_first(1) TYPE c,
      vim_merge_begin TYPE i,
      vim_merge_end TYPE i,
      vim_begdate_entered(1) TYPE c,
      BEGIN OF vim_begdate_name,
        tabname LIKE vimdesc-viewname,
        dash(1) TYPE c VALUE &apos;-&apos;,
        fieldname LIKE vimnamtab-viewfield,
      END OF  vim_begdate_name.
DATA: BEGIN OF vim_enddate_name,
        tabname LIKE vimdesc-viewname,
        dash(1) TYPE c VALUE &apos;-&apos;,
        fieldname LIKE vimnamtab-viewfield,
      END OF  vim_enddate_name,
      vim_last_coll_mainkeys_ix TYPE i,
      vim_coll_mainkeys_beg_ix TYPE i VALUE 1,
      check_all_keyr_scnd_time(1) TYPE c, &quot;Flag: .........
      vim_tdep_title(19) TYPE c.
CONSTANTS: vim_init_date TYPE d VALUE &apos;00000000&apos;.         &quot;#EC VALUE_OK


* data for navigation within internal tables
DATA:
  aktuell(10) TYPE n,
  maximal(10) TYPE n,
  index     LIKE sy-tabix,
  exind     LIKE sy-tabix,
  mandant   LIKE sy-mandt,
  curline   LIKE sy-tabix,             &quot;Cursor-Position in Tab.
  curpage   LIKE sy-tabix VALUE 1,     &quot;aktuelle Seite
  firstline LIKE sy-tabix VALUE 1,
  nextline  LIKE sy-tabix VALUE 1,
                            &quot;Pos. erste Zeile der akt. Seite in Tab.
  anz_lines LIKE sy-tabix,             &quot;Anzahl vorhandener Tab.-Zeilen
  anz_pages LIKE sy-tabix,             &quot;Anzahl vorhandener Tab.-Seiten
  maxlines  LIKE sy-tabix,             &quot;Anzahl vorhandener Tab.-Zeilen
  destpage  LIKE sy-tabix,  &quot;Seite, auf die geblättert werden soll
  looplines LIKE sy-tabix.  &quot;Anzahl Step-loop-Zeilen im Dynpro

* declarations for activating bc-sets                 &quot;UF profile
TYPES: BEGIN OF vim_pr_tab_type,
                recnumber LIKE scprvals-recnumber,
                action TYPE char1,
                keys_fix,
                align TYPE f,
                keys(1024) TYPE x,
                txt_in_sy_langu_exsts TYPE xfeld,
                align2 TYPE f,
                textrecord TYPE vim_line_ul,
       END OF vim_pr_tab_type.
TYPES: BEGIN OF vim_pr_fields_type,
                recnumber LIKE scprvals-recnumber,
                keys_fix(1),
                fields TYPE vimty_fields_tab_type,
       END OF vim_pr_fields_type,
       vimsellist_type TYPE TABLE OF vimsellist,
       BEGIN OF  bc_key_type,   &quot;HCG like e072k but tabkey 255
          trkorr like e071k-trkorr,
          pgmid like e071k-pgmid,
          object like e071k-object,
          objname like e071k-objname,
          as4pos like e071k-as4pos,
          mastertype like e071k-mastertype,
          mastername like e071k-mastername,
          viewname like e071k-viewname,
          objfunc like e071k-objfunc,
          bc_tabkey like scpractr-tabkey,
          sortflag like e071k-sortflag,
          flag like e071k-flag,
          lang like e071k-lang,
          activity like e071k-activity,
       END OF bc_key_type,
       bc_keytab_type type table of bc_key_type,
* For managing entries coming from bc-sets
vim_bc_tab_logs type table of scpractr,
vim_bc_del_records type table of scprreca,
vim_bc_values_lang_type type table of scpr_vall.
DATA:  vim_pr_fields TYPE TABLE OF vim_pr_fields_type INITIAL SIZE 15,
       vim_pr_fields_wa TYPE vim_pr_fields_type,
       vim_coming_from_img,            &quot;&apos;Y&apos;: coming from IMG, &apos;N&apos;: not
       vim_pr_tab TYPE TABLE OF vim_pr_tab_type,
       vim_profile_values TYPE TABLE OF scpr_vals INITIAL SIZE 50,
       vim_bc_entry_list TYPE vimty_bc_entry_list_ttype,
       vim_bc_entry_list_wa TYPE vimty_bc_entry_list_type,
       vim_pr_activating, vim_bc_keys_fix(3),
       vim_set_from_bc_pbo,
       vim_bc_chng_allowed TYPE xfeld, &quot;fix bc-set values modifiable
       vim_pr_records TYPE i.    &quot;number of activated profile records
DATA:  vim_actlinks TYPE vimdesc-viewname. &quot;View: actlinks are valid for
DATA:  vim_actopts TYPE scpractopt, &quot;Activation options at BC-SET import
       vim_bcset_id TYPE scpr_id.                        &quot;Name of BC-SET
* field attributes in profiles
CONSTANTS: vim_profile_fix(3)    VALUE &apos;FIX&apos;,
           vim_profile_fixkey(3) VALUE &apos;FKY&apos;,
           vim_profile_use(3)    VALUE &apos;USE&apos;,
           vim_profile_key(3)    VALUE &apos;KEY&apos;,
           vim_profile_usekey(3) VALUE &apos;UKY&apos;,
           vim_profile_var(3)    VALUE &apos;VAR&apos;,               &quot;824950
* for flag KEYS_FIX
           vim_pr_error    VALUE &apos;E&apos;,                       &quot;key error
           vim_pr_open     VALUE &apos;O&apos;,  &quot;no key field fix
           vim_pr_some_fix VALUE &apos;S&apos;,                       &quot;some fix
           vim_pr_all_fix  VALUE &apos;A&apos;,  &quot;all key fields fix
* others
           vim_pr_into_view VALUE &apos;V&apos;,
           vim_profile_found VALUE &apos;X&apos;,
           vim_pr_imp_unchecked VALUE &apos;Y&apos;,
           vim_writing_bc_imp_log VALUE &apos;W&apos;.
DATA:      vim_pr_stat_txt_me LIKE smp_dyntxt,  &quot;dynamic texts for dynpro
           vim_pr_stat_txt_ch LIKE smp_dyntxt,
           vim_pr_stat_txt_ta LIKE smp_dyntxt,
           vim_pr_stat_txt_or LIKE smp_dyntxt.
* internal tables
DATA: vim_adj_header LIKE vimdesc OCCURS 1,
      vim_adj_namtab LIKE vimnamtab OCCURS 0,
      vim_adj_dbasellist LIKE vimsellist OCCURS 0.
DATA: vim_locked_addresses LIKE SORTED TABLE OF adrc-addrnumber
                           WITH UNIQUE KEY table_line
                           INITIAL SIZE 10
                           WITH HEADER LINE.

DATA: BEGIN OF vim_addresses_to_save OCCURS 10,
        viewname LIKE tvdir-tabname,
        addrnumber LIKE adrc-addrnumber,
        handle LIKE addr1_dia-handle,
      END OF vim_addresses_to_save.

DATA: BEGIN OF textpool_tab OCCURS 30.                       &quot;textpool
        INCLUDE STRUCTURE textpool.
DATA: END OF textpool_tab.

DATA: BEGIN OF exclude_tab OCCURS 10,   &quot;fields to exclude from repl
        field LIKE d021s-fnam,         &quot;functions (old version)
      END OF exclude_tab.

DATA: excl_rpl_tab TYPE vimexclfldtab  &quot;fields to exclude from repl
        WITH HEADER LINE,
      excl_que_tab TYPE vimexclfldtab  &quot;fields to exclude from query
        WITH HEADER LINE,
      excl_pos_tab TYPE vimexclfldtab  &quot;fields to exclude from posit
        WITH HEADER LINE,
      vim_excl_xxx_tab_safe TYPE vimexclfldtabs &quot;safe for all excl tabs
        WITH HEADER LINE.

DATA: BEGIN OF vim_corr_objtab OCCURS 10.       &quot;transport objects on the
        INCLUDE STRUCTURE e071.       &quot;vim-object level
DATA:   lockable(1) TYPE c,
      END OF vim_corr_objtab.

DATA: BEGIN OF vim_corr_entryobjtab OCCURS 10.  &quot;transport objects on the
        INCLUDE STRUCTURE ko200.       &quot;vim-obj-entries level
DATA:   lockable(1) TYPE c,
      END OF vim_corr_entryobjtab.

DATA: BEGIN OF e071k_tab OCCURS 100.    &quot;keys of changed entries
        INCLUDE STRUCTURE e071k.       &quot;(used as parameter for VIEWPROC)
DATA: END OF e071k_tab.

DATA: vim_alv_fcat TYPE slis_t_fieldcat_alv,  &quot;ABAP List Viewer
*      vim_alv_excluding TYPE slis_t_extab,
*      vim_alv_special_groups TYPE slis_t_sp_group_alv,
*      vim_alv_sort TYPE slis_t_sortinfo_alv,
*      vim_alv_sel_hide TYPE slis_sel_hide_alv,
      vim_alv_events TYPE slis_t_event,
*      vim_alv_event_exit TYPE slis_t_event_exit,
      vim_alv_print TYPE slis_print_alv,
      vim_alv_layout TYPE slis_layout_alv,
      vim_alv_variant LIKE disvariant,
      vim_var_save, vim_var_default, vim_alv_value_length TYPE intlen,
      vim_alv_called_by TYPE char30,
      alv_value_tab TYPE TABLE OF tabl8000 INITIAL SIZE 500.
*DATA: BEGIN OF alv_value_tab OCCURS 1,
*      line(4096),
*      END OF alv_value_tab.

DATA: align_value_tab TYPE f,
      BEGIN OF value_tab OCCURS 1,     &quot;Printing with ALV ==&gt;
        line(4096),                                         &quot;
      END OF value_tab.                                      &quot;obsolete

DATA: BEGIN OF structure_table OCCURS 20.   &quot;Printing with ALV ==&gt;
        INCLUDE STRUCTURE dfies.                           &quot;
DATA: END OF structure_table.                               &quot;obsolete

DATA: vim_list_header TYPE slis_t_listheader. &quot;List header for ALV-list

DATA: vim_delim_entries TYPE STANDARD TABLE  &quot;indizes of delim. entries
        OF vim_delim_entr_tl WITH DEFAULT KEY INITIAL SIZE 10
        WITH HEADER LINE.

DATA: BEGIN OF vim_sval_tab OCCURS 1.  &quot;fields for POPUP_GET_VALUES
        INCLUDE STRUCTURE sval.
DATA: END OF vim_sval_tab.

DATA: vim_collapsed_mainkeys TYPE STANDARD TABLE  &quot;collapsed mainkeys
        OF vim_collapsed_mkeys_tl WITH DEFAULT KEY INITIAL SIZE 1
        WITH HEADER LINE.

DATA: vim_merged_entries TYPE STANDARD TABLE      &quot;merged entries
        OF vim_merged_entr_tl WITH DEFAULT KEY INITIAL SIZE 1
        WITH HEADER LINE.

DATA: BEGIN OF vim_copied_indices OCCURS 10,
        ix LIKE sy-tabix, ex_ix LIKE sy-tabix, level TYPE i,
      END OF vim_copied_indices.

DATA: vim_wheretab LIKE vimwheretb OCCURS 10,
      imp_results TYPE slctr_tables_keys WITH HEADER LINE.

* Datencontainer für Texttabelle in mehreren Sprachen     &quot;SW Texttransl
DATA: vim_texttab_container TYPE vim_tabdata_record OCCURS 0
      WITH HEADER LINE,  &quot;da &apos;read table .. assigning &lt;fs&gt;&apos; nicht unterst
      vim_texttab_container_index LIKE sy-tabix,
      vim_d0100_fdescr_ini TYPE vimty_screen_fdescr_tab.

RANGES: mark_functions FOR sy-ucomm,   &quot;fct. which need marked entries
        adrnbr_domain FOR sadr-adrnr,  &quot;domains for address numbers
        exted_functions FOR sy-ucomm,  &quot;fct. used by external edit
        vim_guid_domain FOR vimnamtab-domname,  &quot;domains for GUIDs
        vim_begda_types FOR dd03p-rollname,  &quot;types for time-dependence
        vim_endda_types FOR dd03p-rollname.  &quot;types for time-dependence

* constants for documentation &apos;User Instructions&apos;
CONSTANTS: vim_docu_prog LIKE iwreferenc-programm VALUE &apos;SAPLSVIM&apos;,
           vim_docu_extension LIKE iwreferenc-spec_text
                   VALUE &apos;SM30 USER INTERFACE&apos;.

* Konstanten für Dynpro
CONSTANTS: vim_template_dynpro TYPE x VALUE &apos;20&apos;,  &quot; Vorlagedynpro
           vim_standard_dynpro TYPE x VALUE &apos;C0&apos;.  &quot; Komprimierung ein

* Organisation criteria (linedependent authorisations)
DATA:  vim_oc_inst TYPE REF TO cl_viewfields_org_crit.

* Backup for DBA_SELLIST
DATA  vim_dba_sel_kept TYPE svorg_vimsellist_type.

DATA  vim_first_recnum TYPE scprvals-recnumber.</include_source>
   </include>
   <include NAME="LSVIMF04" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000004" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122421" IDATE="20080721" ITIME="122421">
    <include_source>*&amp;---------------------------------------------------------------------*
*&amp;      Form  LOGS_ANALYSE
*&amp;---------------------------------------------------------------------*
*       Analyses table logs concerning the current maintenance view by
*       calling report RSVTPROT
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM logs_analyse.

  RANGES: sel_obj FOR objh-objectname,
          sel_type FOR objh-objecttype.

  sel_obj-sign = sel_type-sign = &apos;I&apos;.
  sel_obj-option = sel_type-option = &apos;EQ&apos;.
  IF vim_called_by_cluster NE space.
    sel_type-low = vim_clst.
    sel_obj-low = vim_calling_cluster.
  ELSE.
    sel_obj-low = x_header-viewname.
    IF x_header-bastab NE space
     AND x_header-maintview = x_header-viewname.
* table but no table-variant
      sel_type-low = vim_tabl.
    ELSE.
* view, view-variant, or table variant
      sel_type-low = vim_view.
    ENDIF.
  ENDIF.
  APPEND sel_obj. APPEND sel_type.
  SUBMIT rsvtprot VIA SELECTION-SCREEN USING SELECTION-SCREEN 1010
                  WITH cusobj IN sel_obj
                  WITH stype IN sel_type
                  WITH acc_arch = &apos; &apos; AND RETURN.
ENDFORM.                               &quot; LOGS_ANALYSE</include_source>
   </include>
   <include NAME="LSVIMF05" SQLX="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000001" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122421" IDATE="20080721" ITIME="122421">
    <include_source>*---------------------------------------------------------------------*
*       FORM SHOW_FUNCTION_DOCU                                       *
*---------------------------------------------------------------------*
FORM SHOW_FUNCTION_DOCU.
  CALL FUNCTION &apos;IWB_HTML_HELP_OBJECT_SHOW&apos;
       EXPORTING
*         DEVCLASS                    =
*         TCODE                       =
            PROGRAM                     = VIM_DOCU_PROG
*         DYNPRONR                    =
            EXTENSION                   = VIM_DOCU_EXTENSION
*    IMPORTING
*         ACTION                      =
       EXCEPTIONS
            OBJECT_NOT_FOUND            = 1
            RFC_ERROR                   = 2
            NO_PROFIL_PARAMETER         = 3
            IMPORT_PARAMETER_IS_INVALID = 4
            OTHERS                      = 5.

* CALL FUNCTION &apos;DSYS_SHOW&apos;
*      EXPORTING
**          APPLICATION        = &apos;SO70&apos;
*           DOKCLASS           = &apos;WINH&apos;
**          DOKLANGU           = SY-LANGU
*           DOKNAME            = &apos;CATAB.HLP&apos;
*           DOKTITLE           = &apos; &apos;
*           HOMETEXT           = &apos; &apos;
*           OUTLINE            = &apos; &apos;
*           VIEWNAME           = &apos;STANDARD&apos;
*           Z_ORIGINAL_OUTLINE = &apos; &apos;
*           CALLED_FROM_SO70   = &apos; &apos;
*      IMPORTING
*           APPL               =
*           PF03               =
*           PF15               =
*           PF12               =
*      EXCEPTIONS
*           CLASS_UNKNOWN      = 1
*           OBJECT_NOT_FOUND   = 2
*           OTHERS             = 3.
  IF SY-SUBRC NE 0.
    MESSAGE ID SY-MSGID TYPE &apos;I&apos; NUMBER SY-MSGNO
            WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF06" SQLX="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000001" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122421" IDATE="20080721" ITIME="122421">
    <include_source>*---------------------------------------------------------------------*
*       FORM UPDATE_STATUS                                            *
*---------------------------------------------------------------------*
FORM UPDATE_STATUS.
  MOVE: STATUS-DATA TO &lt;STATUS&gt;-ST_DATA,
        STATUS-MODE TO &lt;STATUS&gt;-ST_MODE,
        STATUS-DELETE TO &lt;STATUS&gt;-ST_DELETE,
        STATUS-ACTION TO &lt;STATUS&gt;-ST_ACTION,
        TITLE         TO &lt;STATUS&gt;-TITLE,
*       L             TO &lt;STATUS&gt;-CUR_LINE,
        FIRSTLINE     TO &lt;STATUS&gt;-FIRSTLINE,
        MAXLINES      TO &lt;STATUS&gt;-MAXLINES,
        F             TO &lt;STATUS&gt;-CUR_FIELD,
        O             TO &lt;STATUS&gt;-CUR_OFFSET,
        MARK_EXTRACT  TO &lt;STATUS&gt;-MK_XT,
        MARK_TOTAL    TO &lt;STATUS&gt;-MK_TO,
        FUNCTION      TO &lt;STATUS&gt;-FCODE.
  IF L EQ 0.
    MOVE 1 TO &lt;STATUS&gt;-CUR_LINE.
  ELSE.
    MOVE L TO &lt;STATUS&gt;-CUR_LINE.
  ENDIF.
ENDFORM.                               &quot;UPDATE_STATUS</include_source>
   </include>
   <include NAME="LSVIMF07" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000005" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122421" IDATE="20080721" ITIME="122421">
    <include_source>*---------------------------------------------------------------------*
*       FORM VIM_SINGLE_ENTRY_FILL_SELLIST                            *
*---------------------------------------------------------------------*
* fill sellist in case of single entry maintenance                    *
*---------------------------------------------------------------------*
FORM vim_single_entry_fill_sellist.
  DATA: countx TYPE i, nam_ix TYPE i.
  FIELD-SYMBOLS: &lt;h1&gt;.

  LOOP AT x_namtab WHERE keyflag NE space AND texttabfld EQ space.
    CHECK x_header-clidep EQ space OR sy-tabix GT 1.
    nam_ix = sy-tabix.
    assign component x_namtab-viewfield of structure &lt;table1&gt; to &lt;h1&gt;.
*    ASSIGN &lt;TABLE1&gt;+X_NAMTAB-POSITION(X_NAMTAB-FLENGTH) TO &lt;H1&gt;.
    READ TABLE dpl_sellist WITH KEY viewfield = x_namtab-viewfield
                                    operator  = &apos;EQ&apos;
                                    negation  = space.
    IF sy-subrc NE 0.
      CLEAR dpl_sellist.
      dpl_sellist-viewfield = x_namtab-viewfield.
      dpl_sellist-operator  = &apos;EQ&apos;.
      dpl_sellist-and_or    = &apos;AND&apos;.
      dpl_sellist-tabix     = nam_ix.
      APPEND dpl_sellist.
    ENDIF.
    countx = sy-tabix. CLEAR dpl_sellist-converted.
    dpl_sellist-ddic = &apos;S&apos;. CLEAR dpl_sellist-value.
    CALL FUNCTION &apos;VIEW_CONVERSION_OUTPUT&apos;
         EXPORTING
              value_intern = &lt;h1&gt;
              tabname      = x_header-maintview
              fieldname    = x_namtab-viewfield
*              inttype      = x_namtab-inttype
*              datatype     = x_namtab-datatype
*              decimals     = x_namtab-decimals
*              convexit     = x_namtab-convexit
*              sign         = x_namtab-sign
              outputlen    = x_namtab-outputlen
              intlen       = x_namtab-flength
         IMPORTING
              value_extern = dpl_sellist-value.
    IF dpl_sellist-value EQ space.
      dpl_sellist-initial = &apos;X&apos;.
    ELSE.
      CLEAR dpl_sellist-initial.
    ENDIF.
    MODIFY dpl_sellist INDEX countx.
    x_namtab-readonly = &apos;S&apos;. MODIFY x_namtab.
  ENDLOOP.
  ASSIGN dpl_sellist[] TO &lt;vim_ck_sellist&gt;.
  x_header-subsetflag = x_header-selection = &apos;X&apos;.
  MODIFY x_header INDEX 1.
  PERFORM init_subset_keyfields.
ENDFORM.                               &quot;vim_single_entry_fill_sellist</include_source>
   </include>
   <include NAME="LSVIMF08" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000004" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122421" IDATE="20080721" ITIME="122421">
    <include_source>*---------------------------------------------------------------------*
*       FORM VIM_SET_IMP_RESULTS                                      *
*---------------------------------------------------------------------*
* (re)set result of import for current entry                          *
*---------------------------------------------------------------------*
* VALUE(VSIR_KEY)    ---&gt; key of current entry                        *
* VALUE(VSIR_ACTION) ---&gt; action happened to current entry            *
*                         - GELOESCHT OR UPDATE_GELOESCHT -&gt; deleted  *
*                         - AENDERN                       -&gt; updated  *
*                         - NEUER_EINTRAG                 -&gt; inserted *
*                         - ORIGINAL                      -&gt; unchanged*
*                         - SLCTR_IMP_ERROR               -&gt; error    *
*---------------------------------------------------------------------*
FORM vim_set_imp_results USING value(vsir_key)
                               value(vsir_action) LIKE tvdir-flag.
  DATA: vsir_xkey TYPE vim_tabkey_c, vsir_xkeylen TYPE i,
        vsir_rc TYPE i,
        vsir_ix TYPE i.

  PERFORM vim_set_impres_header.
  PERFORM vim_convert_tabkey USING vsir_key vsir_xkey vsir_xkeylen.
  imp_results-tabkey = vsir_xkey.
  READ TABLE imp_results WITH KEY objtab = imp_results-objtab
                                  tabkey = imp_results-tabkey.
  vsir_rc = sy-subrc. vsir_ix = sy-tabix.
  CLEAR imp_results-import.
  CASE vsir_action.
    WHEN geloescht OR update_geloescht.
      imp_results-import-deleted = 1.
    WHEN aendern.
      imp_results-import-updated = 1.
    WHEN neuer_eintrag.
      imp_results-import-inserted = 1.
    WHEN original.
      imp_results-import-unchanged = 1.
    WHEN OTHERS.
      imp_results-import-errors = 1.
  ENDCASE.
  IF vsir_rc NE 0.
    APPEND imp_results.
  ELSE.
    MODIFY imp_results INDEX vsir_ix.
  ENDIF.
ENDFORM.                               &quot;vim_set_imp_reults</include_source>
   </include>
   <include NAME="LSVIMF09" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000007" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122421" IDATE="20080721" ITIME="122421">
    <include_source>*---------------------------------------------------------------------*
*       FORM VIM_PROCESS_MESSAGE                                      *
*---------------------------------------------------------------------*
* process message depending on dialog mode                            *
*---------------------------------------------------------------------*
* VALUE(PM_ID)          ---&gt; ID of message to send                    *
* VALUE(PM_ONLINE_TYPE) ---&gt; message type used for online mode        *
* VALUE(PM_BATCH_TYPE)  ---&gt; message type used for batch mode         *
* VALUE(PM_NBR)         ---&gt; number of message to send                *
* VALUE(PM_V1)          ---&gt; first mesage variable                    *
* VALUE(PM_V2)          ---&gt; second mesage variable                   *
* VALUE(PM_V3)          ---&gt; third mesage variable                    *
* VALUE(PM_V4)          ---&gt; fourth mesage variable                   *
*---------------------------------------------------------------------*
FORM VIM_PROCESS_MESSAGE USING VALUE(PM_ID) LIKE SY-MSGID
                           VALUE(PM_ONLINE_TYPE) LIKE SY-MSGTY
                           VALUE(PM_BATCH_TYPE) LIKE SY-MSGTY
                           VALUE(PM_NBR)  LIKE SY-MSGNO
                           VALUE(PM_V1) LIKE SY-MSGV1
                           VALUE(PM_V2) LIKE SY-MSGV2
                           VALUE(PM_V3) LIKE SY-MSGV3
                           VALUE(PM_V4) LIKE SY-MSGV4.

  DATA: I_TYPE LIKE SPROT_U-SEVERITY, I_MSGTY LIKE SY-MSGTY,
        I_MSGNO LIKE SY-MSGNO,
        objtype TYPE ob_typ, objname TYPE ob_object.

  IF VIM_NO_DIALOG NE SPACE.           &quot;no dialog - write protocol
    I_TYPE = I_MSGTY = PM_BATCH_TYPE. I_MSGNO = PM_NBR.
    IF VIM_IMPORT_PROFILE = &apos;X&apos;.        &quot;Profilimport
      IF vim_called_by_cluster NE &apos;X&apos;.
         objname = VIM_VIEW_NAME.
        IF x_header-bastab EQ space.
        objtype = &apos;V&apos;.
      ELSE.
        objtype = &apos;S&apos;.
      ENDIF.
      ELSE.
        objname = vim_calling_cluster.
        objtype = &apos;C&apos;.
      ENDIF.
      CALL FUNCTION &apos;SCPR_PROT_DATA_WRITE&apos;
          EXPORTING
            act_id           = VIM_ACTOPTS-ACT_ID
            bcset_id         = VIM_BCSET_ID
            objectname       = objname
*           tablename        = object
*           tabletype        = tabtype
            tablekey         = VIM_PROFILE_ERRORKEY
            msgid            = PM_ID
            msgty            = I_TYPE
            msgno            = I_MSGNO
            var1             = PM_V1
            var2             = PM_V2
            var3             = PM_V3
            var4             = PM_V4
            objecttype       = objtype.
    ELSE.
      TRANSLATE I_TYPE USING &apos;I S &apos;.
      CALL FUNCTION &apos;LCT_MESSAGE&apos;
         EXPORTING
              IV_MSGID  = PM_ID
              IV_MSGTY  = I_TYPE
              IV_MSGNO  = I_MSGNO
              IV_MSGV1  = PM_V1
              IV_MSGV2  = PM_V2
              IV_MSGV3  = PM_V3
              IV_MSGV4  = PM_V4
              IV_DIALOG = SPACE.
    ENDIF.
    VIM_LAST_LOGGED_MESSAGE-ID = PM_ID.
    VIM_LAST_LOGGED_MESSAGE-TYPE = I_MSGTY.
    VIM_LAST_LOGGED_MESSAGE-NBR = PM_NBR.
    VIM_LAST_LOGGED_MESSAGE-V1 = PM_V1.
    VIM_LAST_LOGGED_MESSAGE-V2 = PM_V2.
    VIM_LAST_LOGGED_MESSAGE-V3 = PM_V3.
    VIM_LAST_LOGGED_MESSAGE-V4 = PM_V4.
    IF VIM_IMPORT_NO_MESSAGE EQ SPACE.
      MESSAGE ID PM_ID TYPE I_MSGTY NUMBER PM_NBR &quot;to raise exception
                WITH PM_V1 PM_V2 PM_V3 PM_V4.
    ENDIF.
  ELSE.                                &quot;with dialog - use pm_online_type
    I_MSGTY = PM_ONLINE_TYPE.
    MESSAGE ID PM_ID TYPE I_MSGTY NUMBER PM_NBR
              WITH PM_V1 PM_V2 PM_V3 PM_V4.
  ENDIF.                               &quot;vim_no_dialog eq space
ENDFORM.                               &quot;vim_process_message
*---------------------------------------------------------------------*
*       FORM VIM_BC_PROCESS_MESSAGE
*
*---------------------------------------------------------------------*
* process message depending on dialog mode                            *
*---------------------------------------------------------------------*
* VALUE(PM_ID)          ---&gt; ID of message to send                    *
* VALUE(PM_ONLINE_TYPE) ---&gt; message type used for online mode        *
* VALUE(PM_BATCH_TYPE)  ---&gt; message type used for batch mode         *
* VALUE(PM_NBR)         ---&gt; number of message to send                *
* VALUE(PM_V1)          ---&gt; first mesage variable                    *
* VALUE(PM_V2)          ---&gt; second mesage variable                   *
* VALUE(PM_V3)          ---&gt; third mesage variable                    *
* VALUE(PM_V4)          ---&gt; fourth mesage variable                   *
*---------------------------------------------------------------------*
FORM vim_bc_process_message USING value(pm_id) LIKE sy-msgid
                           value(pm_online_type) LIKE sy-msgty
                           value(pm_batch_type) LIKE sy-msgty
                           value(pm_nbr)  LIKE sy-msgno
                           value(pm_v1) LIKE sy-msgv1
                           value(pm_v2) LIKE sy-msgv2
                           value(pm_v3) LIKE sy-msgv3
                           value(pm_v4) LIKE sy-msgv4
                           value(objtype) TYPE ob_typ.

  DATA: i_type LIKE sprot_u-severity, i_msgty LIKE sy-msgty,
        i_msgno LIKE sy-msgno.

  i_type = i_msgty = pm_batch_type. i_msgno = pm_nbr.

  CALL FUNCTION &apos;SCPR_PROT_DATA_WRITE&apos;
      EXPORTING
        act_id           = vim_actopts-act_id
        bcset_id         = vim_bcset_id
        objectname       = vim_view_name
*       tablename        = object
*       tabletype        = tabtype
        tablekey         = vim_profile_errorkey
        msgid            = pm_id
        msgty            = i_type
        msgno            = i_msgno
        var1             = pm_v1
        var2             = pm_v2
        var3             = pm_v3
        var4             = pm_v4
        objecttype       = objtype.
  vim_last_logged_message-id = pm_id.
  vim_last_logged_message-type = i_msgty.
  vim_last_logged_message-nbr = pm_nbr.
  vim_last_logged_message-v1 = pm_v1.
  vim_last_logged_message-v2 = pm_v2.
  vim_last_logged_message-v3 = pm_v3.
  vim_last_logged_message-v4 = pm_v4.
  IF vim_import_no_message EQ space.
    MESSAGE ID pm_id TYPE i_msgty NUMBER pm_nbr &quot;to raise exception
              WITH pm_v1 pm_v2 pm_v3 pm_v4.
  ENDIF.
ENDFORM.                               &quot;vim_bc_process_message</include_source>
   </include>
   <include NAME="LSVIMF0A" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000003" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122421" IDATE="20080721" ITIME="122421">
    <include_source>*---------------------------------------------------------------------*
*       FORM X_REFRESH_TCTRL                                          *
*---------------------------------------------------------------------*
* refresh table control (external call)                               *
*---------------------------------------------------------------------*
* VALUE(XE_NAME)   ---&gt; name of view/table to process                 *
* VALUE(XE_SCREEN) ---&gt; screen to refresh from                        *
*---------------------------------------------------------------------*
FORM X_REFRESH_TCTRL USING VALUE(XRT_NAME) LIKE VIMDESC-VIEWNAME
                           VALUE(XRT_SCREEN) LIKE VIMDESC-LISTE.
  DATA: XRT_CONTROL_NAME(16) TYPE C VALUE &apos;TCTRL_&apos;.

  XRT_CONTROL_NAME+6 = XRT_NAME.
  REFRESH CONTROL XRT_CONTROL_NAME FROM SCREEN XRT_SCREEN.
ENDFORM.                               &quot;x_refresh_tctrl</include_source>
   </include>
   <include NAME="LSVIMF0B" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000002" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122421" IDATE="20080721" ITIME="122422">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  CHECK_MODIFY_MERGED_ENTRIES                             *
*&amp;--------------------------------------------------------------------*
* check if changed entry is to be merged and if so do it
* merging functionality has never been finished                       *
*&amp;--------------------------------------------------------------------*
* &lt;-- SY-SUBRC: 0 - ok, merge, others: don&apos;t merge                    *
*&amp;--------------------------------------------------------------------*
*FORM CHECK_MODIFY_MERGED_ENTRIES USING VALUE(ENTRY_IN).
*  LOCAL: TOTAL, &lt;TABLE1&gt;.
*  DATA: REC TYPE I VALUE 8.
*  &lt;F1&gt; = ENTRY_IN. &lt;VIM_ENDDATE_MASK&gt; = VIM_DATE_MASK.
*  LOOP AT VIM_MERGED_ENTRIES WHERE NEW_KEY CP &lt;F1&gt;. &quot;Achtung !!!!!!
*    READ TABLE TOTAL WITH KEY VIM_MERGED_ENTRIES-MERGED_KEY
*                     BINARY SEARCH.
*    IF SY-SUBRC EQ 0.
*      &lt;TABLE1&gt; = TOTAL.
*      &lt;VIM_BEGDATE_MASK&gt; = VIM_DATE_MASK.
*      &lt;VIM_ENDDATE_MASK&gt; = VIM_DATE_MASK.
*      IF ENTRY_IN CP &lt;TABLE1&gt;. &quot;entry can be merged. &quot;ACHTUNG!!
*        CLEAR REC.
*        TOTAL = ENTRY_IN.
*        VIM_MERGED_ENTRIES-MERGED_KEY = &lt;VIM_TOTAL_KEY&gt;.
*
*
*
*
*      ENDIF.
*    ENDIF.
*  ENDLOOP.
*ENDFORM.                               &quot;check_modify_merged_entries</include_source>
   </include>
   <include NAME="LSVIMF0C" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000004" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122422" IDATE="20080721" ITIME="122422">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  DELETE_FROM_MAINKEY_TAB                                 *
*&amp;--------------------------------------------------------------------*
* delete entry from mainkey_tab.                                      *
*&amp;--------------------------------------------------------------------*
FORM delete_from_mainkey_tab.
  LOOP AT vim_collapsed_mainkeys.
    CHECK &lt;vim_h_coll_mkey&gt;(x_header-keylen) = &lt;f1_x&gt;.
*  LOOP AT VIM_COLLAPSED_MAINKEYS WHERE MAINKEY EQ &lt;F1&gt;.
    DELETE vim_collapsed_mainkeys.
  ENDLOOP.
ENDFORM.                               &quot;delete_from_mainkey_tab</include_source>
   </include>
   <include NAME="LSVIMF0D" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000004" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122422" IDATE="20080721" ITIME="122422">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  BUILD_MAINKEY_TAB_2                                     *
*&amp;--------------------------------------------------------------------*
* build mainkey tab for display modification - part two               *
*&amp;--------------------------------------------------------------------*
FORM BUILD_MAINKEY_TAB_2.
  APPEND VIM_COLLAPSED_MAINKEYS.
  MOVE: X_HEADER-VIEWNAME TO VIM_MEMORY_ID_1-VIEWNAME,
        SY-UNAME          TO VIM_MEMORY_ID_1-USER.
  EXPORT VIM_COLLAPSED_MAINKEYS TO MEMORY ID VIM_MEMORY_ID_1.
ENDFORM.                               &quot;build_mainkey_tab_2</include_source>
   </include>
   <include NAME="LSVIMF0G" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000006" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122422" IDATE="20080721" ITIME="122422">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  BUILD_MAINKEY_TAB_1                                     *
*&amp;--------------------------------------------------------------------*
* build mainkey tab for display modification - part one               *
* merge identical entries for same mainkey into one entry
* assumptions: TOTAL is sorted ascending by &lt;VIM_TOTAL_KEY&gt;
*              Now, with unicode: sorted by &lt;VIM_TOTAL_KEYX&gt;
*&amp;--------------------------------------------------------------------*
FORM build_mainkey_tab_1.
  DATA: date_safe TYPE d, date_safe_1 TYPE d, date_safe_2 TYPE d,
        date_safe_3 TYPE d.

  date_safe = &lt;vim_begdate&gt;.           &quot;TOTAL
  date_safe_1 = &lt;vim_enddate&gt;.         &quot;TOTAL
  date_safe_2 = &lt;vim_new_begdate&gt;.                          &quot;&lt;TABLE1&gt;
  date_safe_3 = &lt;vim_enddate_mask&gt;.                         &quot;&lt;TABLE1&gt;
  &lt;vim_begdate&gt; = &lt;vim_enddate&gt; = &lt;vim_new_begdate&gt; =
                  &lt;vim_enddate_mask&gt; = &apos;99999999&apos;.
  IF &lt;vim_xtotal&gt; NE &lt;table1_x&gt;.
    MOVE: date_safe   TO &lt;vim_begdate&gt;,
          date_safe_1 TO &lt;vim_enddate&gt;,
          date_safe_2 TO &lt;vim_new_begdate&gt;,
          date_safe_3 TO &lt;vim_enddate_mask&gt;.
    IF vim_no_mainkey_exists EQ vim_no_mkey_not_procsd OR
       &lt;vim_tot_mkey_beforex&gt; NE &lt;vim_f1_beforex&gt;.
*       &lt;vim_tot_mkey_before&gt; NE &lt;vim_f1_before&gt; OR
*       ( vim_mkey_after_exists NE space AND
*         &lt;vim_tot_mkey_after&gt; NE &lt;vim_f1_after&gt; ).
      IF vim_coll_mkeys_first EQ space.
        APPEND vim_collapsed_mainkeys.
        CLEAR vim_collapsed_mainkeys-log_key.
      ELSE.
        CLEAR vim_coll_mkeys_first.
      ENDIF.
      &lt;vim_collapsed_keyx&gt; = &lt;vim_xtotal_key&gt;.
      &lt;vim_collapsed_mkey_bfx&gt; = &lt;vim_tot_mkey_beforex&gt;.
*      vim_collapsed_mainkeys-mainkey = &lt;vim_total_key&gt;.
*      vim_collapsed_mainkeys-mkey_bf = &lt;vim_tot_mkey_before&gt;.
* If the position &lt;= 0, the &lt;vim_collapsed_mkey_bfx&gt; shouldn&apos;t be
* assigned. XB am 27.03.2002 CSN int1332679 2002
    ELSEIF vim_mkey_after_exists NE space AND
         &lt;vim_tot_mkey_afterx&gt; NE &lt;vim_f1_afterx&gt;.
      IF vim_coll_mkeys_first EQ space.
        APPEND vim_collapsed_mainkeys.
        CLEAR vim_collapsed_mainkeys-log_key.
      ELSE.
        CLEAR vim_coll_mkeys_first.
      ENDIF.
      &lt;vim_collapsed_keyx&gt; = &lt;vim_xtotal_key&gt;.
*      &lt;vim_collapsed_mkey_bfx&gt; = &lt;vim_tot_mkey_beforex&gt;.
*      vim_collapsed_mainkeys-mainkey = &lt;vim_total_key&gt;.
*      vim_collapsed_mainkeys-mkey_bf = &lt;vim_tot_mkey_before&gt;.
    ELSE.
      IF x_header-delmdtflag EQ &apos;E&apos; AND &lt;vim_begdate&gt; LE sy-datum AND
       &lt;vim_enddate&gt; GE sy-datum OR x_header-delmdtflag EQ &apos;B&apos; AND
       &lt;vim_begdate&gt; GE sy-datum AND &lt;vim_enddate&gt; LE sy-datum.
        &lt;vim_collapsed_keyx&gt; = &lt;vim_xtotal_key&gt;.
* change xb 12.06.02 begin--------------------------------------------
        if &lt;vim_collapsed_mkey_bfx&gt; NE &lt;vim_tot_mkey_beforex&gt;.
          &lt;vim_collapsed_mkey_bfx&gt; = &lt;vim_tot_mkey_beforex&gt;.
        endif.
* change xb 12.06.02 ***********************************************
*        vim_collapsed_mainkeys-mainkey = &lt;vim_total_key&gt;.
*        vim_collapsed_mainkeys-mkey_bf = &lt;vim_tot_mkey_before&gt;.
      ENDIF.
    ENDIF.
* end correction XB am 27.03.2002 CSN int1332679 2002
    &lt;table1_x&gt; = &lt;vim_xtotal&gt;.
    TRANSLATE vim_no_mainkey_exists USING vim_no_mkey_procsd_patt.
  ELSE.
    MOVE: date_safe   TO &lt;vim_begdate&gt;,
          date_safe_1 TO &lt;vim_enddate&gt;,
          date_safe_2 TO &lt;vim_new_begdate&gt;,
          date_safe_3 TO &lt;vim_enddate_mask&gt;.
    IF x_header-delmdtflag EQ &apos;E&apos; AND &lt;vim_begdate&gt; LE sy-datum AND
      &lt;vim_enddate&gt; GE sy-datum OR x_header-delmdtflag EQ &apos;B&apos; AND
      &lt;vim_begdate&gt; GE sy-datum AND &lt;vim_enddate&gt; LE sy-datum.
      &lt;vim_collapsed_keyx&gt; = &lt;vim_xtotal_key&gt;.
* change xb 12.06.02 begin--------------------------------------------
      if &lt;vim_collapsed_mkey_bfx&gt; NE &lt;vim_tot_mkey_beforex&gt;.
        &lt;vim_collapsed_mkey_bfx&gt; = &lt;vim_tot_mkey_beforex&gt;.
      endif.
* change xb 12.06.02 ***********************************************

*      vim_collapsed_mainkeys-mainkey = &lt;vim_total_key&gt;.
*      vim_collapsed_mainkeys-mkey_bf = &lt;vim_tot_mkey_before&gt;.
    ENDIF.
  ENDIF.

ENDFORM.                               &quot;build_mainkey_tab_1</include_source>
   </include>
   <include NAME="LSVIMF0H" SQLX="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000001" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122422" IDATE="20080721" ITIME="122422">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  BUILD_MAINKEY_TAB_0                                     *
*&amp;--------------------------------------------------------------------*
* build mainkey tab for display modification - part one               *
*&amp;--------------------------------------------------------------------*
FORM BUILD_MAINKEY_TAB_0.
  CLEAR: VIM_MAINKEY, VIM_MERGED_ENTRIES, VIM_COLLAPSED_MAINKEYS,
         &lt;TABLE1&gt;, VIM_MERGE_BEGIN, VIM_MERGE_END.
  TRANSLATE VIM_NO_MAINKEY_EXISTS USING VIM_NO_MKEY_NOT_PROCSD_PATT.
  REFRESH: VIM_COLLAPSED_MAINKEYS,
           VIM_MERGED_ENTRIES.
  VIM_COLL_MKEYS_FIRST = &apos;X&apos;.
ENDFORM.                               &quot;build_mainkey_tab_0</include_source>
   </include>
   <include NAME="LSVIMF0I" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000003" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122422" IDATE="20080721" ITIME="122422">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  BUILD_MAINKEY_TAB                                       *
*&amp;--------------------------------------------------------------------*
* build mainkey tab for display modification - all parts              *
*&amp;--------------------------------------------------------------------*
FORM BUILD_MAINKEY_TAB.
  PERFORM BUILD_MAINKEY_TAB_0.
  LOOP AT TOTAL.
    PERFORM BUILD_MAINKEY_TAB_1.
  ENDLOOP.
  PERFORM BUILD_MAINKEY_TAB_2.
ENDFORM.                               &quot;build_mainkey_tab</include_source>
   </include>
   <include NAME="LSVIMF0J" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000005" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122422" IDATE="20080721" ITIME="122422">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      FORM COLLAPSE                                                 *
*&amp;--------------------------------------------------------------------*
* collapse                                                            *
*&amp;--------------------------------------------------------------------*
FORM collapse USING value(c_begin_ix) TYPE i value(c_end_ix) TYPE i.
  LOCAL: extract.
  DATA: first(1) TYPE c VALUE &apos;X&apos;, hf_ind TYPE i, hf_ind2 TYPE i,
        act_ix TYPE i.

  LOOP AT total.
    act_ix = sy-tabix.
    PERFORM select USING &lt;status&gt;-selected.
    CHECK sy-subrc EQ 0.
    CHECK &lt;vim_tot_mkey_beforeX&gt; EQ &lt;vim_mkey_beforeX&gt; AND
          ( vim_mkey_after_exists EQ space OR
            &lt;vim_tot_mkey_afterx&gt; EQ &lt;vim_mkey_afterx&gt; ).
*    CHECK &lt;vim_tot_mkey_before&gt; EQ &lt;vim_mkey_before&gt; AND
*          ( vim_mkey_after_exists EQ space OR
*            &lt;vim_tot_mkey_after&gt; EQ &lt;vim_mkey_after&gt; ).
    IF first NE space.
* Changed from XB. 12.06.02 BCEK060520/BCEK060521
      &lt;vim_collapsed_keyx&gt; = &lt;vim_xtotal_key&gt;.
*      vim_collapsed_mainkeys-mainkey = &lt;vim_total_key&gt;.
      if &lt;vim_collapsed_mkey_bfx&gt; ne &lt;vim_tot_mkey_beforex&gt;.
        &lt;vim_collapsed_mkey_bfx&gt; = &lt;vim_tot_mkey_beforex&gt;.
*      vim_collapsed_mainkeys-mkey_bf = &lt;vim_tot_mkey_before&gt;.
      endif.
      hf_ind = act_ix.
      CLEAR first.
    ENDIF.
* Changed from XB. 12.06.02 End.

    IF x_header-delmdtflag EQ &apos;E&apos;.
      CHECK &lt;vim_begdate&gt; LE sy-datum AND
            &lt;vim_enddate&gt; GE sy-datum.
    ELSE.
      CHECK &lt;vim_begdate&gt; GE sy-datum AND
            &lt;vim_enddate&gt; LE sy-datum.
    ENDIF.
    &lt;vim_collapsed_keyx&gt; = &lt;vim_xtotal_key&gt;.
* changed from Xue. End.
    if &lt;vim_collapsed_mkey_bfx&gt; ne &lt;vim_tot_mkey_beforex&gt;.
      &lt;vim_collapsed_mkey_bfx&gt; = &lt;vim_tot_mkey_beforex&gt;.
    endif.
*    vim_collapsed_mainkeys-mainkey = &lt;vim_total_key&gt;.
*    &lt;vim_collapsed_mkey_bfx&gt; = &lt;vim_tot_mkey_beforex&gt;.
*    vim_collapsed_mainkeys-mkey_bf = &lt;vim_tot_mkey_before&gt;.

* Change from Xue. End.
    hf_ind = act_ix.
    EXIT.
  ENDLOOP.
  READ TABLE vim_collapsed_mainkeys
                                with key &lt;vim_collapsed_keyx&gt;
*                                WITH KEY vim_collapsed_mainkeys-mainkey
                                BINARY SEARCH
                                TRANSPORTING NO FIELDS.
  INSERT vim_collapsed_mainkeys INDEX sy-tabix.
  vim_delim_entries-index1 = hf_ind.
  vim_delim_entries-index2 = c_begin_ix.
  vim_delim_entries-index3 = c_begin_ix.
  vim_delim_entries-index_corr = &apos;X&apos;.
  APPEND vim_delim_entries.
  hf_ind2 = c_begin_ix + 1.
  CLEAR vim_delim_entries.
  LOOP AT extract FROM hf_ind2 TO c_end_ix.
    vim_delim_entries-index3 = sy-tabix.
    APPEND vim_delim_entries.
  ENDLOOP.
  CLEAR vim_old_viewkey.
  TRANSLATE vim_no_mainkey_exists USING vim_no_mkey_not_procsd_patt.
ENDFORM.                               &quot;collapse</include_source>
   </include>
   <include NAME="LSVIMF0K" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000004" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122422" IDATE="20080721" ITIME="122422">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  TIME_DEPENDENT_DISPLAY_MODIF.                           *
*&amp;--------------------------------------------------------------------*
* process display modification (collapse/expand)                      *
*&amp;--------------------------------------------------------------------*
FORM time_dependent_display_modif.
  DATA: ex_ix TYPE i, modif_mode(1) TYPE c, first(1) TYPE c,
        ex_begin TYPE i, ex_end TYPE i, key_safe TYPE vrsdat1000,
        to_ix TYPE i, rc like sy-subrc.
  READ TABLE extract INDEX nextline.
  key_safe = &lt;vim_xextract_key&gt;.
  CLEAR vim_mainkey.
  TRANSLATE vim_no_mainkey_exists USING vim_no_mkey_not_procsd_patt.
  LOOP AT extract.
    ex_ix = sy-tabix.
    IF vim_no_mainkey_exists EQ vim_no_mkey_not_procsd OR
       &lt;vim_ext_mkey_beforex&gt; NE &lt;vim_mkey_beforex&gt; OR
       ( vim_mkey_after_exists NE space AND
         &lt;vim_ext_mkey_afterx&gt; NE &lt;vim_mkey_afterx&gt; ).
*       &lt;vim_ext_mkey_before&gt; NE &lt;vim_mkey_before&gt; OR
*       ( vim_mkey_after_exists NE space AND
*         &lt;vim_ext_mkey_after&gt; NE &lt;vim_mkey_after&gt; ).
      ex_end = sy-tabix - 1.
      IF modif_mode EQ &apos;C&apos;.
        PERFORM collapse USING ex_begin ex_end.
        modif_mode = &apos;X&apos;.
      ENDIF.                           &quot;modif_mode eq collapse
      ex_begin = ex_ix.
      &lt;vim_h_mkey&gt; = &lt;vim_xextract_key&gt;.
*      vim_mainkey = &lt;vim_extract_key&gt;.
      TRANSLATE vim_no_mainkey_exists USING vim_no_mkey_procsd_patt.
    ENDIF.                             &quot;new mainkey in extract.
    CHECK &lt;xmark&gt; EQ markiert.
    READ TABLE total WITH KEY &lt;vim_xextract_key&gt; BINARY SEARCH.
    &lt;mark&gt; = nicht_markiert. SUBTRACT 1 FROM mark_total.
    MODIFY total INDEX sy-tabix.
    SUBTRACT 1 FROM mark_extract.
    IF modif_mode CO &apos; X&apos;.
      rc = 4.
      LOOP AT vim_collapsed_mainkeys.
        check &lt;vim_collapsed_mkey_bfx&gt; = &lt;vim_mkey_beforex&gt;.
*      WHERE mkey_bf EQ &lt;vim_mkey_before&gt;.
        IF vim_mkey_after_exists NE space.
          CHECK &lt;vim_collapsed_key_afx&gt; EQ &lt;vim_mkey_afterx&gt;.
        ENDIF.
        DELETE vim_collapsed_mainkeys.
        clear rc.
        EXIT.
      ENDLOOP.
      IF rc EQ 0.
* entry in collapsed mode -&gt; expand
        modif_mode = &apos;E&apos;.
      ELSE.
* entry in expanded mode -&gt; collapse
        modif_mode = &apos;C&apos;.
      ENDIF.
    ENDIF.
    IF modif_mode = &apos;E&apos;.
      CLEAR vim_delim_entries.
      vim_delim_entries-index3 = ex_ix.
      APPEND vim_delim_entries.
      CLEAR vim_delim_entries-index3.
      vim_delim_entries-index_corr = &apos;X&apos;.
      LOOP AT total.
        CHECK &lt;vim_tot_mkey_beforex&gt; EQ &lt;vim_mkey_beforex&gt; AND
              ( vim_mkey_after_exists EQ space OR
                &lt;vim_tot_mkey_afterx&gt; EQ &lt;vim_mkey_afterx&gt; ).
*        CHECK &lt;vim_tot_mkey_before&gt; EQ &lt;vim_mkey_before&gt; AND
*              ( vim_mkey_after_exists EQ space OR
*                &lt;vim_tot_mkey_after&gt; EQ &lt;vim_mkey_after&gt; ).
        to_ix = sy-tabix.
        PERFORM select USING &lt;status&gt;-selected.
        CHECK sy-subrc EQ 0.
        vim_delim_entries-index1 = to_ix.
        vim_delim_entries-index2 = ex_ix.
        APPEND vim_delim_entries.
      ENDLOOP.
      modif_mode = &apos;X&apos;.
    ENDIF.
  ENDLOOP.
  IF modif_mode EQ &apos;C&apos;.
    CLEAR vim_delim_entries.
    PERFORM collapse USING ex_begin maxlines.
  ENDIF.
  PERFORM after_temporal_delimitation.
  &lt;vim_xextract_key&gt; = key_safe.
  READ TABLE extract WITH KEY &lt;vim_ext_mkey_beforex&gt;.
*  READ TABLE extract WITH KEY &lt;vim_ext_mkey_before&gt;.
  IF sy-subrc EQ 0.
    nextline = sy-tabix.
  ELSE.
    nextline = 1.
  ENDIF.
* ENDIF.
ENDFORM.                               &quot;time_dependent_display_modif</include_source>
   </include>
   <include NAME="LSVIMF0L" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000004" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122422" IDATE="20080721" ITIME="122422">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form DELIMITATION                                             *
*&amp;--------------------------------------------------------------------*
* process temporal delimitation of marked EXTRACT entries             *
*&amp;--------------------------------------------------------------------*
FORM DELIMITATION.
  LOCAL: &lt;TABLE1&gt;, &lt;TABLE1_TEXT&gt;.
  DATA: D_RC(1) TYPE C.
* request date to delimit
  CALL FUNCTION &apos;POPUP_GET_VALUES&apos;
       EXPORTING
            POPUP_TITLE     = SVIM_TEXT_036
            START_COLUMN    = &apos;10&apos;
            START_ROW       = &apos;10&apos;
       IMPORTING
            RETURNCODE      = D_RC
       TABLES
            FIELDS          = VIM_SVAL_TAB
       EXCEPTIONS
            ERROR_IN_FIELDS = 01.
  IF SY-SUBRC NE 0. RAISE GET_VALUES_ERROR. ENDIF.
  CHECK D_RC NE &apos;A&apos;.
  READ TABLE VIM_SVAL_TAB INDEX 1.
  VIM_SPECIAL_MODE = VIM_DELIMIT.
  CLEAR: COUNTER, VIM_OLD_VIEWKEY.
  TRANSLATE VIM_NO_MAINKEY_EXISTS USING VIM_NO_MKEY_NOT_PROCSD_PATT.

* Event 28 AFter Entering Delimitation Date                   &quot;CG 7/2001
  if x_header-frm_af_edd NE SPACE.
    PERFORM (x_header-frm_af_edd) IN PROGRAM (x_header-fpoolname).
  endif.

  PERFORM KOPIERE.
  IF TEMPORAL_DELIMITATION_HAPPENED NE SPACE.
    REFRESH VIM_DELIM_ENTRIES. CLEAR TEMPORAL_DELIMITATION_HAPPENED.
  ENDIF.
  CLEAR: VIM_SPECIAL_MODE.
ENDFORM.                               &quot;delimitation</include_source>
   </include>
   <include NAME="LSVIMF0M" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000006" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122422" IDATE="20080721" ITIME="122423">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form CONSISTENCY_PRT_FRKY_FIELDS                              *
*&amp;--------------------------------------------------------------------*
* make sure, that part. forkey table fields are consistent            *
*&amp;--------------------------------------------------------------------*
FORM consistency_prt_frky_fields
                               USING value(cpff_alert) LIKE tvdir-flag.
  DATA:  prtfky_field_changed(1) TYPE c, cur_mkey_found(1) TYPE c,
         count TYPE i, offs TYPE i,
         formname(19) TYPE c VALUE &apos;FILL_TEXTTAB_KEY_UC&apos;.
  FIELD-SYMBOLS: &lt;dummy1&gt;.
  LOCAL: total, extract.

  CHECK status-action NE anzeigen.
  CHECK &lt;status&gt;-upd_flag NE space.
  MOVE: &lt;f1_x&gt; TO &lt;vim_xtotal_key&gt;,
        vim_date_mask TO &lt;vim_enddate_mask&gt;,
        &lt;f1_x&gt; TO &lt;vim_h_mkey&gt;,
*        &lt;f1&gt; TO &lt;vim_mainkey_mask&gt;,
        &lt;vim_xtotal_key&gt; TO &lt;f1_x&gt;.
*  vim_mainkey = &lt;f1&gt;.
  IF x_header-selection EQ space.
    LOOP AT total.
      CHECK &lt;vim_xtotal_key&gt; NE &lt;f1_x&gt; AND
            &lt;vim_tot_mkey_beforex&gt; EQ &lt;vim_mkey_beforex&gt; AND
            ( vim_mkey_after_exists EQ space OR
              &lt;vim_tot_mkey_afterx&gt; EQ &lt;vim_mkey_afterx&gt; ).
*      CHECK &lt;vim_total_key&gt; NE &lt;f1&gt; AND
*            &lt;vim_tot_mkey_before&gt; EQ &lt;vim_mkey_before&gt; AND
*            ( vim_mkey_after_exists EQ space OR
*              &lt;vim_tot_mkey_after&gt; EQ &lt;vim_mkey_after&gt; ).
      MOVE 99 TO count.
      EXIT.
    ENDLOOP.
  ELSE.
    MOVE 99 TO count.
  ENDIF.
  IF count EQ 99. &quot;other entries for mainkey (may be) exist
* selections exist or
* prüfen: wurden Texte verändert ?????
* falls aktueller Text leer und hinzufügen --&gt; text aus Extract nehmen
    IF vim_prtfky_assigned CO &apos; Y&apos;.
* partial foreign key not assigned or VIM_PROCESS_ASSIGNS already
* processed
      CLEAR count.
      LOOP AT x_namtab WHERE prtfrkyfld NE space.
        CHECK x_namtab-readonly EQ space.
        IF vim_prtfky_assigned EQ space.
          IF x_header-bastab EQ space             &quot;view
           OR x_header-texttbexst EQ space        &quot;no texttable
           OR x_namtab-texttabfld EQ space.       &quot;no texttabfield
* not a texttablefield in a table &amp; texttable
            ASSIGN: COMPONENT x_namtab-viewfield OF STRUCTURE &lt;table1&gt;
*            ASSIGN &lt;table1&gt;+x_namtab-position(x_namtab-flength)
                    TO &lt;vim_prtfky_wa&gt;.
          ELSE.
            ASSIGN: COMPONENT x_namtab-viewfield
                     OF STRUCTURE &lt;table1_text&gt;
*            offs = x_namtab-position - x_header-tablen.
*            ASSIGN &lt;table1_text&gt;+offs(x_namtab-flength)
                     TO &lt;vim_prtfky_wa&gt;.
          ENDIF.
        ENDIF.
        IF x_header-bastab EQ space               &quot;view
           OR x_header-texttbexst EQ space        &quot;no texttable
           OR x_namtab-texttabfld EQ space.       &quot;no texttabfield
          ASSIGN: COMPONENT x_namtab-viewfield
                   OF STRUCTURE &lt;vim_total_struc&gt;
                   TO &lt;vim_prtfky_total&gt;,
                  COMPONENT x_namtab-viewfield
                   OF STRUCTURE &lt;vim_extract_struc&gt;
                   TO  &lt;vim_prtfky_extract&gt;.
* not a texttablefield in a table &amp; texttable
        ELSE.
          ASSIGN: COMPONENT x_namtab-viewfield
                    OF STRUCTURE &lt;vim_tot_txt_struc&gt;
                     TO &lt;vim_prtfky_total&gt;,
                    COMPONENT x_namtab-viewfield
                     OF STRUCTURE &lt;vim_ext_txt_struc&gt;
                     TO  &lt;vim_prtfky_extract&gt;.
        ENDIF.
*        ASSIGN: total+x_namtab-position(x_namtab-flength)
*                                 TO &lt;vim_prtfky_total&gt;,
*                extract+x_namtab-position(x_namtab-flength)
*                                 TO &lt;vim_prtfky_extract&gt;.
        CLEAR prtfky_field_changed.
        IF status-action EQ hinzufuegen OR status-action EQ kopieren OR
           vim_special_mode EQ vim_upgrade.
          CLEAR cur_mkey_found.
          LOOP AT total.               &quot;            current mainkey.
            CHECK &lt;vim_tot_mkey_beforex&gt; EQ &lt;vim_mkey_beforex&gt; AND
                  ( vim_mkey_after_exists EQ space OR
                    &lt;vim_tot_mkey_afterx&gt; EQ &lt;vim_mkey_afterx&gt; ).
*            CHECK &lt;vim_tot_mkey_before&gt; EQ &lt;vim_mkey_before&gt; AND
*                  ( vim_mkey_after_exists EQ space OR
*                    &lt;vim_tot_mkey_after&gt; EQ &lt;vim_mkey_after&gt; ).
            cur_mkey_found = &apos;X&apos;. EXIT.
          ENDLOOP.
          IF cur_mkey_found NE space.
            IF &lt;vim_prtfky_wa&gt; IS INITIAL. &quot;no entry -&gt; use exist. value
              MOVE &lt;vim_prtfky_total&gt; TO &lt;vim_prtfky_wa&gt;.
              TRANSLATE &lt;status&gt;-upd_flag USING &apos;EY&apos;.
              IF &lt;status&gt;-upd_flag EQ &apos;Y&apos;.
                PERFORM (formname) IN PROGRAM (sy-repid)
                                   USING &lt;table1&gt; &lt;table1_text&gt;.
              ENDIF.
            ELSEIF &lt;vim_prtfky_wa&gt; NE &lt;vim_prtfky_total&gt;.
              MOVE &apos;X&apos; TO prtfky_field_changed.
            ENDIF.
          ENDIF.
        ELSEIF &lt;vim_prtfky_wa&gt; NE &lt;vim_prtfky_extract&gt;.
          MOVE &apos;X&apos; TO prtfky_field_changed.
        ENDIF.
        ADD 1 TO count.
      ENDLOOP.
      IF count EQ 1.
        MOVE &apos;X&apos; TO vim_prtfky_assigned.
      ENDIF.
    ELSE.     &quot; vim_prtfky_assigned = &apos;X&apos;
      IF status-action EQ hinzufuegen OR status-action EQ kopieren OR
         vim_special_mode EQ vim_upgrade.
        LOOP AT total.                 &quot;            current mainkey.
          CHECK &lt;vim_tot_mkey_beforex&gt; EQ &lt;vim_mkey_beforex&gt; AND
                ( vim_mkey_after_exists EQ space OR
                  &lt;vim_tot_mkey_afterx&gt; EQ &lt;vim_mkey_afterx&gt; ).
*          CHECK &lt;vim_tot_mkey_before&gt; EQ &lt;vim_mkey_before&gt; AND
*                ( vim_mkey_after_exists EQ space OR
*                  &lt;vim_tot_mkey_after&gt; EQ &lt;vim_mkey_after&gt; ).
          cur_mkey_found = &apos;X&apos;. EXIT.
        ENDLOOP.
        IF cur_mkey_found NE space.
          IF &lt;vim_prtfky_wa&gt; IS INITIAL. &quot;no entry -&gt; use exist. value
            MOVE &lt;vim_prtfky_total&gt; TO &lt;vim_prtfky_wa&gt;.
            TRANSLATE &lt;status&gt;-upd_flag USING &apos;EY&apos;.
            IF &lt;status&gt;-upd_flag EQ &apos;Y&apos;.
              PERFORM (formname) IN PROGRAM (sy-repid)
                                 USING &lt;table1&gt; &lt;table1_text&gt;.
            ENDIF.
          ELSEIF &lt;vim_prtfky_wa&gt; NE &lt;vim_prtfky_total&gt;.
            MOVE &apos;X&apos; TO prtfky_field_changed.
          ENDIF.
        ENDIF.
      ELSEIF &lt;vim_prtfky_wa&gt; NE &lt;vim_prtfky_extract&gt;.
        MOVE &apos;X&apos; TO prtfky_field_changed.
      ENDIF.
    ENDIF.
*  if verändert.
    IF prtfky_field_changed NE space.
      IF cpff_alert NE space.
        sy-msgv1 = svim_text_030.
        sy-msgv2 = &lt;vim_mainkey_mask&gt;. TRANSLATE sy-msgv2 USING &apos;+ &apos;.
        IF x_header-clidep NE space.
          SHIFT sy-msgv2 BY client_length PLACES.
        ENDIF.
        count = strlen( sy-msgv2 ).
        ASSIGN sy-msgv2(count) TO &lt;dummy1&gt;.
        REPLACE &apos;&amp;&apos; WITH &lt;dummy1&gt; INTO sy-msgv1.
        CALL FUNCTION &apos;POPUP_TO_CONFIRM_WITH_MESSAGE&apos;
          EXPORTING
            diagnosetext1  = svim_text_031
            diagnosetext2  = svim_text_032
            diagnosetext3  = svim_text_033
            textline1      = svim_text_034
            textline2      = svim_text_035
            titel          = sy-msgv1
            cancel_display = space
          IMPORTING
            answer         = answer.
      ELSE.
        answer = &apos;J&apos;.
      ENDIF.
      IF answer EQ &apos;A&apos;.
        answer = &apos;N&apos;.
      ENDIF.
      CASE answer.
*       WHEN &apos;A&apos;. &quot;cancel --&gt; what to do ? same as NO ?
        WHEN &apos;J&apos;.                      &quot;yes, change all
          IF status-action EQ hinzufuegen OR status-action EQ kopieren.
            PERFORM check_key.
          ELSEIF ( x_header-customauth CO sap_cust_ctrl_classes OR
                   vim_ale_keyspec_check NE space OR
                   vim_sync_keyspec_check NE space ).
            PERFORM check_allowed_keyranges.
          ENDIF.
          LOOP AT total.
            CHECK &lt;vim_xtotal_key&gt; NE &lt;f1_x&gt; AND
                  &lt;vim_tot_mkey_beforex&gt; EQ &lt;vim_mkey_beforex&gt; AND
                  ( vim_mkey_after_exists EQ space OR
                    &lt;vim_tot_mkey_afterx&gt; EQ &lt;vim_mkey_afterx&gt; ).
*            CHECK &lt;vim_total_key&gt; NE &lt;f1&gt; AND
*                  &lt;vim_tot_mkey_before&gt; EQ &lt;vim_mkey_before&gt; AND
*                  ( vim_mkey_after_exists EQ space OR
*                    &lt;vim_tot_mkey_after&gt; EQ &lt;vim_mkey_after&gt; ).
*         move der entsprech. Felder --&gt; gemäß X_NAMTAB, zum PBO füllen
            IF vim_prtfky_assigned CO &apos; Y&apos;.
              LOOP AT x_namtab WHERE prtfrkyfld NE space.
                IF vim_prtfky_assigned EQ space.
                  IF x_header-bastab EQ space          &quot;view
                   OR x_header-texttbexst EQ space     &quot;no texttable
                   OR x_namtab-texttabfld EQ space.    &quot;no texttabfield
* not a texttablefield in a table &amp; texttable
                    ASSIGN: COMPONENT x_namtab-viewfield
                       OF STRUCTURE &lt;table1&gt;
                       TO &lt;vim_prtfky_wa&gt;,
                     COMPONENT x_namtab-viewfield
                      OF STRUCTURE &lt;vim_total_struc&gt;
                      TO &lt;vim_prtfky_total&gt;.
                  ELSE.
                    ASSIGN: COMPONENT x_namtab-viewfield
                             OF STRUCTURE &lt;table1_text&gt;
                             TO &lt;vim_prtfky_wa&gt;,
                            COMPONENT x_namtab-viewfield
                             OF STRUCTURE &lt;vim_tot_txt_struc&gt;
                             TO &lt;vim_prtfky_total&gt;.
                  ENDIF.
                ENDIF.
*                  IF x_header-bastab EQ space OR
*                     x_header-texttbexst EQ space OR
*                     x_namtab-texttabfld EQ space.
*                    ASSIGN &lt;table1&gt;+x_namtab-position(x_namtab-flength)
*                                              TO &lt;vim_prtfky_wa&gt;.
*                  ELSE.
*                    offs = x_namtab-position - x_header-tablen.
*                    ASSIGN &lt;table1_text&gt;+offs(x_namtab-flength)
*                                              TO &lt;vim_prtfky_wa&gt;.
*                  ENDIF.
*                ENDIF.
*                ASSIGN total+x_namtab-position(x_namtab-flength)
*                                         TO &lt;vim_prtfky_total&gt;.
                MOVE &lt;vim_prtfky_wa&gt; TO &lt;vim_prtfky_total&gt;.
              ENDLOOP.
            ELSE.
              MOVE &lt;vim_prtfky_wa&gt; TO &lt;vim_prtfky_total&gt;.
            ENDIF.
            MODIFY total.
            READ TABLE extract WITH KEY &lt;vim_xtotal_key&gt;.
            IF sy-subrc EQ 0.
              MOVE total TO extract.
              MODIFY extract INDEX sy-tabix.
            ENDIF.
          ENDLOOP.
          vim_prt_fky_flds_updated = &apos;X&apos;.
        WHEN &apos;N&apos;.
*       text aus Extract bzw. Total (hinzuf.) nehmen
          IF vim_prtfky_assigned CO &apos; Y&apos;.
            LOOP AT x_namtab WHERE prtfrkyfld NE space.
              IF vim_prtfky_assigned EQ space.
                IF x_header-bastab EQ space             &quot;view
                 OR x_header-texttbexst EQ space        &quot;no texttable
               OR x_namtab-texttabfld EQ space.       &quot;no texttabfield
* not a texttablefield in a table &amp; texttable
                  ASSIGN: COMPONENT x_namtab-viewfield
                       OF STRUCTURE &lt;table1&gt;
                       TO &lt;vim_prtfky_wa&gt;,
                     COMPONENT x_namtab-viewfield
                      OF STRUCTURE &lt;vim_total_struc&gt;
                      TO &lt;vim_prtfky_total&gt;,
                     COMPONENT x_namtab-viewfield
                      OF STRUCTURE &lt;vim_extract_struc&gt;
                      TO  &lt;vim_prtfky_extract&gt;.
                ELSE.
                  ASSIGN: COMPONENT x_namtab-viewfield
                           OF STRUCTURE &lt;table1_text&gt;
                           TO &lt;vim_prtfky_wa&gt;,
                          COMPONENT x_namtab-viewfield
                           OF STRUCTURE &lt;vim_tot_txt_struc&gt;
                           TO &lt;vim_prtfky_total&gt;,
                          COMPONENT x_namtab-viewfield
                           OF STRUCTURE &lt;vim_ext_txt_struc&gt;
                           TO  &lt;vim_prtfky_extract&gt;.
                ENDIF.
              ENDIF.
*                IF x_header-bastab EQ space OR
*                   x_header-texttbexst EQ space OR
*                   x_namtab-texttabfld EQ space.
*                  ASSIGN &lt;table1&gt;+x_namtab-position(x_namtab-flength)
*                                            TO &lt;vim_prtfky_wa&gt;.
*                ELSE.
*                  offs = x_namtab-position - x_header-tablen.
*                  ASSIGN &lt;table1_text&gt;+offs(x_namtab-flength)
*                                            TO &lt;vim_prtfky_wa&gt;.
*                ENDIF.
*              ENDIF.
*              ASSIGN: total+x_namtab-position(x_namtab-flength)
*                                       TO &lt;vim_prtfky_total&gt;,
*                      extract+x_namtab-position(x_namtab-flength)
*                                       TO &lt;vim_prtfky_extract&gt;.
              IF status-action EQ hinzufuegen OR
                 status-action EQ kopieren OR
                 vim_special_mode EQ vim_upgrade.
                MOVE &lt;vim_prtfky_total&gt; TO &lt;vim_prtfky_wa&gt;.
              ELSE.
                MOVE &lt;vim_prtfky_extract&gt; TO &lt;vim_prtfky_wa&gt;.
              ENDIF.
            ENDLOOP.
          ELSE.
            IF status-action EQ hinzufuegen OR
               status-action EQ kopieren OR
               vim_special_mode EQ vim_upgrade.
              MOVE &lt;vim_prtfky_total&gt; TO &lt;vim_prtfky_wa&gt;.
            ELSE.
              MOVE &lt;vim_prtfky_extract&gt; TO &lt;vim_prtfky_wa&gt;.
            ENDIF.
          ENDIF.
          IF ( x_header-bastab EQ space OR  &quot;view or no texttab and..
               x_header-texttbexst EQ space ) AND
             &lt;table1_x&gt; EQ &lt;vim_xextract&gt;.     &quot;..no change
            CLEAR &lt;status&gt;-upd_flag.
          ELSEIF x_header-bastab NE space AND &quot;bastab with texttab and
                 x_header-texttbexst NE space AND
                 &lt;table1_xtext&gt; EQ &lt;vim_xextract_text&gt;.
* no change of text
            TRANSLATE &lt;status&gt;-upd_flag USING &apos;XET &apos;.
          ENDIF.
      ENDCASE.
    ENDIF. &quot;vim_prtfky_field_changed ne space
  ENDIF. &quot;COUNT eq 99   other entries for mainkey (may be) exist
ENDFORM.                               &quot;consistency_prt_frky_fields</include_source>
   </include>
   <include NAME="LSVIMF0N" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000004" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122423" IDATE="20080721" ITIME="122423">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  TEMP_DELIM_DETERMINE_ACTION                             *
*&amp;--------------------------------------------------------------------*
* determine action flag                                               *
*&amp;--------------------------------------------------------------------*
FORM TEMP_DELIM_DETERMINE_ACTION USING VALUE(TDDA_INDEX) TDDA_ACT
                                                         TDDA_ACT_TXT.
  LOCAL: TOTAL.
  READ TABLE TOTAL INDEX TDDA_INDEX.
  IF &lt;ACTION&gt; EQ NEUER_GELOESCHT.
    TDDA_ACT = NEUER_EINTRAG.
  ELSE.
    TDDA_ACT = AENDERN.
  ENDIF.
  IF X_HEADER-BASTAB NE SPACE AND X_HEADER-TEXTTBEXST NE SPACE.
    IF &lt;ACTION_TEXT&gt; EQ NEUER_GELOESCHT.
      TDDA_ACT_TXT = NEUER_EINTRAG.
    ELSE.
      TDDA_ACT_TXT = AENDERN.
    ENDIF.
  ENDIF.
ENDFORM.                               &quot;temp_delim_determine_action</include_source>
   </include>
   <include NAME="LSVIMF0O" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000007" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122423" IDATE="20080721" ITIME="122423">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form TEMPORAL_DELIMITATION                                    *
*&amp;--------------------------------------------------------------------*
* process temporal delimitation                                       *
*&amp;--------------------------------------------------------------------*
FORM temporal_delimitation.
  constants: highdate TYPE d VALUE &apos;99991231&apos;.
  DATA: entries_exist(1) TYPE c,
        enddate_safe TYPE d, act(1) TYPE c, act_txt(1) TYPE c,
        hf TYPE i,
        date_safe TYPE d,
        ok_code_safe LIKE ok_code, function_safe LIKE function,
        delim_entr_safe TYPE STANDARD TABLE OF vim_delim_entr_tl
         WITH DEFAULT KEY INITIAL SIZE 10,
        collapsed_mkeys_safe TYPE STANDARD TABLE
         OF vim_collapsed_mkeys_tl WITH DEFAULT KEY INITIAL SIZE 1,
        merged_entr_safe TYPE STANDARD TABLE      &quot;merged entries
         OF vim_merged_entr_tl WITH DEFAULT KEY INITIAL SIZE 1.

  CHECK x_header-delmdtflag NE space.
* check if dates entered properly
  IF ( &lt;vim_new_begdate&gt; is initial OR
     &lt;vim_enddate_mask&gt; EQ vim_init_date ) AND
     status-mode EQ list_bild.         &quot;only on list screen
    MESSAGE e127(sv).&quot;Bitte den Gültigkeitsbereich eingrenzen
  ENDIF.
* process delimitation
  IF x_header-clidep NE space.
    MOVE sy-mandt TO &lt;client&gt;.
  ENDIF.
  IF &lt;xact&gt; NE leer AND neuer NE &apos;J&apos; AND status-delete NE geloescht AND
     ( status-action NE kopieren AND vim_special_mode EQ space OR
       vim_special_mode EQ vim_delimit ).
    READ TABLE total WITH KEY &lt;vim_xextract_key&gt; BINARY SEARCH.
    CHECK sy-subrc EQ 0.
  ELSE. &quot;entry is new (input, copy, undelete, reset, replace, upgrade)
    IF status-mode EQ list_bild.           &quot;only on list screen
      IF x_header-delmdtflag EQ &apos;E&apos; AND    &quot;end date is key field
         &lt;vim_new_begdate&gt; GT &lt;vim_enddate_mask&gt;.
        MESSAGE e045(sv). &quot;Bitte ein Beginn-Datum angeben, das vor dem
      ELSEIF x_header-delmdtflag EQ &apos;B&apos; AND    &quot;begin date is key field
             &lt;vim_new_begdate&gt; LT &lt;vim_enddate_mask&gt;.
        MESSAGE e046(sv). &quot;Bitte ein Ende-Datum angeben, das nach dem be
      ENDIF.
    ENDIF.
    LOOP AT total.
      CHECK &lt;vim_tot_mkey_beforex&gt; EQ &lt;vim_f1_beforex&gt; AND
            ( vim_mkey_after_exists EQ space OR
              &lt;vim_tot_mkey_afterx&gt; EQ &lt;vim_f1_afterx&gt; ).
*      CHECK &lt;vim_tot_mkey_before&gt; EQ &lt;vim_f1_before&gt; AND
*            ( vim_mkey_after_exists EQ space OR
*              &lt;vim_tot_mkey_after&gt; EQ &lt;vim_f1_after&gt; ).
      MOVE &apos;X&apos; TO entries_exist.
      EXIT.
    ENDLOOP.
    CHECK entries_exist NE space.
    MOVE: &lt;table2_x&gt; TO &lt;vim_xtotal&gt;,
          &lt;vim_enddate_mask&gt; TO &lt;vim_enddate&gt;.
    IF x_header-delmdtflag EQ &apos;E&apos;.
      MOVE highdate TO &lt;vim_begdate&gt;.
    ELSE.
      CLEAR &lt;vim_begdate&gt;.
    ENDIF.
  ENDIF.
  CHECK &lt;vim_new_begdate&gt; NE &lt;vim_begdate&gt;.
* check allowed keyranges
  IF x_header-customauth CO sap_cust_ctrl_classes OR
     vim_ale_keyspec_check NE space OR
     vim_sync_keyspec_check NE space.
    PERFORM check_allowed_keyranges.
  ENDIF.
  IF x_header-delmdtflag EQ &apos;E&apos;.       &quot;end date is key field
    IF &lt;vim_new_begdate&gt; GT &lt;vim_enddate&gt;.
      MESSAGE e045(sv). &quot;Bitte ein Beginn-Datum angeben, das vor dem End
    ELSEIF &lt;vim_new_begdate&gt; LT &lt;vim_begdate&gt;.
      PERFORM temp_delim_del_overld_entries USING &lt;vim_new_begdate&gt;
                                                  &lt;vim_enddate&gt;.
    ELSE.
      &lt;vim_enddate&gt; = &lt;vim_new_begdate&gt; - 1.
      IF x_header-texttbexst NE space AND
         x_header-ptfrkyexst EQ space.
        PERFORM vim_temp_delim_texttab
          USING &lt;vim_enddate_mask&gt; &lt;vim_xextract_key&gt;. &quot;SW Texttransl
        IF x_header-bastab NE space.
          MOVE: &lt;vim_enddate&gt; TO &lt;vim_text_enddate&gt;,
                neuer_eintrag TO &lt;action_text&gt;.
        ENDIF.
      ENDIF.
      READ TABLE total WITH KEY &lt;vim_xtotal_key&gt; BINARY SEARCH
                                                TRANSPORTING NO FIELDS.
*      READ TABLE total WITH KEY &lt;vim_total_key&gt; BINARY SEARCH
*                                                TRANSPORTING NO FIELDS.
      IF sy-subrc NE 0.
        &lt;action&gt; = neuer_eintrag.
        &lt;mark&gt; = nicht_markiert.       &quot;new entries are never marked
        INSERT total INDEX sy-tabix.
      ELSE.
* entry MUST be a deleted one
        MESSAGE w121(sv). &quot;Gelöschter Eintrag wird zurückgeholt und ggf.
        PERFORM temp_delim_determine_action USING sy-tabix act act_txt.
        &lt;action&gt; = act.
        IF x_header-bastab NE space AND x_header-texttbexst NE space.
          &lt;action_text&gt; = act_txt.
        ENDIF.
        MODIFY total INDEX sy-tabix.
      ENDIF.
    ENDIF.
  ELSE.                                &quot;begin date is key field
    IF &lt;vim_new_begdate&gt; LT &lt;vim_enddate&gt;.
      MESSAGE e046(sv). &quot;Bitte ein Ende-Datum angeben, das nach dem begi
    ELSEIF &lt;vim_new_begdate&gt; GT &lt;vim_begdate&gt;.
      PERFORM temp_delim_del_overld_entries USING &lt;vim_new_begdate&gt;
                                                  &lt;vim_enddate&gt;.
    ELSE.
      &lt;vim_begdate&gt; = &lt;vim_new_begdate&gt;.
      IF x_header-bastab NE space AND x_header-texttbexst NE space AND
         x_header-ptfrkyexst EQ space.
        IF &lt;action_text&gt; EQ original.
          MOVE aendern   TO &lt;action_text&gt;.
        ENDIF.
      ENDIF.
      IF &lt;action&gt; EQ original.
        &lt;action&gt; = aendern.
      ENDIF.
      MODIFY total INDEX sy-tabix.
      total = extract.
      &lt;vim_enddate&gt; = &lt;vim_new_begdate&gt; + 1.
      &lt;action&gt; = &lt;xact&gt; = neuer_eintrag.
      IF x_header-bastab NE space AND x_header-texttbexst NE space AND
         x_header-ptfrkyexst EQ space.
        MOVE: &lt;vim_enddate&gt; TO &lt;vim_text_enddate&gt;,
              neuer_eintrag TO &lt;action_text&gt;,
              neuer_eintrag TO &lt;xact_text&gt;.
      ENDIF.
      anz_pages = sy-tabix + 1.
      INSERT total INDEX anz_pages.
    ENDIF.
  ENDIF.                               &quot;x_header-delmdtflag eq &apos;E&apos;
  IF temporal_delimitation_happened EQ &apos;N&apos;.
    CLEAR temporal_delimitation_happened. EXIT.
  ENDIF.
  IF temporal_delimitation_happened NE &apos;G&apos;.
    MOVE sy-tabix TO anz_pages.
    LOOP AT vim_delim_entries WHERE index1 GE anz_pages.
      ADD 1 TO vim_delim_entries-index1.
      MODIFY vim_delim_entries.
    ENDLOOP.
    MOVE: anz_pages TO vim_delim_entries-index1,
          nextline  TO vim_delim_entries-index2,
          space     TO vim_delim_entries-index3.
    APPEND vim_delim_entries.
    MOVE &apos;X&apos; TO temporal_delimitation_happened.
  ENDIF.
  IF &lt;xact&gt; NE leer AND neuer NE &apos;J&apos; AND status-delete NE geloescht AND
     ( status-action NE kopieren AND vim_special_mode EQ space OR
       vim_special_mode EQ vim_delimit ).
    IF x_header-adrnbrflag NE space.
* if entry contains address number: ask if new address is wanted
      CALL FUNCTION &apos;POPUP_TO_DECIDE&apos;   &quot;#EC *
           EXPORTING
                defaultoption = &apos;1&apos;
                titel         = svim_text_037
                textline1     = svim_text_038
                textline2     = svim_text_039
                textline3     = svim_text_040
                text_option1  = svim_text_041
                text_option2  = svim_text_042
           IMPORTING
                answer        = answer.
      CASE answer.
        WHEN &apos;A&apos;. EXIT.
        WHEN &apos;2&apos;.                      &quot;clear old address number
          CLEAR &lt;address_number&gt;.
        WHEN OTHERS.                   &quot;copy old address
* not yet possible
      ENDCASE.
    ENDIF.
    IF x_header-guidflag &lt;&gt; space.
      PERFORM vim_make_guid USING space.
    ENDIF.
* if user exit for hidden fields exists: perform exit routine
    IF x_header-frm_h_flds NE space.
      PERFORM (x_header-frm_h_flds) IN PROGRAM.
    ENDIF.
* if user exit for new entries exists: perform exit routine
    IF x_header-frm_on_new NE space.
      PERFORM (x_header-frm_on_new) IN PROGRAM.
    ENDIF.
* if entry contains address number: call address maintain
    IF x_header-adrnbrflag NE space AND answer EQ &apos;2&apos;.
      PERFORM address_maintain.
    ENDIF.
* if user exit after delimitation exists: perform exit routine
    IF x_header-frm_af_dlm NE space.
      delim_entr_safe = vim_delim_entries[].
      collapsed_mkeys_safe = vim_collapsed_mainkeys[].
      merged_entr_safe = vim_merged_entries[].
      IF status-mode EQ detail_bild.
        ok_code_safe = ok_code. function_safe = function.
      ENDIF.
      PERFORM (x_header-frm_af_dlm) IN PROGRAM.
      MOVE delim_entr_safe TO vim_delim_entries[].
      MOVE collapsed_mkeys_safe TO vim_collapsed_mainkeys[].
      MOVE merged_entr_safe TO vim_merged_entries[].
      IF status-mode EQ detail_bild.
        MOVE: ok_code_safe TO ok_code, function_safe TO function.
      ENDIF.
    ENDIF.
  ENDIF.
ENDFORM.                               &quot;temp_delimitation</include_source>
   </include>
   <include NAME="LSVIMF0P" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000004" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122423" IDATE="20080721" ITIME="122424">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  TEMP_DELIM_UNDELETE                                     *
*&amp;--------------------------------------------------------------------*
* process undelete of non-selected entries due to temp. delimitation  *
*&amp;--------------------------------------------------------------------*
* TDU_ENDDA --&gt; enddate to display during warning                     *
* TDU_ACT   --&gt; value of action flag                                  *
* TDU_ACT_TXT --&gt; value of action flag for text table                 *
* TDU_IX    --&gt; index of entry to modify in TOTAL                     *
* COUNTER   &lt;-&gt; (global) number of undeleted entries                  *
* SY-SUBRC  &lt;-- (global) 0 - curr. entry undeleted, others - new entry*
*&amp;--------------------------------------------------------------------*
FORM temp_delim_undelete USING value(tdu_endda) value(tdu_begda)
                               tdu_act tdu_act_txt tdu_ix.
  LOCAL: total.
  DATA: trans_pattern(6) TYPE c, rec TYPE i, ix TYPE i.

  CLEAR tdu_ix.
  READ TABLE total WITH KEY &lt;vim_xtotal_key&gt; BINARY SEARCH.
  IF sy-subrc EQ 0. &quot;new entry already exists - must be a deleted
    &quot;by previous temporal delimitation one
    IF &lt;action&gt; EQ geloescht OR &lt;action&gt; EQ neuer_geloescht OR
       &lt;action&gt; EQ update_geloescht.
      tdu_ix = sy-tabix.
      READ TABLE extract WITH KEY &lt;vim_xtotal_key&gt;.
      rec = sy-subrc. ix = sy-tabix.
      IF sy-subrc EQ 0 AND &lt;xact&gt; EQ markiert.
        SUBTRACT 1 FROM mark_extract.
      ELSE.
        MOVE tdu_endda TO &lt;vim_enddate_mask&gt;.
        IF vim_special_mode EQ vim_reset.
          MESSAGE i120(sv).&quot;Es werden weitere Einträge zurückgeholt
        ELSE.
          MESSAGE w120(sv).&quot;Es werden weitere Einträge zurückgeholt
        ENDIF.
      ENDIF.
      ADD 1 TO counter.
      IF rec EQ 0.                     &quot;read table extract subrc
        sy-fdpos = vim_delim_entries-index3.
        vim_delim_entries-index3 = ix.
        APPEND vim_delim_entries.
        vim_delim_entries-index3 = sy-fdpos.
      ENDIF.
      MOVE: geloescht TO trans_pattern,
              original TO trans_pattern+1(1),
            neuer_geloescht TO trans_pattern+2(1),
              neuer_eintrag TO trans_pattern+3(1),
            update_geloescht TO trans_pattern+4(1),
              aendern TO trans_pattern+5(1).
      TRANSLATE &lt;action&gt; USING trans_pattern.
      MOVE &lt;action&gt; TO tdu_act.
      IF x_header-bastab NE space AND
         x_header-texttbexst NE space.
        TRANSLATE &lt;action_text&gt; USING trans_pattern.
        MOVE &lt;action_text&gt; TO tdu_act_txt.
      ENDIF.
      IF tdu_begda NE &lt;vim_begdate&gt;.   &quot;udl entry will be modified
        MOVE: original TO trans_pattern, aendern TO trans_pattern+1.
        TRANSLATE: tdu_act USING trans_pattern,
                   tdu_act_txt USING trans_pattern.
      ENDIF.
    ENDIF.                             &quot;current entry is a deleted one
    CLEAR sy-subrc.
  ENDIF.                               &quot;sy-subrc eq 0
ENDFORM.                               &quot;temp_delim_undelete</include_source>
   </include>
   <include NAME="LSVIMF0Q" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000004" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122424" IDATE="20080721" ITIME="122424">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  TEMP_DELIM_DEL_OVERLED_ENTRIES                          *
*&amp;--------------------------------------------------------------------*
* delete entries with overlaying time ranges                          *
*---------------------------------------------------------------------*
* BEGDATE ---&gt; E: new begin date /B: new end date                     *
* ENDDATE ---&gt; E: end date /B: begin date                             *
*&amp;--------------------------------------------------------------------*
FORM temp_delim_del_overld_entries USING value(begdate) TYPE d
                                         value(enddate) TYPE d.
  LOCAL: extract, &lt;table1&gt;.
  DATA: first(1) TYPE c VALUE &apos;X&apos;, overlayed(1) TYPE c, cur_ix TYPE i,
        date_increment TYPE i, enddate_safe(8) TYPE c, new_ix TYPE i,
        trans_pattern(6) TYPE c, act_safe, mark_safe, act_txt_safe,
        enddate_safe2(8) TYPE c, act, act_txt, hf TYPE i,
        key_safe LIKE vim_merged_entries-new_key, date_safe TYPE d,
*        old_key TYPE vim_line_ul,
        old_keyx type VRSDAT1000.

  IF vim_temp_delim_alr_checked NE space.
    CLEAR first.
  ENDIF.
  LOOP AT total.
    CHECK &lt;vim_tot_mkey_beforex&gt; EQ &lt;vim_f1_beforex&gt; AND
          ( vim_mkey_after_exists EQ space OR
            &lt;vim_tot_mkey_afterx&gt; EQ &lt;vim_f1_afterx&gt; ).
    IF vim_special_mode NE vim_upgrade AND
       vim_special_mode NE vim_reset AND
       vim_special_mode NE vim_replace.
      CHECK &lt;vim_enddate&gt; NE enddate.
    ENDIF.
    CHECK &lt;action&gt; NE geloescht AND
          &lt;action&gt; NE neuer_geloescht AND
          &lt;action&gt; NE update_geloescht.
    CLEAR overlayed.
    IF x_header-delmdtflag EQ &apos;E&apos;.     &quot;end date is key field
      CHECK &lt;vim_enddate&gt; GE begdate AND &lt;vim_begdate&gt; LE enddate.
      IF &lt;vim_begdate&gt; GE begdate AND &lt;vim_enddate&gt; LT enddate.
        MOVE &apos;F&apos; TO overlayed. &quot;whole old entry is overlayed by new one
      ELSEIF &lt;vim_begdate&gt; LT begdate AND &lt;vim_enddate&gt; GT enddate.
        MOVE &apos;M&apos; TO overlayed. &quot;middle of old entry is overl. by new one
      ELSEIF &lt;vim_begdate&gt; LE enddate AND &lt;vim_enddate&gt; GT enddate.
        MOVE &apos;P&apos; TO overlayed. &quot;part of old entry is overlayed by new on
      ELSEIF &lt;vim_begdate&gt; EQ begdate AND &lt;vim_enddate&gt; EQ enddate.
        temporal_delimitation_happened = &apos;N&apos;. EXIT. &quot;no delim required
      ELSEIF &lt;vim_enddate&gt; EQ enddate.
        MOVE &apos;E&apos; TO overlayed. &quot;end of old entry is overlayed by new one
      ENDIF.
      MOVE -1 TO date_increment.
    ELSE.                              &quot;begin date is key field
      CHECK &lt;vim_enddate&gt; LE begdate AND &lt;vim_begdate&gt; GE enddate. &quot;entr
      IF &lt;vim_begdate&gt; LE begdate AND &lt;vim_enddate&gt; GT enddate.
        MOVE &apos;F&apos; TO overlayed. &quot;whole old entry is overlayed by new one
      ELSEIF &lt;vim_enddate&gt; LT enddate AND &lt;vim_begdate&gt; GT begdate.
        MOVE &apos;M&apos; TO overlayed. &quot;middle of old entry is overl. by new one
      ELSEIF &lt;vim_enddate&gt; LE enddate AND &lt;vim_begdate&gt; GT enddate.
        MOVE &apos;P&apos; TO overlayed. &quot;part of old entry is overlayed by new on
      ELSEIF &lt;vim_begdate&gt; EQ begdate AND &lt;vim_enddate&gt; EQ enddate.
        temporal_delimitation_happened = &apos;N&apos;. EXIT. &quot;no delim required
      ELSEIF &lt;vim_enddate&gt; EQ enddate.
        MOVE &apos;E&apos; TO overlayed. &quot;begin of old entry is overlayed by new o
      ENDIF.
      MOVE 1 TO date_increment.
    ENDIF.                             &quot;x_header-delmdtflag eq &apos;E&apos;
    IF first NE space.
      IF vim_special_mode NE vim_reset.
        MESSAGE w047(sv). &quot;Überlagerte Sätze werden gelöscht
      ELSE.
        MESSAGE i047(sv). &quot;Überlagerte Sätze werden gelöscht
      ENDIF.
      CLEAR first.
    ENDIF.
    cur_ix = sy-tabix.
    CLEAR vim_delim_entries.
    READ TABLE extract WITH KEY &lt;vim_xtotal_key&gt;.
*    READ TABLE extract WITH KEY total.
    IF sy-subrc EQ 0.
      MOVE sy-tabix TO vim_delim_entries-index3.
      IF overlayed NE &apos;P&apos; AND overlayed NE &apos;M&apos; AND overlayed NE &apos;E&apos;.
        APPEND vim_delim_entries.
      ENDIF.
    ENDIF.
    IF overlayed EQ space OR overlayed EQ &apos;F&apos;.
* delete old entry which is overlayed
      MOVE: original TO trans_pattern, geloescht TO trans_pattern+1(1),
            aendern  TO trans_pattern+2(1), update_geloescht
                                                 TO trans_pattern+3(1),
            neuer_eintrag TO trans_pattern+4(1), neuer_geloescht
                                                 TO trans_pattern+5(1).
      TRANSLATE &lt;action&gt; USING trans_pattern.
      IF x_header-bastab NE space AND x_header-texttbexst NE space AND
         x_header-ptfrkyexst EQ space.
        TRANSLATE &lt;action_text&gt; USING trans_pattern.
      ENDIF.
      IF &lt;mark&gt; EQ markiert.
        &lt;mark&gt; = nicht_markiert.
        SUBTRACT 1 FROM mark_total.
      ENDIF.
      MODIFY total.
    ENDIF. &quot;overlayed eq space or overlayed eq &apos;F&apos;
    IF overlayed EQ space OR overlayed EQ &apos;M&apos; OR overlayed EQ &apos;E&apos;.
* create new entry due to delimitation
      IF overlayed EQ &apos;M&apos;.
        MOVE: &lt;vim_enddate&gt; TO enddate_safe, &lt;action&gt; TO act_safe,
              &lt;mark&gt; TO mark_safe.
        IF x_header-bastab NE space AND x_header-texttbexst NE space.
          MOVE &lt;action_text&gt; TO act_txt_safe.
        ENDIF.
      ENDIF.
      CLEAR hf.
      old_keyx = &lt;vim_xtotal_key&gt;.                 &quot;SW Texttransl
*      old_key = total.
      &lt;vim_enddate&gt; = begdate + date_increment.
      CHECK &lt;vim_enddate&gt; GE &lt;vim_begdate&gt;.                 &quot;aro 070798
      &lt;action&gt; = neuer_eintrag.
      &lt;mark&gt; = nicht_markiert.
      IF x_header-texttbexst NE space AND
         x_header-ptfrkyexst EQ space.
        PERFORM vim_temp_delim_texttab
                 USING enddate old_keyx.  &quot;SW Texttransl
        IF x_header-bastab NE space.
          MOVE: &lt;vim_enddate&gt; TO &lt;vim_text_enddate&gt;,
                neuer_eintrag TO &lt;action_text&gt;.
        ENDIF.
      ENDIF.
      IF vim_special_mode NE space.    &quot;special mode
        PERFORM temp_delim_undelete USING &lt;vim_enddate_mask&gt;
                                          &lt;vim_begdate&gt;
                                          act act_txt new_ix.
        IF new_ix NE 0.
          MOVE act TO &lt;action&gt;.
          IF x_header-bastab NE space AND x_header-texttbexst NE space.
            MOVE act_txt TO &lt;action_text&gt;.
          ENDIF.
          MODIFY total INDEX new_ix.
        ENDIF.
      ENDIF.                           &quot;special mode
      IF vim_special_mode EQ space OR sy-subrc NE 0.
        IF x_header-delmdtflag EQ &apos;E&apos;. &quot;end date is key field
          new_ix = cur_ix. INSERT total.
        ELSE.                          &quot;begin date is key field
          new_ix = cur_ix + 1. INSERT total INDEX new_ix.
        ENDIF.                         &quot;x_header-delmdtflag eq &apos;E&apos;
      ENDIF.
      IF vim_special_mode NE vim_undelete AND
         vim_delim_entries-index3 NE 0.
        vim_delim_entries-index1 = new_ix.
        vim_delim_entries-index2 = vim_delim_entries-index3.
        sy-fdpos = vim_delim_entries-index3.
        CLEAR vim_delim_entries-index3.
        APPEND vim_delim_entries.
        vim_delim_entries-index3 = sy-fdpos.
      ENDIF.                           &quot;no undelete mode
    ENDIF. &quot;overlayed eq space or overlayed eq &apos;M&apos;
    IF overlayed EQ &apos;P&apos; OR overlayed EQ &apos;M&apos;.
      IF overlayed EQ &apos;M&apos;.
        MOVE: enddate_safe TO &lt;vim_enddate&gt;, act_safe TO &lt;action&gt;,
              mark_safe TO &lt;mark&gt;.
        IF x_header-bastab NE space AND x_header-texttbexst NE space.
          MOVE act_txt_safe TO &lt;action_text&gt;.
        ENDIF.
      ENDIF.
      CLEAR hf.
      &lt;vim_begdate&gt; = enddate - date_increment.
      MOVE: original TO trans_pattern, aendern TO trans_pattern+1(1).
      TRANSLATE &lt;action&gt; USING trans_pattern.
      IF &lt;mark&gt; EQ markiert.
        &lt;mark&gt; = nicht_markiert.
        SUBTRACT 1 FROM mark_total.
      ENDIF.
      MODIFY total.
      IF vim_delim_entries-index3 NE 0.
        vim_delim_entries-index1 = cur_ix.
        vim_delim_entries-index2 = vim_delim_entries-index3.
        APPEND vim_delim_entries.
      ENDIF.
    ENDIF. &quot;overlayed eq &apos;P&apos; or overlayed eq &apos;M&apos;
  ENDLOOP.
  MOVE &apos;G&apos; TO temporal_delimitation_happened.
ENDFORM.                               &quot;temp_delim_del_overled_entries</include_source>
   </include>
   <include NAME="LSVIMF0R" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000004" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122424" IDATE="20080721" ITIME="122424">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  CHECK_DELIM_NEW_ENTRY                                   *
*&amp;--------------------------------------------------------------------*
* check new entry for delimitation (called from validity period sbscr)*
*---------------------------------------------------------------------*
* BEGDATE ---&gt; E: new begin date /B: new end date                     *
* ENDDATE ---&gt; E: end date /B: begin date                             *
*&amp;--------------------------------------------------------------------*
FORM check_delim_new_entry USING value(begdate) value(enddate).
  LOOP AT total.
    CHECK &lt;vim_tot_mkey_beforex&gt; EQ &lt;vim_f1_beforex&gt; AND
          ( vim_mkey_after_exists EQ space OR
            &lt;vim_tot_mkey_afterx&gt; EQ &lt;vim_f1_afterx&gt; ).
    CHECK &lt;vim_enddate&gt; NE enddate.
    CHECK &lt;action&gt; NE geloescht AND
          &lt;action&gt; NE neuer_geloescht AND
          &lt;action&gt; NE update_geloescht.
    IF x_header-delmdtflag EQ &apos;E&apos;.     &quot;end date is key field
      CHECK &lt;vim_enddate&gt; GE begdate AND &lt;vim_begdate&gt; LE enddate.
    ELSE.                              &quot;begin date is key field
      CHECK &lt;vim_enddate&gt; LE begdate AND &lt;vim_begdate&gt; GE enddate. &quot;entr
    ENDIF.                             &quot;x_header-delmdtflag eq &apos;E&apos;
    IF vim_special_mode NE vim_reset.
      MESSAGE w047(sv). &quot;Überlagerte Sätze werden gelöscht
    ELSE.
      MESSAGE i047(sv). &quot;Überlagerte Sätze werden gelöscht
    ENDIF.
    EXIT.
  ENDLOOP.
ENDFORM.                               &quot;check_delim_new_entry</include_source>
   </include>
   <include NAME="LSVIMF0S" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000005" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122424" IDATE="20080721" ITIME="122424">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  AFTER_TEMPORAL_DELIMITATION                             *
*&amp;--------------------------------------------------------------------*
* fill EXTRACT with new due to temporal delimitation entries          *
*---------------------------------------------------------------------*
*                                                                     *
*&amp;--------------------------------------------------------------------*
FORM after_temporal_delimitation.
  LOCAL: extract, &lt;table1&gt;.                                 &quot;#EC *
  DATA: index_safe TYPE i, rec TYPE i.
  DATA: extract_wa_loc(8096) TYPE c, date_loc TYPE d,
        index_start TYPE i, index_stop TYPE i,
        key_before_loc(256) TYPE c.
  FIELD-SYMBOLS: &lt;extract_wax_loc&gt; TYPE x, &lt;date_loc&gt; TYPE d,
                 &lt;key_beforex_loc&gt; TYPE x.
  LOOP AT vim_delim_entries WHERE index3 NE space.          &quot;#EC *
    DELETE extract INDEX vim_delim_entries-index3.
    MOVE vim_delim_entries-index3 TO index_safe.
    IF vim_special_mode EQ vim_reset.
      SUBTRACT 1 FROM &lt;status&gt;-maxlines.
      IF &lt;status&gt;-st_mode EQ detail_bild AND
         &lt;status&gt;-cur_line GE vim_delim_entries-index3.
        SUBTRACT 1 FROM &lt;status&gt;-cur_line.
      ENDIF.
    ELSE.
      SUBTRACT 1 FROM maxlines.
    ENDIF.
    IF vim_delim_entries-index1 NE 0.
      CLEAR vim_delim_entries-index3.
      MODIFY vim_delim_entries.                             &quot;#EC *
    ENDIF.
    LOOP AT vim_delim_entries WHERE index2 GT index_safe
                                OR  index3 GT index_safe.   &quot;#EC *
      IF vim_delim_entries-index2 GT index_safe.
        SUBTRACT 1 FROM vim_delim_entries-index2.
      ENDIF.
      IF vim_delim_entries-index3 GT index_safe.
        SUBTRACT 1 FROM vim_delim_entries-index3.
      ENDIF.
      MODIFY vim_delim_entries.                             &quot;#EC *
    ENDLOOP.
  ENDLOOP.
  CLEAR extract.
  LOOP AT vim_delim_entries WHERE index3 EQ space.          &quot;#EC *
    READ TABLE total INDEX vim_delim_entries-index1.        &quot;#EC *
    MOVE total TO extract.
    IF x_header-delmdtflag EQ &apos;E&apos; AND &lt;vim_begdate&gt; LE sy-datum AND
       &lt;vim_enddate&gt; GE sy-datum OR x_header-delmdtflag EQ &apos;B&apos; AND
       &lt;vim_begdate&gt; GE sy-datum AND &lt;vim_enddate&gt; LE sy-datum.
      rec = 8.
      LOOP AT vim_collapsed_mainkeys.                       &quot;#EC *
        CHECK &lt;vim_collapsed_mkey_bfx&gt; EQ &lt;vim_tot_mkey_beforex&gt;.
*                WHERE mkey_bf EQ &lt;vim_tot_mkey_before&gt;.
        IF vim_mkey_after_exists NE space.
          CHECK &lt;vim_collapsed_key_afx&gt; EQ &lt;vim_tot_mkey_afterx&gt;.
*          CHECK &lt;vim_collapsed_key_af&gt; EQ &lt;vim_tot_mkey_after&gt;.
        ENDIF.
        READ TABLE extract WITH KEY &lt;vim_collapsed_keyx&gt;
*        READ TABLE extract WITH KEY &lt;vim_collapsed_key&gt;
                           TRANSPORTING NO FIELDS.          &quot;#EC *
        IF sy-subrc EQ 0.
          MODIFY extract INDEX sy-tabix.                    &quot;#EC *
          CLEAR rec.
        ENDIF.
        IF &lt;vim_collapsed_keyx&gt; NE &lt;vim_xtotal_key&gt;.
*        IF vim_collapsed_mainkeys-mainkey NE &lt;vim_total_key&gt;.
          &lt;vim_collapsed_keyx&gt; = &lt;vim_xtotal_key&gt;.
*          vim_collapsed_mainkeys-mainkey = &lt;vim_total_key&gt;.
          &lt;vim_collapsed_mkey_bfx&gt; = &lt;vim_tot_mkey_beforex&gt;.
*          vim_collapsed_mainkeys-mkey_bf = &lt;vim_tot_mkey_before&gt;.
          MODIFY vim_collapsed_mainkeys.                    &quot;#EC *
        ENDIF.
        EXIT.
      ENDLOOP.
      CHECK rec NE 0.
    ELSE.
      PERFORM check_if_entry_is_to_display USING &apos;L&apos; &lt;vim_xtotal_key&gt;
                                                 space &lt;vim_begdate&gt;.
      CHECK sy-subrc LT 8.
    ENDIF.
*******&quot;HCG HW664505 new index calcualtion for insert extract BEGIN*****
    READ TABLE extract WITH KEY &lt;vim_ext_mkey_beforex&gt; TRANSPORTING
                    NO FIELDS.&quot;To check if key_before exists in extract
    IF vim_import_profile EQ space AND sy-subrc EQ 0.
      ASSIGN extract_wa_loc TO &lt;extract_wax_loc&gt; CASTING.
      &lt;extract_wax_loc&gt; = &lt;vim_xextract&gt;.               &quot;save new entry
      LOOP AT x_namtab WHERE keyflag EQ &apos;X&apos;
                         AND domname EQ vim_delim_date_domain
                         AND ( rollname IN vim_begda_types OR
                               rollname IN vim_endda_types ).
      ENDLOOP.                         &quot;Only one entry should be found
      ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE
                      &lt;vim_extract_struc&gt; TO &lt;date_loc&gt;.
      MOVE &lt;date_loc&gt; TO date_loc.                   &quot;date of new entry
      ASSIGN key_before_loc TO &lt;key_beforex_loc&gt; CASTING.
      &lt;key_beforex_loc&gt; = &lt;vim_ext_mkey_beforex&gt;.       &quot;save new entry
      READ TABLE extract WITH KEY &lt;vim_ext_mkey_beforex&gt;.  &quot;first entry
      index_start = sy-tabix.
      index_stop = index_start - 1.
      LOOP AT extract FROM index_start.
        IF &lt;key_beforex_loc&gt; = &lt;vim_ext_mkey_beforex&gt;.
          index_stop = index_stop + 1.
        ELSE.
          EXIT.
        ENDIF.
      ENDLOOP.
      READ TABLE extract INDEX index_start.
      IF x_namtab-rollname IN vim_endda_types.       &quot;ENDDA is keyfield
        IF &lt;date_loc&gt; &gt; date_loc.
          &lt;vim_xextract&gt; = &lt;extract_wax_loc&gt;.
          INSERT extract INDEX index_start.
        ELSE.
          LOOP AT extract FROM index_start.
            IF &lt;date_loc&gt; &gt; date_loc OR sy-tabix = index_stop.
              IF &lt;date_loc&gt; &gt; date_loc.
                &lt;vim_xextract&gt; = &lt;extract_wax_loc&gt;.
              ELSE.              &quot;reached index_stop and insert behind
                &lt;vim_xextract&gt; = &lt;extract_wax_loc&gt;.
                sy-tabix = sy-tabix + 1.
              ENDIF.
              INSERT extract INDEX sy-tabix.
              EXIT.
            ENDIF.
          ENDLOOP.
        ENDIF.
      ELSE.                                          &quot;BEGDA is keyfield
        IF &lt;date_loc&gt; &lt; date_loc.
          &lt;vim_xextract&gt; = &lt;extract_wax_loc&gt;.
          INSERT extract INDEX index_start.
        ELSE.
          LOOP AT extract FROM index_start.
            IF &lt;date_loc&gt; &lt; date_loc OR sy-tabix = index_stop.
              IF date_loc &lt; date_loc.
                &lt;vim_xextract&gt; = &lt;extract_wax_loc&gt;.
              ELSE.            &quot;reached index_stop and insert behind
                &lt;vim_xextract&gt; = &lt;extract_wax_loc&gt;.
                sy-tabix = sy-tabix + 1.
              ENDIF.
                INSERT extract INDEX sy-tabix.
                EXIT.
              ENDIF.
            ENDLOOP.
          ENDIF.
        ENDIF.
      ELSE.
        INSERT extract INDEX vim_delim_entries-index2.      &quot;#EC *
      ENDIF.
*******&quot;HCG HW664505 new index calcualtion for insert extract END*******
      ADD 1 TO maxlines.
      MOVE vim_delim_entries-index2 TO index_safe.
      LOOP AT vim_delim_entries WHERE index2 GE index_safe. &quot;#EC *
        IF vim_delim_entries-index2 EQ index_safe.
          CHECK vim_delim_entries-index_corr NE space.
        ENDIF.
        ADD 1 TO vim_delim_entries-index2.
        MODIFY vim_delim_entries.                           &quot;#EC *
      ENDLOOP.
    ENDLOOP.
    REFRESH vim_delim_entries.
  ENDFORM.                               &quot;after_temporal_delimitation.</include_source>
   </include>
   <include NAME="LSVIMF0T" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000003" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122424" IDATE="20080721" ITIME="122425">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  X_CALL_SCREEN                                           *
*&amp;--------------------------------------------------------------------*
* external call of specified view maintenance screen                  *
*&amp;--------------------------------------------------------------------*
FORM X_CALL_SCREEN USING VALUE(XCS_SCREEN) LIKE D020S-DNUM.
  CALL SCREEN XCS_SCREEN.
ENDFORM.                               &quot;x_call_screen</include_source>
   </include>
   <include NAME="LSVIMF0U" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000009" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122425" IDATE="20080721" ITIME="122425">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form X_CALL_VIEWMAINTENANCE                                   *
*&amp;--------------------------------------------------------------------*
* external call of view maintenance                                   *
*&amp;--------------------------------------------------------------------*
* --&gt; XCV_USE_LCL_TBL:  &apos;X&apos; Datencontainer XCV_TOTAL und XCV_EXTRACT
*                       sind nicht struktueriert und nicht vom Typ X
*                       =&gt; Daten müssen in lokale Container umgesetzt
*                       werden.
* --&gt; XCV_IMP_SPECMODE: &apos;P&apos; Profilimport/
*                       &apos;T&apos; Testmodus Import/&apos;F&apos; Forcemodus Import /
*                       &apos;B&apos; T + F Import
*&amp;--------------------------------------------------------------------*
FORM x_call_viewmaintenance USING
                                value(xcv_use_lcl_tbl) LIKE tvdir-flag
                                value(xcv_import) LIKE tvdir-flag
                                xcv_corrnbr LIKE e070-trkorr
                                value(xcv_fcode) TYPE vimty_tcode
                                value(xcv_action) LIKE tvdir-flag
                                value(xcv_name) TYPE vimty_tablename
                                value(xcv_tot_name) TYPE c
                                value(xcv_ext_name) TYPE c
                                value(xcv_upgr_dest) LIKE rfcdes-rfcdest
                                value(xcv_upgr_clnt) LIKE sy-mandt
                                xcv_upd_requ LIKE tvdir-flag
                                xcv_e071k TYPE table
                                xcv_dba_sel TYPE table
                                xcv_dpl_sel TYPE table
                                xcv_excufc TYPE table
                                xcv_extract TYPE table
                                xcv_total TYPE table
                                xcv_header TYPE table
                                xcv_namtab TYPE table
                                xcv_last_command TYPE vimty_tcode
                                xcv_last_act_entry LIKE sy-tabix
                                xcv_results LIKE vimmodres
                                xcv_imp_results TYPE slctr_tables_keys
                                value(xcv_imp_specmode) LIKE tvdir-flag
                                value(xcv_cmp_slcnds) LIKE tvdir-flag.

  DATA: xcv_return TYPE i, xcv_i_fcode TYPE vimty_tcode,
        line_name(30) TYPE c, length TYPE i, tabtype TYPE ob_typ,
        header_wa_loc TYPE vimdesc,
        BEGIN OF tabline,
          line(4096) TYPE c,
        END OF tabline.
  FIELD-SYMBOLS: &lt;total&gt; TYPE table, &lt;extract&gt; TYPE table,
                 &lt;tabline&gt; TYPE ANY, &lt;tabline_x&gt; TYPE x,
                 &lt;tabline2&gt; TYPE ANY, &lt;tabline2_x&gt; TYPE x,
                 &lt;header&gt; TYPE vimdesc.
  LOCAL: vim_import_mode_active, vim_no_dialog, vim_import_testmode,
         vim_import_forcemode.          &quot;SW  wg. Rekurs. im Cluster

  vim_no_dialog = xcv_import. TRANSLATE vim_no_dialog USING &apos;H DX&apos;.
  IF xcv_imp_specmode = &apos;P&apos;.           &quot;Profilimp
    vim_import_profile = &apos;X&apos;.
  ENDIF.
  vim_import_testmode = xcv_imp_specmode.
  TRANSLATE vim_import_testmode USING &apos;TXBXF P &apos;.
  vim_import_forcemode = xcv_imp_specmode.
  TRANSLATE vim_import_forcemode USING &apos;T BXFXP &apos;.
  IF xcv_use_lcl_tbl NE space.
    ASSIGN: (xcv_tot_name) TO &lt;total&gt;, (xcv_ext_name) TO &lt;extract&gt;.
    IF xcv_use_lcl_tbl NE &apos;L&apos;.         &quot;use not _only_ local tables
      READ TABLE xcv_header ASSIGNING &lt;header&gt; CASTING INDEX 1.
      IF &lt;header&gt;-bastab NE space AND &lt;header&gt;-texttbexst NE space.
        length = &lt;header&gt;-after_tabc + &lt;header&gt;-aft_txttbc
                 + 3 * cl_abap_char_utilities=&gt;charsize.
      ELSE.
        length = &lt;header&gt;-after_tabc
                 + 2 * cl_abap_char_utilities=&gt;charsize.
      ENDIF.
      SEARCH xcv_tot_name FOR &apos;[&apos; IN CHARACTER MODE.
      MOVE xcv_tot_name(sy-fdpos) TO line_name.
      ASSIGN: (line_name) TO &lt;tabline2&gt;,
              &lt;tabline2&gt; TO &lt;tabline2_x&gt; CASTING.
      REFRESH: &lt;total&gt;, &lt;extract&gt;.
      LOOP AT xcv_total ASSIGNING &lt;tabline&gt;.
        ASSIGN &lt;tabline&gt; TO &lt;tabline_x&gt; CASTING.
        MOVE &lt;tabline_x&gt; TO &lt;tabline2_x&gt;(length).
        APPEND &lt;tabline2&gt; TO &lt;total&gt;.
      ENDLOOP.
      LOOP AT xcv_extract ASSIGNING &lt;tabline&gt;.
        ASSIGN &lt;tabline&gt; TO &lt;tabline_x&gt; CASTING.
        MOVE &lt;tabline_x&gt; TO &lt;tabline2_x&gt;(length).
        APPEND &lt;tabline2&gt; TO &lt;extract&gt;.
      ENDLOOP.
*      &lt;total&gt; = xcv_total. &lt;extract&gt; = xcv_extract.
    ENDIF.
  ELSE.
    ASSIGN: xcv_total TO &lt;total&gt;, xcv_extract TO &lt;extract&gt;.
  ENDIF.
  vim_import_mode_active = xcv_import. xcv_i_fcode = xcv_fcode.
  IF xcv_import NE space AND xcv_fcode NE &apos;SAVE&apos;.
  ELSEIF xcv_import NE space AND xcv_fcode EQ &apos;SAVE&apos;.       &quot;SW
    imp_results[] = xcv_imp_results[].                      &quot;SW
  ELSEIF xcv_fcode EQ &apos;INS&apos; OR xcv_fcode EQ &apos;DEL&apos; OR
         xcv_fcode EQ &apos;UPD&apos; OR xcv_fcode EQ &apos;SHOW&apos;.
    vim_single_entry_function = xcv_fcode. xcv_i_fcode = &apos;EDIT&apos;.
  ENDIF.
  IF xcv_import EQ &apos;D&apos; AND xcv_fcode EQ &apos;SAVE&apos;.
    vim_import_no_message = &apos;X&apos;.
  ENDIF.
  CALL FUNCTION &apos;VIEW_MAINTENANCE_LOW_LEVEL&apos;
    EXPORTING
      corr_number                 = xcv_corrnbr
      fcode                       = xcv_i_fcode
      view_action                 = xcv_action
      view_name                   = xcv_name
      rfc_destination_for_upgrade = xcv_upgr_dest
      client_for_upgrade          = xcv_upgr_clnt
      complex_selconds_used       = xcv_cmp_slcnds
    IMPORTING
      last_act_entry              = xcv_last_act_entry
      ucomm                       = xcv_last_command
      update_required             = xcv_upd_requ
      corr_number                 = xcv_corrnbr
    TABLES
      corr_keytab                 = xcv_e071k
      dba_sellist                 = xcv_dba_sel
      dpl_sellist                 = xcv_dpl_sel
      excl_cua_funct              = xcv_excufc
      extract                     = &lt;extract&gt;
      total                       = &lt;total&gt;
      x_header                    = xcv_header
      x_namtab                    = xcv_namtab
    EXCEPTIONS
      function_not_found          = 1
      missing_corr_number         = 2
      no_value_for_subset_ident   = 3
      saving_correction_failed    = 4.
*  IF xcv_import NE space AND
*     ( sy-subrc NE 0 OR
*       xcv_fcode EQ save AND &lt;status&gt;-upd_flag NE space ).
* &quot;HCG BC-Set: sy-subrc NE 0 -&gt; always error message in log
  IF ( xcv_import NE space OR vim_import_profile NE space ) AND
     ( sy-subrc NE 0 OR
       xcv_fcode EQ save AND &lt;status&gt;-upd_flag NE space ).
    IF sy-msgid NE space.
      vim_import_no_message = &apos;X&apos;.
      IF vim_import_profile = &apos;X&apos;.
        READ TABLE xcv_header INTO header_wa_loc INDEX 1.
        IF header_wa_loc-bastab EQ space.
          tabtype = &apos;V&apos;.
        ELSE.
          tabtype = &apos;S&apos;.
        ENDIF.
        PERFORM vim_bc_process_message USING sy-msgid &apos;I&apos; &apos;E&apos; sy-msgno
                        sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 tabtype.
      ELSE.
        PERFORM vim_process_message USING sy-msgid &apos;I&apos; &apos;E&apos; sy-msgno
                       sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ENDIF.
      CLEAR vim_import_no_message.
    ENDIF.
*   IF XCV_IMPORT NE SPACE.
    LOOP AT imp_results.
      IF imp_results-import-inserted NE 0.
        imp_results-import-errors = imp_results-import-inserted.
        CLEAR imp_results-import-inserted.
      ELSEIF imp_results-import-updated NE 0.
        imp_results-import-errors = imp_results-import-updated.
        CLEAR imp_results-import-updated.
      ELSEIF imp_results-import-deleted NE 0.
        imp_results-import-errors = imp_results-import-deleted.
        CLEAR imp_results-import-deleted.
      ENDIF.
      MODIFY imp_results.
    ENDLOOP.
  ELSEIF xcv_import EQ space AND xcv_fcode EQ &apos;READ&apos; AND
         sy-subrc NE 0.                &quot;probably called by VIEW_GET_DATA
    IF sy-subrc EQ 2. &quot;probably individual authority check failed
      MESSAGE i053(sv) RAISING no_authority.
    ELSE.                              &quot;other error
      MESSAGE i037(sv) WITH view_name RAISING no_viewmaint_tool.
    ENDIF.
  ENDIF.
  IF xcv_fcode EQ &apos;EXED&apos; OR xcv_fcode EQ &apos;DEL&apos;.
    xcv_results = vim_results_of_ext_mod.
  ELSEIF xcv_fcode EQ read.
    DESCRIBE TABLE &lt;total&gt; LINES xcv_results-nbr_of_upd.
  ELSEIF xcv_fcode EQ save AND xcv_import EQ &apos;D&apos;.
    CLEAR vim_import_no_message.
  ENDIF.
  IF xcv_use_lcl_tbl NE space AND xcv_use_lcl_tbl NE &apos;L&apos;.
    REFRESH: xcv_total, xcv_extract.
    ASSIGN: tabline TO &lt;tabline2_x&gt; CASTING.
    LOOP AT &lt;total&gt; ASSIGNING &lt;tabline&gt;.
      ASSIGN &lt;tabline&gt; TO &lt;tabline_x&gt; CASTING.
      MOVE &lt;tabline_x&gt; TO &lt;tabline2_x&gt;(length).
      APPEND tabline TO xcv_total.
    ENDLOOP.
    LOOP AT &lt;extract&gt; ASSIGNING &lt;tabline&gt;.
      ASSIGN &lt;tabline&gt; TO &lt;tabline_x&gt; CASTING.
      MOVE &lt;tabline_x&gt; TO &lt;tabline2_x&gt;(length).
      APPEND tabline TO xcv_extract.
    ENDLOOP.
*    MOVE: &lt;total&gt; TO xcv_total, &lt;extract&gt; TO xcv_extract.
  ENDIF.
  CLEAR vim_single_entry_function.                          &quot;SW
  IF xcv_import NE space.
    xcv_imp_results = imp_results[].
    REFRESH imp_results.                                    &quot;SW
  ENDIF.
ENDFORM.                               &quot;x_call_viewmaintenance</include_source>
   </include>
   <include NAME="LSVIMF0V" SQLX="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000001" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122425" IDATE="20080721" ITIME="122425">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form VIM_RESTORE_LOCAL_MEMORY                                 *
*&amp;--------------------------------------------------------------------*
* restore local memory of function pool (for external call)           *
*&amp;--------------------------------------------------------------------*
FORM VIM_RESTORE_LOCAL_MEMORY.
  DATA: H_NAME(31) TYPE C VALUE &apos;*&apos;, H_STATE(30) VALUE &apos;STATUS_&apos;.

  VIEW_NAME = X_HEADER-VIEWNAME.
  IF X_HEADER-BASTAB EQ SPACE.
    H_NAME+1 = X_HEADER-MAINTVIEW. H_STATE+7 = X_HEADER-MAINTVIEW.
    ASSIGN: (X_HEADER-MAINTVIEW) TO &lt;TABLE1&gt;, (H_NAME) TO &lt;INITIAL&gt;,
            (H_STATE) TO &lt;STATUS&gt;.
  ENDIF.
  VIM_RESTORE_MODE = &apos;X&apos;.
  PERFORM INITIALISIEREN.
  VIEW_ACTION = &lt;STATUS&gt;-ST_ACTION. TRANSLATE VIEW_ACTION USING &apos;CUAU&apos;.
  PERFORM JUSTIFY_ACTION_MODE.
  MOVE: VIEW_ACTION TO MAINT_MODE,
        &lt;STATUS&gt;-CORR_NBR TO CORR_NBR,
        &lt;STATUS&gt;-FCODE TO FUNCTION.
  PERFORM CALL_DYNPRO.
ENDFORM.                               &quot;vim_restore_local_memory</include_source>
   </include>
   <include NAME="LSVIMF0W" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000003" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122425" IDATE="20080721" ITIME="122426">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form VIM_APPEND_GLOBAL_TABLE                                  *
*&amp;--------------------------------------------------------------------*
* set global field value (for external call)                          *
*&amp;--------------------------------------------------------------------*
FORM VIM_APPEND_GLOBAL_TABLE USING VALUE(NAME_OF_TABLE) TYPE C
                                   VALUE(BASE_TABLE) LIKE TVDIR-FLAG
                                   VALUE(TABLEN) LIKE VIMDESC-TABLEN
                                   VALUE(ENTRY_TO_APPEND)
                                   VALUE(ACT_FLAG) LIKE TVDIR-FLAG
                                   VALUE(MRK_FLAG) LIKE TVDIR-FLAG
                                   VALUE(TXTACT_FLAG) LIKE TVDIR-FLAG
                                   VAGT_RETURN LIKE SY-SUBRC.
  DATA: WA(4096) TYPE C, DUM TYPE I.
  FIELD-SYMBOLS: &lt;TABLE&gt; TYPE TABLE, &lt;ENTRY&gt;.
  ASSIGN (NAME_OF_TABLE) TO &lt;TABLE&gt;.
  IF SY-SUBRC EQ 0.
    WA = ENTRY_TO_APPEND.
    WA+TABLEN(1) = ACT_FLAG. DUM = TABLEN + 1.
    WA+DUM(1) = MRK_FLAG. ADD 1 TO DUM.
    IF BASE_TABLE NE SPACE.
      WA+DUM(1) = TXTACT_FLAG. ADD 1 TO DUM.
    ENDIF.
    ASSIGN WA(DUM) TO &lt;ENTRY&gt;.
    APPEND &lt;ENTRY&gt; TO &lt;TABLE&gt;.
  ENDIF.
  VAGT_RETURN = SY-SUBRC.
ENDFORM.                               &quot;vim_append_globall_table</include_source>
   </include>
   <include NAME="LSVIMF0X" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000003" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122426" IDATE="20080721" ITIME="122426">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form VIM_SET_GLOBAL_FIELD_VALUE                               *
*&amp;--------------------------------------------------------------------*
* set global field value (for external call)                          *
*&amp;--------------------------------------------------------------------*
FORM VIM_SET_GLOBAL_FIELD_VALUE USING VALUE(NAME_OF_FIELD_TO_SET) TYPE C
                                      VALUE(TYPE_OF_FIELD_TO_SET) TYPE C
                                      VALUE(VALUE_TO_SET)
                                      VSGFV_RETURN LIKE SY-SUBRC.

  FIELD-SYMBOLS: &lt;FIELD&gt;.
  ASSIGN (NAME_OF_FIELD_TO_SET) TO &lt;FIELD&gt; TYPE TYPE_OF_FIELD_TO_SET.
  IF SY-SUBRC EQ 0.
    &lt;FIELD&gt; = VALUE_TO_SET.
  ENDIF.
  VSGFV_RETURN = SY-SUBRC.
ENDFORM.                               &quot;vim_set_global_field_value</include_source>
   </include>
   <include NAME="LSVIMF0Y" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000002" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122426" IDATE="20080721" ITIME="122426">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form VIM_GET_GLOBAL_FIELD_VALUE                               *
*&amp;--------------------------------------------------------------------*
* get global field value (for external call)                          *
*&amp;--------------------------------------------------------------------*
FORM vim_get_global_field_value USING value(name_of_field_to_get) TYPE c
                                      value(type_of_field_to_get) TYPE c
                                      field_value
                                      vggfv_return LIKE sy-subrc.

  FIELD-SYMBOLS: &lt;field&gt; TYPE ANY.
  ASSIGN (name_of_field_to_get) TO &lt;field&gt;
   CASTING TYPE (type_of_field_to_get).
  IF sy-subrc EQ 0.
    field_value = &lt;field&gt;.
  ENDIF.
  vggfv_return = sy-subrc.
ENDFORM.                               &quot;vim_get_global_field_value</include_source>
   </include>
   <include NAME="LSVIMF0Z" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000002" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122426" IDATE="20080721" ITIME="122426">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form VIM_GET_GLOBAL_TABLE                                     *
*&amp;--------------------------------------------------------------------*
* get global field table (for external call)                          *
*&amp;--------------------------------------------------------------------*
FORM vim_get_global_table USING value(name_of_table_to_get) TYPE c
                                table_out TYPE ANY TABLE
                                vggt_return LIKE sy-subrc.

  FIELD-SYMBOLS: &lt;table&gt; TYPE ANY TABLE.
  ASSIGN (name_of_table_to_get) TO &lt;table&gt;.
  IF sy-subrc EQ 0.
    table_out = &lt;table&gt;.
  ENDIF.
  vggt_return = sy-subrc.
ENDFORM.                               &quot;vim_get_global_field_value</include_source>
   </include>
   <include NAME="LSVIMF10" SQLX="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000001" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122426" IDATE="20080721" ITIME="122427">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  LISTE_EXIT_COMMAND                                      *
*&amp;--------------------------------------------------------------------*
* handle exit commands on list screen                                 *
*&amp;--------------------------------------------------------------------*
FORM LISTE_EXIT_COMMAND.
  CASE OK_CODE.
    WHEN &apos;ABR &apos;.
      FUNCTION = OK_CODE.
      CLEAR OK_CODE.
      CASE VIM_SPECIAL_MODE.
        WHEN VIM_REPLACE.
          CLEAR VIM_ACT_DYNP_VIEW. SET SCREEN 0. LEAVE SCREEN.
        WHEN VIM_DELETE.
          SET SCREEN 0. LEAVE SCREEN.
        WHEN VIM_UPGRADE.
*         CLEAR: VIM_SPECIAL_MODE, MAXLINES. LEAVE SCREEN.
          CLEAR VIM_ACT_DYNP_VIEW. NEUER = &apos;N&apos;.
          SET SCREEN 0. LEAVE SCREEN.
        WHEN OTHERS.
          PERFORM LISTE_ABBRECHEN.
      ENDCASE.
    WHEN &apos;IGN &apos;.
      CASE VIM_SPECIAL_MODE.
        WHEN VIM_REPLACE.
          CLEAR VIM_ACT_DYNP_VIEW. SET SCREEN 0. LEAVE SCREEN.
        WHEN VIM_DELETE.
          SET SCREEN 0. LEAVE SCREEN.
*       WHEN VIM_UPGRADE.  &quot;impossible
*         CLEAR OK_CODE. LEAVE SCREEN.
        WHEN VIM_UPGRADE.
          CLEAR VIM_ACT_DYNP_VIEW. NEUER = &apos;N&apos;.
          SET SCREEN 0. LEAVE SCREEN.
        WHEN OTHERS.
          LOOP AT SCREEN.
            SCREEN-ACTIVE = 0.
            MODIFY SCREEN.
          ENDLOOP.
      ENDCASE.
      NEUER = &apos;N&apos;.
      CLEAR &lt;STATUS&gt;-UPD_FLAG.
  ENDCASE.
ENDFORM.                               &quot;liste_exit_command.</include_source>
   </include>
   <include NAME="LSVIMF11" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000012" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122427" IDATE="20080721" ITIME="122427">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  BEFORE_LEAVING_FRAME_FUNCTION.                          *
*&amp;--------------------------------------------------------------------*
* do all the things necessary before leaving the frame function unit  *
*&amp;--------------------------------------------------------------------*
FORM before_leaving_frame_function
                        USING value(exit_form) LIKE vimdesc-frm_bf_end.

  DATA: prc TYPE sy-subrc, dummy TYPE c, dummi TYPE i.

  IF &lt;status&gt;-corr_enqud NE space.
    CALL FUNCTION &apos;DEQUEUE_E_TRKORR&apos;
      EXPORTING
        trkorr = &lt;status&gt;-corr_nbr.
*             X_TRKORR = E02.
    CLEAR &lt;status&gt;-corr_enqud.
  ENDIF.
  CLEAR &lt;status&gt;-corr_nbr.
  CLEAR &lt;status&gt;-initializd.
  CLEAR &lt;initial&gt;. &lt;vim_client_initial&gt; = sy-mandt.
  IF ( maint_mode EQ anzeigen OR maint_mode EQ transportieren ) AND
     vim_corr_obj_viewname NE space.
    CLEAR vim_corr_obj_viewname.
  ENDIF.
  PERFORM vim_reset_texttab USING view_name.        &quot;SW Texttransl
  CALL FUNCTION &apos;VIEW_RESET_LANGUAGES&apos;.&quot;SW Texttransl
  CLEAR: als_active, als_enabled, als_langus_selected. &quot;Clear ALS flags
  REFRESH als_sel_langus.
  IF exit_form NE space.
    PERFORM (exit_form) IN PROGRAM.
  ENDIF.
  CLEAR function.
  FREE vim_bc_entry_list.
  CLEAR vim_actlinks.
  CLEAR: &lt;status&gt;-bcfixnochg, vim_bc_chng_allowed,
         &lt;status&gt;-bcfixdelinfosent.
** test getting profiles: begin
*  IF SY-UNAME = &apos;FRENZELU&apos; OR SY-UNAME = &apos;ROSENTHAL&apos;    &quot;UF Profile
*   OR SY-UNAME = &apos;BUEHLERM&apos;.
*    CALL FUNCTION &apos;SCPR_MEMORY_DELETE&apos;.
*  ENDIF.
** test getting profiles: end
  CLEAR vim_oc_inst.
*  refresh vim_dba_sel_kept.                              &quot;UF210200
*delete after_nonkey flag in check_range.
  PERFORM check_range IN PROGRAM saplsvix
             USING space 0 &apos;E&apos; space space space
             CHANGING dummy prc.
ENDFORM.                               &quot;before_leaving_frame_function</include_source>
   </include>
   <include NAME="LSVIMF12" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000003" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122427" IDATE="20080721" ITIME="122427">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  BEFORE_LEAVING_EXT                                      *
*&amp;--------------------------------------------------------------------*
* do all the things necessary before leaving - external call          *
*&amp;--------------------------------------------------------------------*
FORM BEFORE_LEAVING_EXT USING VALUE(VIEWNAME) LIKE VIMDESC-VIEWNAME
                              VALUE(MAINTVIEW) LIKE VIMDESC-MAINTVIEW
                              VALUE(EXIT_FORM) LIKE VIMDESC-FRM_BF_END.
  DATA: NAME(20) TYPE C VALUE &apos;STATUS_&apos;.
  FIELD-SYMBOLS: &lt;BLE_STATUS&gt;.

  ASSIGN &lt;STATUS&gt; TO &lt;BLE_STATUS&gt;.
* NAME+7 = VIEWNAME.
  NAME+7 = MAINTVIEW.                  &quot;Subviews
  ASSIGN (NAME) TO &lt;STATUS&gt;.
  IF VIM_CORR_OBJ_VIEWNAME NE VIEWNAME.
    CLEAR MAINT_MODE.
  ELSE.
    MAINT_MODE = &lt;STATUS&gt;-ST_ACTION.
  ENDIF.
  PERFORM BEFORE_LEAVING_FRAME_FUNCTION USING EXIT_FORM.
  ASSIGN &lt;BLE_STATUS&gt; TO &lt;STATUS&gt;.
ENDFORM.                               &quot;before_leaving_ext</include_source>
   </include>
   <include NAME="LSVIMF13" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000011" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122427" IDATE="20080721" ITIME="122427">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form AFTER_SAVING                                             *
*&amp;--------------------------------------------------------------------*
* process after-treatment of saving                                   *
*&amp;--------------------------------------------------------------------*
FORM after_saving.
  DATA: dummy.
  DATA  e071_loctab TYPE vim_ko200_tab_type.

  IF x_header-texttbexst &lt;&gt; space AND  &quot;SW Texttransl ..
     vim_abort_saving EQ space.
    IF x_header-frm_tl_upd NE space.
      PERFORM (x_header-frm_tl_upd) IN PROGRAM.
    ELSE.
      PERFORM vim_texttab_db_update.
    ENDIF.
  ENDIF.                               &quot;.. TEXTTRANSL
  IF vim_abort_saving = space AND vim_called_by_cluster = space.
    PERFORM vim_add_img_notices_pai USING &apos;S&apos;
                                    CHANGING dummy.
  ENDIF.
  IF x_header-frm_af_sav NE space.
    PERFORM (x_header-frm_af_sav) IN PROGRAM.
  ENDIF.
*    Call synchronizer
  IF vim_abort_saving EQ space.
    REFRESH e071_loctab.
    APPEND e071 TO e071_loctab.
    PERFORM vim_synchronizer_call
                  USING e071_loctab[]
                        corr_keytab[]
                        &apos;X&apos;.
  ENDIF.
  IF &lt;status&gt;-selected CO &apos;NUD&apos;.
    CLEAR &lt;status&gt;-selected.
  ENDIF.
  IF vim_abort_saving = space AND vim_import_profile NE space.
* build up BC-Set import log
    PERFORM vim_bc_logs_put CHANGING vim_bc_entry_list.
  ENDIF.
  CLEAR vim_abort_saving.
* log end of database changes
  CALL FUNCTION &apos;VIEW_WRITE_CHANGELOG_HEADER&apos;
    EXPORTING
      viewname = x_header-viewname
      bastab   = x_header-bastab
      begin    = space
      clidep   = x_header-clidep.
  TRANSLATE vim_adjust_middle_level_mode USING &apos;XLSL&apos;.
ENDFORM.                               &quot;after_saving</include_source>
   </include>
   <include NAME="LSVIMF14" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000015" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122428" IDATE="20080721" ITIME="122428">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form PREPARE_SAVING                                           *
*&amp;--------------------------------------------------------------------*
* prepare saving of changed data in data base                         *
*&amp;--------------------------------------------------------------------*
* &lt;-- SY-SUBRC: 0 - ok, save, others: - don&apos;t save                    *
* SY-SUBRC soll abgelöst werden durch:
* &lt;-- VIM_ABORT_SAVING: space -&gt; save, others -&gt; don&apos;t save
*&amp;--------------------------------------------------------------------*
FORM prepare_saving.
  DATA: rc LIKE sy-subrc,
        ps_addr_ref LIKE addr_ref,
        ps_transp_addrs(1) TYPE c,
        ps_e071k_tab LIKE e071k OCCURS 0,
        ps_tot_ix TYPE i,
        ps_ko200 LIKE ko200,
        ps_addrrc LIKE szad_field-returncode,
        ps_ko200_tab LIKE ko200 OCCURS 0, addr_e071 LIKE e071,
        addr_e071k LIKE e071k, dummy TYPE char1,
        ps_addr_errtab LIKE addr_error OCCURS 0 WITH HEADER LINE,
        new_addr_group TYPE ad_group, object_key TYPE ad_objkey.
  DATA  e071_loctab TYPE vim_ko200_tab_type.

  FIELD-SYMBOLS: &lt;object_key_x&gt; TYPE x, &lt;addr_key&gt; TYPE x.

  IF vim_adjust_middle_level_mode EQ subset.
    x_header[] = vim_adj_header.
    READ TABLE x_header INDEX 1.
    x_namtab[] = vim_adj_namtab.
  ENDIF.
  CLEAR vim_abort_saving.
  IF &lt;status&gt;-upd_checkd EQ space.
    PERFORM check_upd.
  ENDIF.
  IF &lt;status&gt;-upd_flag NE space.
    IF maint_mode EQ aendern.
      CLEAR sy-subrc.
      IF x_header-frm_bf_sav NE space.
        PERFORM (x_header-frm_bf_sav) IN PROGRAM.
*       CHECK SY-SUBRC EQ 0. &quot;if sy-subrc ne 0 don&apos;t save -&gt; exit
        IF sy-subrc &lt;&gt; 0 OR vim_abort_saving NE space.
          vim_abort_saving = &apos;X&apos;. sy-subrc = 8.
          EXIT.
        ENDIF.
      ENDIF.
      IF x_header-texttbexst &lt;&gt; space.
        PERFORM vim_set_texttab_action_delete.          &quot;SW Texttransl
      ENDIF.
      IF vim_client_state IS INITIAL OR
       ( vim_called_by_cluster &lt;&gt; space AND       &quot;SW  CSS 80009987/1998
          vim_client_state = vim_noact ).
        CALL FUNCTION &apos;VIEW_GET_CLIENT_STATE&apos;
          IMPORTING
            transp_state = vim_client_state.
      ENDIF.
    ENDIF.
    PERFORM vim_bc_logs_maintain USING x_header
                                       vim_import_profile
                                 CHANGING vim_bc_entry_list.
   IF ( vim_no_dialog EQ space OR vim_import_mode_active NE space ) AND
        ( vim_client_state EQ vim_log OR maint_mode EQ transportieren ).
      IF corr_nbr NE space AND corr_nbr NE &lt;status&gt;-corr_nbr.
        &lt;status&gt;-corr_nbr = corr_nbr.
      ENDIF.
      IF maint_mode EQ transportieren.
        IF &lt;status&gt;-corr_nbr EQ space.
          PERFORM request_corr_number.
          IF x_header-flag NE vim_transport_denied AND
             vim_actopts-transp_off NE bc_transport_denied AND
             &lt;status&gt;-l_corr_nbr NE &lt;status&gt;-corr_nbr.
            PERFORM prepare_corr.
          ENDIF.
        ENDIF.
      ELSE.
        PERFORM check_transp_objs_for_maint USING rc.
        IF rc NE 0.
          RAISE missing_corr_number.
        ENDIF.
        IF x_header-flag NE vim_transport_denied AND
           vim_actopts-transp_off NE bc_transport_denied.
          PERFORM prepare_corr.
          PERFORM update_corr.
        ENDIF.
      ENDIF.
      PERFORM corr_upd.
*    elseif not VIM_BC_ENTRY_LIST is initial.
* fill corr_keytab for bc-set import log
*      perform vim_bc_fill_corr_keytab.
    ENDIF.
    IF vim_import_testmode NE space.   &quot;testrun for import
      CLEAR &lt;status&gt;-upd_flag.         &quot;do not save if testrun happens
      vim_import_no_message = &apos;X&apos;.
      PERFORM vim_process_message USING &apos;SV&apos; &apos;I&apos; &apos;I&apos; &apos;154&apos;
                                        space space space space.
      CLEAR vim_import_no_message.
    ELSE.
* log begin of database changes
      CALL FUNCTION &apos;VIEW_WRITE_CHANGELOG_HEADER&apos;
        EXPORTING
          viewname = x_header-viewname
          bastab   = x_header-bastab
          begin    = &apos;X&apos;
          clidep   = x_header-clidep.
* save addresses.
      IF x_header-adrnbrflag EQ &apos;N&apos;.   &quot;only new technique
        ASSIGN: object_key TO &lt;object_key_x&gt; CASTING,
                ps_addr_ref-appl_key TO &lt;addr_key&gt; CASTING.
        IF ( maint_mode EQ transportieren OR
             vim_client_state EQ vim_log ) AND
           x_header-flag NE vim_transport_denied AND
           vim_actopts-transp_off NE bc_transport_denied.
          IF x_header-flag EQ space.   &quot;standard logging required
            LOOP AT vim_addr_e071_tab INTO addr_e071.
              addr_e071-trkorr = &lt;status&gt;-corr_nbr.
              MODIFY vim_addr_e071_tab FROM addr_e071.
              ps_ko200 = addr_e071.
              APPEND ps_ko200 TO ps_ko200_tab.
            ENDLOOP.
            ps_transp_addrs = &apos;X&apos;.
          ENDIF.
        ENDIF.
        LOOP AT vim_addresses_to_save
                                  WHERE viewname EQ x_header-viewname.
*          &lt;f1_x&gt; = vim_addresses_to_save-handle.
          &lt;f1_x&gt; = &lt;vim_addr_handle_x&gt;.
          READ TABLE total WITH KEY &lt;f1_x&gt; BINARY SEARCH.
          ps_tot_ix = sy-tabix.
          object_key = vim_addresses_to_save-handle.
          IF &lt;action&gt; NE geloescht AND &lt;action&gt; NE neuer_geloescht AND
             &lt;action&gt; NE update_geloescht.
* save adress
            REFRESH ps_e071k_tab.
            APPEND LINES OF vim_addr_e071k_tab TO ps_e071k_tab.
            IF vim_addresses_to_save-addrnumber CP &apos;@NEW*&apos;.
* new address
              ps_addr_ref-appl_table = vim_tsadrv-tablename.
              ps_addr_ref-appl_field = vim_tsadrv-fieldname.
              ps_addr_ref-appl_key   = object_key.
              ps_addr_ref-addr_group = vim_addr_group.
              ps_addr_ref-owner = &apos;X&apos;.
              CALL FUNCTION &apos;ADDR_NUMBER_GET&apos;
                   EXPORTING
                       address_handle    = vim_addresses_to_save-handle
                        address_reference = ps_addr_ref
*                     PERSONAL_ADDRESS           = &apos; &apos;
*                     NUMBERRANGE_NUMBER         = &apos;01&apos;
                        generate_transport_entries = ps_transp_addrs
*                     OWNER                      = &apos;X&apos;
                        table_name  = vim_addr_basetable
                        field_name  = vim_addr_bastab_field
                        objkey      = object_key
                   IMPORTING
                      address_number = vim_addresses_to_save-addrnumber
*                     RETURNCODE_NUMBERRANGE     =
                   TABLES
                        e071k_tab                  = ps_e071k_tab
                   EXCEPTIONS
                        address_handle_not_exist   = 1
                        internal_error             = 2
                        parameter_error            = 3.
              IF sy-subrc NE 0.
                MESSAGE ID sy-msgid TYPE &apos;I&apos; NUMBER sy-msgno WITH
                           sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
                RAISE saving_correction_failed.
              ENDIF.
            ELSE.
* existing address
              IF ps_transp_addrs NE space.
                CALL FUNCTION &apos;ADDR_TRANSPORT_ENTRIES&apos;
                  EXPORTING
                    addrnumber = vim_addresses_to_save-addrnumber
                    table_name = vim_addr_basetable
                    field_name = vim_addr_bastab_field
                    objkey     = object_key
                  TABLES
                    e071k_tab  = ps_e071k_tab.
              ENDIF.
            ENDIF.                       &quot;new address
          &lt;vim_total_address_number&gt; = vim_addresses_to_save-addrnumber.
            TRANSLATE &lt;action&gt; USING &apos; U&apos;.
            READ TABLE extract WITH KEY &lt;vim_xtotal_key&gt;
                               TRANSPORTING NO FIELDS.
            IF sy-subrc EQ 0.
              extract = total. MODIFY extract INDEX sy-tabix.
            ENDIF.
            MODIFY total INDEX ps_tot_ix.
            IF ps_transp_addrs NE space.
              CALL FUNCTION &apos;TR_OBJECTS_INSERT&apos;
                EXPORTING
                  wi_order = &lt;status&gt;-order_nbr
                TABLES
                  wt_ko200 = ps_ko200_tab
                  wt_e071k = ps_e071k_tab
                EXCEPTIONS
                  OTHERS   = 8.
              IF sy-subrc NE 0.
                MESSAGE ID sy-msgid TYPE &apos;I&apos; NUMBER sy-msgno WITH
                           sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
                RAISE saving_correction_failed.
              ENDIF.
            ENDIF.
            CALL FUNCTION &apos;ADDR_SINGLE_SAVE&apos;
                 EXPORTING
                    address_number         = &lt;vim_total_address_number&gt;
*                   PERSON_NUMBER          = &apos; &apos;
*                   ADDRESS_TYPE           = 1
*                   EXECUTE_IN_UPDATE_TASK = &apos; &apos;
                 EXCEPTIONS
                      address_not_exist      = 1
                      person_not_exist       = 2
                      address_number_missing = 3
                      reference_missing      = 4
                      internal_error         = 5
                      database_error         = 6
                      parameter_error        = 7.
            IF sy-subrc NE 0.
              MESSAGE ID sy-msgid TYPE &apos;I&apos; NUMBER sy-msgno WITH
                         sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
              RAISE saving_correction_failed.
            ENDIF.
            CALL FUNCTION &apos;ADDR_DEQUEUE&apos;
              EXPORTING
                address_number    = &lt;vim_total_address_number&gt;
              EXCEPTIONS                 &quot;#EC *
                address_not_exist = 1
                internal_error    = 2
                OTHERS            = 3.
          ELSEIF &lt;action&gt; EQ neuer_geloescht.
* reset address (UF557286/2000)
            CALL FUNCTION &apos;ADDR_SINGLE_RESET&apos;
              EXPORTING
                address_handle         = vim_addresses_to_save-handle
              EXCEPTIONS
*               NUMBER_NOT_FOUND       = 1
*               HANDLE_NOT_FOUND       = 2
*               PARAMETER_ERROR        = 3
                internal_error         = 1
                OTHERS                 = 0.
            IF sy-subrc = 1.
              MESSAGE ID sy-msgid TYPE &apos;I&apos; NUMBER sy-msgno
               WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
            ENDIF.
          ENDIF.
          DELETE vim_addresses_to_save.
        ENDLOOP.                       &quot;at vim_addresses to save.
* Delete addresses (temporary: put address into address-groups CADE or
* ZADE)
        IF vim_addr_group = &apos;CA01&apos;.
          new_addr_group = &apos;CADE&apos;.
        ELSEIF vim_addr_group = &apos;ZA01&apos;.
          new_addr_group = &apos;ZADE&apos;.
        ENDIF.
        IF NOT new_addr_group IS INITIAL.
          LOOP AT total.
            CHECK
             ( &lt;action&gt; EQ geloescht OR &lt;action&gt; EQ update_geloescht )
             AND &lt;vim_total_address_number&gt; NP &apos;@NEW*&apos;.
            &lt;object_key_x&gt; = &lt;f1_x&gt;.
            IF ps_transp_addrs NE space.
              REFRESH ps_e071k_tab.
              APPEND LINES OF vim_addr_e071k_tab TO ps_e071k_tab.
              CALL FUNCTION &apos;ADDR_TRANSPORT_ENTRIES&apos;
                EXPORTING
                  addrnumber = &lt;vim_total_address_number&gt;
                  table_name = vim_addr_basetable
                  field_name = vim_addr_bastab_field
                  objkey     = object_key
                TABLES
                  e071k_tab  = ps_e071k_tab.
              CALL FUNCTION &apos;TR_OBJECTS_INSERT&apos;
                EXPORTING
                  wi_order = &lt;status&gt;-order_nbr
                TABLES
                  wt_ko200 = ps_ko200_tab
                  wt_e071k = ps_e071k_tab
                EXCEPTIONS
                  OTHERS   = 8.
              IF sy-subrc NE 0.
                MESSAGE ID sy-msgid TYPE &apos;I&apos; NUMBER sy-msgno WITH
                           sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
                RAISE saving_correction_failed.
              ENDIF.
            ENDIF.
*            PS_ADDR_REF-APPL_TABLE = vim_tsadrv-TABLENAME.
*            PS_ADDR_REF-APPL_FIELD = vim_tsadrv-FIELDNAME.
*            PS_ADDR_REF-APPL_KEY   = &lt;VIM_TOTAL_KEY&gt;.
*            PS_ADDR_REF-ADDR_GROUP = VIM_ADDR_GROUP.
*            PS_ADDR_REF-OWNER = &apos;X&apos;.
*            CALL FUNCTION &apos;ADDR_DELETE&apos;
*                 EXPORTING
**                   ADDRESS_HANDLE      = &apos; &apos;
*                      ADDRESS_NUMBER      = &lt;VIM_TOTAL_ADDRESS_NUMBER&gt;
*                      ADDRESS_REFERENCE   = PS_ADDR_REF
**                   DATE_FROM           = &apos;00010101&apos;
*                 IMPORTING
*                      RETURNCODE          = PS_ADDRRC
*                 TABLES
*                      ERROR_TABLE         = PS_ADDR_ERRTAB
*                 EXCEPTIONS
*                      ADDRESS_NOT_EXIST   = 1
*                      PARAMETER_ERROR     = 2
*                      INTERNAL_ERROR      = 3
*                      REFERENCE_NOT_EXIST = 4.
*            IF SY-SUBRC NE 0.
            IF NOT &lt;vim_total_address_number&gt; IS INITIAL.
              CALL FUNCTION &apos;ADDR_GROUP_CHANGE&apos;
                   EXPORTING
                        address_number    = &lt;vim_total_address_number&gt;
*                    ADDRESS_HANDLE    = &apos; &apos;
                        new_address_group = new_addr_group
                   EXCEPTIONS
                        address_not_exist = 1
                        parameter_error   = 2
                        internal_error    = 3
                        OTHERS            = 4.
              IF sy-subrc = 1.
              ELSEIF sy-subrc = 2.
                MESSAGE i298(am) WITH new_addr_group.
*   Adreßgruppe &amp; nicht definiert, Löschvormerkung für Adresse nicht mög
                RAISE saving_correction_failed.
              ELSEIF sy-subrc &lt;&gt; 0.
                MESSAGE ID sy-msgid TYPE &apos;I&apos; NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
                RAISE saving_correction_failed.
              ENDIF.
*            ENDIF.
*            IF PS_ADDRRC NE SPACE.
*              LOOP AT PS_ADDR_ERRTAB.
*                MESSAGE ID PS_ADDR_ERRTAB-MSG_ID TYPE &apos;I&apos;
*                        NUMBER PS_ADDR_ERRTAB-MSG_NUMBER WITH
*                        PS_ADDR_ERRTAB-MSG_VAR1 PS_ADDR_ERRTAB-MSG_VAR2
*                       PS_ADDR_ERRTAB-MSG_VAR3 PS_ADDR_ERRTAB-MSG_VAR4.
*              ENDLOOP.
*              IF PS_ADDRRC EQ &apos;E&apos;.
*                RAISE SAVING_CORRECTION_FAILED.
*              ENDIF.
*            ENDIF.
              CALL FUNCTION &apos;ADDR_SINGLE_SAVE&apos;
                   EXPORTING
                    address_number         = &lt;vim_total_address_number&gt;
*                   PERSON_NUMBER          = &apos; &apos;
*                   ADDRESS_TYPE           = 1
*                   EXECUTE_IN_UPDATE_TASK = &apos; &apos;
                   EXCEPTIONS
                        address_not_exist      = 1
                        person_not_exist       = 2
                        address_number_missing = 3
                        reference_missing      = 4
                        internal_error         = 5
                        database_error         = 6
                        parameter_error        = 7.
              IF sy-subrc NE 0 AND  sy-subrc NE 1.
                MESSAGE ID sy-msgid TYPE &apos;I&apos; NUMBER sy-msgno WITH
                           sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
                RAISE saving_correction_failed.
              ENDIF.
            ENDIF.            &quot;not &lt;vim_total_address_number&gt; is initial
          ENDLOOP.                                          &quot;at total
        ENDIF.                         &quot;new_addr_group not initial
        CLEAR sy-subrc.
      ENDIF.                           &quot;x_header-adrnbrflag eq &apos;N&apos;.
    ENDIF.                             &quot;vim_import_testmode ne space.
  ELSE.
    IF vim_adjust_middle_level_mode EQ space.
      MESSAGE s043(sv).
      IF function = save AND vim_called_by_cluster = space.
        PERFORM vim_add_img_notices_pai USING &apos;S&apos;
                                        CHANGING dummy.
      ENDIF.
    ELSE.
      vim_adjust_middle_level_mode = &apos;L&apos;.
    ENDIF.
  ENDIF.                               &quot;&lt;status&gt;-upd_flag ne space
  IF maint_mode EQ transportieren.
* call synchronizer also for transp mode &quot;HCG int. message 1832131/2003
* after saving not processed in this case.
    REFRESH e071_loctab.
    APPEND e071 TO e071_loctab.
    PERFORM vim_synchronizer_call
                  USING e071_loctab[]
                        corr_keytab[]
                        &apos;X&apos;.
  ENDIF.
ENDFORM.                               &quot;prepare_saving</include_source>
   </include>
   <include NAME="LSVIMF15" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000002" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122428" IDATE="20080721" ITIME="122428">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  MOVE_EXTRACT_TO_VIEW_WA                                 *
*&amp;--------------------------------------------------------------------*
* move EXTRACT entry to view-/table-/texttable-workarea               *
*&amp;--------------------------------------------------------------------*
FORM move_extract_to_view_wa.

  MOVE &lt;vim_extract_struc&gt; TO &lt;table1&gt;.
*  MOVE EXTRACT TO &lt;TABLE1&gt;.
  IF x_header-bastab NE space AND x_header-texttbexst NE space.
*    MOVE &lt;extract_text&gt; TO &lt;table1_text&gt;.
    MOVE &lt;vim_xextract_text&gt; TO &lt;table1_xtext&gt;.
  ENDIF.
ENDFORM.                               &quot;move_extract_to_view_wa.</include_source>
   </include>
   <include NAME="LSVIMF16" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000006" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122428" IDATE="20080721" ITIME="122428">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form VIM_IMP_CALL_SCREEN                                      *
*&amp;--------------------------------------------------------------------*
* ...                                                                 *
*&amp;--------------------------------------------------------------------*
FORM vim_imp_call_screen USING vics_screen LIKE d020s-dnum.
  DATA: program LIKE sy-repid, import_action LIKE sy-msgv4,
        key_safe1 LIKE sy-msgv1, key_safe2 LIKE sy-msgv2,
        key_safe3 LIKE sy-msgv3, key_safe TYPE vim_tabkey_c,
        vics_xkeylen TYPE i.           &quot;, vics_int_entsafe(4096) TYPE c.
  LOCAL: imp_results.                  &quot;SW  wg. rek. Aufruf im Cluster

  FIELD-SYMBOLS: &lt;res_tabkey&gt; TYPE x, &lt;errkey&gt; TYPE x.

  ASSIGN: imp_results-tabkey TO &lt;res_tabkey&gt; CASTING,
          vim_profile_errorkey TO &lt;errkey&gt; CASTING.
  CLEAR vim_view_wax.
  IF vim_import_mode_active NE space.
*    VICS_INT_ENTSAFE = &lt;TABLE1&gt;.
    &lt;table1_wax&gt; = &lt;table1_x&gt;.
    PERFORM vim_set_impres_header.
    PERFORM vim_convert_tabkey USING &lt;f1_x&gt; key_safe vics_xkeylen.
*    imp_results-tabkey = &lt;f1&gt;.
    &lt;res_tabkey&gt; = &lt;f1_x&gt;.
    key_safe1 = key_safe.
    IF vics_xkeylen GT 50.
      key_safe2 = key_safe+50.
      IF vics_xkeylen GT 100.
        key_safe3 = key_safe+100.
      ENDIF.
    ENDIF.
    IF vim_called_by_cluster = &apos;X&apos;.                         &quot;SW
      CONCATENATE &apos;(&apos; view_name &apos;)&apos; INTO key_safe3.         &quot;SW
    ENDIF.                                                  &quot;SW
    IF status-action EQ hinzufuegen.
      import_action = &apos;INS&apos;.
    ELSEIF function EQ &apos;DELE&apos;.
      import_action = &apos;DEL&apos;.
    ELSEIF status-action EQ aendern.
      import_action = &apos;UPD&apos;.
    ENDIF.
    CLEAR: imp_results-import, vim_last_logged_message.
    IF vim_import_profile = &apos;X&apos;.
*      vim_profile_errorkey = &lt;f1&gt;.
      &lt;errkey&gt;(x_header-keylen) = &lt;f1_x&gt;.
    ELSE.
      vim_import_no_message = &apos;X&apos;.
      PERFORM vim_process_message USING &apos;SV&apos; &apos;S&apos; &apos;S&apos; &apos;150&apos; key_safe1
                                      key_safe2 key_safe3 import_action.
    ENDIF.
  ENDIF.
  IF vim_import_mode_active EQ space OR vim_no_dialog EQ space.
    CALL SCREEN vics_screen.
  ELSE.
    program = sy-repid. CLEAR vim_import_no_message.
    CALL FUNCTION &apos;VIEW_CALL_SCREEN&apos;
         EXPORTING
              screen_number = vics_screen
              program       = program
         EXCEPTIONS
              error_message = 1.
    IF sy-subrc NE 0.
      CLEAR vim_act_dynp_view.
      IF vim_last_logged_message-id NE sy-msgid OR
         vim_last_logged_message-nbr NE sy-msgno.
        vim_import_no_message = &apos;X&apos;.
        PERFORM vim_process_message USING sy-msgid sy-msgty sy-msgty
                                          sy-msgno sy-msgv1 sy-msgv2
                                          sy-msgv3 sy-msgv4.
      ENDIF.
      IF vim_import_forcemode EQ space.
        ok_code = &apos;IGN &apos;. neuer = &apos;N&apos;.
      ELSE.                            &quot;force mode
*        &lt;table1&gt; = vics_int_entsafe.
        &lt;table1_x&gt; = &lt;table1_wax&gt;.
        CASE import_action.
          WHEN &apos;UPD&apos;.
            &lt;status&gt;-upd_flag = &apos;X&apos;. neuer = &apos;N&apos;.
            PERFORM update_tab.
          WHEN &apos;INS&apos;.
            &lt;status&gt;-upd_flag = &apos;X&apos;. neuer = &apos;J&apos;.
            PERFORM update_tab.
          WHEN &apos;DEL&apos;.
            READ TABLE total WITH KEY &lt;f1_x&gt; BINARY SEARCH
                                             TRANSPORTING NO FIELDS.
            IF sy-subrc EQ 0.
              PERFORM logical_delete_from_total USING sy-tabix.
            ENDIF.
        ENDCASE.
      ENDIF.
    ENDIF.
    IF vim_import_profile = &apos;X&apos;.
      CLEAR vim_profile_errorkey.
    ELSE.
      vim_import_no_message = &apos;X&apos;.
      PERFORM vim_process_message USING &apos;SV&apos; &apos;S&apos; &apos;S&apos; &apos;151&apos; key_safe1
                                      key_safe2 key_safe3 import_action.
    ENDIF.
    CLEAR vim_import_no_message.
  ENDIF.
  IF vim_import_mode_active NE space.
    IF ok_code EQ &apos;IGN &apos; OR function EQ &apos;ABR &apos;. &quot;error
      imp_results-import-errors = 1.
    ENDIF.
    IF ok_code NE &apos;IGN&apos; AND function NE &apos;ABR&apos; OR
       vim_import_forcemode NE space.
      CASE import_action.
        WHEN &apos;UPD&apos;. imp_results-import-updated = 1.
        WHEN &apos;INS&apos;. imp_results-import-inserted = 1.
        WHEN &apos;DEL&apos;. imp_results-import-deleted = 1.
      ENDCASE.
    ENDIF.
    APPEND imp_results.
  ENDIF.
ENDFORM.                               &quot;vim_imp_call_screen</include_source>
   </include>
   <include NAME="LSVIMF17" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000005" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122428" IDATE="20080721" ITIME="122429">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form VIM_CONVERT_TABKEY                                       *
*&amp;--------------------------------------------------------------------*
* ...                                                                 *
*&amp;--------------------------------------------------------------------*
FORM vim_convert_tabkey USING value(vct_key_int) TYPE x
                                    vct_key_ext TYPE vim_tabkey_c
                                    vct_xkeylen TYPE i.
  FIELD-SYMBOLS: &lt;h1&gt;, &lt;h2&gt;.
  CLEAR vct_xkeylen.
  &lt;f1_wax&gt; = vct_key_int.
  LOOP AT x_namtab WHERE keyflag NE space AND texttabfld EQ space.
    CHECK x_namtab-position LT x_header-keylen.
*    ASSIGN: vct_key_int+x_namtab-position(x_namtab-flength) TO &lt;h1&gt;,
*            vct_key_ext+vct_xkeylen(x_namtab-outputlen) TO &lt;h2&gt;.
    ASSIGN: COMPONENT x_namtab-viewfield OF STRUCTURE &lt;table1_wa&gt;
             TO &lt;h1&gt;,
            vct_key_ext+vct_xkeylen(x_namtab-outputlen) TO &lt;h2&gt;.
    IF ( x_namtab-inttype NE &apos;C&apos; AND x_namtab-inttype NE &apos;N&apos; )&quot;SW
       OR x_namtab-convexit NE space.
      CALL FUNCTION &apos;VIEW_CONVERSION_OUTPUT&apos;
           EXPORTING
                value_intern = &lt;h1&gt;
                tabname      = x_header-maintview
                fieldname    = x_namtab-viewfield
*                inttype      = x_namtab-inttype
*                datatype     = x_namtab-datatype
*                decimals     = x_namtab-decimals
*                convexit     = x_namtab-convexit
*                sign         = x_namtab-sign
                outputlen    = x_namtab-outputlen
                intlen       = x_namtab-flength
           IMPORTING
                value_extern = &lt;h2&gt;.
    ELSE.
      &lt;h2&gt; = &lt;h1&gt;.
    ENDIF.
    ADD x_namtab-outputlen TO vct_xkeylen.
  ENDLOOP.
ENDFORM.                               &quot;vim_convert_tabkey</include_source>
   </include>
   <include NAME="LSVIMF18" SQLX="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000001" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122429" IDATE="20080721" ITIME="122429">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form VIM_SET_IMPRES_HEADER                                    *
*&amp;--------------------------------------------------------------------*
* ...                                                                 *
*&amp;--------------------------------------------------------------------*
FORM VIM_SET_IMPRES_HEADER.
  IF VIM_CALLED_BY_CLUSTER EQ SPACE.
    IMP_RESULTS-OBJTAB-OBJECT-OBJECTNAME = X_HEADER-VIEWNAME.
    IF X_HEADER-VIEWNAME &lt;&gt; X_HEADER-MAINTVIEW.             &quot;Subviews ..
      CLEAR IMP_RESULTS-OBJTAB-OBJECT-OBJECTTYPE.
    ELSE.
      IMP_RESULTS-OBJTAB-OBJECT-OBJECTTYPE = X_HEADER-BASTAB.
    ENDIF.                             &quot;.. Subviews
    TRANSLATE IMP_RESULTS-OBJTAB-OBJECT-OBJECTTYPE USING &apos; VXS&apos;.
  ELSE.
    IMP_RESULTS-OBJTAB-OBJECT-OBJECTNAME = VIM_CALLING_CLUSTER.
    IMP_RESULTS-OBJTAB-OBJECT-OBJECTTYPE = &apos;C&apos;.
  ENDIF.
  IF X_HEADER-BASTAB NE SPACE.
    IMP_RESULTS-OBJTAB-TABNAME = X_HEADER-MAINTVIEW.
    IF X_HEADER-VIEWNAME &lt;&gt; X_HEADER-MAINTVIEW.             &quot;Subviews ..
      IMP_RESULTS-OBJTAB-VIEWNAME = X_HEADER-VIEWNAME.
    ELSE.                              &quot;.. Subviews
      CLEAR IMP_RESULTS-OBJTAB-VIEWNAME.
    ENDIF.
  ELSE.
    IMP_RESULTS-OBJTAB-TABNAME = X_HEADER-ROOTTAB.
    IMP_RESULTS-OBJTAB-VIEWNAME = X_HEADER-VIEWNAME.
  ENDIF.
  IMP_RESULTS-KEYLEN = X_HEADER-KEYLEN.                     &quot;SW
  IMP_RESULTS-GENKEYLEN = X_HEADER-KEYLEN.                  &quot;SW
ENDFORM.                               &quot;vim_set_impres_header</include_source>
   </include>
   <include NAME="LSVIMF19" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000006" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122429" IDATE="20080721" ITIME="122429">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  VIM_MODIFY_VIEW_ENTRY                                   *
*&amp;--------------------------------------------------------------------*
* update/insert entry, process all checks                             *
*&amp;--------------------------------------------------------------------*
FORM vim_modify_view_entry USING value(vmve_exix) TYPE i
                                 vmve_rc TYPE i.
  DATA: h_ix TYPE i, h_act(1) TYPE c, hact2(1) TYPE c,
        fieldname TYPE fnam_____4.
  FIELD-SYMBOLS: &lt;guid&gt; TYPE ANY, &lt;old_guid&gt; TYPE ANY,
                 &lt;guid_wa&gt; TYPE ANY,
                 &lt;extract_val&gt; TYPE ANY, &lt;total_val&gt; TYPE ANY.
  CLEAR vmve_rc.
  nextline = exind = vmve_exix.
* new: transfer of changed entries from EXTRACT into TOTAL via dynps
* ... first: handle read-only fields and subset fields
  IF x_header-subsetflag NE space OR
     x_header-rdonlyflag NE space OR
     x_header-adrnbrflag NE space.
    IF &lt;xact&gt; NE neuer_eintrag.
      READ TABLE total WITH KEY &lt;vim_xextract_key&gt;
                       BINARY SEARCH.
      h_act = &lt;action&gt;.
    ELSE.
      h_act = &lt;xact&gt;.
    ENDIF.
    LOOP AT x_namtab WHERE readonly EQ rdonly
                       OR  ( readonly EQ subset AND
                             keyflag EQ space ).
      ASSIGN COMPONENT x_namtab-viewfield
       OF STRUCTURE &lt;vim_extract_struc&gt; TO &lt;extract_val&gt;.
      CHECK sy-subrc = 0.
      IF &lt;xact&gt; NE neuer_eintrag.
        ASSIGN COMPONENT x_namtab-viewfield
         OF STRUCTURE &lt;vim_total_struc&gt; TO &lt;total_val&gt;.
        IF sy-subrc = 0.
          &lt;extract_val&gt; = &lt;total_val&gt;.
        ENDIF.
*        extract+x_namtab-position(x_namtab-flength) =
*            total+x_namtab-position(x_namtab-flength).
      ELSE.
        ASSIGN COMPONENT x_namtab-viewfield
         OF STRUCTURE &lt;initial&gt; TO &lt;total_val&gt;.
        IF sy-subrc = 0.
          &lt;extract_val&gt; = &lt;total_val&gt;.
        ENDIF.
*        extract+x_namtab-position(x_namtab-flength) =
*            &lt;initial&gt;+x_namtab-position(x_namtab-flength).
      ENDIF.
    ENDLOOP.
    IF sy-subrc EQ 0.
      hact2 = &lt;xact&gt;. &lt;xact&gt; = h_act.
      MODIFY extract INDEX vmve_exix.
      &lt;xact&gt; = hact2.
    ENDIF.
  ENDIF.
  PERFORM move_extract_to_view_wa.
* ... second: handle address number and GUID
  CLEAR vim_upgr_address_number.
  IF x_header-adrnbrflag NE space.
    IF x_header-adrnbrflag = &apos;N&apos;.
      vim_upgr_address_number = &lt;address_number&gt;.
    ENDIF.
    IF &lt;xact&gt; NE neuer_eintrag.
      &lt;address_number&gt; = &lt;vim_total_address_number&gt;.
    ELSE.
      CLEAR &lt;address_number&gt;.
    ENDIF.
  ENDIF.
  IF x_header-guidflag &lt;&gt; space AND &lt;xact&gt; &lt;&gt; neuer_eintrag.
* update only, GUID will be set in UPDATE_TAB for new entries
    LOOP AT x_namtab WHERE domname IN vim_guid_domain.
      CONCATENATE x_header-maintview x_namtab-viewfield
       INTO fieldname SEPARATED BY &apos;-&apos;.
      ASSIGN COMPONENT x_namtab-viewfield
       OF STRUCTURE &lt;vim_extract_struc&gt; TO &lt;guid&gt;.
      ASSIGN COMPONENT x_namtab-viewfield
       OF STRUCTURE &lt;vim_total_struc&gt; TO &lt;old_guid&gt;.
*      ASSIGN extract+x_namtab-position(x_namtab-flength) TO &lt;guid&gt;
*       CASTING TYPE (fieldname).
*      ASSIGN total+x_namtab-position(x_namtab-flength) TO &lt;old_guid&gt;
*       CASTING TYPE (fieldname).
      IF &lt;guid&gt; IS INITIAL AND &lt;old_guid&gt; IS INITIAL.
* no GUID-value imported from remote system and GUID not yet set in
* current entry
        PERFORM vim_make_guid USING x_namtab-viewfield.
        ASSIGN (fieldname) TO &lt;guid_wa&gt; CASTING TYPE (fieldname).
        &lt;guid&gt; = &lt;guid_wa&gt;.
* (including event 27)
      ELSEIF &lt;guid&gt; IS INITIAL.
* use old GUID
        &lt;guid&gt; = &lt;old_guid&gt;.
        IF x_header-frm_af_uid &lt;&gt; space.
          PERFORM (x_header-frm_af_uid) IN PROGRAM (x_header-fpoolname)
                                    USING &lt;old_guid&gt;
                                    CHANGING &lt;guid&gt;
                                             &lt;vim_extract_struc&gt;.
        ELSEIF x_header-frm_af_uid &lt;&gt; space.
* overwrite old GUID with GUID from remote client... or not?
          PERFORM (x_header-frm_af_uid) IN PROGRAM (x_header-fpoolname)
                                    USING &lt;old_guid&gt;
                                    CHANGING &lt;guid&gt;
                                             &lt;vim_extract_struc&gt;.
        ENDIF.
      ENDIF.
    ENDLOOP.
  ENDIF.
  IF &lt;xact&gt; EQ neuer_eintrag.
    status-action = hinzufuegen.
    &lt;vim_extract_struc&gt; = &lt;initial&gt;.
    IF x_header-bastab NE space AND
       x_header-texttbexst NE space.
      &lt;vim_xextract_text&gt; = &lt;text_initial_x&gt;.
    ENDIF.
    &lt;xact&gt; = leer.
  ELSE.
    status-action = aendern. &lt;xact&gt; = h_act.
  ENDIF.
  MODIFY extract INDEX vmve_exix.
* ...third: call screen a la replace
  CASE status-type.
    WHEN einstufig.
      PERFORM vim_imp_call_screen USING liste.
    WHEN zweistufig.
      IF &lt;xact&gt; EQ leer.
        neuer = &apos;J&apos;.
      ENDIF.
      PERFORM process_detail_screen USING &apos;C&apos;.
  ENDCASE.
  status-action = &lt;status&gt;-st_action = aendern.
  IF ok_code EQ &apos;IGN &apos;. vmve_rc = 4. CLEAR ok_code. EXIT. ENDIF.
  IF function EQ &apos;ABR &apos;. vmve_rc = 8. CLEAR function. EXIT. ENDIF.
ENDFORM.                               &quot;vim_modify_view_entry</include_source>
   </include>
   <include NAME="LSVIMF1A" SQLX="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000001" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122429" IDATE="20080721" ITIME="122429">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  VIM_PROCESS_VIEW_ENTRY                                  *
*&amp;--------------------------------------------------------------------*
* process current function for view entry                             *
*&amp;--------------------------------------------------------------------*
FORM VIM_PROCESS_VIEW_ENTRY USING VALUE(VPVE_EXIX) TYPE I
                                  VALUE(VPVE_OKCODE) LIKE OK_CODE
                                  VPVE_RC TYPE I.
  DATA: FUNCTION_SAFE LIKE FUNCTION.
  CLEAR VPVE_RC.
  NEXTLINE = EXIND = VPVE_EXIX.
  FUNCTION_SAFE = FUNCTION.
  FUNCTION = OK_CODE = VPVE_OKCODE.
  PERFORM MOVE_EXTRACT_TO_VIEW_WA.
  CASE STATUS-TYPE.
    WHEN EINSTUFIG.
*     CALL SCREEN LISTE.
      PERFORM VIM_IMP_CALL_SCREEN USING LISTE.
    WHEN ZWEISTUFIG.
*     PERFORM MOVE_EXTRACT_TO_VIEW_WA.
      PERFORM PROCESS_DETAIL_SCREEN USING &apos;C&apos;.
  ENDCASE.
  IF OK_CODE EQ &apos;IGN &apos;. VPVE_RC = 4. CLEAR OK_CODE. EXIT. ENDIF.
  IF FUNCTION EQ &apos;ABR &apos;. VPVE_RC = 8. CLEAR FUNCTION. EXIT. ENDIF.
  FUNCTION = FUNCTION_SAFE.
ENDFORM.                               &quot;vim_process_view_entry</include_source>
   </include>
   <include NAME="LSVIMF1B" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000005" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122429" IDATE="20080721" ITIME="122429">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form VIM_RESTORE_SUBSET_CONDS                                 *
*&amp;--------------------------------------------------------------------*
* restore subset conditions                                           *
*&amp;--------------------------------------------------------------------*
FORM vim_restore_subset_conds.
  DATA: hi TYPE i.
  FIELD-SYMBOLS: &lt;ifield&gt; TYPE ANY.
  LOOP AT dpl_sellist WHERE ddic CO vim_subset_marks.
    hi = sy-tabix.
    READ TABLE x_namtab INDEX dpl_sellist-tabix.
    ASSIGN COMPONENT x_namtab-viewfield
     OF STRUCTURE &lt;vim_extract_struc&gt; TO &lt;ifield&gt;.
*    ASSIGN EXTRACT+X_NAMTAB-POSITION(X_NAMTAB-FLENGTH) TO &lt;IFIELD&gt;.
    CALL FUNCTION &apos;VIEW_CONVERSION_OUTPUT&apos;
         EXPORTING
              value_intern = &lt;ifield&gt;
              tabname      = x_header-maintview
              fieldname    = x_namtab-viewfield
              outputlen    = x_namtab-outputlen
              intlen       = x_namtab-flength
         IMPORTING
              value_extern = dpl_sellist-value.
    CLEAR dpl_sellist-converted.
    IF dpl_sellist-value IS INITIAL. dpl_sellist-initial = &apos;X&apos;. ENDIF.
    MODIFY dpl_sellist INDEX hi.
  ENDLOOP.
  dba_sellist[] = dpl_sellist[].
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF1C" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000009" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122429" IDATE="20080721" ITIME="122429">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form UPGRADE                                                  *
*&amp;--------------------------------------------------------------------*
* process upgrade                                                     *
*---------------------------------------------------------------------*
* U_MODE --&gt; &apos; &apos; - client 000, &apos;O&apos; - other client, others - remote sys*
*---------------------------------------------------------------------*
FORM upgrade USING value(u_mode) TYPE c.
  DATA: u_kind, u_update_happened, trans_pattern(8) TYPE c,
        hf TYPE i, u_client LIKE sy-mandt, u_tabind LIKE sy-tabix,
        u_it000 LIKE vim_t000 OCCURS 10, u_title(40) TYPE c,
        u_remote_sys LIKE rfcdes-rfcdest, u_t000 LIKE vim_t000,
        u_counter TYPE i, u_del_cnt TYPE i, u_rc TYPE i, hf1 TYPE i,
        u_funcsafe(4) TYPE c, u_txt_fu_beg TYPE i, u_txt_fu_lg TYPE i,
        u_newversion(1) TYPE c VALUE &apos;X&apos;, u_mark_entries(1) TYPE c,
        u_action(1) TYPE c, u_specmode_safe(1) TYPE c,
        u_called_from(1) TYPE c, u_oc_exst LIKE ntab_cmp-flag,
        u_sellist TYPE vimsellist_type, sellines TYPE i.
  CONSTANTS: u_text_frm(30) TYPE c VALUE &apos;FILL_TEXTTAB_KEY&apos;.
  FIELD-SYMBOLS: &lt;u_f1&gt; TYPE x, &lt;u_sellist&gt; TYPE vimsellist_type,
                 &lt;w_sellist&gt; TYPE vimsellist.

* data and field symbols for copying the extract to and from
* the compare tool container:
  DATA:
    cmp_container_ref    TYPE REF TO data,
    cmp_container_wa_ref TYPE REF TO data,
    extract_len          TYPE i,
    subrc_buf            TYPE sy-subrc.
  FIELD-SYMBOLS:
    &lt;cmp_cont&gt;    TYPE STANDARD TABLE,
    &lt;cmp_cont_wa&gt; TYPE ANY,
    &lt;x_dummy&gt;     TYPE x.

  READ TABLE excl_cua_funct WITH KEY function = &apos;CMPR&apos;.
  IF sy-subrc EQ 0.                    &quot;upgrade is not allowed
    MESSAGE s001(sv).
    EXIT.
  ENDIF.
* upgrade with client 0 only if current client &lt;&gt; 000
* upgrade with other clients only if objects are clientdependent
  IF u_mode EQ space AND sy-mandt EQ &apos;000&apos; OR  &quot;upgrade with client 000
     ( u_mode EQ space OR u_mode EQ &apos;O&apos; ) AND
     x_header-clidep EQ space.
    MESSAGE s001(sv).
    EXIT.
  ENDIF.
* send warning if address number could be changed
  IF status-action EQ aendern AND
   ( x_header-adrnbrflag NE space AND x_header-adrnbrflag &lt;&gt; &apos;N&apos; ).
    PERFORM set_pf_status USING &apos;ERROR&apos;.
    MESSAGE i139(sv). &quot;Adreßdaten werden nicht übernommen
    PERFORM set_pf_status USING status.
  ENDIF.
  CLEAR: u_client, u_remote_sys.
  IF u_mode EQ space.
    u_client = &apos;000&apos;.
  ELSEIF u_mode EQ &apos;O&apos;.
    IF vim_default_upgr_clnt-client NE space AND
       vim_default_upgr_clnt-viewname EQ x_header-viewname.
      u_client = vim_default_upgr_clnt-client.
    ENDIF.
  ELSE.
    IF vim_default_rfc_dest-rfcdest NE space AND
       vim_default_rfc_dest-viewname EQ x_header-viewname.
      u_remote_sys = vim_default_rfc_dest-rfcdest.
    ENDIF.
  ENDIF.
  IF vim_special_mode EQ vim_direct_upgrade.
    function = &apos;ABR&apos;.                  &quot;avoid processing detail screen
    PERFORM fill_extract. CLEAR function.
    u_specmode_safe = vim_special_mode.
    ASSIGN dba_sellist[] TO &lt;u_sellist&gt;.
  ELSE.
    ASSIGN &lt;vim_ck_sellist&gt; TO &lt;u_sellist&gt;.
  ENDIF.
  vim_special_mode = vim_upgrade.
  MOVE: geloescht TO trans_pattern, aendern TO trans_pattern+1(1),
        neuer_geloescht TO trans_pattern+2(1),
        neuer_eintrag   TO trans_pattern+3(1),
        update_geloescht TO trans_pattern+4(1),
        aendern         TO trans_pattern+5(1),
        original  TO trans_pattern+6(1),
        aendern TO trans_pattern+7(1).
  IF x_header-bastab EQ space.         &quot;view
    u_kind = &apos;V&apos;.
  ELSE.
    IF x_header-texttbexst EQ space.   &quot;base table
      u_kind = &apos;T&apos;.
    ELSE.                              &quot;base table with text table
      u_kind = &apos;X&apos;.
    ENDIF.
  ENDIF.

* Add collapsed or merged timedep. entries
  IF x_header-delmdtflag NE space.
    DESCRIBE TABLE vim_collapsed_mainkeys LINES hf.
    DESCRIBE TABLE vim_merged_entries.
    IF sy-tfill GT 0 OR hf GT 0.
      vim_ignore_collapsed_mainkeys = &apos;X&apos;.
      PERFORM fill_extract.
      CLEAR vim_ignore_collapsed_mainkeys.
    ENDIF.
  ENDIF.
  IF ( vim_system_type NE &apos;SAP&apos; AND sy-mandt EQ &apos;000&apos; )
   OR x_header-importable = vim_not_importable.
    u_action = anzeigen.
  ELSE.
    u_action = status-action.
  ENDIF.
  TRANSLATE u_action USING &apos;SCUA&apos;.
  IF vim_adjust_middle_level_mode NE space.
    TRANSLATE u_action USING &apos;Aa&apos;.
  ENDIF.
  u_called_from = vim_special_adjust_mode.
  TRANSLATE u_called_from USING &apos; VSFXF&apos;.
  IF NOT vim_oc_inst IS INITIAL.
* data access restricted?
    IF ( u_action = &apos;C&apos;
         AND NOT vim_oc_inst-&gt;oc_selcrit_read_tab IS INITIAL )
     OR ( &apos;Aa&apos; CS u_action
          AND NOT vim_oc_inst-&gt;oc_selcrit_maint_tab IS INITIAL ).
      u_oc_exst = &apos;X&apos;.
    ENDIF.
  ENDIF.
  APPEND LINES OF &lt;u_sellist&gt; TO u_sellist.
  DELETE u_sellist WHERE from_auth &lt;&gt; space
   AND ddic &lt;&gt; &apos;S&apos; AND ddic &lt;&gt; &apos;B&apos;.
  IF sy-subrc = 0.
    DESCRIBE TABLE u_sellist LINES sellines.
    IF sellines GT 0.
      READ TABLE u_sellist INDEX sellines ASSIGNING &lt;w_sellist&gt;.
      CLEAR &lt;w_sellist&gt;-and_or.
    ENDIF.
  ENDIF.

* copy extract to compare tool container
  DESCRIBE FIELD extract LENGTH extract_len IN BYTE MODE.
  IF extract_len &lt;= 64.
    CREATE DATA cmp_container_ref TYPE TABLE OF tbl64.
    ASSIGN cmp_container_ref-&gt;* TO &lt;cmp_cont&gt;.
    CREATE DATA cmp_container_wa_ref TYPE tbl64.
    ASSIGN cmp_container_wa_ref-&gt;* TO &lt;cmp_cont_wa&gt;.
  ELSEIF extract_len &lt;= 256.
    CREATE DATA cmp_container_ref TYPE TABLE OF tbl256.
    ASSIGN cmp_container_ref-&gt;* TO &lt;cmp_cont&gt;.
    CREATE DATA cmp_container_wa_ref TYPE tbl256.
    ASSIGN cmp_container_wa_ref-&gt;* TO &lt;cmp_cont_wa&gt;.
  ELSEIF extract_len &lt;= 1024.
    CREATE DATA cmp_container_ref TYPE TABLE OF tbl1024.
    ASSIGN cmp_container_ref-&gt;* TO &lt;cmp_cont&gt;.
    CREATE DATA cmp_container_wa_ref TYPE tbl1024.
    ASSIGN cmp_container_wa_ref-&gt;* TO &lt;cmp_cont_wa&gt;.
  ELSEIF extract_len &lt;= 4096.
    CREATE DATA cmp_container_ref TYPE TABLE OF tbl4096.
    ASSIGN cmp_container_ref-&gt;* TO &lt;cmp_cont&gt;.
    CREATE DATA cmp_container_wa_ref TYPE tbl4096.
    ASSIGN cmp_container_wa_ref-&gt;* TO &lt;cmp_cont_wa&gt;.
  ELSEif extract_len &lt;= 8192.
    CREATE DATA cmp_container_ref TYPE TABLE OF tbl8192.
    ASSIGN cmp_container_ref-&gt;* TO &lt;cmp_cont&gt;.
    CREATE DATA cmp_container_wa_ref TYPE tbl8192.
    ASSIGN cmp_container_wa_ref-&gt;* TO &lt;cmp_cont_wa&gt;.
  else.
    CREATE DATA cmp_container_ref TYPE TABLE OF tbl32000.
    ASSIGN cmp_container_ref-&gt;* TO &lt;cmp_cont&gt;.
    CREATE DATA cmp_container_wa_ref TYPE tbl32000.
    ASSIGN cmp_container_wa_ref-&gt;* TO &lt;cmp_cont_wa&gt;.
  ENDIF.

  ASSIGN &lt;cmp_cont_wa&gt; TO &lt;x_dummy&gt; CASTING.
  LOOP AT extract.
    CLEAR &lt;x_dummy&gt;.
    &lt;x_dummy&gt; = &lt;vim_xextract&gt;.
    APPEND &lt;cmp_cont_wa&gt; TO &lt;cmp_cont&gt;.
  ENDLOOP.

  CALL FUNCTION &apos;SCT1_VIEW_COMPARE_AND_ADJUST&apos;
       EXPORTING
            iv_view_name              = x_header-maintview  &quot;VIEWNAME
*             IV_VIEW_VARIANT    =
            iv_kind                   = u_kind
            iv_mode                   = u_action
*             IV_LANGUAGE        = SY-LANGU
*             IV_CLIENT_REMOTE   = U_CLIENT
            iv_rfc_destination        = u_remote_sys
            iv_called_from            = u_called_from
            iv_data_access_restricted = u_oc_exst
       IMPORTING
            ev_update          = u_update_happened
            ev_mark_entries    = u_mark_entries
       TABLES
            it_header          = x_header
            it_namtab          = x_namtab
            it_sellist         = u_sellist
            ct_box             = &lt;cmp_cont&gt;
       EXCEPTIONS
            canceled           = 1
            wrong_parameter    = 2
            compare_error      = 3
            OTHERS             = 4.
  subrc_buf = sy-subrc.

* copy compare tool container back to extract
  REFRESH extract.
  LOOP AT &lt;cmp_cont&gt; ASSIGNING &lt;cmp_cont_wa&gt;.
    ASSIGN &lt;cmp_cont_wa&gt; TO &lt;x_dummy&gt; CASTING.
    &lt;vim_xextract&gt; = &lt;x_dummy&gt;(extract_len).
    APPEND extract.
  ENDLOOP.

  sy-subrc = subrc_buf.
  IF sy-subrc GT 01.
    MESSAGE ID sy-msgid TYPE &apos;I&apos; NUMBER sy-msgno
      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    MESSAGE s135(sv). sy-subrc = 01.
  ENDIF.
  IF status-action EQ anzeigen AND u_update_happened NE space.
    sy-subrc = 1.
  ENDIF.
  CASE sy-subrc.
    WHEN 0.
      IF u_update_happened NE space.
* transfer changed entries from EXTRACT into TOTAL
        CLEAR: u_counter, u_del_cnt. replace_mode = &apos;X&apos;.
        DESCRIBE TABLE extract LINES maxlines.
* 1st: handle deleted entries
        LOOP AT extract.
          IF &lt;xact&gt; EQ original.
            DELETE extract. CONTINUE.
          ENDIF.
          CHECK &lt;xact&gt; EQ geloescht OR &lt;xact&gt; EQ neuer_geloescht OR
                &lt;xact&gt; EQ update_geloescht.
          hf = sy-tabix.
          READ TABLE total WITH KEY &lt;vim_xextract_key&gt; BINARY SEARCH.
          IF sy-subrc NE 0 OR ( sy-subrc EQ 0 AND &lt;action&gt; EQ &lt;xact&gt; ).
            DELETE extract. CONTINUE.
          ENDIF.
          &lt;mark&gt; = markiert. ADD 1 TO mark_total.
          MODIFY total INDEX sy-tabix.
          &lt;xmark&gt; = markiert. ADD 1 TO mark_extract.
          MODIFY extract.
          IF vim_special_adjust_mode EQ subset.
            PERFORM vim_restore_subset_conds.
          ENDIF.
          PERFORM vim_process_view_entry USING hf &apos;DELE&apos; u_rc.
          CHECK u_rc NE 4.
          IF u_rc EQ 8.
            EXIT.
          ENDIF.
          ADD: counter TO u_del_cnt, 1 TO u_counter.
        ENDLOOP.
        IF u_counter GT u_del_cnt.
          SUBTRACT u_del_cnt FROM u_counter.
          MESSAGE i116(sv) WITH u_counter. &quot;&amp; Einträge konnten nicht g
        ENDIF.
        CLEAR u_counter.
        IF status-type EQ einstufig.
          CLEAR: ok_code, function.
        ELSE.
          function = ok_code = &apos;COMP&apos;.
        ENDIF.
* 2nd: handle changed entries
        ASSIGN &lt;vim_xtotal&gt;(x_header-tablen) TO &lt;u_f1&gt;.
        LOOP AT extract.
          IF &lt;xact&gt; NE aendern AND &lt;xact&gt; NE neuer_eintrag.
            DELETE extract. CONTINUE.
          ENDIF.
          hf = sy-tabix.
          READ TABLE total WITH KEY &lt;vim_xextract_key&gt; BINARY SEARCH.
          IF sy-subrc EQ 0.            &quot;entry exists in current client
            IF extract EQ total. &quot;no changes -&gt; delete and continue
              DELETE extract. CONTINUE.
            ELSEIF &lt;xact&gt; EQ neuer_eintrag AND &quot;new entry exists and
                &lt;action&gt; EQ geloescht OR &lt;action&gt; EQ neuer_geloescht OR
                 &lt;action&gt; EQ update_geloescht.&quot;entry deleted in cur clnt
              status-delete = geloescht. &quot; -&gt; first undelete it
              &lt;xact&gt; = &lt;action&gt;. MODIFY extract. u_funcsafe = function.
              IF vim_special_adjust_mode EQ subset.
                PERFORM vim_restore_subset_conds.
              ENDIF.
              PERFORM vim_mark_and_process USING hf &apos;UNDO&apos; hf1 u_rc.
              CLEAR status-delete. function = u_funcsafe.
              vim_special_mode = vim_upgrade.
              CHECK u_rc NE 4.
              IF u_rc EQ 8.
                EXIT.
              ENDIF.
              READ TABLE extract INDEX hf.
              READ TABLE total WITH KEY &lt;vim_xextract_key&gt;
                                                      BINARY SEARCH.
              IF &lt;u_f1&gt; EQ &lt;table2_x&gt;.   &quot;no changes after undo
                DELETE extract. CONTINUE.&quot;delete &amp; continue
              ELSE.
                &lt;xact&gt; = aendern. MODIFY extract.
              ENDIF.
            ELSEIF &lt;u_f1&gt; EQ &lt;table2_x&gt;. &quot;no changes -&gt; delete and cont
              DELETE extract. CONTINUE.
            ELSEIF &lt;xact&gt; EQ neuer_eintrag AND &lt;action&gt; EQ original.
              &lt;xact&gt; = aendern. MODIFY extract.
            ENDIF.
          ENDIF.                       &quot;sy-subrc eq 0.
          IF vim_special_adjust_mode EQ subset.
            PERFORM vim_restore_subset_conds.
          ENDIF.
          PERFORM vim_modify_view_entry USING hf u_rc.
          CHECK u_rc NE 4.
          IF u_rc EQ 8.
            EXIT.
          ENDIF.
          IF u_mark_entries NE space.  &quot;mark ajusted entries
            READ TABLE total WITH KEY &lt;vim_xtotal_key&gt; BINARY SEARCH
                             TRANSPORTING NO FIELDS.
            IF &lt;mark&gt; EQ nicht_markiert.
              &lt;mark&gt; = markiert. ADD 1 TO mark_total.
              MODIFY total INDEX sy-tabix.
              ADD 1 TO mark_extract.
            ENDIF.
          ENDIF.
          extract = total.
          MODIFY extract.
          ADD 1 TO u_counter.
        ENDLOOP.
        IF temporal_delimitation_happened NE space.
          REFRESH vim_delim_entries.
          CLEAR temporal_delimitation_happened.
        ENDIF.
        status-data = title-data = auswahldaten.
        nextline = l = 1.
        IF u_del_cnt NE 0 AND u_counter NE 0.
          MESSAGE s140(sv) &quot;&amp;1 Einträge geloescht, &amp;2 Einträge übernom
            WITH u_del_cnt u_counter.
        ELSEIF u_del_cnt NE 0.
          MESSAGE s011(sv) WITH u_del_cnt. &quot;Anzahl gelöschter Einträge
        ELSE.
          MESSAGE s012(sv) WITH u_counter. &quot;Anzahl veränderter Einträg
        ENDIF.
        CLEAR replace_mode.
      ELSE.                            &quot;no update happened
        IF x_header-delmdtflag NE space.
          PERFORM fill_extract. &quot;consider collapsed or merged entries
        ENDIF.
      ENDIF.                           &quot;u_update_happend ne space
      DESCRIBE TABLE extract LINES maxlines.
      nextline = 1.
      IF vim_special_adjust_mode NE space.
        CLEAR: vim_special_mode, vim_special_adjust_mode,
               &lt;status&gt;-upd_flag, maxlines, &lt;status&gt;-maxlines.
        vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
        IF vim_adjust_middle_level_mode NE space.
          function = &apos;SAVE&apos;.
        ENDIF.
      ENDIF.
    WHEN 1. &quot;ignore changes in EXTRACT --&gt; restore EXTRACT from TOTAL
      IF vim_special_adjust_mode NE space.
        CLEAR: vim_special_mode, vim_special_adjust_mode,
               &lt;status&gt;-upd_flag, maxlines, &lt;status&gt;-maxlines.
        vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
        IF vim_adjust_middle_level_mode NE space.
          function = &apos;SAVE&apos;.
        ENDIF.
      ENDIF.
      PERFORM fill_extract.
    WHEN OTHERS. RAISE upgrade_view_failed.
  ENDCASE.
  CLEAR vim_special_mode.
ENDFORM.                               &quot; UPGRADE</include_source>
   </include>
   <include NAME="LSVIMF1D" SQLX="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000001" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122429" IDATE="20080721" ITIME="122429">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  PROCESS_AFTER_ENTRY_RESET                               *
*&amp;--------------------------------------------------------------------*
*                                                                     *
*---------------------------------------------------------------------*
FORM PROCESS_AFTER_ENTRY_RESET.
  IF TEMPORAL_DELIMITATION_HAPPENED NE SPACE.
    PERFORM AFTER_TEMPORAL_DELIMITATION.
    CLEAR TEMPORAL_DELIMITATION_HAPPENED.
  ENDIF.
  PERFORM CHECK_UPD.
  IF X_HEADER-FRM_AF_ORG NE SPACE.
    PERFORM (X_HEADER-FRM_AF_ORG) IN PROGRAM (SY-REPID).
  ENDIF.
ENDFORM.                               &quot;process_after_entry_reset</include_source>
   </include>
   <include NAME="LSVIMF1E" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000006" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122429" IDATE="20080721" ITIME="122430">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  PROCESS_ENTRY_RESET                                     *
*&amp;--------------------------------------------------------------------*
* refresh entry from database                                         *
*---------------------------------------------------------------------*
* --&gt; PER_INDEX current index for modifying EXTRACT                   *
*---------------------------------------------------------------------*
FORM PROCESS_ENTRY_RESET USING VALUE(PER_INDEX) TYPE I.
  DATA: PRT_FRKY_SAFE(255) TYPE C, PER_HF TYPE I,
        REFCNT_SAFE TYPE I.

  REFCNT_SAFE = REFCNT.
  PERFORM MOVE_EXTRACT_TO_VIEW_WA.
  IF &lt;XACT&gt; NE ORIGINAL OR             &quot;SW Texttransl
     ( X_HEADER-BASTAB NE SPACE AND X_HEADER-TEXTTBEXST NE SPACE
                                AND &lt;XACT_TEXT&gt; NE ORIGINAL ).

*   check if the &lt;vim_prtfky_wa&gt; is assigned. If the field belong
*   EZN &amp; KEY, the field will be assinged.
    IF vim_prtfky_assigned NE &apos; &apos;.          &quot;XB 07.2002 BCEK061635
      IF X_HEADER-PTFRKYEXST NE SPACE.
        MOVE &lt;VIM_PRTFKY_WA&gt; TO PRT_FRKY_SAFE.
      ENDIF.
    ENDIF.

    IF X_HEADER-FRM_RP_ORG NE SPACE.
      PERFORM (X_HEADER-FRM_RP_ORG) IN PROGRAM (SY-REPID).
    ELSE.
      IF X_HEADER-BASTAB NE SPACE.
        PERFORM (VIM_TB_READ_SINGLE_FORM) IN PROGRAM (SY-REPID).
      ELSE.
        PER_HF = STRLEN( X_HEADER-MAINTVIEW ).
        IF PER_HF LE 10.
          MOVE X_HEADER-MAINTVIEW TO VIM_READ_SINGLE_FORM-VIEWNAME.
          PERFORM (VIM_READ_SINGLE_FORM) IN PROGRAM.
        ELSE.
          MOVE X_HEADER-MAINTVIEW TO VIM_READ_SINGLE_FORM_40-VIEWNAME.
          PERFORM (VIM_READ_SINGLE_FORM_40) IN PROGRAM.
        ENDIF.
      ENDIF.
    ENDIF.
    IF SY-SUBRC NE 0.
      IF X_HEADER-FRM_RP_ORG EQ SPACE.
        RAISE IMPOSSIBLE_ERROR.        &quot;entry not found
      ENDIF.
    ELSE.

*   check if the &lt;vim_prtfky_wa&gt; is assigned. If the field belong
*   EZN &amp; KEY, the field will be assinged.
      IF vim_prtfky_assigned NE &apos; &apos;.          &quot;XB 07.2002  BCEK061635
        IF X_HEADER-PTFRKYEXST NE SPACE AND                      &quot;SW
           &lt;VIM_PRTFKY_WA&gt; NE PRT_FRKY_SAFE.
          PERFORM CONSISTENCY_PRT_FRKY_FIELDS USING &apos;X&apos;.
        ENDIF.
      ENDIF.

      IF X_HEADER-DELMDTFLAG NE SPACE.
        PERFORM TEMPORAL_DELIMITATION.
      ENDIF.
      PERFORM MODIFY_TABLES USING PER_INDEX.
      IF PER_INDEX NE 0.
        ADD 1 TO REFCNT.
      ENDIF.
    ENDIF.

  ENDIF.                               &quot;SW Texttransl ..
  IF X_HEADER-TEXTTBEXST &lt;&gt; SPACE.     &quot;SW Texttransl ..
    IF X_HEADER-FRM_TL_ORG NE SPACE.
      PERFORM (X_HEADER-FRM_TL_ORG) IN PROGRAM (SY-REPID).
    ELSE.
      PERFORM VIM_READ_TEXTTAB_ENTRY.
    ENDIF.
    IF REFCNT_SAFE = REFCNT AND SY-SUBRC = 0.
      ADD 1 TO REFCNT.
      CLEAR &lt;STATUS&gt;-UPD_FLAG.
      IF &lt;XMARK&gt; EQ MARKIERT.
        SUBTRACT: 1 FROM &lt;STATUS&gt;-MK_XT,
                  1 FROM &lt;STATUS&gt;-MK_TO.
        &lt;XMARK&gt; = NICHT_MARKIERT.
        IF PER_INDEX &lt;&gt; 0.
          MODIFY EXTRACT INDEX PER_INDEX.
        ENDIF.
        READ TABLE TOTAL WITH KEY &lt;VIM_xEXTRACT_KEY&gt; BINARY SEARCH.
        &lt;MARK&gt; = NICHT_MARKIERT.
        MODIFY TOTAL INDEX SY-TABIX.
      ENDIF.
    ENDIF.
  ENDIF.                               &quot;.. Texttransl
ENDFORM.                               &quot;process_entry_reset</include_source>
   </include>
   <include NAME="LSVIMF1F" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000004" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122430" IDATE="20080721" ITIME="122430">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  RESET_ENTRIES                                           *
*&amp;--------------------------------------------------------------------*
* restore the last saved version for the marked entries of EXTRACT    *
*---------------------------------------------------------------------*
* --&gt; RE_MODE requested mode: L - all marked entries, D - single entry*
*---------------------------------------------------------------------*
FORM RESET_ENTRIES USING VALUE(RE_MODE).
  DATA: TEXTTAB_MOD(1) TYPE C.         &quot;SW Texttransl

  VIM_SPECIAL_MODE = VIM_RESET.
  CASE RE_MODE.
    WHEN LIST_BILD.
      MOVE: 0 TO REFCNT, 0 TO NEWCNT, 0 TO ORGCNT.
      LOOP AT EXTRACT.
        CLEAR TEXTTAB_MOD.
        CHECK &lt;XMARK&gt; EQ MARKIERT.
        MOVE SY-TABIX TO INDEX.
        ADD 1 TO NEWCNT.
        CHECK &lt;XACT&gt; NE NEUER_EINTRAG.
        ADD 1 TO ORGCNT.
        IF X_HEADER-TEXTTBEXST &lt;&gt; SPACE.             &quot;SW Texttransl ..
          PERFORM VIM_TEXTTAB_MODIF_FOR_KEY CHANGING TEXTTAB_MOD.
        ENDIF.
        IF X_HEADER-BASTAB NE SPACE AND X_HEADER-TEXTTBEXST NE SPACE.
          CHECK &lt;XACT&gt; NE ORIGINAL OR &lt;XACT_TEXT&gt; NE ORIGINAL
                                   OR TEXTTAB_MOD = &apos;X&apos;.
        ELSE.
          CHECK &lt;XACT&gt; NE ORIGINAL OR TEXTTAB_MOD = &apos;X&apos;.
        ENDIF.
        PERFORM PROCESS_ENTRY_RESET USING INDEX.
      ENDLOOP.
      NEWCNT = NEWCNT - ORGCNT.
      ORGCNT = ORGCNT - REFCNT.
      IF ORGCNT EQ 0 AND NEWCNT EQ 0.
        MESSAGE S016(SV) WITH REFCNT.
      ELSE.
        IF ORGCNT NE 0 AND NEWCNT NE 0.
          MESSAGE S040(SV) WITH REFCNT ORGCNT NEWCNT.
        ELSE.
          IF ORGCNT NE 0.
            MESSAGE S041(SV) WITH REFCNT ORGCNT.
          ELSE.
            MESSAGE S042(SV) WITH REFCNT NEWCNT.
          ENDIF.
        ENDIF.
      ENDIF.
      PERFORM PROCESS_AFTER_ENTRY_RESET.
    WHEN DETAIL_BILD.
      READ TABLE EXTRACT INDEX NEXTLINE. &quot;Extract-WA i.VCL-Kontext n. ok
      PERFORM PROCESS_ENTRY_RESET USING NEXTLINE.
      MESSAGE S017(SV).
      PERFORM PROCESS_AFTER_ENTRY_RESET.
      CLEAR VIM_OLD_VIEWKEY.
      TRANSLATE VIM_NO_MAINKEY_EXISTS USING VIM_NO_MKEY_NOT_PROCSD_PATT.
  ENDCASE.
  CLEAR VIM_SPECIAL_MODE.
ENDFORM.                               &quot;reset_entries</include_source>
   </include>
   <include NAME="LSVIMF1G" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000008" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122430" IDATE="20080721" ITIME="122430">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form CHECK_ALLOWED_KEYRANGES                                  *
*&amp;--------------------------------------------------------------------*
* check new entries fitting allowed keyranges                         *
*---------------------------------------------------------------------*
*                                                                     *
*&amp;--------------------------------------------------------------------*
FORM check_allowed_keyranges.
  DATA: roottab_key LIKE e071k-tabkey,
        tablename LIKE vimdesc-viewname,
        allowed,
        mess_type(1) TYPE c VALUE &apos;W&apos;,
        ale_msgty(1) TYPE c VALUE &apos;E&apos;, ale_msgno LIKE sy-msgno,
        ale_msgid LIKE sy-msgid, ale_msgv1 LIKE sy-msgv1,
        ale_msgv2 LIKE sy-msgv2, ale_msgv3 LIKE sy-msgv3,
        ale_msgv4 LIKE sy-msgv4,
        roottab_row TYPE REF TO data,
        keytab_loc TYPE TABLE OF tbl8096,
        keytab_wa LIKE LINE OF keytab_loc,
        keytab_wa2 LIKE LINE OF keytab_loc,
        allowed_keys TYPE TABLE OF tbl8096,
        sctm_fill_cache, viewtype,
        p_roottab_keylen TYPE i.                            &quot;XB H651706


  FIELD-SYMBOLS: &lt;key_x&gt; TYPE x, &lt;h_old_mkey2&gt; TYPE x,
                 &lt;roottab_row_x&gt; TYPE x,
                 &lt;f_field1&gt; TYPE ANY,
                 &lt;f_field2&gt; TYPE ANY,
                 &lt;roottab_row&gt; TYPE ANY.

  CHECK vim_keyrange_alr_checked EQ space.
* check synchronizer keyspecific stuff
  IF vim_sync_keyspec_check NE space.
    sctm_fill_cache = &apos;X&apos;.
    IF x_header-bastab EQ space.
      viewtype = &apos;V&apos;.
    ELSE.
      viewtype = &apos;S&apos;.
    ENDIF.
    REFRESH keytab_loc.
    REFRESH allowed_keys.
    keytab_wa-line =  &lt;f1_x&gt;.
    APPEND keytab_wa TO keytab_loc.             &quot;Table with 1 line only
    CALL FUNCTION &apos;SCTM_CHECK_VIEW_KEY&apos;
      EXPORTING
        viewname              = x_header-viewname
        viewtype              = viewtype
        bcset                 = vim_bcset_id  &quot;if NE space: BC-set act
        fill_cache            = sctm_fill_cache
*     IMPORTING               &quot;HCG: Already set in justify_action_mode
*       EDIT_FLAG           = vim_sync_edit_lock
*       KESPEC_FLAG         = vim_sync_keyspec_check
      TABLES
        query_tab             = keytab_loc
        allowed_tab           = allowed_keys
      EXCEPTIONS
        no_sync_present       = 1
        old_sync_system       = 2
        OTHERS                = 3.
    IF sy-subrc &lt;&gt; 0.     &quot;Ignore check_result but no message to user
*       MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*                WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
      allowed = &apos;X&apos;.
      CLEAR vim_sync_key_lock_del.     &quot;If no connection: open all
    ELSE.
      CLEAR keytab_wa2-line.
      READ TABLE allowed_keys INTO keytab_wa2 INDEX 1.
      IF keytab_wa-line(x_header-keylen) NE
         keytab_wa2-line(x_header-keylen).  &quot;Key is not changeable
        allowed = &apos;A&apos;. ale_msgno = &apos;182&apos;. ale_msgid = &apos;SV&apos;.
        MOVE vim_sctm_sourcesys TO ale_msgv1.
        vim_sync_key_lock_del = &apos;X&apos;.
      ELSE.
        allowed = &apos;X&apos;.
        CLEAR vim_sync_key_lock_del.
      ENDIF.
    ENDIF.
  ENDIF.
* check ALE keyspecific stuff
  IF vim_ale_keyspec_check NE space AND allowed NE &apos;A&apos;. &quot;HCG HW 718225
    ASSIGN roottab_key TO &lt;key_x&gt; CASTING.
    &lt;key_x&gt; = &lt;f1_x&gt;. allowed = &apos;X&apos;.
    LOOP AT vim_ale_keyspec_objtab.
      CALL FUNCTION &apos;ALE_EDIT_KEY_CHECK&apos;
        EXPORTING
          objecttype          = vim_ale_keyspec_objtab-otype
          objectname          = vim_ale_keyspec_objtab-oname
          objectkey           = roottab_key
        EXCEPTIONS
          key_no_maintainance = 1.
      IF sy-subrc NE 0.
        allowed = &apos;A&apos;. ale_msgno = sy-msgno. ale_msgid = sy-msgid.
        ale_msgv1 = sy-msgv1. ale_msgv2 = sy-msgv2.
        ale_msgv3 = sy-msgv3. ale_msgv4 = sy-msgv4.
        EXIT.
      ENDIF.
    ENDLOOP.
  ENDIF.
  IF allowed &lt;&gt; &apos;A&apos;.                               &quot;329818/2001
    vim_keyrange_alr_checked = &apos;X&apos;.                &quot;329818/2001
  ENDIF.
* check namespace
  IF ( vim_ale_keyspec_check EQ space AND
       vim_sync_keyspec_check EQ space ) OR
     ( x_header-customauth CO sap_cust_ctrl_classes AND
       allowed CO &apos; X&apos; ).
    IF vim_import_profile EQ space. &quot;Skip namespace check in BC-Set Akt
      IF x_header-bastab EQ space.       &quot;view
        MOVE x_header-roottab TO tablename.
      ELSE.                              &quot;base table
        MOVE x_header-viewname TO tablename.
      ENDIF.
      ASSIGN roottab_key TO &lt;key_x&gt; CASTING.
* XB H617717B
* rerange the roottab content from view (&lt;table1&gt;).
      IF x_header-bastab EQ space.       &quot;view
        CREATE DATA roottab_row TYPE (x_header-roottab).
        ASSIGN roottab_row-&gt;* TO &lt;roottab_row&gt;.
        ASSIGN &lt;roottab_row&gt; TO &lt;roottab_row_x&gt; CASTING.
        LOOP AT x_namtab.
          CHECK x_namtab-primtabkey &lt;&gt; 0.
          ASSIGN COMPONENT x_namtab-viewfield
              OF STRUCTURE &lt;table1&gt; TO &lt;f_field1&gt;.
          ASSIGN COMPONENT x_namtab-primtabkey
              OF STRUCTURE &lt;roottab_row&gt; TO &lt;f_field2&gt;.
          &lt;f_field2&gt; = &lt;f_field1&gt;.
        ENDLOOP.
*XB H651706B
        PERFORM vim_get_trspkeylen
                 USING x_header-roottab
                 CHANGING p_roottab_keylen.
        IF x_header-generictrp &lt;&gt; space.
          MOVE &lt;roottab_row_x&gt;(x_header-maxtrkeyln) TO &lt;key_x&gt;.
        ELSE.
          MOVE &lt;roottab_row_x&gt;(p_roottab_keylen) TO &lt;key_x&gt;.
*XB H651706E
        ENDIF.
      ELSE.                     &quot;base table no change the sequence
        IF x_header-generictrp &lt;&gt; space.
          MOVE &lt;f1_x&gt;(x_header-maxtrkeyln) TO &lt;key_x&gt;.
        ELSE.
          MOVE &lt;f1_x&gt;(x_header-keylen) TO &lt;key_x&gt;.
        ENDIF.
      ENDIF.
* XB H617717E
*    IF x_header-generictrp &lt;&gt; space.
*      MOVE &lt;f1_x&gt;(x_header-maxtrkeyln) TO &lt;key_x&gt;.
*    ELSE.
*      MOVE &lt;f1_x&gt;(x_header-keylen) TO &lt;key_x&gt;.
*    ENDIF.
      CALL FUNCTION &apos;CHECK_CUSTOMER_NAMES&apos;
        EXPORTING
          tablename   = tablename
          tablekey    = roottab_key
        IMPORTING
          key_allowed = allowed.
    ENDIF.                   &quot;No BC-Set activation       &quot;HCG HW 718225
  ENDIF.

  IF allowed CO &apos; A&apos;.
    EXPORT vimviewname FROM x_header-viewname TO MEMORY ID sy-uname.
    IF x_header-delmdtflag NE space AND status-mode EQ detail_bild.
      mess_type = &apos;S&apos;.
    ELSEIF allowed EQ &apos;A&apos;.
      mess_type = ale_msgty.
      PERFORM set_pf_status USING &apos;ERROR&apos;.
    ENDIF.
    IF neuer EQ &apos;J&apos;.                   &quot;add mode
      IF x_header-delmdtflag &lt;&gt; space.
        ASSIGN &lt;vim_h_old_mkey&gt;(x_header-keylen) TO &lt;h_old_mkey2&gt;.
        IF &lt;h_old_mkey2&gt; = &lt;f1_x&gt;.
*      IF x_header-delmdtflag NE space AND &lt;f1&gt; EQ vim_old_viewkey.
          CHECK check_all_keyr_scnd_time EQ space. &quot;simul. of warning
        ENDIF.
      ENDIF.
*     MESSAGE E019(SV). &quot;Bitte den Schlüssel aus dem zulässigen Namensra
      CLEAR: vim_keyrange_alr_checked, vim_key_alr_checked.
      IF allowed NE &apos;A&apos;.
        MESSAGE ID &apos;SV&apos; TYPE mess_type NUMBER &apos;019&apos;.
      ELSE.
        MESSAGE ID ale_msgid TYPE mess_type NUMBER ale_msgno WITH
          ale_msgv1 ale_msgv2 ale_msgv3 ale_msgv4.
      ENDIF.
      IF x_header-delmdtflag NE space.
        IF status-mode EQ detail_bild.
          &lt;h_old_mkey2&gt; = &lt;f1_x&gt;.
*          vim_old_viewkey = &lt;f1&gt;.
          check_all_keyr_scnd_time = allowed.    &quot;simulation of warning
          TRANSLATE check_all_keyr_scnd_time USING &apos; XA &apos;.
          TRANSLATE neuer USING &apos;JX&apos;.
          CLEAR: function, ok_code. LEAVE SCREEN.
        ENDIF.
        &lt;h_old_mkey2&gt; = &lt;f1_x&gt;.
*        vim_old_viewkey = &lt;f1_x&gt;.
        check_all_keyr_scnd_time = &apos;X&apos;.&quot;simulation of warning
      ENDIF.
    ELSE.                              &quot;update mode.
      IF allowed NE &apos;A&apos;.
        IF vim_special_mode EQ vim_delete.
          mess_type = &apos;S&apos;.
        ELSE.
          mess_type = &apos;W&apos;.
        ENDIF.
        IF vim_system_type NE &apos;SAP&apos;.
          MESSAGE ID &apos;SV&apos; TYPE mess_type NUMBER &apos;117&apos;.
        ELSE.
*       MESSAGE W136(SV). &quot;Vorsicht bei Änderungen, Eintrag gehört dem K
          MESSAGE ID &apos;SV&apos; TYPE mess_type NUMBER &apos;136&apos;.
        ENDIF.
      ELSE.
        IF vim_special_mode EQ vim_delete.
          mess_type = &apos;S&apos;.
        ELSE.
          mess_type = ale_msgty.
        ENDIF.
        MESSAGE ID ale_msgid TYPE mess_type NUMBER ale_msgno WITH
          ale_msgv1 ale_msgv2 ale_msgv3 ale_msgv4.
      ENDIF.
    ENDIF.
    sy-subrc = 8.
  ELSE.
    CLEAR sy-subrc.
  ENDIF.
ENDFORM.                    &quot;check_allowed_keyranges</include_source>
   </include>
   <include NAME="LSVIMF1H" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000004" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122430" IDATE="20080721" ITIME="122430">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form BUILD_VALTAB_HFIELDS                                     *
*&amp;--------------------------------------------------------------------*
* build value tab ignoring hidden fields using structure table        *
*&amp;--------------------------------------------------------------------*
FORM build_valtab_hfields.

  DATA: fieldname TYPE fnam_____4.
  FIELD-SYMBOLS: &lt;value&gt; TYPE ANY, &lt;valfld&gt; TYPE ANY,
                 &lt;value_tab&gt; TYPE x.
  CLEAR value_tab.
  ASSIGN value_tab TO &lt;value_tab&gt; CASTING.
  LOOP AT structure_table.
    IF x_header-bastab NE space AND x_header-texttbexst NE space AND
       structure_table-tabname EQ x_header-texttab.
* texttabfield
      ASSIGN COMPONENT structure_table-fieldname
       OF STRUCTURE &lt;vim_ext_txt_struc&gt; TO &lt;value&gt;.
*     READ TABLE x_namtab WITH KEY viewfield = structure_table-fieldname
*                                        texttabfld = &apos;X&apos;.
    ELSE.
* viewfield
      LOOP AT x_namtab WHERE viewfield = structure_table-fieldname AND
                        ( texttabfld = space OR keyflag = space ).
        ASSIGN COMPONENT structure_table-fieldname
         OF STRUCTURE &lt;vim_extract_struc&gt; TO &lt;value&gt;.
        EXIT.
      ENDLOOP.
    ENDIF.
    CHECK &lt;value&gt; IS ASSIGNED.
    CONCATENATE structure_table-tabname structure_table-fieldname
     INTO fieldname SEPARATED BY &apos;-&apos;.
    ASSIGN &lt;value_tab&gt;+structure_table-offset(structure_table-intlen)
     TO &lt;valfld&gt; CASTING TYPE (fieldname).
    MOVE &lt;value&gt; TO &lt;valfld&gt;.
*    CHECK sy-subrc EQ 0.
*    MOVE extract+x_namtab-position(x_namtab-flength)
*     TO value_tab+structure_table-offset(structure_table-intlen).
  ENDLOOP.
  APPEND value_tab.
ENDFORM.                               &quot;build_valtab_hfields</include_source>
   </include>
   <include NAME="LSVIMF1J" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000006" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122430" IDATE="20080721" ITIME="122430">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  MARK_IGNORED_ENTRIES                                    *
*&amp;--------------------------------------------------------------------*
* Wiederherstellen der Markierungen für &apos;übergangene&apos; Einträge        *
*---------------------------------------------------------------------*
FORM MARK_IGNORED_ENTRIES CHANGING MIE_NUMBER.
  DATA: TRANSLATION_MASK(2) TYPE C, H_IX LIKE SY-TABIX.

  CHECK IGNORED_ENTRIES_EXIST NE SPACE.
  MOVE: UEBERGEHEN TO TRANSLATION_MASK,
        MARKIERT   TO TRANSLATION_MASK+1(1).
  IF STATUS-MODE EQ LIST_BILD.
    CLEAR MIE_NUMBER.
    LOOP AT TOTAL.
      CHECK &lt;MARK&gt; EQ UEBERGEHEN.
      ADD 1 TO MIE_NUMBER.
      READ TABLE EXTRACT WITH KEY &lt;vim_xTOTAL_key&gt; BINARY SEARCH.
      IF SY-SUBRC EQ 0.
        TRANSLATE &lt;XMARK&gt; USING TRANSLATION_MASK.
        MODIFY EXTRACT INDEX SY-TABIX.
      ENDIF.
      TRANSLATE &lt;MARK&gt; USING TRANSLATION_MASK.
      MODIFY TOTAL.
    ENDLOOP.
  ELSE.
    MOVE DETA_MARK_SAFE TO TRANSLATION_MASK+1(1).
    READ TABLE EXTRACT INDEX NEXTLINE.
    CHECK sy-subrc = 0.                          &quot;UF HW 490645
    MOVE SY-TABIX TO H_IX.
    READ TABLE TOTAL WITH KEY &lt;VIM_xEXTRACT_KEY&gt; BINARY SEARCH.
    TRANSLATE &lt;MARK&gt; USING TRANSLATION_MASK.
    MODIFY TOTAL INDEX SY-TABIX.
    TRANSLATE &lt;XMARK&gt; USING TRANSLATION_MASK.
    MODIFY EXTRACT INDEX H_IX.
    MIE_NUMBER = 1.
  ENDIF.
  IF mie_number &gt; 0.
    CLEAR IGNORED_ENTRIES_EXIST.
  ENDIF.
ENDFORM.                               &quot; MARK_IGNORED_ENTRIES</include_source>
   </include>
   <include NAME="LSVIMF1K" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000005" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122430" IDATE="20080721" ITIME="122430">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form DELETE_CHECK_KEYRANGE                                    *
*&amp;--------------------------------------------------------------------*
* check keyrange for delete                                           *
*---------------------------------------------------------------------*
FORM delete_check_keyrange.
  LOCAL: extract, total, &lt;table1&gt;.
  DATA: dck_specmode_safe LIKE vim_special_mode.

  CLEAR sy-subrc.
  CHECK x_header-customauth CO sap_cust_ctrl_classes OR
        vim_ale_keyspec_check NE space OR
        vim_sync_keyspec_check NE space.
  dck_specmode_safe = vim_special_mode.
  PERFORM move_extract_to_view_wa.
  IF status-mode EQ list_bild.
    vim_special_mode = vim_delete.
  ELSE.
    CLEAR vim_special_mode.
  ENDIF.
  CLEAR vim_keyrange_alr_checked.
  PERFORM check_allowed_keyranges.
  IF sy-subrc NE 0. &quot;vim_import_profile check in check_allowed_keyranges
    IF status-mode EQ list_bild.
      CASE status-type.
        WHEN einstufig.
          CALL SCREEN liste.
          IF ok_code EQ &apos;IGN &apos;. function = ok_code. ENDIF.
        WHEN zweistufig.
          PERFORM process_detail_screen USING &apos;C&apos;.
          status-mode = list_bild.
      ENDCASE.
    ENDIF.
    IF vim_ale_keyspec_check NE space OR  &quot;never delete ALE-locked or
       vim_sync_key_lock_del NE space.    &quot;SYNC-locked keys HW 718225
      function = &apos;IGN &apos;.
    ENDIF.
    CLEAR: sy-subrc, ok_code.
    CASE function.
      WHEN &apos;IGN &apos;. sy-subrc = 4.
      WHEN &apos;ABR &apos;. sy-subrc = 8.
    ENDCASE.
  ENDIF.
* CLEAR VIM_SPECIAL_MODE.
  vim_special_mode = dck_specmode_safe.
  function = &apos;DELE&apos;.
ENDFORM.                               &quot;delete_check_keyrange</include_source>
   </include>
   <include NAME="LSVIMF1L" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000004" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122430" IDATE="20080721" ITIME="122430">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      FORM LOESCHEN                                                 *
*&amp;--------------------------------------------------------------------*
* Behandeln der Funktion &apos;DELE&apos;                                       *
*---------------------------------------------------------------------*
FORM LOESCHEN.
  DATA: NUMBER_OF_IGN_ENTR TYPE I, KEY_SAFE type VIM_tabKEY,
        L_IGN_ENTR_EX(1) TYPE C.
  IF STATUS-ACTION NE AENDERN AND STATUS-ACTION NE HINZUFUEGEN.
    MESSAGE I001(SV).
    EXIT.
  ENDIF.
  IF STATUS-MODE EQ DETAIL_BILD.
*   IF STATUS-ACTION EQ HINZUFUEGEN AND &lt;XACT&gt; NE NEUER_EINTRAG.
    IF STATUS-ACTION EQ HINZUFUEGEN AND NEUER EQ &apos;J&apos;.
      MOVE &lt;INITIAL&gt; TO &lt;TABLE1&gt;.
      IF X_HEADER-BASTAB NE SPACE AND X_HEADER-TEXTTBEXST NE SPACE.
        MOVE &lt;TEXT_INITIAL&gt; TO &lt;TABLE1_TEXT&gt;.
      ENDIF.
      MESSAGE S013(SV).
      CLEAR &lt;STATUS&gt;-UPD_FLAG.
      EXIT.
    ENDIF.
    MOVE &lt;XMARK&gt; TO DETA_MARK_SAFE.
    IF X_HEADER-DELMDTFLAG NE SPACE.
      PERFORM CHECK_IF_ENTRY_IS_TO_DISPLAY USING &apos;L&apos; &lt;VIM_xEXTRACT_KEY&gt;
                                                 SPACE &lt;VIM_BEGDATE&gt;.
      NUMBER_OF_IGN_ENTR = SY-SUBRC.
      KEY_SAFE = &lt;VIM_xEXTRACT_KEY&gt;.
    ENDIF.
    IF X_HEADER-DELMDTFLAG EQ SPACE OR NUMBER_OF_IGN_ENTR LT 8.
      READ TABLE EXTRACT INDEX NEXTLINE.
    ELSE.
      MOVE KEY_SAFE TO &lt;VIM_xEXTRACT_KEY&gt;.
      READ TABLE TOTAL WITH KEY &lt;VIM_xEXTRACT_KEY&gt; BINARY SEARCH.
      EXTRACT = TOTAL.
    ENDIF.
  ENDIF.
  IF X_HEADER-FRM_BF_DEL NE SPACE.
    PERFORM (X_HEADER-FRM_BF_DEL) IN PROGRAM (SY-REPID).
  ENDIF.
  IF VIM_CALLED_BY_CLUSTER NE SPACE.
    PERFORM VIM_STORE_STATE_INFO.
    CALL FUNCTION &apos;VIEWCLUSTER_DELETE_DEPENDENT&apos;
         EXPORTING
              VIEW_NAME         = X_HEADER-VIEWNAME
              STATUS_MODE       = STATUS-MODE
              WORKAREA          = EXTRACT
              NO_DIALOG         = VIM_EXTERNAL_MODE
         IMPORTING
              IGN_ENTRIES_EXIST = L_IGN_ENTR_EX.
    IF L_IGN_ENTR_EX NE SPACE.
      IGNORED_ENTRIES_EXIST = L_IGN_ENTR_EX.
    ENDIF.
  ENDIF.
  IF STATUS-MODE EQ LIST_BILD.
    PERFORM LISTE_LOESCHE.
  ELSE.
*   IF &lt;STATUS&gt;-DISPL_MODE EQ EXPANDED.
*     READ TABLE EXTRACT INDEX NEXTLINE.
*   ELSE.
*     READ TABLE TOTAL WITH KEY &lt;F1&gt; BINARY SEARCH.
*     EXTRACT = TOTAL.
*   ENDIF.
    IF &lt;XMARK&gt; NE UEBERGEHEN.
      PERFORM DELETE_CHECK_KEYRANGE.
      IF SY-SUBRC EQ 0.
        PERFORM DETAIL_LOESCHE.
      ELSE.
        COUNTER = 0.
      ENDIF.
    ELSE.
      COUNTER = 0.
    ENDIF.
  ENDIF.
  IF VIM_SPECIAL_MODE EQ VIM_UPGRADE AND COUNTER EQ 0.
    FUNCTION = OK_CODE = &apos;IGN &apos;.
  ENDIF.
  IF X_HEADER-FRM_AF_DEL NE SPACE.
    PERFORM (X_HEADER-FRM_AF_DEL) IN PROGRAM (SY-REPID).
  ELSE.
    IF IGNORED_ENTRIES_EXIST NE SPACE.
      PERFORM MARK_IGNORED_ENTRIES CHANGING NUMBER_OF_IGN_ENTR.
      CHECK VIM_SPECIAL_MODE NE VIM_UPGRADE.
      IF NUMBER_OF_IGN_ENTR EQ 1.
        MESSAGE S115(SV). &quot;Eintrag konnte nicht gelöscht werden
      ELSEIF NUMBER_OF_IGN_ENTR GT 1.
        MESSAGE S116(SV) WITH NUMBER_OF_IGN_ENTR.
      ENDIF.
    ENDIF.
  ENDIF.
ENDFORM.                               &quot; LOESCHEN</include_source>
   </include>
   <include NAME="LSVIMF1M" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000004" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122430" IDATE="20080721" ITIME="122430">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form ZURUECKHOLEN                                             *
*&amp;--------------------------------------------------------------------*
* Behandeln der Funktion &apos;UNDO&apos;                                       *
*---------------------------------------------------------------------*
FORM zurueckholen.

  DATA: number_of_ign_entr TYPE i, key_safe TYPE tabl1024,
        z_ign_entr_ex(1) TYPE c, z_specmode_safe(1) TYPE c.

  IF status-action NE aendern OR status-delete NE geloescht.
    MESSAGE i001(sv).
    EXIT.
  ENDIF.
  CLEAR counter. z_specmode_safe = vim_special_mode.
  vim_special_mode = vim_undelete.
  IF status-mode EQ detail_bild.
    MOVE &lt;xmark&gt; TO deta_mark_safe.
    IF x_header-delmdtflag NE space.
      PERFORM check_if_entry_is_to_display USING &apos;L&apos; &lt;vim_xextract_key&gt;
                                                 space &lt;vim_begdate&gt;.
      number_of_ign_entr = sy-subrc.
      key_safe = &lt;vim_xextract_key&gt;.
    ENDIF.
*   IF &lt;STATUS&gt;-DISPL_MODE EQ EXPANDED.
    IF x_header-delmdtflag EQ space OR number_of_ign_entr LT 8.
      READ TABLE extract INDEX nextline.
    ELSE.
      READ TABLE total WITH KEY key_safe BINARY SEARCH.
      extract = total.
    ENDIF.
  ENDIF.
  IF x_header-frm_bf_udl NE space.
    PERFORM (x_header-frm_bf_udl) IN PROGRAM (sy-repid).
  ENDIF.
  IF vim_called_by_cluster NE space.
    PERFORM vim_store_state_info.
    CALL FUNCTION &apos;VIEWCLUSTER_UNDO_DEPENDENT&apos;
         EXPORTING
              view_name         = x_header-viewname
              status_mode       = status-mode
              workarea          = extract
              no_dialog         = vim_external_mode
         IMPORTING
              ign_entries_exist = z_ign_entr_ex.
    IF z_ign_entr_ex NE space.
      ignored_entries_exist = z_ign_entr_ex.
    ENDIF.
  ENDIF.
  IF status-mode EQ list_bild.
    PERFORM liste_zurueckholen.
  ELSE.
    IF &lt;xmark&gt; NE uebergehen.
      PERFORM detail_zurueckholen.
    ENDIF.
  ENDIF.
  IF replace_mode NE space AND counter EQ 0.
    function = ok_code = &apos;IGN &apos;.
  ENDIF.
  IF x_header-frm_af_udl NE space.
    PERFORM (x_header-frm_af_udl) IN PROGRAM (sy-repid).
  ELSE.
    IF ignored_entries_exist NE space.
      PERFORM mark_ignored_entries CHANGING number_of_ign_entr.
      IF replace_mode EQ space.
        IF number_of_ign_entr EQ 1.
          MESSAGE s113(sv). &quot;Eintrag konnte nicht zurückgeholt werden
        ELSEIF number_of_ign_entr GT 1.
          MESSAGE s114(sv) WITH number_of_ign_entr.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.
* CLEAR VIM_SPECIAL_MODE.
  vim_special_mode = z_specmode_safe.
ENDFORM.                               &quot; ZURUECKHOLEN</include_source>
   </include>
   <include NAME="LSVIMF1N" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000006" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122430" IDATE="20080721" ITIME="122431">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  EDIT_VIEW_ENTRY                                         *
*&amp;--------------------------------------------------------------------*
*       edit entry in TOTAL/EXTRACT due to foreign request            *
*---------------------------------------------------------------------*
* ENTRY  ---&gt; entry to edit                                           *
* ACTION ---&gt; action: UPD - add/update, DEL - delete, UDL - undelete  *
*             IGN - mark entry as to ignore, MRK - mark/unmark entry  *
* SY_SUBRC -&gt; return code: 0 - all right, others: failure             *
* EXT    ---&gt; table containing selected view entries                  *
* TOT    ---&gt; table containing all view entries                       *
* HEADER ---&gt; table containing header information of current view     *
* NAMTAB ---&gt; table containing information about current viewfields   *
* SELLIST --&gt; table containing select options                         *
*---------------------------------------------------------------------*
FORM edit_view_entry TABLES ext tot
                            header  STRUCTURE vimdesc
                            namtab  STRUCTURE vimnamtab
                            sellist STRUCTURE vimsellist
                     USING value(entry) value(action).
  DATA: state_vect_name(37) TYPE c,
        rc LIKE sy-subrc, pos LIKE sy-fdpos,
        texttablename(31) TYPE c VALUE &apos;*          &apos;, mmark(1) TYPE c,
        tab_rc LIKE sy-subrc, tab_ix LIKE sy-tabix,
        dummy_tab LIKE vimexclfun OCCURS 1, name(20) TYPE c.
  FIELD-SYMBOLS: &lt;tot_x&gt; TYPE x, &lt;ext_x&gt; TYPE x, &lt;ent_x&gt; TYPE x,
                 &lt;viewkey&gt; TYPE x, &lt;act&gt; TYPE c, &lt;xact&gt; TYPE c,
                 &lt;mrk&gt; TYPE c, &lt;xmrk&gt; TYPE c,
                 &lt;txt_act&gt; TYPE c,
                 &lt;tot_struc&gt; TYPE ANY, &lt;ent_struc&gt; TYPE ANY,
                 &lt;tot_txt&gt; TYPE x, &lt;ent_txt&gt; TYPE x, &lt;ent_txt2&gt; TYPE x,
                 &lt;tot_txt_struc&gt; TYPE ANY, &lt;txt_init&gt; TYPE ANY.

  READ TABLE header INDEX 1.
  pos = header-after_tabc.
*  MOVE HEADER-TABLEN TO POS.
  ASSIGN: tot TO &lt;tot_x&gt; CASTING, ext TO &lt;ext_x&gt; CASTING,
          entry TO &lt;ent_x&gt; CASTING,
          &lt;tot_x&gt; TO &lt;tot_struc&gt; CASTING TYPE (header-maintview),
          &lt;ent_x&gt; TO &lt;ent_struc&gt; CASTING TYPE (header-maintview).
  IF header-bastab NE space AND header-texttbexst NE space.
* tab+txttb
    ADD header-aft_txttbc TO pos.
    MOVE header-texttab TO texttablename+1.
    ASSIGN: &lt;tot_x&gt;+header-after_tabc(header-texttablen) TO &lt;tot_txt&gt;,
            &lt;ent_x&gt;+header-after_tabc(header-texttablen) TO &lt;ent_txt&gt;,
            &lt;tot_txt&gt; TO &lt;tot_txt_struc&gt; CASTING TYPE (header-texttab),
            (texttablename) TO &lt;txt_init&gt;.
*    ASSIGN: TOT+HEADER-TABLEN(HEADER-TEXTTABLEN) TO &lt;TOT_TXT&gt;,
*            ENTRY+HEADER-TABLEN(HEADER-TEXTTABLEN) TO &lt;ENT_TXT&gt;,
*            (TEXTTABLENAME) TO &lt;TXT_INIT&gt;.
  ENDIF.
  ASSIGN: &lt;ent_x&gt;(header-keylen) TO &lt;viewkey&gt;,
          &lt;tot_x&gt;+pos(cl_abap_char_utilities=&gt;charsize)
           TO &lt;act&gt; CASTING,
          &lt;ext_x&gt;+pos(cl_abap_char_utilities=&gt;charsize)
           TO &lt;xact&gt; CASTING.
  ADD cl_abap_char_utilities=&gt;charsize TO pos.
  ASSIGN: &lt;tot_x&gt;+pos(cl_abap_char_utilities=&gt;charsize)
           TO &lt;mrk&gt; CASTING,
          &lt;ext_x&gt;+pos(cl_abap_char_utilities=&gt;charsize)
           TO &lt;xmrk&gt; CASTING.
  IF header-bastab NE space AND header-texttbexst NE space.&quot;tab+txttb
    ADD cl_abap_char_utilities=&gt;charsize TO pos.
    ASSIGN &lt;tot_x&gt;+pos(cl_abap_char_utilities=&gt;charsize)
     TO &lt;txt_act&gt; CASTING.
  ENDIF.
*  ASSIGN: ENTRY(HEADER-KEYLEN) TO &lt;VIEWKEY&gt;,
*          TOT+POS(1) TO &lt;ACT&gt;.
*  ADD 1 TO POS.
*  ASSIGN TOT+POS(1) TO &lt;MRK&gt;.
*  IF HEADER-BASTAB NE SPACE AND HEADER-TEXTTBEXST NE SPACE.&quot;tab+txttb
*    ADD 1 TO POS.
*    ASSIGN TOT+POS(1) TO &lt;TXT_ACT&gt;.
*    SUBTRACT 1 FROM POS.
*  ENDIF.
  IF header-viewname NE last_ext_modif_view.
    MOVE state_vect_prefix TO state_vect_name.
    WRITE header-maintview TO state_vect_name+state_vect_prefix_length.
    ASSIGN (state_vect_name) TO &lt;state&gt;.
    MOVE header-viewname TO last_ext_modif_view.
  ENDIF.
  READ TABLE tot WITH KEY &lt;viewkey&gt; BINARY SEARCH.
  tab_rc = sy-subrc. tab_ix = sy-tabix.
  IF sy-subrc EQ 0.                    &quot; entry found in TOT
    CASE action.
      WHEN &apos;DEL&apos;.
        CASE &lt;act&gt;.
          WHEN neuer_eintrag.
            &lt;act&gt; = neuer_geloescht.
          WHEN original.
            &lt;act&gt; = geloescht.
          WHEN aendern.
            &lt;act&gt; = update_geloescht.
        ENDCASE.
        IF header-bastab NE space AND header-texttbexst NE space.
          CASE &lt;txt_act&gt;.
            WHEN neuer_eintrag.
              &lt;txt_act&gt;            = neuer_geloescht.
            WHEN original.
              IF &lt;tot_txt_struc&gt; NE &lt;txt_init&gt;.
                &lt;txt_act&gt;             = geloescht.
              ENDIF.
            WHEN aendern.
              &lt;txt_act&gt;             = update_geloescht.
          ENDCASE.
        ENDIF.
        mmark = &lt;mrk&gt;.
        IF &lt;mrk&gt; EQ markiert.
          &lt;mrk&gt; = nicht_markiert. SUBTRACT 1 FROM &lt;state&gt;-mk_to.
        ENDIF.
        MODIFY tot INDEX sy-tabix.
        READ TABLE ext WITH KEY &lt;viewkey&gt;.
        IF sy-subrc EQ 0.
          IF mmark EQ markiert.
            SUBTRACT 1 FROM &lt;state&gt;-mk_xt.
          ENDIF.
          DELETE ext INDEX sy-tabix.
          SUBTRACT 1 FROM &lt;state&gt;-maxlines.
        ENDIF.
      WHEN &apos;UPD&apos;.
        IF header-bastab NE space AND header-texttbexst NE space.
          IF &lt;tot_txt&gt; NE &lt;ent_txt&gt;.
            IF &lt;tot_txt_struc&gt; EQ &lt;txt_init&gt;.
              &lt;txt_act&gt; = neuer_eintrag.
            ELSE.
              IF &lt;txt_act&gt; EQ original.
                &lt;txt_act&gt; = aendern.
              ENDIF.
            ENDIF.
            MOVE &lt;ent_txt&gt; TO &lt;tot_txt&gt;.
          ENDIF.
        ENDIF.
        MOVE &lt;ent_struc&gt; TO &lt;tot_struc&gt;.
        IF &lt;act&gt; EQ original.
          &lt;act&gt; = aendern.
        ENDIF.
        MODIFY tot INDEX sy-tabix.
        READ TABLE ext WITH KEY &lt;viewkey&gt;.
        IF sy-subrc EQ 0.
          MOVE tot TO ext.
          MODIFY ext INDEX sy-tabix.
        ENDIF.
      WHEN &apos;UDL&apos;.
        CASE &lt;act&gt;.
          WHEN neuer_geloescht.
            &lt;act&gt; = neuer_eintrag.
          WHEN geloescht.
            &lt;act&gt; = original.
          WHEN update_geloescht.
            &lt;act&gt; = aendern.
          WHEN OTHERS.
            rc = 8.
        ENDCASE.
        IF rc EQ 0.
          IF header-bastab NE space AND header-texttbexst NE space.
            CASE &lt;txt_act&gt;.
              WHEN neuer_geloescht.
                &lt;txt_act&gt;         = neuer_eintrag.
              WHEN geloescht.
                &lt;txt_act&gt;         = original.
              WHEN update_geloescht.
                &lt;txt_act&gt;         = aendern.
            ENDCASE.
          ENDIF.
          MODIFY tot INDEX sy-tabix.
          READ TABLE ext WITH KEY &lt;viewkey&gt;.
          IF sy-subrc EQ 0.
            IF &lt;state&gt;-selected EQ geloescht.
              DELETE ext INDEX sy-tabix.
            ELSE.
              &lt;xmrk&gt; = &lt;mrk&gt;.
              &lt;xact&gt; = &lt;act&gt;.
              MODIFY ext INDEX sy-tabix.
            ENDIF.
          ENDIF.
        ENDIF.
      WHEN &apos;IGN&apos;.
        IF &lt;mrk&gt; EQ markiert.
          MOVE uebergehen TO &lt;mrk&gt;.
          MODIFY tot INDEX sy-tabix.
          READ TABLE ext WITH KEY &lt;viewkey&gt;.
          IF sy-subrc EQ 0.
            &lt;xmrk&gt; = &lt;mrk&gt;.
            MODIFY ext INDEX sy-tabix.
          ENDIF.
        ENDIF.
        rc = 1.
      WHEN &apos;MRK&apos;.
        IF &lt;mrk&gt; EQ markiert.
          MOVE nicht_markiert TO &lt;mrk&gt;.
        ELSE.
          MOVE markiert TO &lt;mrk&gt;.
        ENDIF.
        MODIFY tot INDEX sy-tabix.
        IF &lt;mrk&gt; EQ markiert.
          ADD 1 TO &lt;state&gt;-mk_to.
        ELSE.
          SUBTRACT 1 FROM &lt;state&gt;-mk_to.
        ENDIF.
        READ TABLE ext WITH KEY &lt;viewkey&gt;.
        IF sy-subrc EQ 0.
          &lt;xmrk&gt; = &lt;mrk&gt;.
          MODIFY ext INDEX sy-tabix.
          IF &lt;mrk&gt; EQ markiert.
            ADD 1 TO &lt;state&gt;-mk_xt.
          ELSE.
            SUBTRACT 1 FROM &lt;state&gt;-mk_xt.
          ENDIF.
        ENDIF.
        rc = 1.
    ENDCASE.
  ELSE.                                &quot;entry NOT found in TOT
    CLEAR sy-subrc.
    IF action NE &apos;UPD&apos;.
      rc = 8.
    ELSE.
      IF header-selection NE space.
        IF header-bastab &lt;&gt; space AND header-texttbexst &lt;&gt; space.
          ASSIGN &lt;ent_txt&gt; TO &lt;ent_txt2&gt;.
        ELSE.
          ASSIGN &lt;ent_x&gt; TO &lt;ent_txt2&gt;.
        ENDIF.
        CALL FUNCTION &apos;TABLE_RANGE_CHECK&apos;
          EXPORTING
            tabname                   = header-maintview
            entry                     = entry
            entry_text                = &lt;ent_txt2&gt;
            ddic                      = &apos;J&apos;
            key                       = &apos;J&apos;
            ignore_blank_subsetfields = &apos;N&apos;
          TABLES
            x_namtab                  = namtab
            x_header                  = header
            sellist                   = sellist
          EXCEPTIONS
            entry_not_fits            = 8.
      ENDIF.
      IF sy-subrc EQ 0.
        MOVE &lt;ent_struc&gt; TO &lt;tot_struc&gt;.
        &lt;act&gt; = neuer_eintrag.
        &lt;mrk&gt; = nicht_markiert.
        IF header-bastab NE space AND header-texttbexst NE space.
          &lt;tot_txt&gt; = &lt;ent_txt&gt;.
          IF &lt;tot_txt_struc&gt; NE &lt;txt_init&gt;.
            &lt;txt_act&gt; = neuer_eintrag.
          ELSE.
            &lt;txt_act&gt; = original.
          ENDIF.
        ENDIF.
        CASE tab_rc.
          WHEN 4.
            INSERT tot INDEX tab_ix.
          WHEN 8.
            APPEND tot.
        ENDCASE.
      ELSE.
        rc = sy-subrc.
      ENDIF.
    ENDIF.
  ENDIF.
  IF rc EQ 0.
    MOVE &apos;X&apos; TO &lt;state&gt;-upd_flag.
  ENDIF.
  sy-subrc = ( rc DIV 8 ) * 8.
ENDFORM.                               &quot; EDIT_VIEW_ENTRY</include_source>
   </include>
   <include NAME="LSVIMF1O" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000004" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122431" IDATE="20080721" ITIME="122431">
    <include_source>*---------------------------------------------------------------------*
*       FORM VIM_FILL_WHERETAB                                        *
*---------------------------------------------------------------------*
* fill internal table for dynamic select                              *
*---------------------------------------------------------------------*
FORM VIM_FILL_WHERETAB.
  CALL FUNCTION &apos;VIEW_FILL_WHERETAB&apos;
       EXPORTING
            TABLENAME               = X_HEADER-ROOTTAB
       TABLES
            SELLIST                 = DBA_SELLIST
            WHERETAB                = VIM_WHERETAB
            X_NAMTAB                = X_NAMTAB
       EXCEPTIONS                          &quot;#EC *
            NO_CONDITIONS_FOR_TABLE = 01.
ENDFORM.                               &quot;vim_fill_wheretab.</include_source>
   </include>
   <include NAME="LSVIMF1P" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000012" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122431" IDATE="20080721" ITIME="122431">
    <include_source>*---------------------------------------------------------------------*
*       FORM PREPARE_READ_REQUEST                                     *
*---------------------------------------------------------------------*
*       prepare global data for read request                          *
*---------------------------------------------------------------------*
FORM prepare_read_request.

  DATA: action TYPE activ_auth, oc_to_be_checked TYPE xfeld,
        sellines TYPE i, viewtype.

  PERFORM init_state_vector.
  PERFORM vim_reset_texttab USING view_name.           &quot;SW Texttransl
  IF &lt;status&gt;-st_action NE anzeigen AND                 &quot;HCG HW680584
    vim_import_profile = space.     &quot;No actlinks needed in activation
* If table completely locked by cust distribution -&gt; no bc-locks needed
    IF x_header-bastab EQ space.
      viewtype = &apos;V&apos;.
    ELSE.
      viewtype = &apos;S&apos;.
    ENDIF.
    CALL FUNCTION &apos;SCTM_CHECK_VIEW_EDIT&apos;
             EXPORTING
               viewname        = view_name
               viewtype        = viewtype
               bcset           = vim_bcset_id &quot;if NE space -&gt; BC-set act.
             IMPORTING
               edit_flag       = vim_sync_edit_lock
               kespec_flag     = vim_sync_keyspec_check
               sourcesys       = vim_sctm_sourcesys
             EXCEPTIONS   &quot;#EC *
               no_sync_present
               old_sync_system
               rfc_failure.
    IF vim_sync_edit_lock NE space AND      &quot;Table locked completely
       vim_sync_keyspec_check EQ space.
    ELSE.
      PERFORM vim_bc_logs_get USING view_name x_header x_namtab[]
                            CHANGING vim_bc_entry_list.
      vim_actlinks = x_header-viewname. &quot;For which actlinks are valid
    ENDIF.
  ENDIF.
  IF vim_adjust_middle_level_mode EQ subset. &quot;ignore subsets
    vim_adj_header = x_header[].
    CLEAR x_header-subsetflag. MODIFY x_header INDEX 1.
    vim_adj_namtab = x_namtab[].
    LOOP AT x_namtab WHERE readonly EQ subset AND keyflag NE space.
      CLEAR x_namtab-readonly. MODIFY x_namtab.
    ENDLOOP.
    vim_adj_dbasellist = dba_sellist[].
    LOOP AT dba_sellist WHERE ddic CO vim_subset_marks.
      IF dba_sellist-value IS INITIAL AND dba_sellist-initial EQ space.
        DELETE dba_sellist. &quot;unvollständige Subsetbedingungen löschen
      ELSE.
        TRANSLATE dba_sellist-ddic USING &apos;S BX&apos;. &quot;&apos;S A BXMX&apos;.
        MODIFY dba_sellist.
      ENDIF.
    ENDLOOP.
    DESCRIBE TABLE dba_sellist.
    IF sy-tfill GT 0.
      READ TABLE dba_sellist INDEX sy-tfill.
      CLEAR dba_sellist-and_or.
      MODIFY dba_sellist INDEX sy-tabix.
    ENDIF.
  ENDIF.
* remove old selections from authorisation
*  if not vim_dba_sel_kept is initial and vim_called_by_cluster = space.
*    refresh dba_sellist[].                                 &quot;UF210200b
*    append lines of vim_dba_sel_kept to dba_sellist.
*  endif.
*  DELETE dba_sellist WHERE ddic = &apos;M&apos;.
  IF vim_called_by_cluster = space.
    DELETE dba_sellist WHERE from_auth &lt;&gt; space
     AND ddic &lt;&gt; &apos;S&apos; and ddic &lt;&gt; &apos;B&apos;.                       &quot;UF210200e
    DESCRIBE TABLE dba_sellist LINES sellines.
    IF sellines GT 0.
      READ TABLE dba_sellist INDEX sellines.
      CLEAR dba_sellist-and_or.
      MODIFY dba_sellist INDEX sy-tabix.
    ENDIF.
  ENDIF.                                                     &quot;UF210200
  IF NOT vim_oc_inst IS INITIAL.
* insert selection from authorisation into sellist
    IF &lt;status&gt;-st_action = anzeigen.
      action = svorg_read.
    ELSE.
      action = svorg_maint.
    ENDIF.
    CALL METHOD vim_oc_inst-&gt;combine_vimsel_with_auth
      EXPORTING
        action  = action
      CHANGING
        sellist = dba_sellist[].
    CALL METHOD vim_oc_inst-&gt;get_to_be_checked
      IMPORTING
        to_be_checked = oc_to_be_checked.
    IF oc_to_be_checked &lt;&gt; space or x_header-bastab &lt;&gt; space.
* check TOTAL vs. authorisation after reading
      PERFORM vim_maint_selflag USING    &apos;S&apos;
                                CHANGING x_header-selection.
    ENDIF.
  ENDIF.
ENDFORM.                    &quot;prepare_read_request</include_source>
   </include>
   <include NAME="LSVIMF1Q" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000003" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122431" IDATE="20080721" ITIME="122431">
    <include_source>*---------------------------------------------------------------------*
*       FORM GET_KEYTAB                                               *
*---------------------------------------------------------------------*
*       read table e071k                                              *
*---------------------------------------------------------------------*
FORM GET_KEYTAB.
  LOCAL: E071.
  LOOP AT VIM_CORR_OBJTAB INTO E071.
    CALL FUNCTION &apos;TRINT_READ_COMM_KEYS&apos;
         EXPORTING
              WI_APPENDING = &apos;X&apos;
              WI_E071      = E071
              WI_TRKORR    = &lt;STATUS&gt;-CORR_NBR
         TABLES
              WT_E071K     = CORR_KEYTAB.
  ENDLOOP.
  CLEAR: &lt;STATUS&gt;-KEYTBMODFD, GET_CORR_KEYTAB, &lt;STATUS&gt;-KEYTBINVLD.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF1R" SQLX="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000001" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122431" IDATE="20080721" ITIME="122431">
    <include_source>*---------------------------------------------------------------------*
*       FORM TRANSPORTIEREN                                           *
*---------------------------------------------------------------------*
*       send popup to confirm: saving etc.                            *
*---------------------------------------------------------------------*
FORM TRANSPORTIEREN.
  CALL FUNCTION &apos;POPUP_TO_CONFIRM_WITH_MESSAGE&apos;
       EXPORTING
            TITEL         = SVIM_TEXT_020  &quot;Einträge transportieren
            DIAGNOSETEXT1 = SVIM_TEXT_018  &quot;Daten wurden verändert.
            DIAGNOSETEXT2 =
               SVIM_TEXT_021           &quot;Wenn die Änderungen transport
            DIAGNOSETEXT3 =
               SVIM_TEXT_022           &quot;werden sollen, müssen sie ers
            TEXTLINE1     = SVIM_TEXT_023  &quot;gesichert werden.
            TEXTLINE2     = SVIM_TEXT_019  &quot;Änderungen vorher sichern ?
       IMPORTING
            ANSWER        = ANSWER.
  CASE ANSWER.
    WHEN &apos;J&apos;.
      SY-SUBRC = 0.
    WHEN &apos;N&apos;.
      CLEAR &lt;STATUS&gt;-UPD_FLAG.
      SY-SUBRC = 8.
    WHEN &apos;A&apos;.
      SY-SUBRC = 12.
  ENDCASE.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF1S" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000010" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122431" IDATE="20080721" ITIME="122431">
    <include_source>*---------------------------------------------------------------------*
*       FORM CORR_UPD.                                                *
*---------------------------------------------------------------------*
*       Behandlung des FCODES &apos;SAVE&apos; im Transportmodus                *
*       logging of changes                                            *
*---------------------------------------------------------------------*
FORM corr_upd.
  DATA: ko200 LIKE ko200,
        cu_e071k_tab LIKE e071k OCCURS 100,
        cu_e071_tab LIKE e071 OCCURS 10,
        cu_trpar LIKE trpar_int OCCURS 1,
        cu_trmess LIKE trmess_int OCCURS 1,
        cu_tadir LIKE tadir,
        cu_e071_htb LIKE e071 OCCURS 10,
        cu_dderr LIKE dderr,
        cu_corr_keytab_safe LIKE corr_keytab OCCURS 50,
        cu_corr_keyhtb LIKE corr_keytab OCCURS 50,
        lockable_objects_exist(1) TYPE c, e071_safe LIKE e071,
        cu_ko200_tab LIKE ko200 OCCURS 10,
        cu_last_corr LIKE e071-trkorr,
        w_cu_ko200 LIKE ko200,
        cu_ko200_sec LIKE ko200 OCCURS 10,
        corr_for_insert LIKE e071-trkorr, rc LIKE sy-subrc,
        cu_new_locks LIKE strlocktab OCCURS 10,
        cu_begix TYPE i,
        cu_hobjfunc(1) TYPE c, cu_tdevc LIKE tdevc,
        cu_order_type LIKE e070-trfunction, cu_obj_not_chkd(1) TYPE c,
        cu_task_type LIKE e070-trfunction, cu_appendable(1) TYPE c,
        cu_request TYPE trwbo_request, cu_category LIKE vim_syst,
        cu_corr_objtab LIKE LINE OF vim_corr_objtab OCCURS 0,
        cu_last_cat LIKE vim_syst, cu_h_flag(1) TYPE c,
        cu_h_e071 LIKE e071, cuiorder LIKE e071-trkorr,
        cuitask LIKE e071-trkorr.

  DATA: lt_edt_objects       TYPE tredt_objects,
        ls_edt_object        TYPE LINE OF tredt_objects.
  DATA: corr_keyhtb_wa LIKE LINE OF cu_corr_keyhtb.
  FIELD-SYMBOLS: &lt;ls_e071&gt;   TYPE e071.

  FIELD-SYMBOLS: &lt;vim_corr_objtab&gt; LIKE vim_corr_objtab,
                 &lt;e071&gt; LIKE e071.

  CHECK maint_mode EQ transportieren OR vim_client_state EQ vim_log.
  CHECK x_header-flag NE vim_transport_denied.
  CHECK vim_actopts-transp_off NE bc_transport_denied.
  cu_h_flag = x_header-flag.
  IF vim_corr_obj_viewname NE x_header-viewname.
    REFRESH vim_corr_objtab.
  ELSE.
    cu_corr_objtab = vim_corr_objtab[].
  ENDIF.
  e071_safe = e071.
  CLEAR e071.
  LOOP AT corr_keytab WHERE mastername EQ x_header-viewname
                        AND ( mastertype EQ vim_unlockable_object
                              OR mastertype EQ vim_lockable_object ).
    MOVE: corr_keytab-trkorr  TO e071-trkorr,    &quot;fill object tab
          corr_keytab-pgmid   TO e071-pgmid,
          corr_keytab-object  TO e071-object,
*         CORR_KEYTAB-OBJNAME TO E071-OBJ_NAME,
          corr_keytab-objfunc TO e071-objfunc,
          corr_keytab-activity TO e071-activity. &quot;UF738595/2001
    IF corr_keytab-objname EQ vim_long_objname.
      e071-obj_name = corr_keytab-tabkey.
    ELSE.
      e071-obj_name = corr_keytab-objname.
    ENDIF.
    APPEND e071 TO cu_e071_tab.
    READ TABLE vim_corr_objtab WITH KEY pgmid = e071-pgmid
                                        object = e071-object
                                        obj_name = e071-obj_name
                               TRANSPORTING NO FIELDS.
    IF sy-subrc NE 0.                  &quot;entry not found...
*      vim_corr_objtab = e071.
      MOVE-CORRESPONDING e071 TO vim_corr_objtab.     &quot;UNICODE
      IF corr_keytab-mastertype EQ vim_unlockable_object.
*       APPEND E071 TO VIM_ULO_TRSP_OBJS.
        vim_corr_objtab-lockable = space.
      ELSE.
*       APPEND E071 TO VIM_LCK_TRSP_OBJS.
        vim_corr_objtab-lockable = lockable_objects_exist = &apos;X&apos;.
      ENDIF.
      APPEND vim_corr_objtab.
      IF corr_keytab-flag EQ &apos;V&apos;.
        IF vim_corr_obj_viewname NE x_header-viewname.
          APPEND vim_corr_objtab TO cu_corr_objtab.
        ENDIF.
      ELSE.
        cu_obj_not_chkd = &apos;X&apos;.
      ENDIF.
    ELSEIF corr_keytab-mastertype EQ vim_lockable_object.
      lockable_objects_exist = &apos;X&apos;.
    ENDIF.
  ENDLOOP.
  LOOP AT cu_e071_tab INTO e071.
    LOOP AT corr_keytab WHERE mastertype EQ e071-object
                          AND mastername EQ e071-obj_name
                          AND pgmid EQ vim_deleted_key.
      corr_keytab-pgmid = transporter. &quot;collect all keys to
      APPEND corr_keytab TO cu_e071k_tab. &quot;delete for all objects
      DELETE corr_keytab.
    ENDLOOP.
  ENDLOOP.
  vim_corr_obj_viewname = x_header-viewname.
* save keytab entries related to objects not in e071 tab
  LOOP AT corr_keytab.
    IF x_header-flag NE space AND x_header-frm_e071 EQ space AND
       ( x_header-frm_e071ka NE space OR x_header-frm_e071ks NE space ).
      IF corr_keytab-objname EQ vim_long_objname.
        READ TABLE cu_e071_tab WITH KEY
         object = corr_keytab-object
         obj_name = corr_keytab-tabkey
         TRANSPORTING NO FIELDS.
      ELSE.
        READ TABLE cu_e071_tab WITH KEY
         object = corr_keytab-object
         obj_name = corr_keytab-objname
         TRANSPORTING NO FIELDS.
      ENDIF.
      IF sy-subrc EQ 0.                &quot;delete corr_keytab anyway
        DELETE corr_keytab.
      ENDIF.
    ELSE.
      READ TABLE cu_e071_tab WITH KEY
       object = corr_keytab-mastertype
       obj_name = corr_keytab-mastername
       TRANSPORTING NO FIELDS.
    ENDIF.
    CHECK sy-subrc NE 0.
    APPEND corr_keytab TO cu_corr_keytab_safe.
    DELETE corr_keytab.
  ENDLOOP.
  IF maint_mode EQ aendern AND lockable_objects_exist EQ space AND
     cu_obj_not_chkd NE space.
* may be objects are not yet checked
    LOOP AT cu_e071_tab ASSIGNING &lt;e071&gt;.        &quot;UNICODE
      MOVE-CORRESPONDING &lt;e071&gt; TO w_cu_ko200.   &quot;UNICODE
      APPEND w_cu_ko200 TO cu_ko200_tab.         &quot;UNICODE
*    cu_ko200_tab = cu_e071_tab.
    ENDLOOP.                                     &quot;UNICODE
    CALL FUNCTION &apos;TR_OBJECTS_CHECK&apos;
*       exporting
*            IV_NO_SHOW_OPTION              = &apos;X&apos;
       IMPORTING
            we_order                       = cuiorder
            we_task                        = cuitask
            we_objects_appendable          = cu_appendable
         TABLES
              wt_ko200                     = cu_ko200_tab
              wt_e071k                     = corr_keytab
       EXCEPTIONS
       cancel_edit_other_error       = 1
       show_only_other_error         = 2
       OTHERS                        = 3.
    IF sy-subrc NE 0 OR cu_appendable EQ space.
      rc = sy-subrc.
      LOOP AT cu_corr_keytab_safe INTO corr_keytab.
        APPEND corr_keytab.
      ENDLOOP.
      e071 = e071_safe. vim_corr_objtab[] = cu_corr_objtab.
      IF rc NE 0.
        MESSAGE ID     sy-msgid
                TYPE   &apos;I&apos;
                NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2  sy-msgv3 sy-msgv4.
        RAISE saving_correction_failed.
      ELSE.
        sy-subrc = rc.
        EXIT.
      ENDIF.
    ELSEIF cuiorder NE space OR cuitask NE space.
      &lt;status&gt;-order_nbr = cuiorder.
      &lt;status&gt;-corr_nbr = cuitask.
    ENDIF.
    REFRESH cu_ko200_tab.
  ENDIF. &quot;may be objects are not yet checked
  IF maint_mode EQ aendern AND lockable_objects_exist NE space OR
     maint_mode EQ transportieren AND cu_obj_not_chkd NE space.
    IF cu_obj_not_chkd NE space.
* first check previously unchecked lockable objects
      CLEAR vim_last_source_system.
      LOOP AT vim_corr_objtab WHERE lockable NE space.
        READ TABLE cu_corr_objtab
                         WITH KEY pgmid  = vim_corr_objtab-pgmid
                                 object  = vim_corr_objtab-object
                                 obj_name = vim_corr_objtab-obj_name
                         TRANSPORTING NO FIELDS.
        CHECK sy-subrc NE 0.
        e071 = vim_corr_objtab.
        PERFORM check_lockable_object USING e071 rc.
        IF rc NE 0 OR x_header-flag EQ vim_transport_denied.
          x_header-flag = cu_h_flag. MODIFY x_header INDEX 1.
          MESSAGE i162(sv) WITH vim_corr_objtab-pgmid
                                vim_corr_objtab-object
                                vim_corr_objtab-obj_name.
          IF maint_mode EQ aendern.
            rc = 9. EXIT.
          ELSE.
            DELETE vim_corr_objtab.
          ENDIF.
        ENDIF.
      ENDLOOP.
      DESCRIBE TABLE vim_corr_objtab.
      IF maint_mode EQ aendern AND rc NE 0 OR sy-tfill EQ 0.
* restore saved keytab entries and corr_objtab
        LOOP AT cu_corr_keytab_safe INTO corr_keytab.
          APPEND corr_keytab.
        ENDLOOP.
        e071 = e071_safe.
        RAISE saving_correction_failed.
      ENDIF.
    ENDIF.                             &quot;cu_obj_not_chckd ne space
    IF &lt;status&gt;-corr_nbr EQ space.
      LOOP AT vim_corr_objtab INTO e071.
        CALL FUNCTION &apos;TR_CHECK_TYPE&apos;
          EXPORTING
            wi_e071     = e071
          IMPORTING
            we_tadir    = cu_tadir
            we_category = cu_category.
       CHECK cu_category EQ vim_syst OR cu_category EQ vim_cust_syst OR
                     cu_category EQ vim_appl.
        cu_last_cat = vim_syst. cu_h_e071 = e071.
      ENDLOOP.
      IF cu_last_cat EQ space.
        cu_category = vim_cust.
      ELSE.
        cu_category = cu_last_cat. e071 = cu_h_e071.
      ENDIF.
      CALL FUNCTION &apos;TRINT_GET_REQUEST_TYPE&apos;
* UF041099 inserted instead of TRINT_CHECK_ORDER_TYPE
           EXPORTING
                iv_pgmid                   = e071-pgmid
                iv_object                  = e071-object
                iv_obj_name                = e071-obj_name
                iv_category                = cu_category
                is_tadir                   = cu_tadir
                is_tdevc                   = cu_tdevc
*                IV_USE_MEMORY              = &apos;X&apos;
           IMPORTING
                ev_request_type            = cu_order_type
                ev_task_type               = cu_task_type
*                EV_TARGET                  =
           EXCEPTIONS
                internal_error             = 1
                no_request_needed          = 2
                cts_initialization_failure = 3
                OTHERS                     = 4.
      CASE sy-subrc.
        WHEN 0.
        WHEN 2.
          cu_order_type = &apos;K&apos;.
          cu_task_type = &apos;S&apos;.
        WHEN OTHERS.
          LOOP AT cu_corr_keytab_safe INTO corr_keytab.
            APPEND corr_keytab.
          ENDLOOP.
          e071 = e071_safe. vim_corr_objtab[] = cu_corr_objtab.
          MESSAGE ID     sy-msgid
                  TYPE   &apos;I&apos;
                  NUMBER sy-msgno
                  WITH sy-msgv1 sy-msgv2  sy-msgv3 sy-msgv4.
          RAISE saving_correction_failed.
      ENDCASE.
      DO.
        CALL FUNCTION &apos;TRINT_ORDER_CHOICE&apos;
          EXPORTING
            wi_order_type          = cu_order_type
            wi_task_type           = cu_task_type
            wi_category            = cu_category
            wi_cli_dep             = space
          IMPORTING
            we_order               = &lt;status&gt;-order_nbr
            we_task                = &lt;status&gt;-corr_nbr
          TABLES
            wt_e071                = cu_e071_tab
            wt_e071k               = corr_keytab
          EXCEPTIONS
            no_correction_selected = 1
            display_mode           = 2
            object_append_error    = 3
            recursive_call         = 4
            OTHERS                 = 5.
        IF sy-subrc NE 0.
* restore saved keytab entries and corr_objtab
          LOOP AT cu_corr_keytab_safe INTO corr_keytab.
            APPEND corr_keytab.
          ENDLOOP.
          e071 = e071_safe. vim_corr_objtab[] = cu_corr_objtab.
          IF sy-subrc NE 1.
            MESSAGE ID     sy-msgid
                    TYPE   &apos;I&apos;
                    NUMBER sy-msgno
                    WITH sy-msgv1 sy-msgv2  sy-msgv3 sy-msgv4.
          ENDIF.
          RAISE saving_correction_failed.
        ENDIF.                         &quot;sy-subrc ne 0
        IF maint_mode EQ transportieren.
* enqueue corr
          CALL FUNCTION &apos;ENQUEUE_E_TRKORR&apos;
               EXPORTING
                    trkorr = &lt;status&gt;-corr_nbr
*               X_TRKORR = E02
               EXCEPTIONS
                    foreign_lock = 01
                    system_failure = 02.
          CASE sy-subrc.
            WHEN 0.
            WHEN 1.
          MESSAGE s092(sv) WITH &lt;status&gt;-corr_nbr. &quot;Korr. wirdger.bearb.
              CONTINUE.
            WHEN 2.
              MESSAGE a095(sv) WITH &lt;status&gt;-corr_nbr. &quot;Systemfehler
              CONTINUE.
          ENDCASE.
          &lt;status&gt;-corr_enqud = &apos;X&apos;.
          EXIT.
        ELSE.                          &quot;change mode
          EXIT.
        ENDIF.                         &quot;maint_mode eq transportieren
      ENDDO.
    ENDIF.                             &quot;&lt;status&gt;-corr_nbr eq space.
* store corr number into tables
    LOOP AT cu_e071_tab INTO e071 WHERE trkorr EQ space.
      e071-trkorr = &lt;status&gt;-corr_nbr.
      MODIFY cu_e071_tab FROM e071.
      LOOP AT vim_corr_objtab WHERE pgmid = e071-pgmid
                                AND object = e071-object
                                AND obj_name = e071-obj_name.
        vim_corr_objtab-trkorr = &lt;status&gt;-corr_nbr.
        MODIFY vim_corr_objtab.
        EXIT.
      ENDLOOP.
      sy-fdpos = strlen( e071-obj_name ).
      IF sy-fdpos GT vim_71k_name_length.
        READ TABLE corr_keytab WITH KEY pgmid = e071-pgmid
                                        object = e071-object
                                        objname = vim_long_objname
                                        tabkey  = e071-obj_name.
      ELSE.
        READ TABLE corr_keytab WITH KEY pgmid = e071-pgmid
                                        object = e071-object
                                        objname = e071-obj_name.
      ENDIF.
      IF sy-subrc EQ 0.
        corr_keytab-trkorr = &lt;status&gt;-corr_nbr.
        MODIFY corr_keytab INDEX sy-tabix.
      ENDIF.
    ENDLOOP.
  ENDIF.
  IF maint_mode EQ transportieren OR lockable_objects_exist NE space.
    SORT cu_e071_tab BY trkorr.
    LOOP AT cu_e071_tab INTO e071 WHERE objfunc NE &apos;D&apos;.
      cu_begix = sy-tabix + 1.
      EXIT.
    ENDLOOP.
    IF sy-subrc EQ 0.
      APPEND e071 TO cu_e071_htb.
      LOOP AT corr_keytab WHERE mastertype EQ e071-object
                            AND mastername EQ e071-obj_name.
        APPEND corr_keytab TO cu_corr_keyhtb.
      ENDLOOP.
      cu_last_corr = e071-trkorr.
      LOOP AT cu_e071_tab INTO e071 FROM cu_begix WHERE objfunc NE &apos;D&apos;.
        IF e071-trkorr NE cu_last_corr.
*___________________________________________________________________
          LOOP AT cu_e071_htb ASSIGNING &lt;ls_e071&gt;.
            MOVE-CORRESPONDING &lt;ls_e071&gt; TO ls_edt_object.
            APPEND ls_edt_object TO lt_edt_objects.
          ENDLOOP.
          CALL FUNCTION &apos;TR_EC_CUST_ORIG_LANG&apos;
            EXPORTING
              it_objects   = lt_edt_objects
              iv_checkmode = &apos; &apos;
              iv_dialog    = &apos;X&apos;
            CHANGING
              ct_keys      = cu_corr_keyhtb
            EXCEPTIONS
              cancel       = 1
              display_only = 2
              OTHERS       = 3.
          IF sy-subrc &lt;&gt; 0.
* MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*         WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
          ENDIF.
*--------------------------------------------------------------------
          CALL FUNCTION &apos;TRINT_APPEND_TO_COMM_ARRAYS&apos;
            EXPORTING
              wi_trkorr     = cu_last_corr
            TABLES
              wt_e071       = cu_e071_htb
              wt_e071k      = cu_corr_keyhtb
              wt_trmess_int = cu_trmess
              wt_trpar_int  = cu_trpar
            EXCEPTIONS
              OTHERS        = 08.
          IF sy-subrc NE 0.
* restore saved keytab entries and corr_objtab
            LOOP AT cu_corr_keytab_safe INTO corr_keytab.
              APPEND corr_keytab.
            ENDLOOP.
            e071 = e071_safe. vim_corr_objtab[] = cu_corr_objtab.
            MESSAGE ID     sy-msgid
                    TYPE   &apos;I&apos;
                    NUMBER sy-msgno
                    WITH sy-msgv1 sy-msgv2  sy-msgv3 sy-msgv4.
            RAISE saving_correction_failed.
          ENDIF.
          REFRESH: cu_e071_htb, cu_corr_keyhtb.
          cu_last_corr = e071-trkorr.
        ENDIF.
        APPEND e071 TO cu_e071_htb.
        LOOP AT corr_keytab WHERE mastertype EQ e071-object
                              AND mastername EQ e071-obj_name.
          APPEND corr_keytab TO cu_corr_keyhtb.
        ENDLOOP.
      ENDLOOP.
    ENDIF.                             &quot;sy-subrc of loop at e071_tab
    DESCRIBE TABLE cu_e071_htb.
    IF sy-tfill NE 0.
*      CALL FUNCTION &apos;TR_APPEND_TO_COMM_OBJS_KEYS&apos;
*        EXPORTING
**         WI_SIMULATION                        = &apos; &apos;
**         WI_SUPPRESS_KEY_CHECK                = &apos; &apos;
*          wi_trkorr                            = e071-trkorr
*        tables
*          wt_e071                              = cu_e071_htb
*          wt_e071k                             = cu_corr_keyhtb
*       EXCEPTIONS
*         KEY_CHAR_IN_NON_CHAR_FIELD           = 1
*         KEY_CHECK_KEYSYNTAX_ERROR            = 2
*         KEY_INTTAB_TABLE                     = 3
*         KEY_LONGER_FIELD_BUT_NO_GENERC       = 4
*         KEY_MISSING_KEY_MASTER_FIELDS        = 5
*         KEY_MISSING_KEY_TABLEKEY             = 6
*         KEY_NON_CHAR_BUT_NO_GENERIC          = 7
*         KEY_NO_KEY_FIELDS                    = 8
*         KEY_STRING_LONGER_CHAR_KEY           = 9
*         KEY_TABLE_HAS_NO_FIELDS              = 10
*         KEY_TABLE_NOT_ACTIV                  = 11
*         KEY_UNALLOWED_KEY_FUNCTION           = 12
*         KEY_UNALLOWED_KEY_OBJECT             = 13
*         KEY_UNALLOWED_KEY_OBJNAME            = 14
*         KEY_UNALLOWED_KEY_PGMID              = 15
*         KEY_WITHOUT_HEADER                   = 16
*         OB_CHECK_OBJ_ERROR                   = 17
*         OB_DEVCLASS_NO_EXIST                 = 18
*         OB_EMPTY_KEY                         = 19
*         OB_GENERIC_OBJECTNAME                = 20
*         OB_ILL_DELIVERY_TRANSPORT            = 21
*         OB_ILL_LOCK                          = 22
*         OB_ILL_PARTS_TRANSPORT               = 23
*         OB_ILL_SOURCE_SYSTEM                 = 24
*         OB_ILL_SYSTEM_OBJECT                 = 25
*         OB_ILL_TARGET                        = 26
*         OB_INTTAB_TABLE                      = 27
*         OB_LOCAL_OBJECT                      = 28
*         OB_LOCKED_BY_OTHER                   = 29
*         OB_MODIF_ONLY_IN_MODIF_ORDER         = 30
*         OB_NAME_TOO_LONG                     = 31
*         OB_NO_APPEND_OF_CORR_ENTRY           = 32
*         OB_NO_APPEND_OF_C_MEMBER             = 33
*         OB_NO_CONSOLIDATION_TRANSPORT        = 34
*         OB_NO_ORIGINAL                       = 35
*         OB_NO_SHARED_REPAIRS                 = 36
*         OB_NO_SYSTEMNAME                     = 37
*         OB_NO_SYSTEMTYPE                     = 38
*         OB_NO_TADIR                          = 39
*         OB_NO_TADIR_NOT_LOCKABLE             = 40
*         OB_PRIVAT_OBJECT                     = 41
*         OB_REPAIR_ONLY_IN_REPAIR_ORDER       = 42
*         OB_RESERVED_NAME                     = 43
*         OB_SYNTAX_ERROR                      = 44
*         OB_TABLE_HAS_NO_FIELDS               = 45
*         OB_TABLE_NOT_ACTIV                   = 46
*         TR_ENQUEUE_FAILED                    = 47
*         TR_ERRORS_IN_ERROR_TABLE             = 48
*         TR_ILL_KORRNUM                       = 49
*         TR_LOCKMOD_FAILED                    = 50
*         TR_LOCK_ENQUEUE_FAILED               = 51
*         TR_NOT_OWNER                         = 52
*         TR_NO_SYSTEMNAME                     = 53
*         TR_NO_SYSTEMTYPE                     = 54
*         TR_ORDER_NOT_EXIST                   = 55
*         TR_ORDER_RELEASED                    = 56
*         TR_ORDER_UPDATE_ERROR                = 57
*         TR_WRONG_ORDER_TYPE                  = 58
*         OB_INVALID_TARGET_SYSTEM             = 59
*         TR_NO_AUTHORIZATION                  = 60
*         OB_WRONG_TABLETYP                    = 61
*         OB_WRONG_CATEGORY                    = 62
*         OB_SYSTEM_ERROR                      = 63
*         OB_UNLOCAL_OBJEKT_IN_LOCAL_ORD       = 64
*         TR_WRONG_CLIENT                      = 65
*         OB_WRONG_CLIENT                      = 66
*         KEY_WRONG_CLIENT                     = 67
*         OTHERS                               = 68
*                .
*___________________________________________________________________
      LOOP AT cu_e071_htb ASSIGNING &lt;ls_e071&gt;.
        MOVE-CORRESPONDING &lt;ls_e071&gt; TO ls_edt_object.
        APPEND ls_edt_object TO lt_edt_objects.
      ENDLOOP.
      CALL FUNCTION &apos;TR_EC_CUST_ORIG_LANG&apos;
        EXPORTING
          it_objects   = lt_edt_objects
          iv_checkmode = &apos; &apos;
          iv_dialog    = &apos;X&apos;
        CHANGING
          ct_keys      = cu_corr_keyhtb
        EXCEPTIONS
          cancel       = 1
          display_only = 2
          OTHERS       = 3.
      IF sy-subrc &lt;&gt; 0.
* MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*         WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
      ENDIF.
*--------------------------------------------------------------------
      IF e071-trkorr EQ space.                        &quot;HCG HW 707466
        READ TABLE cu_corr_keyhtb into corr_keyhtb_wa INDEX 1.
        e071-trkorr = corr_keyhtb_wa-trkorr.
      ENDIF.
      CALL FUNCTION &apos;TRINT_APPEND_TO_COMM_ARRAYS&apos;
           EXPORTING
                wi_trkorr     = e071-trkorr
           TABLES
                wt_e071       = cu_e071_htb
                wt_e071k      = cu_corr_keyhtb
                wt_trmess_int = cu_trmess
                wt_trpar_int  = cu_trpar
*           EXCEPTIONS
*                OTHERS        = 08.
       EXCEPTIONS
         key_check_keysyntax_error          = 1
         ob_check_obj_error                 = 2
         tr_lockmod_failed                  = 3
         tr_lock_enqueue_failed             = 4
         tr_wrong_order_type                = 5
         tr_order_update_error              = 6
         file_access_error                  = 7
         ob_no_systemname                   = 8
         OTHERS                             = 9.
      IF sy-subrc NE 0.
* restore saved keytab entries and corr_objtab
        LOOP AT cu_corr_keytab_safe INTO corr_keytab.
          APPEND corr_keytab.
        ENDLOOP.
        e071 = e071_safe. vim_corr_objtab[] = cu_corr_objtab.
        MESSAGE ID     sy-msgid
                TYPE   &apos;I&apos;
                NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2  sy-msgv3 sy-msgv4.
        RAISE saving_correction_failed.
      ENDIF.
    ENDIF.
    IF maint_mode EQ transportieren.
* process deletion
      LOOP AT cu_e071_tab INTO e071 WHERE objfunc NE space.
        IF e071-objfunc EQ &apos;K&apos;.
          CALL FUNCTION &apos;TRINT_DELETE_COMM_KEYS&apos;
            EXPORTING
              wi_e071                = e071
              wi_trkorr              = &lt;status&gt;-corr_nbr
            TABLES
              wt_e071k               = cu_e071k_tab
            EXCEPTIONS
              e070_update_error      = 01
              keys_protected         = 02
              order_already_released = 03
              unallowed_ordertyp     = 04
              user_not_owner         = 05
              wrong_client           = 06.
          IF sy-subrc NE 0.
* restore saved keytab entries and corr_objtab
            LOOP AT cu_corr_keytab_safe INTO corr_keytab.
              APPEND corr_keytab.
            ENDLOOP.
            e071 = e071_safe. vim_corr_objtab[] = cu_corr_objtab.
*         MESSAGE S097(SV) WITH &lt;STATUS&gt;-CORR_NBR.
            MESSAGE ID     sy-msgid
                    TYPE   &apos;I&apos;
                    NUMBER sy-msgno
                    WITH sy-msgv1 sy-msgv2  sy-msgv3 sy-msgv4.
            RAISE saving_correction_failed.
          ELSE.
* check if object is to be deleted and delete it if necessary
            LOOP AT corr_keytab WHERE mastertype EQ e071-object
                                  AND mastername EQ e071-obj_name.
              EXIT.
            ENDLOOP.
          ENDIF.                       &quot;sy-subrc of function call
        ELSEIF e071-objfunc EQ &apos;D&apos;.
          sy-subrc = 8.
        ELSE.
          CLEAR sy-subrc.
        ENDIF.                         &quot;e071-objfunc
        IF sy-subrc NE 0.
* delete object
          cu_hobjfunc = e071-objfunc.
          cu_request-objects = cu_e071_tab.
          cu_request-objects_filled = &apos;X&apos;.
          CALL FUNCTION &apos;TRINT_DELETE_COMM_OBJECT_KEYS&apos;
               EXPORTING
                    is_e071_delete              = e071
                    iv_dialog_flag              = &apos; &apos;
*                IMPORTING
*                     ET_NEW_LOCKS                =
               CHANGING
                    cs_request                  = cu_request
               EXCEPTIONS
                    OTHERS = 8.

          IF sy-subrc NE 0.
* restore saved keytab entries and corr_objtab
            LOOP AT cu_corr_keytab_safe INTO corr_keytab.
              APPEND corr_keytab.
            ENDLOOP.
            e071 = e071_safe. vim_corr_objtab[] = cu_corr_objtab.
            MESSAGE ID     sy-msgid
                    TYPE   &apos;I&apos;
                    NUMBER sy-msgno
                    WITH sy-msgv1 sy-msgv2  sy-msgv3 sy-msgv4.
            RAISE saving_correction_failed.
          ENDIF. &quot;sy-subrc of function call corr_delete_entry.
          IF sy-subrc EQ 0 AND &quot;del. was successful or entry didn&apos;t ex.
             cu_hobjfunc EQ &apos;D&apos;.       &quot;and no table entry
            DELETE cu_corr_keytab_safe
              WHERE pgmid EQ e071-pgmid AND object EQ e071-object
                AND ( objname EQ e071-obj_name OR
                      objname EQ vim_long_objname AND
                      tabkey EQ e071-obj_name )
                AND objfunc EQ e071-objfunc.
          ENDIF.
        ENDIF.                         &quot;sy-subrc for deletion
      ENDLOOP.
      CLEAR: &lt;status&gt;-keytbmodfd, &lt;status&gt;-upd_flag.
      MESSAGE s096(sv) WITH &lt;status&gt;-corr_nbr.
    ENDIF.                             &quot;maint_mode eq transportieren.
* call synchronizer also for transp mode &quot;HCG int. message 1832131/2003
    cu_ko200_sec = cu_ko200_tab.
    ASSIGN vim_corr_objtab TO &lt;vim_corr_objtab&gt;.
    LOOP AT vim_corr_objtab.            &quot;Fill cu_ko200_tab for sync-call
      MOVE-CORRESPONDING &lt;vim_corr_objtab&gt; TO w_cu_ko200. &quot;UNICODE
      APPEND w_cu_ko200 TO cu_ko200_tab.                  &quot;UNICODE
    ENDLOOP.
    PERFORM vim_synchronizer_call
                             USING
                                  cu_ko200_tab[]
                                  corr_keytab[]
                                  space.
    cu_ko200_tab = cu_ko200_sec.              &quot;Reset cu_ko200_tab again
  ELSE.
* change mode and no lockable objects
    ASSIGN vim_corr_objtab TO &lt;vim_corr_objtab&gt;.
    LOOP AT vim_corr_objtab.
      MOVE-CORRESPONDING &lt;vim_corr_objtab&gt; TO w_cu_ko200. &quot;UNICODE
      APPEND w_cu_ko200 TO cu_ko200_tab.                  &quot;UNICODE
    ENDLOOP.
    IF &lt;status&gt;-order_nbr NE space.
      corr_for_insert = &lt;status&gt;-order_nbr.
    ELSE.
      corr_for_insert = &lt;status&gt;-corr_nbr.
    ENDIF.

    CALL FUNCTION &apos;TR_OBJECTS_INSERT&apos;
         EXPORTING
*             WI_ORDER                       = &lt;STATUS&gt;-ORDER_NBR
              wi_order                       = corr_for_insert
         IMPORTING
              we_order                       = &lt;status&gt;-order_nbr
              we_task                        = &lt;status&gt;-corr_nbr
         TABLES
              wt_ko200                       = cu_ko200_tab
              wt_e071k                       = corr_keytab
         EXCEPTIONS
              cancel_edit_other_error        = 4
              show_only_other_error          = 6
              OTHERS                         = 8.

    IF sy-subrc NE 0.
      rc = sy-subrc.
* restore saved keytab entries and corr_objtab
      LOOP AT cu_corr_keytab_safe INTO corr_keytab.
        APPEND corr_keytab.
      ENDLOOP.
      e071 = e071_safe. vim_corr_objtab[] = cu_corr_objtab.
      IF rc GT 4.
*       MESSAGE I097(SV) WITH &lt;STATUS&gt;-CORR_NBR.
        MESSAGE ID     sy-msgid
                TYPE   &apos;I&apos;
                NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2  sy-msgv3 sy-msgv4.
      ENDIF.
      RAISE saving_correction_failed.
    ENDIF.
    PERFORM vim_synchronizer_call
                             USING
                                  cu_ko200_tab[]
                                  corr_keytab[]
                                  space.
  ENDIF. &quot;maint_mode eq transportieren or lockable_objects_exist ne spac
* delete saved keytab entries - but not in transport mode
  IF maint_mode EQ aendern.
    IF x_header-flag NE space AND x_header-frm_e071 EQ space AND
       ( x_header-frm_e071ks NE space OR x_header-frm_e071ka NE space ).
      REFRESH corr_keytab.
    ELSE.
      DELETE corr_keytab WHERE mastertype NE vim_unlockable_object
                           AND mastertype NE vim_lockable_object.
    ENDIF.
  ENDIF.
* restore saved keytab entries and set used task number
  LOOP AT cu_corr_keytab_safe INTO corr_keytab.
    IF corr_keytab-mastername EQ x_header-viewname AND
       ( corr_keytab-mastertype EQ vim_unlockable_object OR
         corr_keytab-mastertype EQ vim_lockable_object ).
      corr_keytab-trkorr = &lt;status&gt;-corr_nbr.
    ENDIF.
    APPEND corr_keytab.
  ENDLOOP.
  SUBTRACT sy-subrc FROM sy-subrc.
  e071 = e071_safe.
  LOOP AT vim_corr_objtab.
    READ TABLE cu_corr_objtab WITH KEY pgmid = vim_corr_objtab-pgmid
                                       object = vim_corr_objtab-object
                                     obj_name = vim_corr_objtab-obj_name
                              TRANSPORTING NO FIELDS.
    CHECK sy-subrc NE 0.               &quot;delete added entries
    DELETE vim_corr_objtab.
  ENDLOOP.
  e071-trkorr = &lt;status&gt;-corr_nbr.
  last_corr_number = &lt;status&gt;-l_corr_nbr = &lt;status&gt;-corr_nbr.
  CLEAR &lt;status&gt;-keytbmodfd.
  FREE: cu_e071k_tab, cu_trmess, cu_trpar, cu_e071_tab,
        cu_corr_keytab_safe, cu_ko200_tab, cu_e071_htb, cu_new_locks.
ENDFORM.                    &quot;corr_upd</include_source>
   </include>
   <include NAME="LSVIMF1T" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000007" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122431" IDATE="20080721" ITIME="122431">
    <include_source>*---------------------------------------------------------------------*
*       FORM UPDATE_CORR_KEYTAB
*---------------------------------------------------------------------*
*       update CORR_KEYTAB
*---------------------------------------------------------------------*
* UET_ACTION ---&gt; action: A - add to, D - delete from CORR_KEYTAB     *
*                         P - check if entry exists in CORR_KEYTAB    *
*                         W - do nothing
* CORR_KEYTAB (global) ---&gt; header of CORR_KEYTAB with current entry  *
*---------------------------------------------------------------------*
FORM update_corr_keytab USING value(uet_action) uet_rc.
  DATA: e071k_safe LIKE e071k,
        asteriskpos TYPE i.
  MOVE: 1 TO uet_rc,
        corr_keytab TO e071k_safe.
* modify tabkey if only generic transport allowed
  IF vim_exit_11_12_active EQ space.
    IF e071k_safe-objname EQ x_header-texttab.
      IF x_header-genertxtrp NE space.
        asteriskpos
         = x_header-trtxgkpos / cl_abap_char_utilities=&gt;charsize.
        CHECK e071k_safe-tabkey NE space.
        e071k_safe-tabkey+asteriskpos = &apos;*&apos;.
      ENDIF.
    ELSE.
      asteriskpos
       = x_header-trgkeypos / cl_abap_char_utilities=&gt;charsize.
      IF x_header-generictrp NE space.
        e071k_safe-tabkey+asteriskpos = &apos;*&apos;.
      ENDIF.
    ENDIF.
  ELSE. &quot;exits active - clear VIEWNAME for non-ddic-viewtables.
    CLEAR e071k_safe-viewname.
  ENDIF.
  CASE uet_action.
    WHEN hinzufuegen.
      IF e071k_safe-object EQ transp_object.     &quot;table keys
        LOOP AT corr_keytab WHERE objname    EQ e071k_safe-objname
                              AND tabkey     EQ e071k_safe-tabkey
                              AND mastername EQ e071k_safe-mastername.
          IF corr_keytab-pgmid EQ vim_deleted_key.
            MOVE e071k_safe TO corr_keytab.
            MODIFY corr_keytab.
            CLEAR uet_rc.
          ENDIF.
          EXIT.
        ENDLOOP.
      ELSE.                            &quot;other objects
        LOOP AT corr_keytab WHERE pgmid      EQ e071k_safe-pgmid
                              AND object     EQ e071k_safe-object
                              AND objname    EQ e071k_safe-objname
                              AND tabkey     EQ e071k_safe-tabkey
                              AND mastername EQ e071k_safe-mastername.
          IF corr_keytab-objfunc EQ &apos;D&apos;.
            MOVE e071k_safe TO corr_keytab.
            MODIFY corr_keytab.
            CLEAR uet_rc.
          ENDIF.
          EXIT.
        ENDLOOP.
      ENDIF.
      IF sy-subrc NE 0.
        MOVE e071k_safe TO corr_keytab.
        APPEND corr_keytab.
        CLEAR uet_rc.
      ENDIF.
    WHEN geloescht.
      IF e071k_safe-object EQ transp_object.     &quot;table keys
        LOOP AT corr_keytab WHERE objname    EQ e071k_safe-objname
                              AND tabkey     EQ e071k_safe-tabkey
                              AND mastername EQ e071k_safe-mastername
                              AND pgmid      NE vim_deleted_key.
          corr_keytab-pgmid = vim_deleted_key.
          MODIFY corr_keytab.
          CLEAR uet_rc.
          EXIT.
        ENDLOOP.
      ELSE.                            &quot;other objects
        IF e071k_safe-mastername EQ space. &quot;avoid error in exit rout.
          e071k_safe-mastername = master_name.
        ENDIF.
        LOOP AT corr_keytab WHERE pgmid      EQ e071k_safe-pgmid
                              AND object     EQ e071k_safe-object
                              AND objname    EQ e071k_safe-objname
                              AND tabkey     EQ e071k_safe-tabkey
                              AND mastername EQ e071k_safe-mastername.
*                             AND OBJFUNC    NE &apos;D&apos;.
          IF corr_keytab-objfunc NE &apos;D&apos;.
            corr_keytab-objfunc = &apos;D&apos;.
            MODIFY corr_keytab.
            CLEAR uet_rc.
          ENDIF.
          EXIT.
        ENDLOOP.
* &lt;&lt; Übergangslösung, da objekte zum Tabkey noch nicht eingelesen werden
        IF sy-subrc NE 0.
          MOVE e071k_safe TO corr_keytab.
          corr_keytab-objfunc = &apos;D&apos;.
          APPEND corr_keytab.
          CLEAR uet_rc.
        ENDIF.
* &gt;&gt; Übergangslösung, da objekte zum Tabkey noch nicht eingelesen werden
      ENDIF.
    WHEN pruefen.
      IF e071k_safe-object EQ transp_object.     &quot;table keys
        LOOP AT corr_keytab WHERE objname    EQ e071k_safe-objname
                              AND tabkey     EQ e071k_safe-tabkey
                              AND mastername EQ e071k_safe-mastername
                              AND pgmid      NE vim_deleted_key.
          CLEAR uet_rc.
          EXIT.
        ENDLOOP.
      ELSE.                            &quot;other objects
        LOOP AT corr_keytab WHERE pgmid      EQ e071k_safe-pgmid
                              AND object     EQ e071k_safe-object
                              AND objname    EQ e071k_safe-objname
                              AND tabkey     EQ e071k_safe-tabkey
                              AND mastername EQ e071k_safe-mastername
                              AND objfunc    NE &apos;D&apos;.
          CLEAR uet_rc.
          EXIT.
        ENDLOOP.
      ENDIF.
    WHEN vim_writing_bc_imp_log.
      APPEND corr_keytab.
  ENDCASE.
  IF uet_rc EQ 0 AND uet_action NE pruefen.
    MOVE &apos;X&apos; TO &lt;status&gt;-keytbmodfd.
  ENDIF.
ENDFORM.                    &quot;UPDATE_CORR_KEYTAB</include_source>
   </include>
   <include NAME="LSVIMF1U" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000002" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122431" IDATE="20080721" ITIME="122431">
    <include_source>*---------------------------------------------------------------------*
*       FORM VIM_ADDRESS_KEYTAB_ENTRIES_INTERN
*---------------------------------------------------------------------*
* create address related keytab entries (intern)
*---------------------------------------------------------------------*
FORM vim_addr_keytab_entries_intern
                          USING value(vakei_tabname) TYPE tabname
                                value(vakei_table)
                                value(vakei_keylen) TYPE i
                                value(vakei_action) TYPE sychar01
                                vakei_rc type sy-subrc.
  corr_keytab =  e071k.
  corr_keytab-objname = vakei_tabname.
  MOVE vakei_table TO corr_keytab-tabkey(vakei_keylen).
  vim_exit_11_12_active = &apos;X&apos;.
  PERFORM update_corr_keytab USING vakei_action vakei_rc.
  CLEAR vim_exit_11_12_active.
ENDFORM. &quot;vim_address_keytab_entries_intern</include_source>
   </include>
   <include NAME="LSVIMF1V" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000004" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122431" IDATE="20080721" ITIME="122432">
    <include_source>*---------------------------------------------------------------------*
*       FORM VIM_ADDRESS_KEYTAB_ENTRIES
*---------------------------------------------------------------------*
* create address related keytab entries
*---------------------------------------------------------------------*
FORM vim_address_keytab_entries USING value(vake_action) TYPE c
                                      vake_rc TYPE i.
  STATICS: sadr2_keylen type syfleng.
  DATA: rc1 LIKE sy-subrc, x030l_wa type x030l.

  if sadr2_keylen is initial.
    CALL FUNCTION &apos;DDIF_NAMETAB_GET&apos;
      EXPORTING
        tabname           = &apos;SADR2&apos;
      IMPORTING
        X030L_WA          = x030l_wa
      EXCEPTIONS
        OTHERS            = 2.
    IF sy-subrc = 0.
      sadr2_keylen = x030l_wa-keylen / cl_abap_char_utilities=&gt;charsize.
    else.
      RAISE nametab_get_failed.
    ENDIF.
  endif.
  SELECT SINGLE * FROM sadr WHERE adrnr EQ &lt;address_number&gt;.
  IF sy-subrc NE 0.
* Übergangslösung Adressumstellung 30F Anfang
    CALL FUNCTION &apos;ADDR_CONVERT_ADRC_TO_SADR&apos;
      CHANGING
        address_number = &lt;address_number&gt;.
    IF &lt;address_number&gt; NE space.
      SELECT SINGLE * FROM sadr WHERE adrnr EQ &lt;address_number&gt;.
    ELSE.
      EXIT.
    ENDIF.
  ENDIF.
* Übergangslösung Adressumstellung 30F Ende
  vake_rc = 8.
  PERFORM vim_addr_keytab_entries_intern USING &apos;SADR&apos; sadr
                                               sadr_keylen
                                               vake_action rc1.
  IF rc1 EQ 0.
    CLEAR vake_rc.
  ELSE.
    IF vake_action EQ pruefen.
      EXIT.
    ENDIF.
  ENDIF.
  SELECT COUNT(*) FROM sadr2 WHERE adrnr EQ sadr-adrnr.
  CLEAR sadr2.
  MOVE: sadr-mandt TO sadr2-mandt,
        sadr-adrnr TO sadr2-adrnr,
        &apos;*&apos; TO sadr2-stdfl.
  IF sy-dbcnt GT 0.                    &quot;only if entries exist
    PERFORM vim_addr_keytab_entries_intern USING &apos;SADR2&apos; sadr2
                                                 sadr2_keylen
                                                 vake_action rc1.
    IF rc1 EQ 0.
      CLEAR vake_rc.
    ELSE.
      IF vake_action EQ pruefen.
        vake_rc = 8. EXIT.
      ENDIF.
    ENDIF.
  ENDIF.
  SELECT COUNT(*) FROM sadr3 WHERE adrnr EQ sadr-adrnr.
  IF sy-dbcnt GT 0.                    &quot;only if entries exist
    sadr3 = sadr2.
    PERFORM vim_addr_keytab_entries_intern USING &apos;SADR3&apos; sadr3
                                                 sadr2_keylen
                                                 vake_action rc1.
    IF rc1 EQ 0.
      CLEAR vake_rc.
    ELSE.
      IF vake_action EQ pruefen.
        vake_rc = 8. EXIT.
      ENDIF.
    ENDIF.
  ENDIF.
  SELECT COUNT(*) FROM sadr4 WHERE adrnr EQ sadr-adrnr.
  IF sy-dbcnt GT 0.                    &quot;only if entries exist
    sadr4 = sadr2.
    PERFORM vim_addr_keytab_entries_intern USING &apos;SADR4&apos; sadr4
                                                 sadr2_keylen
                                                 vake_action rc1.
    IF rc1 EQ 0.
      CLEAR vake_rc.
    ELSE.
      IF vake_action EQ pruefen.
        vake_rc = 8. EXIT.
      ENDIF.
    ENDIF.
  ENDIF.
  SELECT COUNT(*) FROM sadr5 WHERE adrnr EQ sadr-adrnr.
  IF sy-dbcnt GT 0.                    &quot;only if entries exist
    sadr5 = sadr2.
    PERFORM vim_addr_keytab_entries_intern USING &apos;SADR5&apos; sadr5
                                                  sadr2_keylen
                                                  vake_action rc1.
    IF rc1 EQ 0.
      CLEAR vake_rc.
    ELSE.
      IF vake_action EQ pruefen.
        vake_rc = 8.
      ENDIF.
    ENDIF.
  ENDIF.
ENDFORM.                               &quot;vim_address_keytab_entries</include_source>
   </include>
   <include NAME="LSVIMF1W" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000015" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122432" IDATE="20080721" ITIME="122432">
    <include_source>*---------------------------------------------------------------------*
*       FORM UPDATE_CORR                                              *
*---------------------------------------------------------------------*
*       update correction command file                                *
* UF230499: no changing of X_HEADER-KEYLEN if key is to long for
*           transport. Move appropriate key length to KEYLEN instead.
* UF170200: same for translated text fields
*---------------------------------------------------------------------*
* CORR_ACTION -&gt;(glob) action: D - delete from, A - add to command file
*---------------------------------------------------------------------*
FORM update_corr.
  LOCAL: x_header.
  DATA: rc LIKE sy-subrc, fails TYPE i, flag TYPE c, rc1 LIKE sy-subrc,
        uc_addr_71ktab LIKE e071k OCCURS 0,
        addr_e071k LIKE e071k,
        object_key TYPE ad_objkey, keylen TYPE syfleng,
        txtkeylen TYPE syfleng,
        sys_type(10) TYPE c,
        texttab_wa TYPE REF TO data,
        max_trsp_keylength_in_byte type i.
  FIELD-SYMBOLS: &lt;adr_obj_key&gt; TYPE x,
                 &lt;texttab_wa&gt; TYPE ANY,                    &quot;#EC *
                 &lt;texttab_wax&gt; TYPE x,                     &quot;#EC *
                 &lt;lang&gt; TYPE ANY.                          &quot;#EC *

  CHECK maint_mode EQ aendern OR maint_mode EQ transportieren.
  CHECK x_header-flag NE vim_transport_denied.
  CHECK vim_actopts-transp_off NE bc_transport_denied.
  max_trsp_keylength_in_byte = vim_max_trsp_keylength
   * cl_abap_char_utilities=&gt;charsize.
  CALL &apos;C_SAPGPARAM&apos; ID &apos;NAME&apos;  FIELD &apos;transport/systemtype&apos;
                     ID &apos;VALUE&apos; FIELD sys_type.
  IF x_header-keylen GT max_trsp_keylength_in_byte.
    keylen = x_header-maxtrkeyln.                           &quot;UF230499
  ELSE.                                                     &quot;UF230499
    keylen = x_header-keylen.                               &quot;UF230499
  ENDIF.
  IF x_header-textkeylen GT max_trsp_keylength_in_byte.
    txtkeylen = x_header-maxtrtxkln.                        &quot;UF230499
  ELSE.                                                     &quot;UF230499
    txtkeylen = x_header-textkeylen.                        &quot;UF230499
  ENDIF.
  IF x_header-adrnbrflag EQ &apos;N&apos;.
    ASSIGN object_key TO &lt;adr_obj_key&gt; CASTING.
    LOOP AT vim_addr_e071k_tab INTO addr_e071k.
      e071k-trkorr = &lt;status&gt;-corr_nbr.
    ENDLOOP.
  ENDIF.
  IF status-action EQ transportieren.
* force marked entries
************************************************************************
    CHECK vim_client_state NE vim_local_clnt.
    IF status-mode EQ list_bild.
* overview_screen
      IF ( x_header-frm_e071ks NE space OR x_header-flag EQ space ) AND
         vim_called_by_cluster NE space.
        PERFORM vim_store_state_info.
        CALL FUNCTION &apos;VIEWCLUSTER_TRANS_DEPENDENT&apos;
          EXPORTING
            view_name   = x_header-viewname
            action      = corr_action
            status_mode = status-mode
            workarea    = extract
            no_dialog   = vim_external_mode
            corr_number = &lt;status&gt;-corr_nbr.
      ENDIF.
      CLEAR counter.
      LOOP AT extract.
        CHECK &lt;xmark&gt; EQ markiert.
        PERFORM move_extract_to_view_wa.
        IF x_header-flag EQ space.     &quot;standard logging required
          IF x_header-bastab EQ space. &quot;view
            PERFORM (corr_formname) IN PROGRAM (sy-repid)
                                                   USING corr_action rc.
          ELSE.                        &quot;base table
            corr_keytab =  e071k.
            corr_keytab-objname = x_header-maintview.
            MOVE &lt;vim_xextract_key&gt; TO &lt;vim_corr_keyx&gt;(keylen).
            PERFORM update_corr_keytab USING corr_action rc.
            IF x_header-texttbexst NE space AND  &quot;base table with
            &lt;vim_xextract_text&gt; NE &lt;text_initial_x&gt;.     &quot;text table
* only texttable&apos;s original language shall be transported internally
              corr_keytab =  e071k.
              corr_keytab-objname = x_header-texttab.
              MOVE &lt;vim_xextract_text&gt; TO &lt;vim_corr_keyx&gt;(txtkeylen).
              PERFORM update_corr_keytab USING corr_action rc1.
              IF rc1 EQ 0. MOVE rc1 TO rc. ENDIF.
            ENDIF.
          ENDIF.
          IF x_header-texttbexst &lt;&gt; space AND        &quot;SW Texttransl ..
             vim_texttab_is_ro EQ space.
            PERFORM vim_text_keytab_entry
                    USING &lt;vim_xextract_key&gt; corr_action rc1.
            IF rc1 EQ 0. MOVE rc1 TO rc. ENDIF.
          ENDIF.                       &quot;.. Texttransl
          IF x_header-adrnbrflag EQ &apos;O&apos; AND &lt;address_number&gt; NE space.
            PERFORM vim_address_keytab_entries USING corr_action rc1.
            IF rc1 EQ 0. MOVE rc1 TO rc. ENDIF.
          ELSEIF x_header-adrnbrflag EQ &apos;N&apos; AND
                 &lt;address_number&gt; NE space.
            APPEND LINES OF vim_addr_e071k_tab TO uc_addr_71ktab.
*            object_key = &lt;vim_total_key&gt;.
            &lt;adr_obj_key&gt;(keylen) = &lt;vim_xextract_key&gt;. &quot;UF474925/2000
            CALL FUNCTION &apos;ADDR_TRANSPORT_ENTRIES&apos;
              EXPORTING
                addrnumber = &lt;address_number&gt;
                table_name = vim_addr_basetable
                field_name = vim_addr_bastab_field
                objkey     = object_key
              TABLES
                e071k_tab  = uc_addr_71ktab.
            vim_exit_11_12_active = &apos;X&apos;.
            LOOP AT uc_addr_71ktab INTO corr_keytab WHERE
             mastername = vim_addr_e071k_master_46 OR    &quot;UF688403/2000
             mastername = vim_addr_e071k_master.
* Rel &lt; 4.6A: ignore old type address entries inserted only for downward
*             compatibility
              PERFORM update_corr_keytab USING corr_action rc1.
              IF rc1 EQ 0. MOVE rc1 TO rc. ENDIF.
            ENDLOOP.
            REFRESH uc_addr_71ktab.
            CLEAR vim_exit_11_12_active.
          ENDIF.
        ENDIF.                         &quot;standard logging required
        IF x_header-frm_e071ks NE space.
          vim_exit_11_12_active = &apos;X&apos;.
          PERFORM (x_header-frm_e071ks) IN PROGRAM (sy-repid).
          IF sy-subrc EQ 0. MOVE sy-subrc TO rc. ENDIF.
          CLEAR vim_exit_11_12_active.
        ELSE.
          IF x_header-frm_e071 NE space AND
             x_header-frm_e071ka EQ space.
            &lt;status&gt;-keytbmodfd = &apos;X&apos;.
          ENDIF.
          IF x_header-flag NE space.
            EXIT.
          ENDIF.
        ENDIF.
        IF rc NE 0.
          ADD 1 TO fails.
          IF replace_mode NE space.
            READ TABLE total WITH KEY &lt;vim_xextract_key&gt; BINARY SEARCH.
            &lt;mark&gt; = &lt;xmark&gt; = nicht_markiert.
            MODIFY total INDEX sy-tabix.
            MODIFY extract.
            SUBTRACT: 1 FROM mark_total, 1 FROM mark_extract.
            ok_code = &apos;IGN &apos;.
          ENDIF.
        ELSE.
          READ TABLE total WITH KEY &lt;vim_xextract_key&gt; BINARY SEARCH.
          &lt;mark&gt; = &lt;xmark&gt; = nicht_markiert.
*          IF rc EQ 0.                          &quot;??? UF222098
          CASE corr_action.
            WHEN hinzufuegen.
              MOVE transportieren TO &lt;action&gt;.
            WHEN geloescht.
              CLEAR &lt;action&gt;.
          ENDCASE.
          &lt;xact&gt; = &lt;action&gt;.
*          ENDIF.
          MODIFY total INDEX sy-tabix.
          MODIFY extract.
          SUBTRACT: 1 FROM mark_total, 1 FROM mark_extract.
        ENDIF.
        ADD 1 TO counter.
      ENDLOOP.
      IF counter GT fails.
        IF fails GT 0.
          MOVE 4 TO rc.
        ELSE.
          CLEAR rc.
        ENDIF.
      ELSE.
        MOVE 8 TO rc.
      ENDIF.
      IF replace_mode EQ space.
        IF corr_action EQ hinzufuegen.
          IF counter EQ 1.
            IF rc EQ 0.
          MESSAGE s098(sv) WITH &lt;status&gt;-corr_nbr. &quot;Eintr. in K. aufgen.
            ELSE.
          MESSAGE s107(sv) WITH &lt;status&gt;-corr_nbr. &quot;Eintr. schon enthal.
            ENDIF.
          ELSE.
            SUBTRACT fails FROM counter.
            CASE rc.
              WHEN 0.
                MESSAGE s105(sv) WITH counter
                                &lt;status&gt;-corr_nbr. &quot;Eintr. in K. aufgen.
              WHEN 4.
                MESSAGE s109(sv) WITH counter fails
                                  &lt;status&gt;-corr_nbr. &quot;Eintr. schon enth.
              WHEN 8.
                MESSAGE s108(sv) WITH fails
                                  &lt;status&gt;-corr_nbr. &quot;Eintr. schon enth.
            ENDCASE.
          ENDIF.
        ELSE.
          IF counter EQ 1.
            IF rc EQ 0.
          MESSAGE s099(sv) WITH &lt;status&gt;-corr_nbr. &quot;Eintr.aus K. gelösch
            ELSE.
          MESSAGE s110(sv) WITH &lt;status&gt;-corr_nbr. &quot;Eintr. schon enthal.
            ENDIF.
          ELSE.
            SUBTRACT fails FROM counter.
            CASE rc.
              WHEN 0.
                MESSAGE s106(sv) WITH counter
                               &lt;status&gt;-corr_nbr. &quot;Eintr. aus K. gelösch
              WHEN 4.
                MESSAGE s111(sv) WITH counter fails
                                  &lt;status&gt;-corr_nbr. &quot;Eintr. nicht enth.
              WHEN 8.
                MESSAGE s112(sv) WITH fails
                                  &lt;status&gt;-corr_nbr. &quot;Eintr. nicht enth.
            ENDCASE.
          ENDIF.
        ENDIF.
      ENDIF.                           &quot;replace_mode eq space
    ELSE.
* detail screen
      IF x_header-flag EQ space.
* standard logging required
        IF x_header-bastab EQ space.
* view
          PERFORM (corr_formname) IN PROGRAM (sy-repid)
                                                   USING corr_action rc.
        ELSE.
* base table
          corr_keytab =  e071k.
          corr_keytab-objname = x_header-maintview.
*          MOVE &lt;table1&gt; TO corr_keytab-tabkey(x_header-keylen).
          MOVE &lt;table1_x&gt; TO &lt;vim_corr_keyx&gt;(keylen).
          PERFORM update_corr_keytab USING corr_action rc.
          IF x_header-texttbexst NE space
           AND &lt;table1_text&gt; NE &lt;text_initial&gt;.
* base table with text table
            corr_keytab =  e071k.
            corr_keytab-objname = x_header-texttab.
            MOVE &lt;table1_xtext&gt; TO &lt;vim_corr_keyx&gt;(txtkeylen).
            PERFORM update_corr_keytab USING corr_action rc1.
            IF rc1 EQ 0. MOVE rc1 TO rc. ENDIF.
          ENDIF.
        ENDIF.
        IF x_header-texttbexst &lt;&gt; space AND        &quot;SW Texttransl ..
           vim_texttab_is_ro EQ space.
          PERFORM vim_text_keytab_entry
                  USING &lt;table1_x&gt; corr_action rc1.
          IF rc1 EQ 0. MOVE rc1 TO rc. ENDIF.
        ENDIF.                         &quot;.. Texttransl
        IF x_header-adrnbrflag EQ &apos;O&apos; AND &lt;address_number&gt; NE space.
          PERFORM vim_address_keytab_entries USING corr_action rc1.
          IF rc1 EQ 0. MOVE rc1 TO rc. ENDIF.
        ELSEIF x_header-adrnbrflag EQ &apos;N&apos; AND
               &lt;address_number&gt; NE space.
* transport addresses
          APPEND LINES OF vim_addr_e071k_tab TO uc_addr_71ktab.
*          object_key = &lt;vim_extract_key&gt;.
          &lt;adr_obj_key&gt;(keylen) = &lt;vim_xextract_key&gt;.
          CALL FUNCTION &apos;ADDR_TRANSPORT_ENTRIES&apos;
            EXPORTING
              addrnumber = &lt;address_number&gt;
              table_name = vim_addr_basetable
              field_name = vim_addr_bastab_field
              objkey     = object_key
            TABLES
              e071k_tab  = uc_addr_71ktab.
          vim_exit_11_12_active = &apos;X&apos;.
          LOOP AT uc_addr_71ktab INTO corr_keytab WHERE
           mastername = vim_addr_e071k_master_46 OR    &quot;UF688403/2000
           mastername = vim_addr_e071k_master.
* Rel &lt; 4.6A: ignore old type address entries inserted only for downward
*             compatibility
            PERFORM update_corr_keytab USING corr_action rc1.
            IF rc1 EQ 0. MOVE rc1 TO rc. ENDIF.
          ENDLOOP.
          REFRESH uc_addr_71ktab.
          CLEAR vim_exit_11_12_active.
        ENDIF.
      ENDIF.                           &quot;standard logging required
      IF x_header-frm_e071ks NE space.
        vim_exit_11_12_active = &apos;X&apos;.
        PERFORM (x_header-frm_e071ks) IN PROGRAM (sy-repid).
        IF sy-subrc EQ 0. MOVE sy-subrc TO rc. ENDIF.
        CLEAR vim_exit_11_12_active.
      ELSE.
        IF x_header-frm_e071 NE space AND
           x_header-frm_e071ka EQ space.
          IF x_header-flag NE space.
            &lt;status&gt;-keytbmodfd = &apos;E&apos;.
          ELSE.
            &lt;status&gt;-keytbmodfd = &apos;X&apos;.
          ENDIF.
        ENDIF.
      ENDIF.
      IF &lt;status&gt;-keytbmodfd NE &apos;E&apos;.
        IF vim_called_by_cluster NE space.
          PERFORM vim_store_state_info.
          CALL FUNCTION &apos;VIEWCLUSTER_TRANS_DEPENDENT&apos;
            EXPORTING
              view_name   = x_header-viewname
              action      = corr_action
              status_mode = status-mode
              workarea    = extract
              no_dialog   = vim_external_mode
              corr_number = &lt;status&gt;-corr_nbr.
        ENDIF.
      ELSE.
        &lt;status&gt;-keytbmodfd = &apos;X&apos;.
      ENDIF.
      READ TABLE total WITH KEY &lt;vim_xextract_key&gt; BINARY SEARCH.
      IF rc EQ 0.
        CASE corr_action.
          WHEN hinzufuegen.
            MOVE transportieren TO &lt;action&gt;.
          WHEN geloescht.
            CLEAR &lt;action&gt;.
        ENDCASE.
        &lt;xact&gt; = &lt;action&gt;.
        MOVE &apos;X&apos; TO flag.
      ELSE.
        IF replace_mode NE space.
          ok_code = &apos;IGN &apos;.
        ENDIF.
      ENDIF.
      IF &lt;xmark&gt; EQ markiert.
        &lt;mark&gt; = &lt;xmark&gt; = nicht_markiert.
        SUBTRACT: 1 FROM mark_total, 1 FROM mark_extract.
        MOVE &apos;X&apos; TO flag.
      ENDIF.
      IF flag NE space.
        MODIFY total INDEX sy-tabix.
        MODIFY extract INDEX nextline.
      ENDIF.
      IF replace_mode EQ space.
        IF corr_action EQ hinzufuegen.
          IF rc EQ 0.
            MESSAGE s098(sv) WITH &lt;status&gt;-corr_nbr.&quot;Eintr. in K. aufg.
          ELSE.
            MESSAGE s107(sv) WITH &lt;status&gt;-corr_nbr.&quot;Eintr. schon enthl.
          ENDIF.
        ELSE.
          IF rc EQ 0.
            MESSAGE s099(sv) WITH &lt;status&gt;-corr_nbr.&quot;Eintr.aus K. gelösc
          ELSE.
            MESSAGE s110(sv) WITH &lt;status&gt;-corr_nbr.&quot;Eintr. schon enthl.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.
  ELSE.
* logging of changed entries
***********************************************************************
    CHECK vim_client_state EQ vim_log.
    corr_action = hinzufuegen.
*   REFRESH CORR_KEYTAB. &quot;only delete all keys for current object
    LOOP AT vim_corr_objtab WHERE objfunc NE space.
      LOOP AT corr_keytab WHERE mastertype EQ vim_corr_objtab-object
                            AND mastername EQ vim_corr_objtab-obj_name.
        DELETE corr_keytab.
      ENDLOOP.
    ENDLOOP.
    LOOP AT total.
      IF x_header-flag EQ space.       &quot;standard logging required
        IF x_header-bastab EQ space.   &quot;view
          CHECK &lt;action&gt; NE original AND &lt;action&gt; NE neuer_geloescht.
          MOVE &lt;vim_total_struc&gt; TO &lt;table1&gt;.
          PERFORM (corr_formname) IN PROGRAM (sy-repid)
                                                  USING corr_action rc.
        ELSE.                          &quot;base table
          IF x_header-texttbexst EQ space.
            CHECK &lt;action&gt; NE original AND &lt;action&gt; NE neuer_geloescht.
          ELSE.
          CHECK &lt;action&gt; NE original AND &lt;action&gt; NE neuer_geloescht OR
                                         &lt;action_text&gt; NE original AND
                                       &lt;action_text&gt; NE neuer_geloescht.
          ENDIF.
          MOVE &lt;vim_total_struc&gt; TO &lt;table1&gt;.
          corr_keytab =  e071k.
          corr_keytab-objname = x_header-maintview.
          MOVE &lt;vim_xtotal_key&gt; TO &lt;vim_corr_keyx&gt;(keylen).
          PERFORM update_corr_keytab USING corr_action rc.
          IF x_header-texttbexst NE space AND       &quot;base table with
             &lt;vim_xtotal_text&gt; NE &lt;text_initial_x&gt;. &quot;text table
            corr_keytab =  e071k.
            corr_keytab-objname = x_header-texttab.
            MOVE &lt;vim_xtotal_text&gt; TO &lt;vim_corr_keyx&gt;(txtkeylen).
            PERFORM update_corr_keytab USING corr_action rc1.
          ENDIF.
        ENDIF.                         &quot;base table or view
        IF x_header-adrnbrflag EQ &apos;O&apos; AND &lt;address_number&gt; NE space.
          PERFORM vim_address_keytab_entries USING corr_action rc1.
        ELSEIF x_header-adrnbrflag EQ &apos;N&apos; AND &lt;address_number&gt; NE space.
          READ TABLE vim_addresses_to_save
                        WITH KEY viewname = x_header-viewname
                                 addrnumber = &lt;address_number&gt;
                        BINARY SEARCH TRANSPORTING NO FIELDS.
          IF sy-subrc NE 0.            &quot;only existing addresses possible
            APPEND LINES OF vim_addr_e071k_tab TO uc_addr_71ktab.
*            object_key = &lt;vim_extract_key&gt;.
            &lt;adr_obj_key&gt;(keylen) = &lt;vim_xtotal_key&gt;. &quot;UF686454/2000
            CALL FUNCTION &apos;ADDR_TRANSPORT_ENTRIES&apos;
              EXPORTING
                addrnumber = &lt;address_number&gt;
                table_name = vim_addr_basetable
                field_name = vim_addr_bastab_field
                objkey     = object_key
              TABLES
                e071k_tab  = uc_addr_71ktab.
            vim_exit_11_12_active = &apos;X&apos;.
            LOOP AT uc_addr_71ktab INTO corr_keytab WHERE
             mastername = vim_addr_e071k_master_46 OR    &quot;UF688403/2000
             mastername = vim_addr_e071k_master.
* Rel &lt; 4.6A: ignore old type address entries inserted only for downward
*             compatibility
              PERFORM update_corr_keytab USING corr_action rc1.
              IF rc1 EQ 0. MOVE rc1 TO rc. ENDIF.
            ENDLOOP.
            REFRESH uc_addr_71ktab.
            CLEAR vim_exit_11_12_active.
          ENDIF.
        ENDIF.
      ENDIF.                           &quot;standard logging required
      IF x_header-frm_e071ks NE space.
        vim_exit_11_12_active = &apos;X&apos;.
        PERFORM (x_header-frm_e071ks) IN PROGRAM (sy-repid).
        CLEAR vim_exit_11_12_active.
      ELSE.
        IF x_header-flag NE space.
          EXIT.
        ENDIF.
      ENDIF.
    ENDLOOP.
    IF x_header-flag EQ space AND      &quot;standard logging required
       x_header-texttbexst &lt;&gt; space.   &quot;SW Texttransl ..
      PERFORM vim_text_keytab_entries USING corr_action rc1
                                            keylen          &quot;UF170200
                                            txtkeylen.      &quot;UF170200
    ENDIF.                             &quot;.. Texttransl
  ENDIF.                               &quot;maint_mode transport or update
  IF x_header-frm_e071ka NE space.
    vim_exit_11_12_active = &apos;X&apos;.
    PERFORM (x_header-frm_e071ka) IN PROGRAM (sy-repid).
    CLEAR vim_exit_11_12_active.
    IF status-action EQ transportieren AND x_header-flag NE space AND
       x_header-frm_e071 NE space AND x_header-frm_e071ks EQ space AND
       vim_called_by_cluster NE space.
      PERFORM vim_store_state_info.
      CALL FUNCTION &apos;VIEWCLUSTER_TRANS_DEPENDENT&apos;
        EXPORTING
          view_name   = x_header-viewname
          action      = corr_action
          status_mode = status-mode
          workarea    = extract
          no_dialog   = vim_external_mode
          corr_number = &lt;status&gt;-corr_nbr.
    ENDIF.
  ENDIF.
ENDFORM.                    &quot;update_corr</include_source>
   </include>
   <include NAME="LSVIMF1X" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000009" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122432" IDATE="20080721" ITIME="122432">
    <include_source>*---------------------------------------------------------------------*
*       FORM PREPARE_CORR                                             *
*---------------------------------------------------------------------*
*       prepare command file tables (E070, E071)                      *
*---------------------------------------------------------------------*
FORM prepare_corr.
  DATA: x030l_sadr type x030l,
        pc_objtype LIKE objs-objecttype,
        pc_maint_mode(1) TYPE c.

  CHECK x_header-flag NE vim_transport_denied.
  CHECK vim_actopts-transp_off NE bc_transport_denied.
  CHECK maint_mode EQ transportieren OR&quot;transport mode or change mode
        vim_client_state EQ vim_log.   &quot;and logging required
  IF &lt;status&gt;-tr_alrchkd EQ &apos;x&apos;.
* send warning if generic transport is required &quot;HCG and no BCset import
    IF x_header-generictrp NE space and vim_import_profile EQ space.
      MESSAGE i141(sv) WITH vim_max_trsp_keylength
                            vim_max_trsp_identical_key
                            x_header-maxtrkeyln.
    ELSEIF x_header-genertxtrp NE space and vim_import_profile EQ space.
      MESSAGE i141(sv) WITH vim_max_trsp_keylength
                            vim_max_trsp_identical_key
                            x_header-maxtrtxkln.
    ENDIF.
    DESCRIBE TABLE vim_corr_objtab.
    IF sy-tfill GT 0.                  &quot;save objects in corr_keytab
      CLEAR corr_keytab.
      MOVE x_header-viewname TO corr_keytab-mastername.
      LOOP AT vim_corr_objtab.
        IF vim_corr_objtab-lockable EQ space.
          corr_keytab-mastertype = vim_unlockable_object.
        ELSE.
          corr_keytab-mastertype = vim_lockable_object.
        ENDIF.
        MOVE: vim_corr_objtab-pgmid    TO corr_keytab-pgmid,
              vim_corr_objtab-object   TO corr_keytab-object,
*             VIM_CORR_OBJTAB-OBJ_NAME TO CORR_KEYTAB-OBJNAME,
              vim_corr_objtab-objfunc  TO corr_keytab-objfunc,
        vim_corr_objtab-activity TO corr_keytab-activity. &quot;UF738595/2001
        sy-fdpos = strlen( vim_corr_objtab-obj_name ).
        IF sy-fdpos GT vim_71k_name_length.
          corr_keytab-objname = vim_long_objname.
          corr_keytab-tabkey  = vim_corr_objtab-obj_name.
        ELSE.
          corr_keytab-objname = vim_corr_objtab-obj_name.
        ENDIF.
        READ TABLE corr_keytab
                   WITH KEY pgmid      = corr_keytab-pgmid
                            object     = corr_keytab-object
                            objname    = corr_keytab-objname
                            objfunc    = corr_keytab-objfunc
                            mastertype = corr_keytab-mastertype
                            mastername = corr_keytab-mastername
                   TRANSPORTING NO FIELDS.
        CHECK sy-subrc NE 0.
        IF vim_corr_objtab-trkorr EQ space.
          MOVE: &lt;status&gt;-corr_nbr    TO corr_keytab-trkorr,
                &lt;status&gt;-corr_nbr    TO vim_corr_objtab-trkorr.
          MODIFY vim_corr_objtab.
        ELSE.
          corr_keytab-trkorr = vim_corr_objtab-trkorr.
        ENDIF.
        corr_keytab-flag = &apos;V&apos;.
        APPEND corr_keytab.
      ENDLOOP.
    ENDIF.                             &quot;sy-tfill
  ENDIF.                               &quot;&lt;status&gt;-tr_alrchkd eq &apos;x&apos;.
  IF maint_mode EQ transportieren.
    MOVE &apos;X&apos; TO get_corr_keytab.
    IF &lt;status&gt;-keytbinvld EQ space.
      LOOP AT vim_corr_objtab WHERE lockable EQ space.
        LOOP AT corr_keytab WHERE mastertype EQ vim_corr_objtab-object
                             AND mastername EQ vim_corr_objtab-obj_name.
          EXIT.
        ENDLOOP.
        IF sy-subrc EQ 0.
          CLEAR get_corr_keytab.
        ENDIF.
      ENDLOOP.
    ELSE.
      LOOP AT vim_corr_objtab WHERE lockable EQ space.
        LOOP AT corr_keytab WHERE mastertype EQ vim_corr_objtab-object
                             AND mastername EQ vim_corr_objtab-obj_name.
          DELETE corr_keytab.
        ENDLOOP.
      ENDLOOP.
    ENDIF.
  ENDIF.
  MOVE &lt;status&gt;-corr_nbr TO &lt;status&gt;-l_corr_nbr.
  &lt;status&gt;-tr_alrchkd = &apos;X&apos;.
  IF ( status-action EQ transportieren OR
       vim_client_state EQ vim_log ) AND
     x_header-adrnbrflag EQ &apos;O&apos; AND sadr_namtab_read EQ space.
    CALL FUNCTION &apos;DDIF_NAMETAB_GET&apos;
      EXPORTING
        tabname           = &apos;SADR&apos;
      IMPORTING
        X030L_WA          = x030l_sadr
      EXCEPTIONS
        OTHERS            = 2.
    IF sy-subrc EQ 0.
      MOVE &apos;X&apos; TO sadr_namtab_read.
      sadr_keylen = x030l_sadr-keylen
                     / cl_abap_char_utilities=&gt;charsize.
* Übrgangslösung Adreßtabellen SADR2...SADR5 zu 3.0A Anfang
      IF x_header-bastab EQ space.
        pc_objtype = &apos;V&apos;.
      ELSE.
        pc_objtype = &apos;S&apos;.
      ENDIF.
      CALL FUNCTION &apos;VIEW_CHECK_OBJ_LIST_FOR_ADDR&apos;
        EXPORTING
          objectname                     = x_header-viewname
          objecttype                     = pc_objtype
        EXCEPTIONS
          not_all_address_tables_in_list = 01.
      IF sy-subrc NE 0. &quot;regenerating of object list required
        pc_maint_mode = x_header-bastab.
        TRANSLATE pc_maint_mode USING &apos; VXS&apos;.
        CALL FUNCTION &apos;OBJ_GENERATE&apos;
          EXPORTING
            iv_objectname    = x_header-viewname
            iv_objecttype    = pc_maint_mode
            iv_maint_mode    = aendern
            iv_no_correction = &apos;X&apos;
          EXCEPTIONS   &quot;#EC *
            OTHERS           = 5.
      ENDIF.
* Übrgangslösung Adreßtabellen SADR2...SADR5 zu 3.0A Ende
    ELSE.
      RAISE nametab_get_failed.
    ENDIF.
  ENDIF.
ENDFORM.                    &quot;PREPARE_CORR</include_source>
   </include>
   <include NAME="LSVIMF1Y" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000006" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122432" IDATE="20080721" ITIME="122432">
    <include_source>*---------------------------------------------------------------------*
*       FORM CHECK_TRANSP_OBJS_FOR_MAINT                              *
*---------------------------------------------------------------------*
*  check transport objects for logging during maintenance             *
*---------------------------------------------------------------------*
FORM check_transp_objs_for_maint USING ctofm_return TYPE i.
  DATA: obj_appendable(1) TYPE c, rc LIKE sy-subrc, e071_safe LIKE e071,
      last_order LIKE e071-trkorr, ctofm_ko200_tab LIKE ko200 OCCURS 10,
        ctofm_keytab_safe LIKE corr_keytab OCCURS 50,
        last_corr LIKE e071-trkorr.

  CLEAR ctofm_return.
  CHECK maint_mode EQ aendern.
* Insert IMG-activity
  PERFORM vim_get_img_activity CHANGING e071-activity.  &quot;UF738595/2001
  IF vim_corr_obj_viewname NE x_header-viewname.
    CLEAR e071-trkorr.
    PERFORM get_transp_info.
    CHECK x_header-flag NE vim_transport_denied.
    CHECK vim_actopts-transp_off NE bc_transport_denied.
    IF maint_mode EQ anzeigen. ctofm_return = 4. EXIT. ENDIF.
  ELSE. &quot; csn ext.382209 2002 XB
    IF NOT objh IS INITIAL.
      IF x_header-importable IS INITIAL.
        x_header-importable = objh-importable.
      ENDIF.
    ENDIF.
  ENDIF.
  CHECK vim_client_state EQ vim_log.
  IF &lt;status&gt;-corr_nbr NE &lt;status&gt;-l_corr_nbr.
    CLEAR: &lt;status&gt;-tr_alrchkd, &lt;status&gt;-corr_enqud.
  ENDIF.
  IF &lt;status&gt;-tr_alrchkd NE space.
    vim_corr_obj_viewname = x_header-viewname.
    EXIT.
  ENDIF.
* first get corr nbr for lockable transport objects
  e071_safe = e071.
  CLEAR vim_last_source_system.
  LOOP AT vim_corr_objtab WHERE lockable NE space.
    e071 = vim_corr_objtab.
    PERFORM check_lockable_object USING e071 ctofm_return.
    IF ctofm_return NE 0 OR x_header-flag EQ vim_transport_denied.
      EXIT.
    ENDIF.
  ENDLOOP.
  IF ctofm_return NE 0 OR x_header-flag EQ vim_transport_denied.
    e071 = e071_safe. EXIT.
  ENDIF.
  vim_corr_obj_viewname = x_header-viewname.
* second: check unlockable objects
* REFRESH VIM_ULO_TRSP_OBJS.
  LOOP AT vim_corr_objtab WHERE lockable EQ space.
    e071 = vim_corr_objtab.
*   APPEND E071 TO VIM_ULO_TRSP_OBJS.
    APPEND e071 TO ctofm_ko200_tab.
  ENDLOOP.
  IF sy-subrc EQ 0.                    &quot;only if unlockable objects exist
* CTOFM_KO200_TAB = VIM_ULO_TRSP_OBJS.
    LOOP AT corr_keytab.                &quot;save keys of other objects
      LOOP AT vim_corr_objtab WHERE lockable EQ space
                                AND object   EQ corr_keytab-mastertype
                                AND obj_name EQ corr_keytab-mastername.
        EXIT.
      ENDLOOP.
      CHECK sy-subrc NE 0.
      APPEND corr_keytab TO ctofm_keytab_safe.
      DELETE corr_keytab.
    ENDLOOP.
    last_order = &lt;status&gt;-order_nbr.
    last_corr = &lt;status&gt;-corr_nbr.
    CALL FUNCTION &apos;TR_OBJECTS_CHECK&apos;
      IMPORTING
        we_order                = &lt;status&gt;-order_nbr
        we_task                 = &lt;status&gt;-corr_nbr
        we_objects_appendable   = obj_appendable
      TABLES
        wt_ko200                = ctofm_ko200_tab
        wt_e071k                = corr_keytab
      EXCEPTIONS
        cancel_edit_other_error = 1
        show_only_other_error   = 2
        OTHERS                  = 3.
    IF sy-subrc NE 0.
      rc = sy-subrc.
      MESSAGE ID      sy-msgid
              TYPE    &apos;I&apos;
              NUMBER  sy-msgno
              WITH    sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      IF rc = 2.
*     MAINT_MODE = STATUS-ACTION = ANZEIGEN.
        ctofm_return = 4.
        e071 = e071_safe. EXIT.
      ELSE.                            &quot;cancel edit
*     RAISE MISSING_CORR_NUMBER.
        ctofm_return = 8. e071 = e071_safe. EXIT.
      ENDIF.
    ENDIF.
    IF &lt;status&gt;-corr_nbr NE space AND last_corr NE space.
      IF last_corr NE &lt;status&gt;-corr_nbr.
        IF &lt;status&gt;-order_nbr NE last_order.
          MESSAGE i129(sv). &quot;Zusammengehörige Objekte in verschied
*       RAISE MISSING_CORR_NUMBER.
          ctofm_return = 4. e071 = e071_safe. EXIT.
        ENDIF.
      ENDIF.
    ELSE.
      IF &lt;status&gt;-corr_nbr EQ space.
        &lt;status&gt;-corr_nbr = last_corr.
        &lt;status&gt;-order_nbr = last_order.
      ENDIF.
    ENDIF.
    LOOP AT ctofm_keytab_safe INTO corr_keytab. &quot;restore saved entries
      APPEND corr_keytab.
    ENDLOOP.
    IF obj_appendable EQ space.        &quot;no ...INSERT - call required
      vim_client_state = vim_noact.
    ENDIF.
  ENDIF.                               &quot;unlockable objects exist
  e071 = e071_safe.
  &lt;status&gt;-tr_alrchkd = &apos;x&apos;.
ENDFORM.                               &quot;check_transp_objs_for_maint
*&amp;---------------------------------------------------------------------*
*&amp;      Form  vim_get_img_activity
*&amp;---------------------------------------------------------------------*
*       Gets IMG-activity the dialogue has been called from.
*       UF738595/2001
*----------------------------------------------------------------------*
*      &lt;--P_ACTIVITY  IMG-activity
*----------------------------------------------------------------------*
FORM vim_get_img_activity  CHANGING p_activity TYPE e071-activity.

  CALL FUNCTION &apos;READ_IMG_ACTIVITY_FROM_MEMORY&apos;
    IMPORTING
      img_activity = p_activity.
ENDFORM.                    &quot; get_img_activity</include_source>
   </include>
   <include NAME="LSVIMF1Z" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000003" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122432" IDATE="20080721" ITIME="122432">
    <include_source>*---------------------------------------------------------------------*
*       FORM CHECK_LOCKABLE_OBJECT                                    *
*---------------------------------------------------------------------*
*  check lockable transport objects                                   *
*---------------------------------------------------------------------*
* &lt;---&gt; CLO_E071 ......
* &lt;---- return code: 0 - ok, 4 - display only, 8 - cancel edit        *
*---------------------------------------------------------------------*
FORM CHECK_LOCKABLE_OBJECT USING CLO_E071 STRUCTURE E071
                                 CLO_RETURN TYPE I.
  DATA: CLO_TADIR LIKE TADIR, CLO_DDERR LIKE DDERR,
        CLO_LOCKED(1) TYPE C, CLO_LOCKABLE(1) TYPE C,
        CLO_EDITABLE(1) TYPE C, CLO_LOCK_TASK LIKE E071-TRKORR,
        CLO_LOCK_USER LIKE SY-UNAME, CLO_LOCK_ORDER LIKE E071-TRKORR,
        CLO_TRANSPORTABLE(1) TYPE C, CLO_ICORR LIKE E070-TRKORR,
        CLO_TE071 LIKE KO200 OCCURS 0, CLO_TTADIR LIKE TADIR OCCURS 0,
        CLO_TE071K LIKE E071K OCCURS 0.

  APPEND CLO_E071 TO CLO_TE071.
  CALL FUNCTION &apos;TR_EDIT_CHECK_OBJECTS_KEYS&apos;
       EXPORTING
            WI_ORDER                       = CLO_E071-TRKORR
            WI_WITH_DIALOG                 = &apos;R&apos;
*           WI_OBJ_CATEGOGY_MIX            = &apos;X&apos;
            WI_SEND_MESSAGE                = &apos; &apos;
       IMPORTING
*           WE_ORDER                       =
            WE_TASK                        = CLO_E071-TRKORR
*           WE_OBJECTS_APPENDABLE          =
*           EV_ERRNUM                      =
*           EV_OBJECT_UNLOCKED             =
       TABLES
            WT_E071                        = CLO_TE071
            WT_E071K                       = CLO_TE071K
            WT_TADIR                       = CLO_TTADIR
       EXCEPTIONS
            CANCEL_EDIT_APPEND_ERROR_KEYS  = 1
            CANCEL_EDIT_APPEND_ERROR_OBJCT = 2
            CANCEL_EDIT_APPEND_ERROR_ORDER = 3
            CANCEL_EDIT_BUT_SE01           = 4
            CANCEL_EDIT_NO_HEADER_OBJECT   = 5
            CANCEL_EDIT_NO_ORDER_SELECTED  = 6
            CANCEL_EDIT_REPAIRED_OBJECT    = 7
            CANCEL_EDIT_SYSTEM_ERROR       = 8
            CANCEL_EDIT_TADIR_MISSING      = 9
            CANCEL_EDIT_TADIR_UPDATE_ERROR = 10
            CANCEL_EDIT_UNKNOWN_DEVCLASS   = 11
            CANCEL_EDIT_UNKNOWN_OBJECTTYPE = 12
            CANCEL_EDIT_NO_CHECK_CALL      = 13
            CANCEL_EDIT_CATEGORY_MIXTURE   = 14
            CANCEL_EDIT_USER_AFTER_ERROR   = 15
            CANCEL_EDIT_CUSTOM_OBJ_AT_SAP  = 16
            CANCEL_EDIT_ACCESS_DENIED      = 17
            SHOW_ONLY_CLOSED_SYSTEM        = 18
            SHOW_ONLY_CONSOLIDATION_LEVEL  = 19
            SHOW_ONLY_DDIC_IN_CUSTOMER_SYS = 20
            SHOW_ONLY_DELIVERY_SYSTEM      = 21
            SHOW_ONLY_DIFFERENT_ORDERTYPES = 22
            SHOW_ONLY_DIFFERENT_TASKTYPES  = 23
            SHOW_ONLY_ENQUEUE_FAILED       = 24
            SHOW_ONLY_GENERATED_OBJECT     = 25
            SHOW_ONLY_ILL_LOCK             = 26
            SHOW_ONLY_LOCK_ENQUEUE_FAILED  = 27
            SHOW_ONLY_MIXED_ORDERS         = 28
            SHOW_ONLY_MIX_LOCAL_TRANSP_OBJ = 29
            SHOW_ONLY_NO_SHARED_REPAIR     = 30
            SHOW_ONLY_OBJECT_LOCKED        = 31
            SHOW_ONLY_REPAIRED_OBJECT      = 32
            SHOW_ONLY_SHOW_CLIENT          = 33
            SHOW_ONLY_TADIR_MISSING        = 34
            SHOW_ONLY_UNKNOWN_DEVCLASS     = 35
            SHOW_ONLY_CLOSED_CLIENT        = 36
            SHOW_ONLY_CLOSED_ALE_OBJECT    = 37
            SHOW_ONLY_UNALLOWED_SUPERUSER  = 38
            SHOW_ONLY_NO_REPAIR_SYSTEM     = 39
            SHOW_ONLY_NO_LICENSE           = 40
            SHOW_ONLY_CENTRAL_BASIS        = 41
            SHOW_ONLY_USER_AFTER_ERROR     = 42
            SHOW_ONLY_OBJECT_NOT_PATCHABLE = 43.
  IF SY-SUBRC NE 0.
    MESSAGE ID SY-MSGID TYPE &apos;I&apos; NUMBER SY-MSGNO
            WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
    IF SY-SUBRC LE 17.
      CLO_RETURN = 8. EXIT.
    ELSE.
      CLO_RETURN = 4. &lt;STATUS&gt;-CORR_NBR = VIM_LOCKED_IN_CORR. EXIT.
    ENDIF.
  ELSE.
    READ TABLE CLO_TE071 INTO CLO_E071 INDEX 1.
    READ TABLE CLO_TTADIR INTO CLO_TADIR INDEX 1.
    IF CLO_TADIR-DEVCLASS IS INITIAL.
      CALL FUNCTION &apos;TR_EDIT_CHECK_OBJECTS_KEYS&apos;
           EXPORTING
                WI_ORDER                       = CLO_E071-TRKORR
                WI_WITH_DIALOG                 = &apos;X&apos;
*           WI_OBJ_CATEGOGY_MIX            = &apos;X&apos;
                WI_SEND_MESSAGE                = &apos; &apos;
           IMPORTING
*           WE_ORDER                       =
                WE_TASK                        = CLO_E071-TRKORR
*           WE_OBJECTS_APPENDABLE          =
*           EV_ERRNUM                      =
*           EV_OBJECT_UNLOCKED             =
           TABLES
                WT_E071                        = CLO_TE071
                WT_E071K                       = CLO_TE071K
                WT_TADIR                       = CLO_TTADIR
           EXCEPTIONS
                CANCEL_EDIT_APPEND_ERROR_KEYS  = 1
                CANCEL_EDIT_APPEND_ERROR_OBJCT = 2
                CANCEL_EDIT_APPEND_ERROR_ORDER = 3
                CANCEL_EDIT_BUT_SE01           = 4
                CANCEL_EDIT_NO_HEADER_OBJECT   = 5
                CANCEL_EDIT_NO_ORDER_SELECTED  = 6
                CANCEL_EDIT_REPAIRED_OBJECT    = 7
                CANCEL_EDIT_SYSTEM_ERROR       = 8
                CANCEL_EDIT_TADIR_MISSING      = 9
                CANCEL_EDIT_TADIR_UPDATE_ERROR = 10
                CANCEL_EDIT_UNKNOWN_DEVCLASS   = 11
                CANCEL_EDIT_UNKNOWN_OBJECTTYPE = 12
                CANCEL_EDIT_NO_CHECK_CALL      = 13
                CANCEL_EDIT_CATEGORY_MIXTURE   = 14
                CANCEL_EDIT_USER_AFTER_ERROR   = 15
                CANCEL_EDIT_CUSTOM_OBJ_AT_SAP  = 16
                CANCEL_EDIT_ACCESS_DENIED      = 17
                SHOW_ONLY_CLOSED_SYSTEM        = 18
                SHOW_ONLY_CONSOLIDATION_LEVEL  = 19
                SHOW_ONLY_DDIC_IN_CUSTOMER_SYS = 20
                SHOW_ONLY_DELIVERY_SYSTEM      = 21
                SHOW_ONLY_DIFFERENT_ORDERTYPES = 22
                SHOW_ONLY_DIFFERENT_TASKTYPES  = 23
                SHOW_ONLY_ENQUEUE_FAILED       = 24
                SHOW_ONLY_GENERATED_OBJECT     = 25
                SHOW_ONLY_ILL_LOCK             = 26
                SHOW_ONLY_LOCK_ENQUEUE_FAILED  = 27
                SHOW_ONLY_MIXED_ORDERS         = 28
                SHOW_ONLY_MIX_LOCAL_TRANSP_OBJ = 29
                SHOW_ONLY_NO_SHARED_REPAIR     = 30
                SHOW_ONLY_OBJECT_LOCKED        = 31
                SHOW_ONLY_REPAIRED_OBJECT      = 32
                SHOW_ONLY_SHOW_CLIENT          = 33
                SHOW_ONLY_TADIR_MISSING        = 34
                SHOW_ONLY_UNKNOWN_DEVCLASS     = 35
                SHOW_ONLY_CLOSED_CLIENT        = 36
                SHOW_ONLY_CLOSED_ALE_OBJECT    = 37
                SHOW_ONLY_UNALLOWED_SUPERUSER  = 38
                SHOW_ONLY_NO_REPAIR_SYSTEM     = 39
                SHOW_ONLY_NO_LICENSE           = 40
                SHOW_ONLY_CENTRAL_BASIS        = 41
                SHOW_ONLY_USER_AFTER_ERROR     = 42
                SHOW_ONLY_OBJECT_NOT_PATCHABLE = 43.
      IF SY-SUBRC NE 0.
        MESSAGE ID SY-MSGID TYPE &apos;I&apos; NUMBER SY-MSGNO
                WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
        IF SY-SUBRC LE 17.
          CLO_RETURN = 8. EXIT.
        ELSE.
          CLO_RETURN = 4. &lt;STATUS&gt;-CORR_NBR = VIM_LOCKED_IN_CORR. EXIT.
        ENDIF.
      ELSE.
        READ TABLE CLO_TE071 INTO CLO_E071 INDEX 1.
        READ TABLE CLO_TTADIR INTO CLO_TADIR INDEX 1.
      ENDIF.
    ENDIF.
  ENDIF.
* PERFORM MCOMMEDITCHECK(RDDINSYS)
*                        CHANGING CLO_E071 CLO_TADIR CLO_DDERR.
* IF CLO_DDERR-SEVERITY EQ &apos;F&apos;.
*   IF CLO_DDERR-ERRNUM EQ &apos;16&apos;.       &quot;repair requested
*     PERFORM FCOMMEDITCHECK(RDDINSYS)
*                            CHANGING CLO_E071 CLO_TADIR CLO_DDERR.
*     IF CLO_DDERR-SEVERITY EQ &apos;F&apos;.
*       CASE CLO_DDERR-ERRNUM.
*         WHEN 4.                      &quot;display
**          MAINT_MODE = STATUS-ACTION = ANZEIGEN.
**          EXIT.
*           CLO_RETURN = 4. &lt;STATUS&gt;-CORR_NBR = VIM_LOCKED_IN_CORR.
*           EXIT.
*         WHEN 12.                     &quot;cancel edit
**          RAISE MISSING_CORR_NUMBER.
*           CLO_RETURN = 8. EXIT.
*       ENDCASE.
*     ENDIF.
*   ELSEIF CLO_DDERR-ERRNUM EQ &apos;17&apos; OR &quot;no TADIR or
*          CLO_DDERR-ERRNUM EQ &apos;18&apos;.   &quot;missing devclass
*     IF CLO_DDERR-ERRNUM EQ &apos;17&apos;.
*       MESSAGE S133(SV). &quot;Bitte Transporteigenschaften eingeben
*     ELSE.
*       MESSAGE S486(TK) WITH CLO_TADIR-DEVCLASS.
*     ENDIF.
*     CLO_TADIR-PGMID    = CLO_E071-PGMID.
*     CLO_TADIR-OBJECT   = CLO_E071-OBJECT.
*     CLO_TADIR-OBJ_NAME = CLO_E071-OBJ_NAME.
*     CALL FUNCTION &apos;TADIR_PFLEGE&apos;
*          EXPORTING
*               ADIR      = CLO_TADIR
*               E71TEMP   = CLO_E071
*               START_ROW = 2
*          IMPORTING
*               NEWADIR   = CLO_TADIR
*               PDDERR    = CLO_DDERR
*          EXCEPTIONS
*               ILL_TYPE  = 01.
*     IF SY-SUBRC NE 0.
*       MESSAGE I095(SV) WITH E071-TRKORR. &quot;Systemfehler
**      RAISE MISSING_CORR_NUMBER.
*       CLO_RETURN = 8. EXIT.
*     ENDIF.
*     IF CLO_DDERR-SEVERITY EQ &apos;F&apos;.
*       CASE CLO_DDERR-ERRNUM.
*         WHEN 4.                      &quot;display
**          MAINT_MODE = STATUS-ACTION = ANZEIGEN.
**          EXIT.
*           CLO_RETURN = 4. &lt;STATUS&gt;-CORR_NBR = VIM_LOCKED_IN_CORR.
*           EXIT.
*         WHEN 12.                     &quot;cancel edit
**          RAISE MISSING_CORR_NUMBER.
*           CLO_RETURN = 8. EXIT.
*       ENDCASE.
*     ELSE.
*       CALL FUNCTION &apos;TRINT_CHANGE_TADIR_MASTERLANG&apos;
*            EXPORTING
*                 WI_TADIR_PGMID               = CLO_TADIR-PGMID
*                 WI_TADIR_OBJECT              = CLO_TADIR-OBJECT
*                 WI_TADIR_OBJ_NAME            = CLO_TADIR-OBJ_NAME
*                 WI_TADIR_MASTERLANG          = SY-LANGU
*            EXCEPTIONS
*                 MASTERLANG_NOT_ALLOWED       = 1.
*       IF SY-SUBRC NE 0. &quot;language not allowed
*         MESSAGE ID SY-MSGID TYPE &apos;I&apos; NUMBER SY-MSGNO
*           WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
*       ENDIF.
*     ENDIF.
*   ELSE.  &quot;other problems in MCOMM....
*     MESSAGE ID SY-MSGID TYPE &apos;I&apos; NUMBER SY-MSGNO
*             WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
**    MESSAGE I733(TK).
*     IF CLO_DDERR-ERRNUM EQ &apos;4&apos;.   &quot;display
*       CLO_RETURN = 4. &lt;STATUS&gt;-CORR_NBR = VIM_LOCKED_IN_CORR.
*       EXIT.
*     ELSE.                         &quot;cancel
*       CLO_RETURN = 8. EXIT.
*     ENDIF.
**    MESSAGE I095(SV) WITH E071-TRKORR. &quot;Systemfehler
**    RAISE MISSING_CORR_NUMBER.
*   ENDIF.                             &quot; clo_dderr-errnum in ( 17, 18 )
* ENDIF.                               &quot;clo_dderr-severity eq &apos;F&apos;
* first check if devclass is ok
* SELECT SINGLE * FROM TADIR INTO CLO_TADIR &quot;already done in MCOMMEDITCH
*                            WHERE PGMID    = CLO_E071-PGMID
*                              AND OBJECT   = CLO_E071-OBJECT
*                              AND OBJ_NAME = CLO_E071-OBJ_NAME.
* IF TADIR-DEVCLASS(1) EQ &apos;$&apos;. &quot;local object -&gt; no transport
  IF CLO_TADIR IS INITIAL.             &quot;may be no lockable object?
    CALL FUNCTION &apos;TR_CHECK_OBJECT_LOCK&apos;
         EXPORTING
              WI_OBJECT                  = CLO_E071-OBJECT
              WI_OBJNAME                 = CLO_E071-OBJ_NAME
              WI_PGMID                   = CLO_E071-PGMID
         IMPORTING
              WE_LOCKABLE_OBJECT         = CLO_LOCKABLE
              WE_LOCKED                  = CLO_LOCKED
              WE_LOCK_TASK               = CLO_LOCK_TASK
              WE_LOCK_TASK_USER          = CLO_LOCK_USER
              WE_LOCK_ORDER              = CLO_LOCK_ORDER
              WE_OBJECT_EDITABLE         = CLO_EDITABLE
* 4.0 Namesp. WE_POSSIBLE_USER_EDIT_TASK = CLO_TADIR-KORRNUM
              WE_POSSIBLE_USER_EDIT_TASK = CLO_ICORR
         EXCEPTIONS
              EMPTY_KEY                  = 01
              NO_SYSTEMNAME              = 02
              NO_SYSTEMTYPE              = 03
              UNALLOWED_LOCK_ORDER       = 04.
    IF SY-SUBRC NE 0.
      MESSAGE I095(SV) WITH E071-TRKORR. &quot;Systemfehler
*     RAISE MISSING_CORR_NUMBER.
      CLO_RETURN = 8. EXIT.
    ENDIF.
    IF CLO_LOCKABLE EQ SPACE.          &quot;yes no lockable object
      VIM_CORR_OBJTAB-LOCKABLE = SPACE.
      MODIFY VIM_CORR_OBJTAB.
      EXIT.
    ELSE.                              &quot;inconsistent object.
      MESSAGE I095(SV) WITH E071-TRKORR. &quot;Systemfehler
      CLO_RETURN = 8. EXIT.
    ENDIF.
  ENDIF.                               &quot;clo_tadir is initial
  CALL FUNCTION &apos;VIEW_GET_DEVCLASS_STATE&apos;
       EXPORTING
            DEV_CLASS          = CLO_TADIR-DEVCLASS
       IMPORTING
            TRANSPORT_POSSIBLE = CLO_TRANSPORTABLE
       EXCEPTIONS
            NOT_FOUND          = 01.
  IF CLO_TRANSPORTABLE EQ SPACE.       &quot;local object -&gt; no transport
    X_HEADER-FLAG = VIM_TRANSPORT_DENIED.
    MODIFY X_HEADER INDEX 1.
  ELSE.
* second check if all objects have valid source systems
    IF VIM_LAST_SOURCE_SYSTEM EQ SPACE.
      VIM_LAST_SOURCE_SYSTEM = CLO_TADIR-SRCSYSTEM.
    ELSE.
      IF CLO_TADIR-SRCSYSTEM EQ SY-SYSID.    &quot;if one object has sy-sysid
        IF VIM_LAST_SOURCE_SYSTEM NE SY-SYSID.&quot;all objs must have sy-sys
          MESSAGE I134(SV). &quot;Inkonsistenz in Objektdefinition, nur Anzei
*       MAINT_MODE = STATUS-ACTION = ANZEIGEN.
*       EXIT.
          CLO_RETURN = 4. &lt;STATUS&gt;-CORR_NBR = VIM_LOCKED_IN_CORR. EXIT.
        ENDIF.
      ELSE. &quot;if one object has another source system, all objects must
        IF VIM_LAST_SOURCE_SYSTEM EQ SY-SYSID. &quot;another source system
          MESSAGE I134(SV). &quot;Inkonsistenz in Objektdefinition, nur Anzei
*       MAINT_MODE = STATUS-ACTION = ANZEIGEN.
*       EXIT.
          CLO_RETURN = 4. &lt;STATUS&gt;-CORR_NBR = VIM_LOCKED_IN_CORR. EXIT.
        ENDIF.
      ENDIF.
    ENDIF.
    CALL FUNCTION &apos;TR_CHECK_OBJECT_LOCK&apos;
         EXPORTING
              WI_OBJECT                  = CLO_E071-OBJECT
              WI_OBJNAME                 = CLO_E071-OBJ_NAME
              WI_PGMID                   = CLO_E071-PGMID
         IMPORTING
              WE_LOCKABLE_OBJECT         = CLO_LOCKABLE
              WE_LOCKED                  = CLO_LOCKED
              WE_LOCK_TASK               = CLO_LOCK_TASK
              WE_LOCK_TASK_USER          = CLO_LOCK_USER
              WE_LOCK_ORDER              = CLO_LOCK_ORDER
              WE_OBJECT_EDITABLE         = CLO_EDITABLE
* 4.0 Namesp. WE_POSSIBLE_USER_EDIT_TASK = CLO_TADIR-KORRNUM
              WE_POSSIBLE_USER_EDIT_TASK = CLO_ICORR
         EXCEPTIONS
              EMPTY_KEY                  = 01
              NO_SYSTEMNAME              = 02
              NO_SYSTEMTYPE              = 03
              UNALLOWED_LOCK_ORDER       = 04.
    IF SY-SUBRC NE 0.
      MESSAGE I095(SV) WITH E071-TRKORR. &quot;Systemfehler
*     RAISE MISSING_CORR_NUMBER.
      CLO_RETURN = 8. EXIT.
    ENDIF.
    IF CLO_LOCKABLE EQ SPACE.
      VIM_CORR_OBJTAB-LOCKABLE = SPACE.
      MODIFY VIM_CORR_OBJTAB.
      EXIT.
    ENDIF.
    IF CLO_LOCKED NE SPACE.
      IF CLO_EDITABLE EQ SPACE.
        MESSAGE I132(SV) WITH CLO_LOCK_TASK CLO_LOCK_USER.
*       MAINT_MODE = STATUS-ACTION = ANZEIGEN.
*       EXIT.
        CLO_RETURN = 4. &lt;STATUS&gt;-CORR_NBR = VIM_LOCKED_IN_CORR. EXIT.
      ELSE.
*       CLO_E071-TRKORR = CLO_TADIR-KORRNUM.   &quot;4.0 Namespace
        CLO_E071-TRKORR = CLO_ICORR.   &quot;4.0 Namespace
      ENDIF.
    ENDIF.                             &quot;clo_locked
  ENDIF.                               &quot;devclass
  IF &lt;STATUS&gt;-CORR_NBR NE SPACE AND CLO_E071-TRKORR NE SPACE.
    IF CLO_E071-TRKORR NE &lt;STATUS&gt;-CORR_NBR.
      IF &lt;STATUS&gt;-ORDER_NBR NE CLO_LOCK_ORDER.
        MESSAGE I129(SV). &quot;Zusammengehörige Objekte in verschied
*       RAISE MISSING_CORR_NUMBER.
        CLO_RETURN = 4. &lt;STATUS&gt;-CORR_NBR = VIM_LOCKED_IN_CORR. EXIT.
      ENDIF.
      VIM_CORR_OBJTAB-TRKORR = CLO_E071-TRKORR.
      MODIFY VIM_CORR_OBJTAB.
    ENDIF.
  ELSE.
    IF &lt;STATUS&gt;-CORR_NBR EQ SPACE.
      &lt;STATUS&gt;-CORR_NBR = CLO_E071-TRKORR.
      &lt;STATUS&gt;-ORDER_NBR = CLO_LOCK_ORDER.
    ENDIF.
  ENDIF.
  TRANSLATE &lt;STATUS&gt;-TR_ALRCHKD USING &apos; x&apos;.
  CLEAR CLO_RETURN.
ENDFORM.                               &quot;check_lockable_object</include_source>
   </include>
   <include NAME="LSVIMF20" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000008" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122432" IDATE="20080721" ITIME="122432">
    <include_source>*---------------------------------------------------------------------*
*       FORM REQUEST_CORR_NUMBER                                      *
*---------------------------------------------------------------------*
*       request correction number                                     *
*---------------------------------------------------------------------*
FORM request_corr_number.
  DATA: rc LIKE sy-subrc, e071_safe LIKE e071.

  CHECK maint_mode EQ transportieren.  &quot;manual transport mode
  IF &lt;status&gt;-l_corr_nbr NE space.
    IF &lt;status&gt;-corr_nbr NE &lt;status&gt;-l_corr_nbr.
      CLEAR: &lt;status&gt;-tr_alrchkd, &lt;status&gt;-corr_enqud.
    ELSE.
      IF vim_external_mode EQ space.
        TRANSLATE &lt;status&gt;-tr_alrchkd USING &apos;Xx&apos;.
      ENDIF.
    ENDIF.
  ENDIF.
  PERFORM vim_get_img_activity CHANGING e071-activity.  &quot;UF738595/2001
  IF vim_corr_obj_viewname NE x_header-viewname.
    CLEAR e071-trkorr.
    PERFORM get_transp_info.
    CHECK x_header-flag NE vim_transport_denied.
    CHECK vim_actopts-transp_off NE bc_transport_denied.
  ENDIF.
  IF &lt;status&gt;-tr_alrchkd EQ space.
* first get corr nbr for lockable transport objects
    e071_safe = e071.
    CLEAR vim_last_source_system.
    LOOP AT vim_corr_objtab WHERE lockable NE space.
      e071 = vim_corr_objtab.
      PERFORM check_lockable_object USING e071 rc.
      CASE rc.
        WHEN 4. maint_mode = anzeigen.
        WHEN 8. RAISE missing_corr_number.
      ENDCASE.
      IF maint_mode EQ anzeigen OR
         x_header-flag EQ vim_transport_denied OR
         vim_actopts-transp_off EQ bc_transport_denied.
        EXIT.
      ENDIF.
    ENDLOOP.
    e071 = e071_safe.
  ENDIF.                               &quot;&lt;status&gt;-tr_alrchkd eq space
  CHECK maint_mode NE anzeigen AND
        x_header-flag NE vim_transport_denied AND
        vim_actopts-transp_off NE bc_transport_denied.
  vim_corr_obj_viewname = x_header-viewname.
  IF &lt;status&gt;-corr_nbr NE space AND    &quot;task specified and...
     corr_nbr EQ space AND          &quot;...task not setted by caller and...
     &lt;status&gt;-corr_enqud EQ space.     &quot;...corr not yet enqueued
    CALL FUNCTION &apos;ENQUEUE_E_TRKORR&apos;
         EXPORTING
              trkorr = &lt;status&gt;-corr_nbr
*               X_TRKORR = E02
         EXCEPTIONS
              foreign_lock = 01
              system_failure = 02.
    CASE sy-subrc.
      WHEN 1.
        MESSAGE s092(sv) WITH &lt;status&gt;-corr_nbr. &quot;Korr. wird ger.bearb.
      WHEN 2.
        MESSAGE a095(sv) WITH &lt;status&gt;-corr_nbr. &quot;Systemfehler
    ENDCASE.
    &lt;status&gt;-corr_enqud = &apos;X&apos;.
  ENDIF.
* if no lockable objects exist get corr nbr for other objects...
* but only if objects exist....
  DESCRIBE TABLE vim_corr_objtab.
  IF &lt;status&gt;-corr_nbr EQ space AND sy-tfill GT 0.
    DO.
      CALL FUNCTION &apos;TR_ORDER_CHOICE_CORRECTION&apos;
           EXPORTING
                iv_category            = objh-objcateg
                iv_cli_dep             = objh-clidep
           IMPORTING
                ev_order               = &lt;status&gt;-order_nbr
                ev_task                = &lt;status&gt;-corr_nbr
           EXCEPTIONS
                invalid_category       = 01
                no_correction_selected = 02.
      CASE sy-subrc.
        WHEN 1.
          IF objh-objcateg NE vim_syst AND objh-objcateg NE vim_cust.
            CASE objh-objcateg.
              WHEN vim_cust_syst. objh-objcateg = vim_syst.
              WHEN vim_appl.      objh-objcateg = vim_syst.
              WHEN OTHERS.
                MESSAGE ID     sy-msgid
                        TYPE   &apos;I&apos;
                        NUMBER sy-msgno
                        WITH sy-msgv1 sy-msgv2  sy-msgv3 sy-msgv4.
                RAISE missing_corr_number.
            ENDCASE.
            CONTINUE.
          ENDIF.
        WHEN 2.
          CLEAR vim_corr_obj_viewname.
          RAISE missing_corr_number.
      ENDCASE.
      CALL FUNCTION &apos;ENQUEUE_E_TRKORR&apos;
           EXPORTING
                trkorr = &lt;status&gt;-corr_nbr
*               X_TRKORR = E02
           EXCEPTIONS
                foreign_lock = 01
                system_failure = 02.
      CASE sy-subrc.
*       WHEN 0.
        WHEN 1.
          MESSAGE s092(sv) WITH &lt;status&gt;-corr_nbr. &quot;Korr. wirdger.bearb.
          CONTINUE.
        WHEN 2.
          MESSAGE a095(sv) WITH &lt;status&gt;-corr_nbr. &quot;Systemfehler
          CONTINUE.
      ENDCASE.
      IF ( last_corr_number NE space AND
           &lt;status&gt;-corr_nbr NE last_corr_number ) OR
         &lt;status&gt;-tr_alrchkd EQ space.
        LOOP AT corr_keytab.             &quot;UF 514599/1999beg
          READ TABLE vim_corr_objtab
           WITH KEY pgmid    = corr_keytab-pgmid
           object   = corr_keytab-object obj_name = corr_keytab-objname.
          CHECK sy-subrc = 0 AND vim_corr_objtab-lockable = space.
* new corrnumber for unlockable objects only
          CLEAR vim_corr_objtab-trkorr.
* will be filled again in form PREPARE_CORR
          MODIFY vim_corr_objtab INDEX sy-tabix.
        ENDLOOP.                       &quot;UF 514599/1999end
        REFRESH corr_keytab.
        MOVE &lt;status&gt;-corr_nbr TO last_corr_number.
      ELSEIF last_corr_number EQ space.
        LOOP AT corr_keytab WHERE
                                ( mastertype EQ vim_unlockable_object OR
                                  mastertype EQ vim_lockable_object ).
*                           AND TRKORR EQ SPACE.
* SW: bei TRSP -&gt; neue Korrnummer, alte blieb aber in CORR_KEYTAB-TRKORR
          IF  corr_keytab-trkorr EQ space.
            corr_keytab-trkorr = &lt;status&gt;-corr_nbr.
            MODIFY corr_keytab.
          ELSE.                        &quot;SW ..
            READ TABLE vim_corr_objtab
                    WITH KEY pgmid    = corr_keytab-pgmid
                             object   = corr_keytab-object
                             obj_name = corr_keytab-objname.
            IF sy-subrc = 0.
              corr_keytab-trkorr = &lt;status&gt;-corr_nbr.
              MODIFY corr_keytab.
            ENDIF.
          ENDIF.                       &quot;.. SW
        ENDLOOP.
      ENDIF.
      EXIT.
    ENDDO.
    &lt;status&gt;-corr_enqud = &apos;X&apos;.
  ENDIF.                               &quot;&lt;status&gt;-corr_nbr eq space
  MOVE: &lt;status&gt;-corr_nbr TO e071k-trkorr,
        &lt;status&gt;-corr_nbr TO e071-trkorr,
        &lt;status&gt;-corr_nbr TO e070-trkorr.
  TRANSLATE &lt;status&gt;-tr_alrchkd USING &apos; x&apos;.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF21" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000010" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122432" IDATE="20080721" ITIME="122432">
    <include_source>*---------------------------------------------------------------------*
*       FORM GET_TRANSP_INFO                                          *
*---------------------------------------------------------------------*
* get client state and transport objects                              *
*---------------------------------------------------------------------*
FORM get_transp_info.
  LOCAL: e071.
  DATA: obj_type LIKE objh-objecttype, last_category LIKE objh-objcateg,
        last_clidep LIKE objh-clidep VALUE &apos;X&apos;, gti_e071 LIKE e071,
        last_protect LIKE objh-protect, gti_cliindep_state(1) TYPE c,
        gti_x030l LIKE x030l,
        gti_tabname TYPE tabname,
        gti_client_role LIKE t000-cccategory,
        gti_flag_safe(1) TYPE c,
        cursetting TYPE cursetting, addr_e071k LIKE e071k,
        importable TYPE objimp value &apos;4&apos;,
        tr_result LIKE trpari-s_checked,
        addr_e071k2 LIKE e071k.

* check if logging of changes is necessary
  gti_flag_safe = x_header-flag.
  IF x_header-customauth CO no_transport_classes.&quot;transport impossible
    x_header-flag = vim_transport_denied. &quot;no standard logging
    CLEAR: x_header-frm_e071,          &quot;no individual transport
           x_header-frm_e071ks,
           x_header-frm_e071ka.
    IF maint_mode EQ aendern.
      MOVE &apos;TRSP&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
    ELSEIF maint_mode EQ transportieren.
      MESSAGE i128(sv) WITH &quot;Auslieferungsklasse &amp;, kein Transport mög
              x_header-customauth.
      RAISE missing_corr_number.
    ENDIF.
    MOVE &apos;ORDR&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
    sy-subrc = 9.
  ELSEIF x_header-customauth CO no_transport_log_classes.
    IF x_header-frm_e071 EQ space AND x_header-frm_e071ks EQ space AND
       x_header-frm_e071ka EQ space.   &quot;no individual transport routines
      x_header-flag = vim_transport_denied. &quot;no transport
      IF maint_mode EQ aendern.
        MOVE &apos;TRSP&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
      ELSEIF maint_mode EQ transportieren.
        MESSAGE i128(sv) WITH &quot;Auslieferungsklasse &amp;, kein Transport mög
                x_header-customauth.
        RAISE missing_corr_number.
      ENDIF.
      MOVE &apos;ORDR&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
    ELSE.
      x_header-flag = &apos;X&apos;.             &quot;no standard logging
    ENDIF.
    sy-subrc = 9.
  ENDIF.
  IF sy-subrc EQ 9.
    MODIFY x_header INDEX 1.
  ENDIF.
*&lt;&lt;&lt; Übergangslösung Transportstatus des Mandanten Anfang
* check if client allows transport
  CALL FUNCTION &apos;VIEW_GET_CLIENT_STATE&apos;
    IMPORTING
      transp_state   = vim_client_state
      cliindep_state = gti_cliindep_state
      client_state   = gti_client_role.
  IF x_header-clidep NE space AND      &quot;clientdependent and
     x_header-customauth CN sap_only_classes. &quot;not delclass `S`
    CASE vim_client_state.
      WHEN vim_local_clnt. &quot;client is local -&gt; transport denied
        IF maint_mode EQ aendern OR maint_mode EQ anzeigen.
          excl_cua_funct-function = &apos;TRSP&apos;. COLLECT excl_cua_funct.
          excl_cua_funct-function = &apos;ORDR&apos;. COLLECT excl_cua_funct.
          x_header-flag = vim_transport_denied.
        ELSE.
          MESSAGE i130(sv) WITH &quot;Mandant ist lokal, keine Transporte m
                  sy-mandt.
          RAISE missing_corr_number.
        ENDIF.
      WHEN vim_locked. &quot;client is locked -&gt; no changes but transport
*       IF MAINT_MODE EQ AENDERN.  &quot;only for CUST/CUSY objects!!!!!!
*         MESSAGE I430(TK) WITH SY-MANDT.&quot;Mandant &amp;1 &apos;nicht änderbar&apos;
*         MAINT_MODE = STATUS-ACTION = ANZEIGEN.
*         EXIT.
*       ENDIF.
    ENDCASE.
  ELSE. &quot;clientindependent or deliveryclass &apos;S&apos;
    vim_client_state = vim_log.        &quot;such objects always log
  ENDIF.                               &quot;xheader-clidep ne space.
*&lt;&lt;&lt; Übergangslösung Transportstatus des Mandanten Ende
* if transport allowed -&gt; get transport objects
  REFRESH vim_corr_objtab.
  gti_e071 = e071.
  IF x_header-frm_e071 NE space.       &quot;individual transport objects
    PERFORM (x_header-frm_e071) IN PROGRAM (sy-repid).
  ENDIF.
  IF gti_flag_safe EQ space.                                &quot;240997
* automatic recording of changes switched on in SE54
    APPEND gti_e071 TO vim_corr_objtab.
    IF x_header-adrnbrflag EQ &apos;N&apos;.     &quot;new version of addresses used
* addresses
      REFRESH: vim_addr_e071k_tab, vim_addr_e071_tab.
      CALL FUNCTION &apos;ADDR_TRANSPORT_TDAT_ENTRIES&apos;
        TABLES
          e071k_tab = vim_addr_e071k_tab.
      addr_e071k2 = e071k.
      LOOP AT vim_addr_e071k_tab INTO addr_e071k.
        gti_e071-object = addr_e071k2-mastertype
         = addr_e071k-mastertype.
        gti_e071-obj_name = addr_e071k2-mastername
         = addr_e071k-mastername.
        APPEND gti_e071 TO vim_addr_e071_tab.
        APPEND gti_e071 TO vim_corr_objtab.
        MODIFY vim_addr_e071k_tab FROM addr_e071k2.
      ENDLOOP.
    ENDIF.
  ELSEIF x_header-frm_e071 EQ space AND    &quot;no individual transport
         x_header-frm_e071ks EQ space AND  &quot;routines and no standard
         x_header-frm_e071ka EQ space.
* no events concerning change recording are used
    APPEND gti_e071 TO vim_corr_objtab.    &quot;but check cliiendep settings
    x_header-flag = vim_transport_denied. MODIFY x_header INDEX 1.
    IF maint_mode EQ aendern.
      MOVE &apos;TRSP&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
    ENDIF.
    MOVE &apos;ORDR&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
    gti_flag_safe = &apos;@&apos;.
  ENDIF.
* get object category and client dependency for transport objects
  LOOP AT vim_corr_objtab.
    CASE vim_corr_objtab-object.
      WHEN vim_view_type.              &quot;-&gt; view
        obj_type = vim_view.
      WHEN transp_object.              &quot;-&gt; tables
        obj_type = vim_tabl.
      WHEN vim_tran_type.              &quot;-&gt; individual transaction
        obj_type = vim_tran.
      WHEN vim_clus_type.           &quot;-&gt; cluster of views/tables/clusters
        obj_type = vim_clst.
      WHEN OTHERS.                     &quot;-&gt; may be: TLOGO object ?
        obj_type = vim_logo.
    ENDCASE.
    IF obj_type NE vim_logo.
      SELECT SINGLE * FROM objh
                      WHERE objectname EQ vim_corr_objtab-obj_name
                        AND objecttype EQ obj_type. &quot;#EC CI_GENBUFF
    ELSE. &quot;TLOGO -&gt; use obj type as obj name
      SELECT SINGLE * FROM objh
                      WHERE objectname EQ vim_corr_objtab-object
                        AND objecttype EQ obj_type. &quot;#EC CI_GENBUFF
    ENDIF.
    IF sy-subrc NE 0.
      IF obj_type NE vim_logo. &quot;set defaults for table transp. obj.
        IF x_header-viewname EQ vim_corr_objtab-obj_name AND
           ( x_header-bastab EQ space AND
             vim_corr_objtab-object EQ vim_view_type OR
             x_header-bastab NE space AND
             vim_corr_objtab-object EQ transp_object ) OR
           vim_called_by_cluster NE space AND
           vim_calling_cluster EQ vim_corr_objtab-obj_name AND
           vim_corr_objtab-object EQ vim_clus_type.
          IF x_header-clidep EQ space. &quot;clientindependent
            IF x_header-customauth CO customizing_delivery_classes.
              objh-objcateg = vim_cust_syst.
            ELSEIF x_header-customauth CO sap_only_classes.
              objh-objcateg = vim_syst.
            ELSEIF x_header-customauth CO application_delivery_classes.
              objh-objcateg = vim_appl.
            ELSE.
              objh-objcateg = vim_syst.
            ENDIF.
          ELSE.                        &quot;clientdependent
            IF x_header-customauth CO customizing_delivery_classes.
              objh-objcateg = vim_cust.
            ELSEIF x_header-customauth CO sap_only_classes.
              objh-objcateg = vim_cust_syst.
            ELSEIF x_header-customauth CO application_delivery_classes.
              objh-objcateg = vim_appl.
            ELSE.
              objh-objcateg = vim_syst.
            ENDIF.
          ENDIF.
          objh-clidep   = x_header-clidep.
        ELSE.           &quot;unknown object -&gt; check if clientdep. table
          IF vim_corr_objtab-object EQ transp_object. &quot;table
            gti_tabname = vim_corr_objtab-obj_name.
            CALL FUNCTION &apos;DDIF_NAMETAB_GET&apos;
              EXPORTING
                tabname   = gti_tabname
              IMPORTING
                x030l_wa  = gti_x030l
              EXCEPTIONS
                not_found = 1
                OTHERS    = 2.
            IF sy-subrc EQ 0 AND gti_x030l-flagbyte O vim_clidep.
              objh-objcateg = vim_cust.&quot;clientdependent table
              objh-clidep   = &apos;X&apos;.
            ELSE.                      &quot;no nametab or clientindependent
              objh-objcateg = vim_syst.
              objh-clidep   = space.
            ENDIF.
          ELSE.                        &quot;unknown object -&gt; syst
            objh-objcateg = vim_syst.
            objh-clidep   = space.
          ENDIF.
        ENDIF.
      ELSE. &quot;vim_logo                  &quot;no objh-object -&gt; syst
        objh-objcateg = vim_syst.
        objh-clidep   = space.
* note lockable transport object
        vim_corr_objtab-lockable = &apos;X&apos;.
        MODIFY vim_corr_objtab.
      ENDIF.                           &quot;obj_type ne vim_logo
    ELSE.
* entry in OBJH found -&gt; check current setting, importability,
* protect-flag
      IF objh-cursetting &lt;&gt; space.           &quot;UF615995/2000b
        cursetting = objh-cursetting.
      ENDIF.                                 &quot;UF615995/2000e
      IF objh-importable &lt;&gt; space
       AND objh-importable &lt; importable.     &quot;#EC PORTABLE
* &quot;most unimportable&quot; object sets standard
        importable = objh-importable.
      ENDIF.
      IF objh-protect NE space.
        IF objh-objectname EQ x_header-viewname AND &quot;current VIM object
           ( x_header-bastab EQ space AND objh-objecttype EQ vim_view OR
             x_header-bastab NE space AND objh-objecttype EQ vim_tabl ).
          IF x_header-frm_e071 EQ space AND
             x_header-frm_e071ks EQ space AND
             x_header-frm_e071ka EQ space. &quot;no individ. transp. routines
            x_header-flag = vim_transport_denied. &quot;no transport
            MOVE &apos;TRSP&apos; TO excl_cua_funct-function.
            COLLECT excl_cua_funct.
            MOVE &apos;ORDR&apos; TO excl_cua_funct-function.
            COLLECT excl_cua_funct.
*           EXIT.                                         &quot;240997
          ELSE.
            x_header-flag = &apos;X&apos;.       &quot;no standard logging
            DELETE vim_corr_objtab.
          ENDIF.
          MODIFY x_header INDEX 1.
        ENDIF. &quot;curr. VIM obj./ignore added individual transport objects
      ENDIF.                           &quot;protect ne space
*     IF OBJH-OBJECTTYPE EQ VIM_LOGO.
* note object as lockable transport object until TR_OBJECTS_* force
* TLOGO-objects too  &quot;changed in 4.0
      IF objh-checkid EQ &apos;L&apos;.          &quot;note lockable object!
        vim_corr_objtab-lockable = &apos;X&apos;.
        MODIFY vim_corr_objtab.
      ENDIF.
    ENDIF.                             &quot;sy-subrc ne 0.
    IF ( objh-objcateg EQ vim_syst OR
         objh-objcateg EQ vim_cust_syst ) AND
       last_category NE vim_syst.
      last_category = objh-objcateg.
    ENDIF.
    IF objh-clidep EQ space.
      last_clidep = objh-clidep.
    ENDIF.
  ENDLOOP.
* IF SY-SUBRC NE 0.  &quot;may be user exits.....
  IF sy-subrc NE 0.
    IF ( x_header-frm_e071 NE space OR
       x_header-frm_e071ks EQ space AND x_header-frm_e071ka EQ space ).
      x_header-flag = vim_transport_denied. MODIFY x_header INDEX 1.
      IF maint_mode EQ aendern.
        MOVE &apos;TRSP&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
      ENDIF.
      MOVE &apos;ORDR&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
    ENDIF.
    EXIT. &quot;if no object could be determined exit this routine
  ELSEIF gti_flag_safe EQ &apos;@&apos;.         &quot;temporaryly appended
    REFRESH vim_corr_objtab.
  ENDIF.
* CHECK X_HEADER-FLAG NE VIM_TRANSPORT_DENIED.             &quot;240997
  IF objh-objcateg NE vim_syst AND
     ( last_category EQ vim_syst OR
       last_category EQ vim_cust_syst ).
    objh-objcateg = last_category.
  ENDIF.
  objh-clidep = last_clidep.
* no logging for settings in productive clients
  IF cursetting NE space.
    x_header-cursetting = x_header-flag.
    TRANSLATE x_header-cursetting USING &apos; XXY&apos;.
    MODIFY x_header INDEX 1.
  ENDIF.
* put importable-flag into x_header.
  IF importable &lt;&gt; 4.
    x_header-importable = importable.
    MODIFY x_header INDEX 1.
  ENDIF.
  IF maint_mode EQ aendern AND objh-clidep NE space AND
     cursetting NE space AND gti_client_role EQ &apos;P&apos;.
    x_header-flag = vim_transport_denied. MODIFY x_header INDEX 1.
    MOVE &apos;ORDR&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
    EXIT.                                                   &quot;240997
  ENDIF.
* CHECK X_HEADER-FLAG NE VIM_TRANSPORT_DENIED.          &quot;240997
  IF x_header-flag NE vim_transport_denied AND
     vim_actopts-transp_off NE bc_transport_denied AND
     vim_client_state EQ vim_locked AND
     ( objh-objcateg EQ vim_cust OR objh-objcateg EQ vim_cust_syst ) AND
     maint_mode EQ aendern.            &quot;only for CUST/CUSY objects!!!!!!
    MESSAGE i430(tk) WITH sy-mandt.    &quot;Mandant &amp;1 &apos;nicht änderbar&apos;
    maint_mode = status-action = anzeigen.
    ASSIGN dba_sellist-*sys* TO &lt;vim_sellist&gt;.
    vim_enqueue_range = x_header-subsetflag.
    PERFORM enqueue
                USING
                    &apos;D&apos;
                    space.
    EXIT.
  ENDIF.
  CASE gti_cliindep_state.
    WHEN vim_noact.
    WHEN vim_nocliindep_cust.
      IF maint_mode EQ aendern AND objh-objcateg = vim_cust_syst.
        CHECK x_header-flag NE vim_transport_denied.
        CHECK vim_actopts-transp_off NE bc_transport_denied.
        MESSAGE i731(tk).              &quot; WITH SY-MANDT.
        maint_mode = status-action = anzeigen.
        ASSIGN dba_sellist-*sys* TO &lt;vim_sellist&gt;.
        vim_enqueue_range = x_header-subsetflag.
        PERFORM enqueue
                    USING
                        &apos;D&apos;
                        space.
        vim_client_state = vim_noact. EXIT.
      ENDIF.
    WHEN vim_noreposiandcust.
      IF maint_mode EQ aendern AND
       ( objh-objcateg = vim_syst OR objh-objcateg = vim_cust_syst ).
        CHECK x_header-flag NE vim_transport_denied.
        CHECK vim_actopts-transp_off NE bc_transport_denied.
        MESSAGE i730(tk).              &quot; WITH SY-MANDT.
        maint_mode = status-action = anzeigen.
        ASSIGN dba_sellist-*sys* TO &lt;vim_sellist&gt;.
        vim_enqueue_range = x_header-subsetflag.
        PERFORM enqueue
                    USING
                        &apos;D&apos;
                        space.
        vim_client_state = vim_noact. EXIT.
      ENDIF.
    WHEN vim_noreposichanges.
      LOOP AT vim_corr_objtab INTO e071.
        CALL FUNCTION &apos;TR_CHECK_TYPE&apos;
          EXPORTING
            wi_e071   = e071
          IMPORTING
            pe_result = tr_result.
*  PE_RESULT        syntax  transport  TADIR     TLOCK
*           SPACE     -         -        -         -
*             S       X         -        -         -
*             R       X         X        -         -
*             T       X         X        X         -  (only for sapsccs)
*             L       X         X        X         X
*             P     system object or illegal name selection
*                   (T100, SAPL...., ... )
* no repository object and not lockable?
        IF &apos;TLP&apos; CS tr_result.
          MESSAGE i729(tk).              &quot;WITH SY-MANDT.
          IF x_header-flag NE vim_transport_denied AND
             vim_actopts-transp_off NE bc_transport_denied.
            maint_mode = status-action = anzeigen.
            ASSIGN dba_sellist-*sys* TO &lt;vim_sellist&gt;.
            vim_enqueue_range = x_header-subsetflag.
            PERFORM enqueue
                        USING
                            &apos;D&apos;
                            space.
            vim_client_state = vim_noact.
          ENDIF.
          EXIT.
        ENDIF.
      ENDLOOP.
  ENDCASE.
ENDFORM.                               &quot;get_transp_info</include_source>
   </include>
   <include NAME="LSVIMF22" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000002" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122432" IDATE="20080721" ITIME="122432">
    <include_source>*---------------------------------------------------------------------*
*       FORM ORDER_ADMINISTRATION                                     *
*---------------------------------------------------------------------*
* get client state and transport objects                              *
*---------------------------------------------------------------------*
FORM ORDER_ADMINISTRATION.
  DATA: RC LIKE SY-SUBRC.
  IF STATUS-ACTION EQ ANZEIGEN AND
     VIM_CORR_OBJ_VIEWNAME NE X_HEADER-VIEWNAME.
    CLEAR E071-TRKORR.
    PERFORM GET_TRANSP_INFO.
    VIM_CORR_OBJ_VIEWNAME = X_HEADER-VIEWNAME.
  ENDIF.
  IF X_HEADER-FLAG EQ VIM_TRANSPORT_DENIED.
    MESSAGE S001(SV). EXIT.
  ENDIF.
  IF vim_actopts-transp_off EQ bc_transport_denied.
    EXIT. &quot;HCG No message in BC_Set activation mode
  ENDIF.
  DO.
    CALL FUNCTION &apos;TR_TASK_OVERVIEW&apos;
         EXPORTING
              IV_USERNAME      = SY-UNAME
              IV_CATEGORY      = OBJH-OBJCATEG
              IV_CLIENT        = SY-MANDT
         EXCEPTIONS
              INVALID_CATEGORY = 01
              OTHERS           = 02.
    RC = SY-SUBRC.
    IF SY-SUBRC EQ 1 AND
       OBJH-OBJCATEG EQ VIM_CUST_SYST OR OBJH-OBJCATEG EQ VIM_APPL.
      OBJH-OBJCATEG = VIM_SYST.
      CONTINUE.
    ENDIF.
    EXIT.
  ENDDO.
  IF RC NE 0.
    MESSAGE ID      SY-MSGID
            TYPE    &apos;I&apos;
            NUMBER  SY-MSGNO
            WITH    SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.
  CLEAR FUNCTION.
ENDFORM.                               &quot;order_administration</include_source>
   </include>
   <include NAME="LSVIMF23" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000004" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122432" IDATE="20080721" ITIME="122433">
    <include_source>*---------------------------------------------------------------------*
*       FORM ORIGINAL_HOLEN                                           *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM original_holen.
  DATA: count1 TYPE i, count2 TYPE i, count3 TYPE i, sum TYPE i,
        texttab_mod(1) TYPE c.         &quot;SW Texttransl
  IF status-action NE aendern OR status-delete EQ geloescht.
    MESSAGE i001(sv).
    EXIT.
  ENDIF.
  IF status-mode EQ list_bild.
    LOOP AT extract.
      CLEAR texttab_mod.
      CHECK &lt;xmark&gt; EQ markiert.
      ADD 1 TO count1.
      IF x_header-texttbexst &lt;&gt; space. &quot;SW Texttransl
        PERFORM vim_texttab_modif_for_key CHANGING texttab_mod.
      ENDIF.
      IF x_header-bastab NE space AND x_header-texttbexst NE space.
        CHECK &lt;xact&gt; EQ neuer_eintrag OR ( &lt;xact&gt; EQ original AND
              &lt;xact_text&gt; EQ original  AND texttab_mod EQ space ).
      ELSE.
        CHECK &lt;xact&gt; EQ neuer_eintrag OR ( &lt;xact&gt; EQ original
                                     AND texttab_mod EQ space ).
      ENDIF.
      IF &lt;xact&gt; EQ neuer_eintrag.
        ADD 1 TO count2.
      ELSE.
        ADD 1 TO count3.
      ENDIF.
    ENDLOOP.
  ELSE.
    ADD 1 TO count1.
    CASE &lt;xact&gt;.
      WHEN neuer_eintrag.
        ADD 1 TO count2.
      WHEN original.
        CLEAR texttab_mod.
        IF x_header-texttbexst &lt;&gt; space.              &quot;SW Texttransl
          PERFORM vim_texttab_modif_for_key CHANGING texttab_mod.
        ENDIF.
        IF x_header-bastab NE space AND x_header-texttbexst NE space.
*          IF sy-datar EQ space AND &lt;table1&gt; EQ &lt;extract_enti&gt; AND
          IF sy-datar EQ space AND &lt;table1&gt; EQ &lt;vim_extract_struc&gt;
           AND &lt;table1_xtext&gt; EQ &lt;vim_xextract_text&gt;
           AND texttab_mod EQ space.
            ADD 1 TO count3.
          ENDIF.
        ELSE.
*          IF sy-datar EQ space AND &lt;table1&gt; EQ &lt;table2&gt;
          IF sy-datar EQ space AND &lt;table1&gt; EQ &lt;vim_extract_struc&gt;
                               AND texttab_mod EQ space.
            ADD 1 TO count3.
          ENDIF.
        ENDIF.
    ENDCASE.
  ENDIF.
  sum = count2 + count3.
  IF count1 EQ 0.
    MESSAGE s056(sv).
  ELSEIF count1 EQ count2.
    IF count1 EQ 1.
      MESSAGE s057(sv).
      IF status-mode EQ detail_bild.
        CLEAR function.
      ENDIF.
    ELSE.
      MESSAGE s058(sv).
    ENDIF.
  ELSEIF count1 EQ count3.
    IF count1 EQ 1.
      MESSAGE s059(sv).
    ELSE.
      MESSAGE s060(sv).
    ENDIF.
  ELSEIF count1 EQ sum.
    MESSAGE s061(sv) WITH count3 count2.
  ELSE.
    CALL FUNCTION &apos;POPUP_TO_CONFIRM_STEP&apos;
         EXPORTING
              titel     = svim_text_010
              textline1 = svim_text_009
              textline2 = svim_text_011
         IMPORTING
              answer    = answer.
    IF answer EQ &apos;J&apos;.
      IF status-mode EQ list_bild.
        function = &apos;ORGL&apos;.
      ELSE.
        IF &lt;xact&gt; NE original OR texttab_mod NE space.
          function = &apos;ORGD&apos;.
        ELSE.
          answer = &apos;N&apos;.
        ENDIF.
      ENDIF.
      IF answer = &apos;J&apos;.
*       SET SCREEN 0. LEAVE SCREEN.
        vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
      ENDIF.
    ELSE.
      CLEAR function.
    ENDIF.
  ENDIF.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF24" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000010" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122433" IDATE="20080721" ITIME="122433">
    <include_source>*---------------------------------------------------------------------*
*       FORM ADDRESS_MAINTAIN                                         *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM address_maintain.
  DATA: mode, return TYPE i, kz, answer, am_save(1) TYPE c,
        am_pos LIKE sy-fdpos, am_length LIKE sy-fdpos,
        func_name TYPE rs38l_fnam.
  DATA: am_handletab LIKE addr1_dia OCCURS 1 WITH HEADER LINE,
        am_sel LIKE addr1_sel, am_address LIKE addr1_val,
        am_ucomm LIKE sy-ucomm, am_title LIKE sy-title.
  DATA: keytab TYPE TABLE OF vimty_textfield,
        keytab_wa TYPE vimty_textfield,
        am_key TYPE vimty_max_textline.

  FIELD-SYMBOLS: &lt;am_title&gt; TYPE c, &lt;am_key&gt; TYPE c,
                 &lt;am_handle_x&gt; TYPE x,
                 &lt;namtab&gt; TYPE vimnamtab,                        &quot;#EC *
                 &lt;keyfld&gt; TYPE ANY.                             &quot;#EC *

  IF x_header-adrnbrflag EQ space.
    MESSAGE e001(sv).
    EXIT.
  ENDIF.
  IF status-action NE anzeigen AND status-action NE transportieren AND
     adrnbr_roflag EQ space.
    MOVE svim_text_012 TO am_title.    &quot;Adresse bearbeiten
  ELSE.
    MOVE svim_text_017 TO am_title.    &quot;Adresse anzeigen
  ENDIF.
  am_pos = strlen( am_title ).
  am_length = 70 - am_pos.
  ASSIGN am_title+am_pos(am_length) TO &lt;am_title&gt;.
  MOVE &apos;:&apos; TO &lt;am_title&gt;.
  ADD 2 TO am_pos.
  SUBTRACT 2 FROM am_length.
  ASSIGN am_title+am_pos(am_length) TO &lt;am_title&gt;.
  CLEAR am_pos.
  PERFORM vim_external_repr_for_key TABLES keytab
                                    USING &lt;f1_x&gt;.
  LOOP AT keytab INTO keytab_wa.
    CONCATENATE am_key keytab_wa-text INTO am_key SEPARATED BY space.
    am_pos = am_pos + keytab_wa-outplen + 1.
    IF am_pos &gt; am_length. EXIT. ENDIF.
  ENDLOOP.
  IF sy-subrc = 0.
    ASSIGN am_key(am_pos) TO &lt;am_key&gt;.
*  IF x_header-clidep NE space.
*    am_length = x_header-keylen - client_length.
*    ASSIGN &lt;f1&gt;+client_length(am_length) TO &lt;am_key&gt;.
*  ELSE.
*    ASSIGN &lt;f1&gt; TO &lt;am_key&gt;.
*  ENDIF.
    MOVE &lt;am_key&gt; TO &lt;am_title&gt;.
  ENDIF.
  ASSIGN am_handletab-handle TO &lt;am_handle_x&gt; CASTING.
  IF x_header-adrnbrflag EQ &apos;O&apos;.       &quot;use old technique
* Übergangslösung Adressumstellung 3.0F Anfang
    IF &lt;address_number&gt; NE space.
      SELECT adrnr FROM sadr INTO sadr-adrnr
                             WHERE adrnr EQ &lt;address_number&gt;.
        EXIT.
      ENDSELECT.
      IF sy-subrc NE 0.
        CALL FUNCTION &apos;ADDR_CONVERT_ADRC_TO_SADR&apos;
          CHANGING
            address_number = &lt;address_number&gt;.
*     IF &lt;ADDRESS_NUMBER&gt; NE SPACE AND &quot;new address number -&gt; update
*        STATUS-ACTION NE ANZEIGEN AND STATUS-ACTION NE TRANSPORTIEREN.
*       &lt;STATUS&gt;-UPD_FLAG = &apos;X&apos;.
*     ENDIF.  &quot;not necessary, adrnbr will never be changed
      ENDIF.
    ENDIF.
* Übergangslösung Adressumstellung 3.0F Ende
    MOVE &lt;address_number&gt; TO sadr-adrnr.
    kz = space.
   IF status-action NE anzeigen AND status-action NE transportieren AND
             adrnbr_roflag EQ space.
      IF &lt;address_number&gt; EQ space.
        mode = &apos;A&apos;.
      ELSE.
        mode = &apos;M&apos;.
      ENDIF.
      IF status-action EQ kopieren.
        IF &lt;address_number&gt; NE space.
          SELECT * FROM sadr WHERE adrnr EQ &lt;address_number&gt;.
            kz = &apos;X&apos;.
            EXIT.
          ENDSELECT.
        ELSE.
          CLEAR sadr.
        ENDIF.
        CLEAR &lt;address_number&gt;.
        mode = &apos;A&apos;.
      ENDIF.
    ELSE.
      mode = &apos;D&apos;.
    ENDIF.
    func_name = &apos;ADDRESS_MAINTAIN&apos;. &quot;struggling against extended check
    DO.
      CALL FUNCTION func_name
        EXPORTING
          adrswa_in         = sadr
          processing_status = mode
          kennzeichen       = kz
          save_intern       = &apos;X&apos;
          title             = am_title
        IMPORTING
          adrswa_out        = sadr
          returncode        = return
          update_flag       = am_save
        EXCEPTIONS
          not_found         = 4.
      IF sy-subrc NE 0.
        IF status-action NE anzeigen AND
           status-action NE transportieren AND
           adrnbr_roflag EQ space.
          CALL FUNCTION &apos;POPUP_TO_CONFIRM_WITH_MESSAGE&apos;   &quot;#EC *
            EXPORTING
              diagnosetext1 = svim_text_013   &quot;Die Adresse für das
              diagnosetext2 = &lt;am_key&gt;
              diagnosetext3 = svim_text_014 &quot;wurde nicht gefunden.
              textline1     = svim_text_015&quot;Möchten Sie eine neue er
              titel         = svim_text_016&quot;Adresse nicht vorhanden
            IMPORTING
              answer        = answer.
          IF answer EQ &apos;J&apos;.
            mode = &apos;A&apos;.
          ELSE.
            return = 4.
            EXIT.
          ENDIF.
        ELSE.
          MESSAGE i055(sv) WITH &lt;am_key&gt;.
          return = 4.
          EXIT.
        ENDIF.
      ELSE.
        EXIT.
      ENDIF.
    ENDDO.
   IF status-action NE anzeigen AND status-action NE transportieren AND
             adrnbr_roflag EQ space.
      IF return NE 4 AND sadr-adrnr NE &lt;address_number&gt; OR
         am_save NE space. &quot;transport for address changes is requested
        MOVE: &apos;X&apos; TO &lt;status&gt;-upd_flag,
               sadr-adrnr TO &lt;address_number&gt;.
      ENDIF.
    ENDIF.
    CLEAR am_ucomm.
  ELSE. &quot;4.0: use new version of address maintenance
   IF status-action NE anzeigen AND status-action NE transportieren AND
             adrnbr_roflag EQ space.
      IF status-action EQ kopieren.
        IF &lt;address_number&gt; NE space.
          IF &lt;address_number&gt; NP &apos;@NEW*&apos;.
            am_sel-addrnumber = &lt;address_number&gt;.
          ELSE.
            am_sel-addrhandle = &lt;f1_x&gt;.
          ENDIF.
          CALL FUNCTION &apos;ADDR_GET&apos;
            EXPORTING
              address_selection = am_sel
            IMPORTING
              address_value     = am_address
            EXCEPTIONS
              parameter_error   = 1
              address_not_exist = 2
              version_not_exist = 3
              internal_error    = 4.
          IF sy-subrc EQ 0.
            MOVE-CORRESPONDING am_address TO am_handletab.
          ENDIF.
        ENDIF.
        CLEAR &lt;address_number&gt;.
        am_handletab-maint_mode = &apos;CREATE&apos;.
      ELSE.
        IF &lt;address_number&gt; EQ space.
          am_handletab-maint_mode = &apos;CREATE&apos;.
        ELSE.
          am_handletab-maint_mode = &apos;CHANGE&apos;.
        ENDIF.
      ENDIF.                           &quot;status-action eq kopieren.
    ELSE.
      IF &lt;address_number&gt; IS INITIAL.  &quot;no address assigned
        MESSAGE i055(sv) WITH &lt;am_key&gt;.
        EXIT.
      ENDIF.
      am_handletab-maint_mode = &apos;DISPLAY&apos;.
    ENDIF.
    IF am_handletab-maint_mode EQ &apos;CREATE&apos; OR
       &lt;address_number&gt; CP &apos;@NEW*&apos;.
      &lt;am_handle_x&gt;(x_header-keylen) = &lt;f1_x&gt;.
*      am_handletab-handle = &lt;f1&gt;.
    ELSE.
      CLEAR am_handletab-handle.
    ENDIF.
    IF &lt;address_number&gt; NP &apos;@NEW*&apos;.
      am_handletab-addrnumber = &lt;address_number&gt;.
    ELSE.
      CLEAR am_handletab-addrnumber.
    ENDIF.
    am_handletab-addr_group = vim_addr_group.
    APPEND am_handletab.
* individual preparation of address dialog requested?.....
    CLEAR: vim_addr_field_selection,
           vim_addr_keywords,
           vim_addr_chng_deflt_comm_types,
           vim_addr_frame_text,
           vim_addr_excluded_functions.
    REFRESH vim_addr_excluded_functions.
    vim_addr_titlebar = am_title.
    CLEAR vim_skip_adr_maint.                               &quot;UF120400
    IF x_header-frm_bf_adr NE space.   &quot;...yes
      PERFORM (x_header-frm_bf_adr) IN PROGRAM.
    ENDIF.
    CHECK vim_skip_adr_maint IS INITIAL.                    &quot;UF120400
    CALL FUNCTION &apos;ADDR_DIALOG_PREPARE&apos;
         EXPORTING
              field_selection           = vim_addr_field_selection
              keywords                  = vim_addr_keywords
*             TITLEBAR                  = AM_TITLE
              titlebar                  = vim_addr_titlebar
              change_default_comm_types = vim_addr_chng_deflt_comm_types
              frame_text                = vim_addr_frame_text
         TABLES
              excluded_functions        = vim_addr_excluded_functions
*             ERROR_TABLE               =
         EXCEPTIONS
              internal_error            = 1
              OTHERS                    = 2.
    IF am_handletab-maint_mode EQ &apos;CHANGE&apos; AND
       am_handletab-addrnumber NE space.
      READ TABLE vim_locked_addresses FROM am_handletab-addrnumber
                                      TRANSPORTING NO FIELDS.
      IF sy-subrc NE 0.                &quot;not yet locked
        CALL FUNCTION &apos;ADDR_ENQUEUE&apos;
             EXPORTING
                  address_number    = am_handletab-addrnumber
*               MODE_ADRC         = &apos;E&apos;
*               _SCOPE            = &apos;2&apos;
*               _WAIT             = &apos; &apos;
*               _COLLECT          = &apos; &apos;
             EXCEPTIONS
                  address_not_exist = 1
                  foreign_lock      = 2
                  system_failure    = 3
                  internal_error    = 4.
        CASE sy-subrc.
          WHEN 0.
            INSERT am_handletab-addrnumber INTO TABLE
                                           vim_locked_addresses.
          WHEN 1.
            IF status-action NE anzeigen AND
               status-action NE transportieren AND
               adrnbr_roflag EQ space.
              CALL FUNCTION &apos;POPUP_TO_CONFIRM_WITH_MESSAGE&apos;
                EXPORTING
                  diagnosetext1 = svim_text_013&quot;Die Adresse für das Obj:
                  diagnosetext2 = &lt;am_key&gt;
                  diagnosetext3 = svim_text_014&quot;wurde nicht gefunden.
                  textline1     = svim_text_015&quot;Möchten Sie eine neue er
                  titel         = svim_text_016&quot;Adresse nicht vorhanden
                IMPORTING
                  answer        = answer.
              IF answer EQ &apos;J&apos;.
                am_handletab-maint_mode = &apos;CREATE&apos;.
                IF &lt;address_number&gt; NP &apos;@NEW*&apos;.
                  &lt;am_handle_x&gt;(x_header-keylen) = &lt;f1_x&gt;.
*                  am_handletab-handle = &lt;f1&gt;.
                  CLEAR am_handletab-addrnumber.
                ENDIF.
                MODIFY am_handletab INDEX 1.
              ELSE.
                EXIT.
              ENDIF.
            ELSE.
              MESSAGE i055(sv) WITH &lt;am_key&gt;.
              EXIT.
            ENDIF.
          WHEN 2.
            MESSAGE i049(sv) WITH sy-msgv1.
            am_handletab-maint_mode = &apos;DISPLAY&apos;.
          WHEN OTHERS.
            MESSAGE i050(sv) WITH &lt;am_key&gt;.
            am_handletab-maint_mode = &apos;DISPLAY&apos;.
        ENDCASE.
      ENDIF.                           &quot;not yet locked
    ENDIF. &quot;am_handletab-maint_mode eq &apos;CHANGE&apos; and no new address
    DO.
      CALL FUNCTION &apos;ADDR_DIALOG&apos;
           IMPORTING
                ok_code           = am_ucomm
           TABLES
                number_handle_tab = am_handletab
*             VALUES            =
           EXCEPTIONS
                address_not_exist = 1
                group_not_valid   = 2
                parameter_error   = 3
                internal_error    = 4.
      CASE sy-subrc.
        WHEN 0.
          READ TABLE am_handletab INDEX 1.
          EXIT.
        WHEN 1.
          IF status-action NE anzeigen AND
             status-action NE transportieren AND
             adrnbr_roflag EQ space.
            CALL FUNCTION &apos;POPUP_TO_CONFIRM_WITH_MESSAGE&apos;
              EXPORTING
                diagnosetext1 = svim_text_013 &quot;Die Adresse für das
                diagnosetext2 = &lt;am_key&gt;
                diagnosetext3 = svim_text_014&quot;wurde nicht gefunden.
                textline1     = svim_text_015&quot;Möchten Sie eine neue er
                titel         = svim_text_016&quot;Adresse nicht vorhanden
              IMPORTING
                answer        = answer.
            IF answer EQ &apos;J&apos;.
              READ TABLE am_handletab INDEX 1.
              am_handletab-maint_mode = &apos;CREATE&apos;.
              IF &lt;address_number&gt; NP &apos;@NEW*&apos;.
                &lt;am_handle_x&gt;(x_header-keylen) = &lt;f1_x&gt;.
*                am_handletab-handle = &lt;f1&gt;.
                CLEAR am_handletab-addrnumber.
              ENDIF.
              MODIFY am_handletab INDEX 1.
            ELSE.
              am_ucomm = &apos;CANC&apos;.
              EXIT.
            ENDIF.
          ELSE.
            MESSAGE i055(sv) WITH &lt;am_key&gt;.
            am_ucomm = &apos;CANC&apos;.
            EXIT.
          ENDIF.
        WHEN OTHERS.
          MESSAGE ID sy-msgid TYPE &apos;I&apos; NUMBER sy-msgno WITH
                  sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
          am_ucomm = &apos;CANC&apos;. EXIT.
      ENDCASE.
    ENDDO.
    IF am_handletab-maint_mode EQ &apos;CHANGE&apos; AND
       am_handletab-addrnumber NE space    AND
       ( am_ucomm EQ &apos;CANC&apos; OR am_handletab-updateflag EQ space ).
      READ TABLE vim_locked_addresses FROM am_handletab-addrnumber
                                      TRANSPORTING NO FIELDS.
      IF sy-subrc EQ 0.                &quot;dequeue
        CALL FUNCTION &apos;ADDR_DEQUEUE&apos;
               EXPORTING
                 address_number    = am_handletab-addrnumber
*                MODE_ADRC         = &apos;E&apos;
*                _SCOPE            = &apos;3&apos;
*                _SYNCHRON         = &apos; &apos;
*                _COLLECT          = &apos; &apos;
               EXCEPTIONS
                 address_not_exist = 1
                 internal_error    = 2.
      ENDIF.
    ENDIF.
   IF status-action NE anzeigen AND status-action NE transportieren AND
             adrnbr_roflag EQ space.
      IF am_ucomm NE &apos;CANC&apos;.
        IF am_handletab-maint_mode EQ &apos;CREATE&apos;.
          &lt;address_number&gt; = &apos;@NEW&apos;.
          &lt;address_number&gt;+4(6) = &lt;status&gt;-newadrcnt.
          ADD 1 TO &lt;status&gt;-newadrcnt.
          &lt;status&gt;-upd_flag = &apos;X&apos;.
        ENDIF.
        IF am_handletab-updateflag NE space. &quot;addr. itself is to be save
          READ TABLE vim_addresses_to_save
                              WITH KEY viewname = x_header-viewname
                                       addrnumber = &lt;address_number&gt;
                              BINARY SEARCH TRANSPORTING NO FIELDS.
          IF sy-subrc NE 0.
            vim_addresses_to_save-addrnumber = &lt;address_number&gt;.
            CLEAR vim_addresses_to_save-handle.
            &lt;vim_addr_handle_x&gt;(x_header-keylen) = &lt;f1_x&gt;.
*            vim_addresses_to_save-handle = &lt;f1&gt;.
            INSERT vim_addresses_to_save INDEX sy-tabix.
          ENDIF.
          IF vim_client_state EQ vim_log AND
             x_header-flag NE vim_transport_denied AND
             vim_actopts-transp_off NE bc_transport_denied.
            &lt;status&gt;-upd_flag = &apos;X&apos;. &quot;nec. for transport of master entry
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.
    CLEAR return.
  ENDIF.                               &quot;am_statetab-value eq space.
* IF STATUS-ACTION NE KOPIEREN AND STATUS-ACTION NE HINZUFUEGEN.
  IF status-action NE kopieren AND status-action NE hinzufuegen AND
     vim_single_entry_function NE &apos;INS&apos;.
    IF return NE 4 AND am_ucomm NE &apos;CANC&apos;.
      IF &lt;xmark&gt; EQ markiert.
        &lt;xmark&gt; = nicht_markiert.
        IF &lt;status&gt;-upd_flag EQ space.
          MODIFY extract INDEX exind.
          READ TABLE total WITH KEY &lt;vim_xextract_key&gt; BINARY SEARCH.
          &lt;mark&gt; = nicht_markiert.
          MODIFY total INDEX sy-tabix.
        ENDIF.
        SUBTRACT: 1 FROM mark_extract,
                  1 FROM mark_total.
      ENDIF.
    ENDIF.
    CLEAR function.
  ENDIF.
ENDFORM.                    &quot;address_maintain</include_source>
   </include>
   <include NAME="LSVIMF25" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000004" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122433" IDATE="20080721" ITIME="122433">
    <include_source>*---------------------------------------------------------------------*
*       FORM LISTE_ADDRESS_MAINTAIN                                   *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM LISTE_ADDRESS_MAINTAIN.
  IF X_HEADER-ADRNBRFLAG EQ SPACE.
    MESSAGE E001(SV).
    EXIT.
  ENDIF.
  LOOP AT EXTRACT.
    CHECK &lt;XMARK&gt; EQ MARKIERT.
    MOVE SY-TABIX TO EXIND.
    PERFORM MOVE_EXTRACT_TO_VIEW_WA.
    PERFORM ADDRESS_MAINTAIN.
    PERFORM UPDATE_TAB.
  ENDLOOP.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF27" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000006" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122433" IDATE="20080721" ITIME="122433">
    <include_source>*---------------------------------------------------------------------*
*       FORM ENQUEUE                                                  *
*---------------------------------------------------------------------*
* enqueue view                                                        *
*---------------------------------------------------------------------*
* VALUE(E_ACT) --&gt; action: E -&gt; enqueue, D -&gt; dequeue                 *
* VALUE(EXIT_FORM) ---&gt; name of exit form to process after enqueue    *
*---------------------------------------------------------------------*
FORM enqueue USING value(e_act) value(exit_form).
*----------------------------------------------------------------------*
*      enqueue view
*----------------------------------------------------------------------*
  CALL FUNCTION &apos;VIEW_ENQUEUE&apos;
       EXPORTING
            view_name        = vim_view_name
            action           = e_act
            enqueue_mode     = &apos;E&apos;
            enqueue_range    = vim_enqueue_range
       TABLES
            sellist          = &lt;vim_sellist&gt;
       EXCEPTIONS
            foreign_lock     = 1
            system_failure   = 2
            table_not_found  = 5
            client_reference = 7.

  DATA: rc LIKE sy-subrc.

  CASE sy-subrc.
    WHEN 1.
      MESSAGE i049(sv) WITH sy-msgv1.
      sy-subrc = 1.
    WHEN 2.
      MESSAGE a050(sv) WITH view_name.
    WHEN 3.
      MESSAGE a037(sv) WITH view_name.
    WHEN 5.
      MESSAGE a028(sv) WITH view_name.
    WHEN 7.
      MESSAGE w054(sv) WITH sy-mandt.
      sy-subrc = 7.
  ENDCASE.
  rc = sy-subrc.
  IF exit_form NE space.
    PERFORM (exit_form) IN PROGRAM (sy-repid).
  ENDIF.
  IF e_act EQ &apos;E&apos;.
    IF sy-subrc &lt;&gt; 0.
      vim_enq_s_u_rc = sy-subrc.
    ELSEIF rc &lt;&gt; 0.
      vim_enq_s_u_rc = rc.
    ELSE.
      vim_enq_s_u_rc = 0.
    ENDIF.
  ENDIF.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF28" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000003" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122433" IDATE="20080721" ITIME="122433">
    <include_source>*---------------------------------------------------------------------*
*       FORM X_ENQUEUE                                                *
*---------------------------------------------------------------------*
* enqueue view (external call)                                        *
*---------------------------------------------------------------------*
* XE_SELLIST       ---&gt; table of selection conditions for view/table  *
* VALUE(XE_NAME)   ---&gt; name of view/table to process                 *
* VALUE(XE_ACT)    ---&gt; action: E -&gt; enqueue, D -&gt; dequeue            *
* VALUE(EXIT_FORM) ---&gt; name of exit form to process after enqueue    *
* VALUE(XE_ENQRNG) ---&gt; flag: X -&gt; enqueue range, &apos; &apos; -&gt; full table   *
*---------------------------------------------------------------------*
FORM X_ENQUEUE TABLES XE_SELLIST STRUCTURE VIMSELLIST
               USING VALUE(XE_NAME) VALUE(XE_ACT) VALUE(EXIT_FORM)
                     VALUE(XE_ENQRNG).
  DATA: VIEWNAME_SAFE LIKE VIMDESC-VIEWNAME, ENQ_RANGE_SAFE(1) TYPE C.

  VIEWNAME_SAFE = VIM_VIEW_NAME. ENQ_RANGE_SAFE = VIM_ENQUEUE_RANGE.
  VIM_VIEW_NAME = XE_NAME. VIM_ENQUEUE_RANGE = XE_ENQRNG.
  ASSIGN XE_SELLIST-*SYS* TO &lt;VIM_SELLIST&gt;.
  PERFORM ENQUEUE USING XE_ACT EXIT_FORM.
  VIM_VIEW_NAME = VIEWNAME_SAFE. VIM_ENQUEUE_RANGE = ENQ_RANGE_SAFE.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF29" SQLX="X" VARCL="X" SUBC="I" APPL="S" CNAM="SAP" CDAT="20060612" UNAM="SAP" UDAT="20080721" VERN="000003" RSTAT="T" RMAND="000" RLOAD="E" SDATE="20080721" STIME="122433" IDATE="20080721" ITIME="122433" UCCHECK="X">
    <include_source>*----------------------------------------------------------------------*
***INCLUDE LSVIMF29 .
*----------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp;      Form  VIM_MULTI_LANGU_TEXT_ALS
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM VIM_MULTI_LANGU_TEXT_ALS .

  DATA: sel_langus TYPE ALS_T002,
        texttab_for_output TYPE vimty_multilangu_texttab,
        lb_als TYPE REF TO IF_EX_VIM_ALS_BADI,
        curr_sptxt LIKE t002t-sptxt,
        maint_mode(1) TYPE c,
        textmodif(1) TYPE c,
        f_called_by_viewmaint TYPE c,
        als_text TYPE vimty_max_textline,
        wa1_texttab_for_output LIKE LINE OF texttab_for_output,
        wa2_texttab_for_output LIKE LINE OF texttab_for_output,
        wa1_texttab TYPE vimty_textfield,
        wa2_texttab TYPE vimty_textfield,
        index TYPE sy-tabix.


  CALL METHOD cl_exithandler=&gt;get_instance
    EXPORTING
      null_instance_accepted        = seex_false
      exit_name                     = &apos;VIM_ALS_BADI&apos;
    CHANGING
      instance                      = lb_als
    EXCEPTIONS
      no_reference                  = 1
      no_interface_reference        = 2
      no_exit_interface             = 3
      class_not_implement_interface = 4
      single_exit_multiply_active   = 5
      cast_error                    = 6
      exit_not_existing             = 7
      data_incons_in_exit_managem   = 8
      OTHERS                        = 9.
  IF sy-subrc NE 0.
    EXIT.
  ELSE.
    IF als_active &lt;&gt; &apos;X&apos; AND als_langus_selected &lt;&gt; &apos;X&apos;.
      CALL METHOD lb_als-&gt;get_als_languages
        EXPORTING
          view_name  = x_header-viewname
        IMPORTING
          als_active = als_active
        CHANGING
          als_langus = sel_langus.
      als_langus_selected = &apos;X&apos;.
      als_sel_langus[] = sel_langus[].
    ENDIF.

    sel_langus[] = als_sel_langus[].
    CALL FUNCTION &apos;VIEW_SET_ALS_LANGUAGES&apos;
      IMPORTING
        curr_sptxt = curr_sptxt
      TABLES
        languages  = sel_langus.

    PERFORM vim_read_texttab_for_langus TABLES sel_langus USING &apos; &apos;.
    REFRESH texttab_for_output.
    PERFORM vim_fill_texttab_for_als TABLES sel_langus
                                       USING curr_sptxt
                                       CHANGING texttab_for_output.

    CLEAR als_text.
    CLEAR index.

    LOOP AT texttab_for_output INTO wa1_texttab_for_output.
      IF sy-tabix EQ 1.
        LOOP AT wa1_texttab_for_output-texttab INTO wa1_texttab.
          index = sy-tabix.
          als_text = wa1_texttab-text.
          LOOP AT texttab_for_output INTO wa2_texttab_for_output.
            IF sy-tabix EQ 1.
              wa2_texttab_for_output-ACTION = &apos;X&apos;.
              MODIFY texttab_for_output FROM wa2_texttab_for_output.
            ELSE.
              LOOP AT wa2_texttab_for_output-texttab INTO wa2_texttab.
                IF sy-tabix = index.
                  wa2_texttab-text = als_text.
                 MODIFY wa2_texttab_for_output-texttab FROM wa2_texttab.
                  MODIFY texttab_for_output FROM wa2_texttab_for_output.
                ENDIF.
              ENDLOOP.
            ENDIF.
          ENDLOOP.
        ENDLOOP.
      ENDIF.
    ENDLOOP.

    PERFORM als_update_texttab USING texttab_for_output.
    MODIFY vim_texttab_container INDEX vim_texttab_container_index.
  ENDIF.


ENDFORM.                    &quot; VIM_MULTI_LANGU_TEXT_ALS
*&amp;---------------------------------------------------------------------*
*&amp;      Form  vim_fill_texttab_for_als
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_SEL_LANGUS  text
*      --&gt;P_CURR_SPTXT  text
*      &lt;--P_TEXTTAB_FOR_OUTPUT  text
*----------------------------------------------------------------------*
FORM vim_fill_texttab_for_als TABLES sel_langus STRUCTURE h_t002
               USING curr_sptxt LIKE t002t-sptxt
               CHANGING texttab_for_maint TYPE vimty_multilangu_texttab.
  DATA: textmaint_record TYPE vimty_textmaint_record,
        textmaint_field TYPE vimty_textfield,
        align1 TYPE f,
        texttab_wa TYPE vim_line_ul,
        align2 TYPE f,
        tmp_wa TYPE tabl8000,
        condense(1) TYPE c,
        texttab_tabix LIKE sy-tabix,
        extract_index LIKE sy-tabix,
        keylen TYPE i,
        rc LIKE sy-subrc,
        keys_identical TYPE xfeld.
  DATA: primkeylen TYPE i.
  FIELD-SYMBOLS: &lt;extract_key&gt; TYPE x,
                 &lt;next_spras&gt; TYPE spras,
                 &lt;text_rec_key&gt; TYPE x, &lt;h_texttab_wa&gt; TYPE x,
                 &lt;viewkey_in_texttab&gt; TYPE x, &lt;txtfld&gt; TYPE ANY,
                 &lt;h_tmp&gt; TYPE x, &lt;tmp_struc&gt; TYPE ANY,
                 &lt;h_texttab&gt; TYPE x, &lt;texttab_struc&gt; TYPE ANY.
  FIELD-SYMBOLS: &lt;extract_primkey&gt; TYPE x.

  ASSIGN &lt;f1_x&gt; TO &lt;extract_key&gt;.
  keylen = x_header-after_keyc.
  keylen = x_header-keylen.

* In case of viewkey &gt; primtabkey -&gt; additional key fields are filled
* in &lt;extract_key&gt; but not existent in &lt;vim_texttab&gt; &quot;HCG 09/02/2005
*  primkeylen = x_header-textkeylen - cl_abap_char_utilities=&gt;charsize.
  IF x_header-bastab EQ space.                              &quot;IG 875536
    CLEAR keys_identical.
    PERFORM vim_comp_roottabkey USING x_header
                                      x_namtab[]
                             CHANGING keys_identical
                                      rc.
    IF keys_identical EQ space.
      primkeylen = keylen.
    ELSE.
      clear primkeylen.
      LOOP AT x_namtab WHERE keyflag = &apos;X&apos; AND
                           bastabname = x_header-roottab.
        IF x_namtab-DATATYPE NE &apos;DATS&apos;.
          primkeylen = primkeylen + x_namtab-FLENGTH.
        ENDIF.
      ENDLOOP.
    ENDIF.
  ELSE.
    primkeylen = x_header-keylen.
  ENDIF.                                                    &quot;IG 875536
  ASSIGN: texttab_wa TO &lt;h_texttab_wa&gt; CASTING,
          &lt;h_texttab_wa&gt;(primkeylen) TO &lt;viewkey_in_texttab&gt;,
          &lt;h_texttab_wa&gt;+keylen(x_header-texttablen) TO &lt;h_texttab&gt;,
          tmp_wa+keylen(x_header-texttablen)
           TO &lt;h_tmp&gt;,
          &lt;h_texttab&gt; TO &lt;texttab_struc&gt;
           CASTING TYPE (x_header-texttab),
          &lt;h_tmp&gt; TO &lt;tmp_struc&gt; CASTING TYPE (x_header-texttab),
          COMPONENT x_header-sprasfield OF STRUCTURE &lt;texttab_struc&gt;
           TO &lt;next_spras&gt;,
           textmaint_record-keys TO &lt;text_rec_key&gt; CASTING.

  CLEAR textmaint_record.
  &lt;text_rec_key&gt; = &lt;extract_key&gt;.
  PERFORM vim_external_repr_for_key TABLES textmaint_record-keytab
                                    USING &lt;vim_xextract_key&gt;.
  textmaint_record-spras = sy-langu.
  textmaint_record-sptxt = curr_sptxt.
  IF x_header-bastab = space.
* view
    LOOP AT x_namtab WHERE textfldsel = &apos;X&apos;.
      textmaint_field-namtab_idx = sy-tabix.
      textmaint_field-outplen = x_namtab-flength.
      ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE
       &lt;table1&gt; TO &lt;txtfld&gt;.
      textmaint_field-text = &lt;txtfld&gt;.
      APPEND textmaint_field TO textmaint_record-texttab.
    ENDLOOP.
  ELSE.
* tab + texttab
    LOOP AT x_namtab WHERE textfldsel = &apos;X&apos;.
      textmaint_field-namtab_idx = sy-tabix.
      textmaint_field-outplen = x_namtab-flength.
      ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE
       &lt;table1_text&gt; TO &lt;txtfld&gt;.
      textmaint_field-text = &lt;txtfld&gt;.
      APPEND textmaint_field TO textmaint_record-texttab.
    ENDLOOP.
  ENDIF.
  APPEND textmaint_record TO texttab_for_maint.

*   Texte in ausgewählten Sprachen
************************************************************************
  CLEAR: &lt;viewkey_in_texttab&gt;, &lt;texttab_struc&gt;.
*    CLEAR texttab_wa.
*   In case of viewkey &gt; primtabkey -&gt; additional key fields are filled
*   in &lt;extract_key&gt; but not existent in &lt;vim_texttab&gt;  &quot;HCG 09/02/2005
  ASSIGN &lt;extract_key&gt;(primkeylen) TO &lt;extract_primkey&gt;.
  READ TABLE &lt;vim_texttab&gt; WITH KEY &lt;extract_primkey&gt;
                             INTO texttab_wa. &quot; BINARY SEARCH.
  texttab_tabix = sy-tabix.
  LOOP AT sel_langus.
    CLEAR textmaint_record.
    &lt;text_rec_key&gt; = &lt;extract_key&gt;.
    textmaint_record-spras = sel_langus-spras.
    textmaint_record-sptxt = sel_langus-sptxt.
    textmaint_record-action = &apos;X&apos;.

    IF &lt;viewkey_in_texttab&gt; = &lt;extract_primkey&gt; AND         &quot;817790
       &lt;next_spras&gt; &lt; sel_langus-spras.                   &quot;#EC PORTABLE
      LOOP AT &lt;vim_texttab&gt; FROM texttab_tabix INTO texttab_wa.
        IF &lt;viewkey_in_texttab&gt; &lt;&gt; &lt;extract_primkey&gt; OR     &quot;817790
           &lt;next_spras&gt; &gt;= sel_langus-spras.              &quot;#EC PORTABLE
          texttab_tabix = sy-tabix.
          EXIT.
        ENDIF.
      ENDLOOP.
    ENDIF.   &quot; &lt;next_spras&gt; &gt;= sel_langus-spras oder ex. nicht
    IF &lt;next_spras&gt; &lt;&gt; sel_langus-spras OR
        &lt;viewkey_in_texttab&gt; &lt;&gt; &lt;extract_primkey&gt;.&quot;langu:text not ex
      CLEAR &lt;tmp_struc&gt;.
    ELSE.
      tmp_wa = &lt;h_texttab_wa&gt;.
    ENDIF.
    LOOP AT x_namtab WHERE textfldsel = &apos;X&apos;.
      textmaint_field-namtab_idx = sy-tabix.
      textmaint_field-outplen = x_namtab-flength.
      ASSIGN COMPONENT x_namtab-bastabfld OF STRUCTURE     &quot;HCG wrong
       &lt;tmp_struc&gt; TO &lt;txtfld&gt;.   &quot;HCG for txtfldname in view differs
      textmaint_field-text = &lt;txtfld&gt;.
      APPEND textmaint_field TO textmaint_record-texttab.
    ENDLOOP.
    APPEND textmaint_record TO texttab_for_maint.
  ENDLOOP.                           &quot; SEL_LANGUS

ENDFORM.                    &quot; vim_fill_texttab_for_als
*&amp;---------------------------------------------------------------------*
*&amp;      Form  set_als_update_flag
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM set_als_update_flag .

  DATA: als_flag(1) TYPE c.
  FIELD-SYMBOLS: &lt;h1&gt;,
                 &lt;h2&gt;.
  CLEAR als_flag.
  LOOP AT x_namtab WHERE keyflag EQ space
      AND bastabname EQ x_header-texttab.
    assign component x_namtab-viewfield of structure &lt;table1&gt; to &lt;h1&gt;.
    assign component x_namtab-viewfield of structure
                     &lt;vim_extract_struc&gt; to &lt;h2&gt;.
    IF &lt;h1&gt; NE &lt;h2&gt;.
      als_flag =&apos;X&apos;.
    ENDIF.
  ENDLOOP.

  IF als_flag EQ &apos;X&apos;.
    PERFORM VIM_MULTI_LANGU_TEXT_ALS.
  ENDIF.

ENDFORM.                    &quot; set_als_update_flag
*&amp;---------------------------------------------------------------------*
*&amp;      Form  ALS_UPDATE_TEXTTAB
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM als_update_texttab
                USING texttab_for_maint TYPE vimty_multilangu_texttab.
  DATA: textmaint_record TYPE vimty_textmaint_record,
        textmaint_field TYPE vimty_textfield,
        align TYPE f,                                       &quot;#EC NEEDED
        texttab_wa TYPE vim_line_ul,
        search_key TYPE tabl8000,
        offset LIKE sy-fdpos,
        keylen LIKE sy-fdpos,
        extract_index LIKE sy-tabix,
        total_index   LIKE sy-tabix,
        texttab_tabix LIKE sy-tabix,
        new_entry(1)  TYPE c,
        keylen_char TYPE i,
        primkeylen type i,                                  &quot;817790
        rc LIKE sy-subrc,                                   &quot;875536
        keys_identical TYPE xfeld.
  FIELD-SYMBOLS:
        &lt;search_key&gt; TYPE x, &lt;rec_key&gt; TYPE x, &lt;curr_spras&gt; TYPE ANY,
        &lt;h_texttab_wa&gt; TYPE x,
        &lt;viewkey_in_texttab&gt; TYPE x, &quot;Key aus View/Tab in Texttab
        &lt;texttab_key&gt; TYPE x, &lt;texttab_struc&gt; TYPE ANY,
        &lt;h_texttab&gt; TYPE x, &lt;tot_fld&gt; TYPE ANY, &lt;ext_fld&gt; TYPE ANY,   &quot;#EC *
        &lt;texttab_action&gt; TYPE c,
        &lt;t_action&gt;, &lt;e_action&gt;,
        &lt;search_txtkey&gt; type x.                             &quot;817790

  IF x_header-delmdtflag &lt;&gt; space AND     &quot;zeitabh. &amp; part. Fremdschl.
     x_header-ptfrkyexst  = &apos;X&apos;.          &quot;      -&gt; zeitunabh. Texttab.
    keylen = x_header-after_keyc
     - vim_datum_length * cl_abap_char_utilities=&gt;charsize.
  ELSE.
    keylen = x_header-after_keyc.
  ENDIF.
  keylen_char = keylen / cl_abap_char_utilities=&gt;charsize.
  IF x_header-bastab EQ space.                              &quot;IG 875536
    CLEAR keys_identical.
    PERFORM vim_comp_roottabkey USING x_header
                                      x_namtab[]
                             CHANGING keys_identical
                                      rc.
    IF keys_identical EQ space.
      primkeylen = keylen.
    ELSE.
      clear primkeylen.
      LOOP AT x_namtab WHERE keyflag = &apos;X&apos; AND
                           bastabname = x_header-roottab.
        IF x_namtab-DATATYPE NE &apos;DATS&apos;.
          primkeylen = primkeylen + x_namtab-FLENGTH.
        ENDIF.
      ENDLOOP.
    ENDIF.
  ELSE.
    primkeylen = x_header-keylen.
  ENDIF.                                                    &quot;IG 875536

  ASSIGN: search_key(keylen) TO &lt;search_key&gt;,
          textmaint_record-keys(keylen_char) TO &lt;rec_key&gt; CASTING,
          texttab_wa TO &lt;h_texttab_wa&gt; CASTING,
          &lt;h_texttab_wa&gt;(keylen) TO &lt;viewkey_in_texttab&gt;,
          &lt;h_texttab_wa&gt;+keylen(x_header-textkeylen) TO &lt;texttab_key&gt;,
          &lt;h_texttab_wa&gt;+keylen(x_header-texttablen) TO &lt;h_texttab&gt;,
          &lt;h_texttab&gt; TO &lt;texttab_struc&gt;
           CASTING TYPE (x_header-texttab),
          COMPONENT x_header-sprasfield OF STRUCTURE &lt;texttab_struc&gt;
           TO &lt;curr_spras&gt;.
  ASSIGN: search_key(primkeylen) TO &lt;search_txtkey&gt;.        &quot;817790

  offset = keylen + x_header-aft_txttbc.
  ASSIGN &lt;h_texttab_wa&gt;+offset(cl_abap_char_utilities=&gt;charsize)
   TO &lt;texttab_action&gt; CASTING.
  IF x_header-bastab = &apos;X&apos;.
* tab+texttab
    ASSIGN &lt;action_text&gt; TO &lt;t_action&gt;.
    ASSIGN &lt;xact_text&gt; TO &lt;e_action&gt;.
  ELSE.
    ASSIGN &lt;action&gt; TO &lt;t_action&gt;.
    ASSIGN &lt;xact&gt; TO &lt;e_action&gt;.
  ENDIF.

  LOOP AT texttab_for_maint INTO textmaint_record.
    IF textmaint_record-spras = sy-langu.
      &lt;search_key&gt; = &lt;rec_key&gt;.
      READ TABLE extract WITH KEY &lt;search_key&gt; BINARY SEARCH.&quot;#EC *
      extract_index = sy-tabix.
    ENDIF.
    CHECK textmaint_record-action = &apos;X&apos;.      &quot; Texte wurden modifiziert

    IF textmaint_record-spras = sy-langu.
      READ TABLE total WITH KEY &lt;search_key&gt; BINARY SEARCH. &quot;#EC *
      total_index = sy-tabix.
      IF x_header-bastab = &apos;X&apos;
       AND &lt;vim_xextract_text&gt; = &lt;text_initial_x&gt;.
        PERFORM map_viewkey_to_texttabkey TABLES x_namtab
                                          USING x_header
                                                sy-langu
                                                &lt;vim_xtotal&gt;
                                          CHANGING &lt;vim_xextract_text&gt;.
        PERFORM map_viewkey_to_texttabkey TABLES x_namtab
                                          USING x_header
                                                sy-langu
                                                &lt;vim_xtotal&gt;
                                          CHANGING &lt;vim_xtotal_text&gt;.

        &lt;e_action&gt; = neuer_eintrag.
        &lt;t_action&gt; = neuer_eintrag.
      ELSEIF &lt;e_action&gt; = original.
        &lt;e_action&gt; = aendern.
        &lt;t_action&gt; = aendern.
*     Else.                     &quot; neuer_eintrag / aendern =&gt; ok
      ENDIF.

    ELSE.
* different language: Update in texttable
      CLEAR: &lt;h_texttab_wa&gt;, &lt;texttab_struc&gt;.
      READ TABLE &lt;vim_texttab&gt; WITH KEY &lt;search_txtkey&gt;     &quot;817790
                               INTO texttab_wa BINARY SEARCH.&quot;817790

      texttab_tabix = sy-tabix.
      IF &lt;viewkey_in_texttab&gt;(primkeylen) = &lt;search_txtkey&gt; AND&quot;817790
         &lt;curr_spras&gt; &lt; textmaint_record-spras.
        LOOP AT &lt;vim_texttab&gt; FROM texttab_tabix INTO texttab_wa.
        IF &lt;viewkey_in_texttab&gt;(primkeylen) &lt;&gt; &lt;search_txtkey&gt; OR&quot;817790
             &lt;curr_spras&gt; &gt;= textmaint_record-spras.
            texttab_tabix = sy-tabix.
            EXIT.
          ELSEIF &lt;curr_spras&gt; &lt; textmaint_record-spras.
            texttab_tabix = sy-tabix + 1.
          ENDIF.
        ENDLOOP.
      ENDIF.   &quot; &lt;next_spras&gt; &gt;= sel_langus-spras oder ex. nicht
      IF &lt;viewkey_in_texttab&gt;(primkeylen) &lt;&gt; &lt;search_txtkey&gt; OR &quot;817790
        &lt;curr_spras&gt; &lt;&gt; textmaint_record-spras.
        CLEAR: &lt;texttab_struc&gt;.
        new_entry = &apos;X&apos;.
        &lt;viewkey_in_texttab&gt; = &lt;search_key&gt;.
        &lt;texttab_action&gt; = neuer_eintrag.
        PERFORM map_viewkey_to_texttabkey TABLES x_namtab
                                          USING x_header
                                                textmaint_record-spras
                                                &lt;viewkey_in_texttab&gt;
                                          CHANGING &lt;texttab_key&gt;.
      ELSE.
        CLEAR new_entry.
      ENDIF.
*     Text-Values übernehmen
      LOOP AT textmaint_record-texttab INTO textmaint_field.
        READ TABLE x_namtab INDEX textmaint_field-namtab_idx.
        IF x_namtab-lowercase = space.
          TRANSLATE textmaint_field-text TO UPPER CASE.
        ENDIF.
        IF x_header-bastab = &apos;X&apos;.&quot;HCG Custmessage 282684/02------------
* tab + texttab
          ASSIGN: COMPONENT x_namtab-viewfield OF STRUCTURE
                   &lt;texttab_struc&gt; TO &lt;ext_fld&gt;. &quot;XB int.40684/02
        ELSE.
* view, basis table field name.
          ASSIGN: COMPONENT x_namtab-bastabfld OF STRUCTURE
                   &lt;texttab_struc&gt; TO &lt;ext_fld&gt;. &quot;XB int.. 40684
        ENDIF.
        &lt;ext_fld&gt; = textmaint_field-text.
      ENDLOOP.
      IF &lt;texttab_action&gt; = original.
        &lt;texttab_action&gt; = aendern.
      ENDIF.
      IF new_entry = &apos;X&apos;.
        INSERT texttab_wa INTO &lt;vim_texttab&gt; INDEX texttab_tabix.
      ELSE.
        MODIFY &lt;vim_texttab&gt; FROM texttab_wa INDEX texttab_tabix.
      ENDIF.

    ENDIF.                             &quot; Sy-Langu
  ENDLOOP.                             &quot; TEXTTAB_FOR_MAINT


ENDFORM.                    &quot; ALS_UPDATE_TEXTTAB</include_source>
   </include>
   <include NAME="LSVIMF2A" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000002" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122433" IDATE="20080721" ITIME="122433">
    <include_source>*---------------------------------------------------------------------*
*       FORM COMPLETE_SUBSETFIELDS                                    *
*---------------------------------------------------------------------*
*  fill subset comment fields in view-wa from *view-wa (detail screen)*
*---------------------------------------------------------------------*
FORM complete_subsetfields.

  FIELD-SYMBOLS: &lt;namtab&gt; TYPE vimnamtab.

  LOOP AT x_namtab ASSIGNING &lt;namtab&gt;
   WHERE readonly EQ subset AND keyflag EQ space.
    ASSIGN: COMPONENT &lt;namtab&gt;-viewfield OF STRUCTURE &lt;initial&gt;
             TO &lt;value&gt;,
            COMPONENT &lt;namtab&gt;-viewfield OF STRUCTURE &lt;table1&gt;
             TO &lt;subsetfield&gt;.
*    ASSIGN &lt;INITIAL&gt;+X_NAMTAB-POSITION(X_NAMTAB-FLENGTH)
*           TO &lt;VALUE&gt;.
*    ASSIGN &lt;TABLE1&gt;+X_NAMTAB-POSITION(X_NAMTAB-FLENGTH)
*           TO &lt;SUBSETFIELD&gt;.
    MOVE &lt;value&gt; TO &lt;subsetfield&gt;.
  ENDLOOP.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF2B" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000003" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122433" IDATE="20080721" ITIME="122433">
    <include_source>*---------------------------------------------------------------------*
*       FORM COMPLETE_EXPROFIELDS                                     *
*---------------------------------------------------------------------*
*  fill read only fields of referenced tables (exp ro tables)         *
*---------------------------------------------------------------------*
FORM COMPLETE_EXPROFIELDS.
  IF X_HEADER-FRM_RP_CPL NE SPACE.
    PERFORM (X_HEADER-FRM_RP_CPL) IN PROGRAM.
  ELSE.
    PERFORM (COMPL_FORMNAME) IN PROGRAM (SY-REPID) USING &lt;TABLE1&gt;
                                 IF FOUND.
  ENDIF.
  IF VIM_CALLED_BY_CLUSTER NE SPACE.
    CALL FUNCTION &apos;VIEWCLUSTER_COMPL_SUBSET_VALUE&apos;
         EXPORTING
              VIEW_NAME = X_HEADER-VIEWNAME
         CHANGING
              WORKAREA  = &lt;TABLE1&gt;.
  ENDIF.
ENDFORM.                               &quot;complete_exprofields</include_source>
   </include>
   <include NAME="LSVIMF2C" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000002" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122433" IDATE="20080721" ITIME="122433">
    <include_source>*---------------------------------------------------------------------*
*       FORM FILL_SUBSETFIELDS                                        *
*---------------------------------------------------------------------*
*  fill subset fields in *view-wa                                     *
*---------------------------------------------------------------------*
FORM FILL_SUBSETFIELDS.
  DATA: progname LIKE sy-repid.
  IF &lt;STATUS&gt;-SBSID_RCVD CO &apos; R&apos;.
    progname = sy-repid.
    PERFORM INIT_SUBSET_FCTFIELDS USING COMPL_FORMNAME progname.
    TRANSLATE &lt;STATUS&gt;-SBSID_RCVD USING &apos; XRS&apos;.
  ELSE.
    IF MAXLINES EQ 0 OR VIM_CALLED_BY_CLUSTER NE SPACE.
      MOVE &lt;INITIAL&gt; TO &lt;TABLE1&gt;.
    ENDIF.
  ENDIF.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF2D" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000004" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122433" IDATE="20080721" ITIME="122434">
    <include_source>*---------------------------------------------------------------------*
*       FORM INIT_SUBSET_FCTFIELDS                                    *
*---------------------------------------------------------------------*
* init subset fields which are not keyfields                          *
*---------------------------------------------------------------------*
* FORMNAME --&gt; name of FORM to get view work area filled with current *
*              subset field values                                    *
* PROGNAME --&gt; program of FORM &apos;FORMNAME&apos;                             *
*---------------------------------------------------------------------*
FORM init_subset_fctfields USING value(formname) value(progname).

  DATA: alr_read TYPE c.

  LOOP AT x_namtab WHERE readonly EQ subset AND keyflag EQ space.
    ASSIGN component x_namtab-viewfield of structure &lt;initial&gt;
           TO &lt;subsetfield&gt;.
    ASSIGN component x_namtab-viewfield of structure &lt;table1&gt;
           TO &lt;value&gt;.
    IF alr_read EQ space.
      MOVE &lt;initial&gt; TO &lt;table1&gt;.
      IF x_header-clidep NE space.
        MOVE sy-mandt TO &lt;client&gt;.
      ENDIF.
      IF x_header-frm_rp_cpl NE space.   &quot;event AD
        PERFORM (x_header-frm_rp_cpl) IN PROGRAM (sy-repid).
      ELSEIF formname NE compl_formname OR progname NE sy-repid.
        PERFORM (formname) IN PROGRAM (progname) USING &lt;table1&gt;.
      ELSEIF maxlines EQ 0.
        PERFORM (compl_formname) IN PROGRAM (sy-repid) USING &lt;table1&gt;
                                 IF FOUND.
      ELSE.
        READ TABLE extract INDEX 1.
        MOVE &lt;vim_extract_struc&gt; TO &lt;table1&gt;.
      ENDIF.
      IF vim_called_by_cluster NE space.
        CALL FUNCTION &apos;VIEWCLUSTER_COMPL_SUBSET_VALUE&apos;
             EXPORTING
                  view_name = x_header-viewname
             CHANGING
                  workarea  = &lt;table1&gt;.
      ENDIF.
      MOVE &apos;X&apos; TO  alr_read.
    ENDIF.
    MOVE &lt;value&gt; TO &lt;subsetfield&gt;.
  ENDLOOP.
  IF sy-subrc NE 0 AND maxlines EQ 0.
    MOVE &lt;initial&gt; TO &lt;table1&gt;.
  ENDIF.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF2E" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000007" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122434" IDATE="20080721" ITIME="122434">
    <include_source>*---------------------------------------------------------------------*
*       FORM INIT_SUBSET_KEYFIELDS                                    *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM init_subset_keyfields.
  DATA: all_flds_blank TYPE c VALUE &apos;X&apos;, state_init TYPE c.
  FIELD-SYMBOLS: &lt;key&gt; type x.
  ASSIGN &lt;initial_x&gt;(x_header-keylen) TO &lt;key&gt;.
  clear &lt;table1_wa&gt;.
  MOVE &lt;key&gt; TO &lt;f1_wax&gt;.
  IF &lt;status&gt;-sbsid_rcvd NE space.
    CALL FUNCTION &apos;VIEW_INIT_SUBST_KEYFLDS&apos;
         EXPORTING
              visk_tabname         = x_header-maintview
              workarea_in          = &lt;initial&gt;
         IMPORTING
              workarea_out         = &lt;initial&gt;
              all_fields_blank     = all_flds_blank
              state_init_necessary = state_init
         TABLES
              sellist              = dba_sellist
              x_namtab             = x_namtab.
  ELSE.
    CALL FUNCTION &apos;VIEW_INIT_SUBST_KEYFLDS&apos;
         EXPORTING
              visk_tabname         = x_header-maintview
              workarea_in          = &lt;initial&gt;
         IMPORTING
              workarea_out         = &lt;initial&gt;
              all_fields_blank     = all_flds_blank
              state_init_necessary = state_init
         TABLES
              sellist              = dpl_sellist
              x_namtab             = x_namtab.
    IF all_flds_blank NE space.
      RAISE no_value_for_subset_ident.
    ENDIF.
    IF &lt;key&gt; NE &lt;f1_wax&gt;.
      MOVE &apos;X&apos; TO state_init.
    ELSE.  &quot;nicht-Key Subsetfelder, für die in ZP19 Keyflag gesetzt
      LOOP AT x_namtab where keyflag  &lt;&gt; SPACE  AND
                             readonly =  subset AND
                             position &gt;= x_header-keylen.
        MOVE &apos;X&apos; TO state_init. EXIT.
      ENDLOOP.
    ENDIF.
    IF state_init NE space.
      CLEAR: &lt;status&gt;-maxlines,
             &lt;status&gt;-cur_field,
             &lt;status&gt;-cur_offset.
      MOVE: 1 TO &lt;status&gt;-cur_line,
            1 TO &lt;status&gt;-firstline,
            maint_mode TO &lt;status&gt;-st_action,
            nicht_geloescht TO &lt;status&gt;-st_delete,
            list_bild TO &lt;status&gt;-st_mode.
      PERFORM set_status_nokeyselcnds.
    ELSE.
* further selection criteria?
      LOOP AT dpl_sellist TRANSPORTING NO FIELDS
                          WHERE ddic EQ space OR ( operator EQ &apos;GE&apos; OR
                                                   operator EQ &apos;GT&apos; OR
                                                   operator EQ &apos;LE&apos; OR
                                                   operator EQ &apos;LT&apos; ).
        EXIT.
      ENDLOOP.
      IF sy-subrc &lt;&gt; 0 and &lt;status&gt;-maxlines &lt;&gt; 0.
        &lt;status&gt;-selcd_rcvd = &apos;X&apos;.
      ENDIF.
    ENDIF.
  ENDIF.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF2F" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000004" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122434" IDATE="20080721" ITIME="122434">
    <include_source>*---------------------------------------------------------------------*
*       FORM MODIFY_TABLES                                            *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  --&gt;  VALUE(TAB_INDEX)                                              *
*---------------------------------------------------------------------*
FORM modify_tables USING value(tab_index).
  CLEAR &lt;status&gt;-upd_flag.
  IF &lt;xmark&gt; EQ markiert.
    SUBTRACT: 1 FROM &lt;status&gt;-mk_xt,
              1 FROM &lt;status&gt;-mk_to.
  ENDIF.
  READ TABLE total WITH KEY &lt;vim_xextract_key&gt; BINARY SEARCH.
  MOVE &lt;table1&gt; TO &lt;vim_extract_struc&gt;.
  IF x_header-bastab NE space AND x_header-texttbexst NE space.
    MOVE: &lt;table1_xtext&gt; TO &lt;vim_xextract_text&gt;,
          original TO &lt;xact_text&gt;.
  ENDIF.
  &lt;xmark&gt; = nicht_markiert.
  &lt;xact&gt; = original.
  IF tab_index NE 0.
    MODIFY extract INDEX tab_index.
  ENDIF.
  total = extract.
  MODIFY total INDEX sy-tabix.
  IF x_header-frm_on_org NE space.
    PERFORM (x_header-frm_on_org) IN PROGRAM (sy-repid).
  ENDIF.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF2G" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000009" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122434" IDATE="20080721" ITIME="122434">
    <include_source>*---------------------------------------------------------------------*
*       FORM CHECK_DYNAMIC_SELECT_OPTIONS                             *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM check_dynamic_select_options.
  DATA: total_ix TYPE i VALUE &apos;2&apos;, flag.
  DATA: cdso_sellist LIKE vimsellist OCCURS 10,
        oc_to_be_checked TYPE xfeld,
        keyvalues TYPE occheckkeyflds,
        activity TYPE xuval.
  FIELD-SYMBOLS: &lt;vim_tot_txt_struc_loc&gt; TYPE ANY.

  IF x_header-delmdtflag NE space.
    PERFORM build_mainkey_tab_0.
  ENDIF.
  IF x_header-subsetflag NE space.
    MOVE &apos;R&apos; TO &lt;status&gt;-sbsid_rcvd.
    LOOP AT dba_sellist WHERE ddic CO vim_subset_marks
                          AND value EQ space
                          AND initial EQ space.
      CLEAR &lt;status&gt;-sbsid_rcvd. EXIT.
    ENDLOOP.
  ENDIF.
  READ TABLE total INDEX 1.
  IF sy-subrc NE 0.
    EXIT.
  ENDIF.
  IF NOT vim_oc_inst IS INITIAL.
* check authorisation for lines: only for conditions from authorisation
* which could not be included into dba_sellist
    CALL METHOD vim_oc_inst-&gt;get_to_be_checked
      IMPORTING
        to_be_checked = oc_to_be_checked.
    IF oc_to_be_checked &lt;&gt; space.
      IF &lt;status&gt;-st_action = anzeigen.
        activity = svorg_read.
      ELSE.
        activity = svorg_maint.
      ENDIF.
      LOOP AT total.
        CALL METHOD vim_oc_inst-&gt;build_key_value_tab
          EXPORTING
            entry     = total
          IMPORTING
            keyvalues = keyvalues.
        CALL METHOD vim_oc_inst-&gt;check_oc_authority
          EXPORTING
            activity        = activity
          CHANGING
            key_values      = keyvalues
           EXCEPTIONS
             no_auth         = 1
             key_incomplete  = 2
*          WRONG_PARAMETER = 3
             OTHERS          = 4.
        IF sy-subrc = 1.
          DELETE total.
*       MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*                  WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
        ENDIF.
      ENDLOOP.
    ENDIF.
  ENDIF.
  LOOP AT dba_sellist.
    IF dba_sellist-ddic CO ddic_marks. &quot;only ddic-limits
      READ TABLE x_namtab INDEX dba_sellist-tabix.
      IF x_namtab-texttabfld NE space OR x_header-bastab EQ space AND
         x_namtab-bastabname NE x_header-roottab.
        CLEAR dba_sellist-ddic.
      ENDIF.
    ENDIF.
    APPEND dba_sellist TO cdso_sellist.
  ENDLOOP.
  READ TABLE total INDEX 1.                                 &quot;IG 951411
  IF x_header-bastab &lt;&gt; space AND x_header-texttbexst &lt;&gt; space.
    ASSIGN &lt;vim_tot_txt_struc&gt; TO &lt;vim_tot_txt_struc_loc&gt;.
  ELSE.
    ASSIGN &lt;vim_total_struc&gt; TO &lt;vim_tot_txt_struc_loc&gt;.
  ENDIF.
  CALL FUNCTION &apos;TABLE_RANGE_CHECK&apos;
    EXPORTING
      tabname                   = x_header-maintview
      entry                     = total
      entry_text                = &lt;vim_tot_txt_struc_loc&gt;
      ddic                      = &apos;N&apos;
      key                       = &apos;N&apos;
      ignore_blank_subsetfields = &apos;J&apos;
    TABLES
      x_namtab                  = x_namtab
      x_header                  = x_header
      sellist                   = cdso_sellist
    EXCEPTIONS
      entry_not_fits            = 1
      no_value_for_subset_ident = 2.
  CASE sy-subrc.
    WHEN 0.
      IF x_header-delmdtflag NE space.
        PERFORM build_mainkey_tab_1. flag = &apos;X&apos;.
      ENDIF.
    WHEN 1.
      DELETE total INDEX 1.
      SUBTRACT 1 FROM total_ix.
    WHEN 2.
      CLEAR &lt;status&gt;-sbsid_rcvd.
  ENDCASE.
  LOOP AT total FROM total_ix.
    CALL FUNCTION &apos;TABLE_RANGE_CHECK&apos;
      EXPORTING
        tabname                   = x_header-maintview
        entry                     = total
        entry_text                = &lt;vim_tot_txt_struc_loc&gt;
        ddic                      = &apos;N&apos;
        key                       = &apos;N&apos;
        ignore_blank_subsetfields = &apos;J&apos;
      TABLES
        x_namtab                  = x_namtab
        x_header                  = x_header
        sellist                   = cdso_sellist
      EXCEPTIONS
        entry_not_fits            = 1
        no_value_for_subset_ident = 2.
    CASE sy-subrc.
      WHEN 0.
        IF x_header-delmdtflag NE space.
          PERFORM build_mainkey_tab_1. flag = &apos;X&apos;.
        ENDIF.
      WHEN 1.
        DELETE total.
      WHEN 2.
        CLEAR &lt;status&gt;-sbsid_rcvd.
    ENDCASE.
  ENDLOOP.
  IF flag NE space.
    PERFORM build_mainkey_tab_2.
  ENDIF.
ENDFORM.                    &quot;check_dynamic_select_options</include_source>
   </include>
   <include NAME="LSVIMF2H" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000004" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122434" IDATE="20080721" ITIME="122434">
    <include_source>*---------------------------------------------------------------------*
*       FORM VIM_MARK_AND_PROCESS                                     *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM VIM_MARK_AND_PROCESS USING VALUE(VMAP_EXIX) TYPE I
                                VALUE(VMAP_OKCODE) LIKE OK_CODE
                                VMAP_NBR TYPE I VMAP_RC TYPE I.
  DATA: VMAP_I_RC TYPE I.
  READ TABLE TOTAL WITH KEY &lt;VIM_xEXTRACT_KEY&gt; BINARY SEARCH.
  &lt;MARK&gt; = MARKIERT. ADD 1 TO MARK_TOTAL.
  MODIFY TOTAL INDEX SY-TABIX.
  &lt;XACT&gt; = &lt;ACTION&gt;.
  &lt;XMARK&gt; = MARKIERT. ADD 1 TO MARK_EXTRACT.
  MODIFY EXTRACT.
  PERFORM VIM_PROCESS_VIEW_ENTRY USING VMAP_EXIX VMAP_OKCODE VMAP_I_RC.
  IF VMAP_I_RC EQ 0.
    ADD 1 TO VMAP_NBR.
  ELSE.
    VMAP_RC = VMAP_I_RC.
  ENDIF.
ENDFORM.                               &quot;vim_mark_and_process</include_source>
   </include>
   <include NAME="LSVIMF2I" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000005" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122434" IDATE="20080721" ITIME="122434">
    <include_source>*---------------------------------------------------------------------*
*       FORM VIM_EXTERNAL_EDIT                                        *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM vim_external_edit.
  TYPES: vee_sellist LIKE vimsellist OCCURS 10.
  DATA: ee_rc TYPE i, upd_flags(3) TYPE c, del_flags(3) TYPE c,
      h_flag(1) TYPE c, repmode_safe(1) TYPE c, specmode_safe(1) TYPE c,
        extmode_safe(1) TYPE c, vee_results LIKE vimmodres, h_ix TYPE i.
  FIELD-SYMBOLS: &lt;h_sellist&gt; TYPE vee_sellist, &lt;hf&gt; TYPE ANY.

  IF maint_mode EQ anzeigen.
    vee_results-rc_udl = vee_results-rc_ins = vee_results-rc_upd =
    vee_results-rc_del = vee_results-rc_tin = vee_results-rc_del = 8.
    vim_results_of_ext_mod = vee_results.
    EXIT.
  ENDIF.
  MOVE: aendern TO upd_flags, neuer_eintrag TO upd_flags+1,
        kopieren TO upd_flags+2,
        geloescht TO del_flags, update_geloescht TO del_flags+1,
        neuer_geloescht TO del_flags+2.
  repmode_safe = replace_mode. replace_mode = &apos;X&apos;.
  specmode_safe = vim_special_mode. vim_special_mode = vim_upgrade.
  extmode_safe = vim_external_mode. vim_external_mode = &apos;X&apos;.
  maxlines = 1.
  clear &lt;status&gt;-bcfixdelinfosent.
  LOOP AT extract.
    IF &lt;xact&gt; EQ zurueckholen.
      h_flag = status-delete. status-delete = geloescht.
      PERFORM vim_mark_and_process USING sy-tabix &apos;UNDO&apos;
                                         vee_results-nbr_of_udl
                                         vee_results-rc_udl.
      status-delete = h_flag.
      ee_rc = vee_results-rc_udl.
    ELSEIF &lt;xact&gt; CO upd_flags.
      IF &lt;xact&gt; EQ kopieren.
        h_ix = sy-tabix + 1.
        vim_extcopy_mode = &apos;X&apos;.
        &lt;xact&gt; = neuer_eintrag.
        ASSIGN &lt;vim_ck_sellist&gt; TO &lt;h_sellist&gt;.
        LOOP AT &lt;h_sellist&gt; INTO dpl_sellist
                            WHERE value EQ space AND initial EQ space.
* check if sellist is filled completely &amp; fill it if not
          READ TABLE x_namtab INDEX dpl_sellist-tabix.
          IF sy-subrc EQ 0.
            IF x_header-bastab = space.
* view
              ASSIGN COMPONENT x_namtab-viewfield
               OF STRUCTURE &lt;vim_total_struc&gt; TO &lt;hf&gt;.
            ELSE.
              IF x_namtab-texttabfld NE space.
* Type S: text field
                ASSIGN COMPONENT x_namtab-viewfield
                 OF STRUCTURE &lt;vim_ext_txt_struc&gt; TO &lt;hf&gt;.
              ELSE.
* Type S: key field
                ASSIGN COMPONENT x_namtab-viewfield
                 OF STRUCTURE &lt;vim_extract_struc&gt; TO &lt;hf&gt;.
              ENDIF.
            ENDIF.
*            ASSIGN TOTAL+X_NAMTAB-POSITION(X_NAMTAB-FLENGTH) TO &lt;HF&gt;.
            READ TABLE extract INTO total INDEX h_ix.
            dpl_sellist-value = &lt;hf&gt;.
            IF &lt;hf&gt; EQ space. dpl_sellist-initial = &apos;X&apos;. ENDIF.
            CLEAR dpl_sellist-converted.
            MODIFY &lt;h_sellist&gt; FROM dpl_sellist.
          ENDIF.
        ENDLOOP.
      ENDIF.
      h_flag = &lt;xact&gt;.
      PERFORM vim_modify_view_entry USING sy-tabix ee_rc.
      CLEAR vim_extcopy_mode.
      DELETE extract.                                       &quot;190298
      IF ee_rc EQ 0.
        IF h_flag EQ neuer_eintrag.
          ADD 1 TO vee_results-nbr_of_ins.
        ELSE.
          ADD 1 TO vee_results-nbr_of_upd.
        ENDIF.
      ELSE.
        IF h_flag EQ neuer_eintrag.
          vee_results-rc_ins = ee_rc.
        ELSE.
          vee_results-rc_upd = ee_rc.
        ENDIF.
      ENDIF.
    ELSEIF &lt;xact&gt; CO del_flags.
      PERFORM vim_mark_and_process USING sy-tabix &apos;DELE&apos;
                                         vee_results-nbr_of_del
                                         vee_results-rc_del.
      ee_rc = vee_results-rc_del.
    ELSEIF &lt;xact&gt; EQ task_add.
      PERFORM vim_mark_and_process USING sy-tabix &apos;TRIN&apos;
                                         vee_results-nbr_of_tin
                                         vee_results-rc_tin.
      ee_rc = vee_results-rc_tin.
    ELSEIF &lt;xact&gt; EQ task_del.
      PERFORM vim_mark_and_process USING sy-tabix &apos;TREX&apos;
                                         vee_results-nbr_of_tex
                                         vee_results-rc_tex.
      ee_rc = vee_results-rc_tex.
    ENDIF.
    IF ee_rc EQ 8. EXIT. ENDIF.
    IF &lt;status&gt;-bcfixdelinfosent EQ &apos;X&apos;.
      &lt;status&gt;-bcfixdelinfosent = &apos;Y&apos;.
    ENDIF.
  ENDLOOP.
  clear &lt;status&gt;-bcfixdelinfosent.
  vim_results_of_ext_mod = vee_results.
* CLEAR: REPLACE_MODE, VIM_SPECIAL_MODE, VIM_EXTERNAL_MODE.
  replace_mode = repmode_safe. vim_special_mode = specmode_safe.
  vim_external_mode = extmode_safe.
ENDFORM.                               &quot;external_edit</include_source>
   </include>
   <include NAME="LSVIMF2J" SQLX="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000001" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122434" IDATE="20080721" ITIME="122434">
    <include_source>*---------------------------------------------------------------------*
*       FORM VIM_RESTORE_STATE_INFO                                   *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM VIM_RESTORE_STATE_INFO.
  STATUS-DATA = &lt;STATUS&gt;-ST_DATA.
  STATUS-MODE =  &lt;STATUS&gt;-ST_MODE.
  STATUS-DELETE =  &lt;STATUS&gt;-ST_DELETE.
  STATUS-ACTION =  &lt;STATUS&gt;-ST_ACTION.
  TITLE         =  &lt;STATUS&gt;-TITLE.
  MAXLINES      =  &lt;STATUS&gt;-MAXLINES.
  F             =  &lt;STATUS&gt;-CUR_FIELD.
  O             =  &lt;STATUS&gt;-CUR_OFFSET.
  FUNCTION      =  &lt;STATUS&gt;-FCODE.
  L = &lt;STATUS&gt;-CUR_LINE.
ENDFORM.                               &quot;vim_restore_state_info</include_source>
   </include>
   <include NAME="LSVIMF2K" SQLX="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000001" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122434" IDATE="20080721" ITIME="122434">
    <include_source>*---------------------------------------------------------------------*
*       FORM VIM_STORE_STATE_INFO                                     *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM VIM_STORE_STATE_INFO.
  MOVE: STATUS-DATA TO &lt;STATUS&gt;-ST_DATA,
        STATUS-MODE TO &lt;STATUS&gt;-ST_MODE,
        STATUS-DELETE TO &lt;STATUS&gt;-ST_DELETE,
        STATUS-ACTION TO &lt;STATUS&gt;-ST_ACTION,
        TITLE         TO &lt;STATUS&gt;-TITLE,
        MAXLINES      TO &lt;STATUS&gt;-MAXLINES,
        F             TO &lt;STATUS&gt;-CUR_FIELD,
        O             TO &lt;STATUS&gt;-CUR_OFFSET,
        FUNCTION      TO &lt;STATUS&gt;-FCODE.
  IF L EQ 0.
    MOVE 1 TO &lt;STATUS&gt;-CUR_LINE.
  ELSE.
    MOVE L TO &lt;STATUS&gt;-CUR_LINE.
  ENDIF.
ENDFORM.                               &quot;vim_store_state_info</include_source>
   </include>
   <include NAME="LSVIMF2L" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000019" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122434" IDATE="20080721" ITIME="122435">
    <include_source>*---------------------------------------------------------------------*
*       FORM CALL_DYNPRO                                              *
*---------------------------------------------------------------------*
*       UF170200: transp. mode: don&apos;t fill CORR_KEYTAB-TABKEY with
*                 more than 120 chars
*
*---------------------------------------------------------------------*
FORM call_dynpro.
  DATA: state_init TYPE c, rc LIKE sy-subrc,
        dpl_sel_entries TYPE i, cd_specmode_safe(1) TYPE c,
        addr_e071k LIKE e071k, cd_addr_71ktab LIKE e071k OCCURS 0,
        object_key TYPE ad_objkey,
        max_trsp_keylength_in_byte TYPE i,
*       viewcluster dequeue flag XB H626152
        f_return(1) TYPE c.

  FIELD-SYMBOLS: &lt;object_keyx&gt; TYPE x.

  max_trsp_keylength_in_byte = vim_max_trsp_keylength
   * cl_abap_char_utilities=&gt;charsize.
  CASE vim_adjust_middle_level_mode.
    WHEN space.
    WHEN subset OR &apos;X&apos;.
      vim_special_mode = vim_direct_upgrade.
      IF vim_adjust_middle_level_mode EQ subset.
        x_namtab[] = vim_adj_namtab.
      ENDIF.
    WHEN &apos;L&apos;.
      CLEAR vim_adjust_middle_level_mode. function = &apos;ENDE&apos;.
      EXIT.
  ENDCASE.
* IF &lt;STATUS&gt;-ALR_SETUP EQ SPACE.
  IF &lt;status&gt;-initializd EQ space.
    PERFORM init_state_vector.
  ENDIF.
  DESCRIBE TABLE dpl_sellist LINES dpl_sel_entries.
  IF x_header-selection EQ space.
    IF dpl_sel_entries GT 0.
      MOVE &apos;X&apos; TO x_header-selection.
      MODIFY x_header INDEX 1.
      ASSIGN dpl_sellist-*sys* TO &lt;vim_ck_sellist&gt;.
    ELSE.
      DESCRIBE TABLE dba_sellist.
      IF sy-tfill GT 0.
        MOVE &apos;X&apos; TO x_header-selection.
        MODIFY x_header INDEX 1.
*       ASSIGN DBA_SELLIST-*SYS* TO &lt;VIM_CK_SELLIST&gt;.
      ENDIF.
      ASSIGN dba_sellist-*sys* TO &lt;vim_ck_sellist&gt;.
    ENDIF.
  ELSE.
    IF dpl_sel_entries GT 0.
      ASSIGN dpl_sellist-*sys* TO &lt;vim_ck_sellist&gt;.
    ELSE.
      ASSIGN dba_sellist-*sys* TO &lt;vim_ck_sellist&gt;.
    ENDIF.
  ENDIF.
  PERFORM vim_maint_selflag USING &apos;I&apos;
                            CHANGING x_header-selection.
* Übergangslösung Sortierungsproblem Anfang
  IF &lt;status&gt;-alr_sorted EQ space.
    SORT total BY &lt;vim_xtotal_key&gt;.
    MOVE &apos;X&apos; TO &lt;status&gt;-alr_sorted.
  ENDIF.
* Übergangslösung Sortierungsproblem Ende
  PERFORM exclude_cua_functions.
  IF x_header-frm_on_aut NE space AND  &quot;4.5a: support indiv. auth. chck
     &lt;status&gt;-auth_check NE space.     &quot;auth check is requested
    vim_auth_action = view_action.
    vim_auth_event = vim_auth_requested_check.
    ASSIGN &lt;vim_ck_sellist&gt; TO &lt;vim_auth_sellist&gt;.
    PERFORM (x_header-frm_on_aut) IN PROGRAM.
    IF vim_auth_rc NE 0.
      PERFORM vim_process_message USING vim_auth_msgid &apos;I&apos; &apos;E&apos;
                                        vim_auth_msgno
                                        vim_auth_msgv1 vim_auth_msgv2
                                        vim_auth_msgv3 vim_auth_msgv4.
      CASE vim_auth_rc.
        WHEN 4.                        &quot;show only
          maint_mode = anzeigen.
          excl_cua_funct-function = &apos;AEND&apos;. COLLECT excl_cua_funct.
        WHEN 8.                        &quot;exit
          RAISE missing_corr_number.
      ENDCASE.
    ENDIF.
  ENDIF.
  IF maint_mode NE anzeigen AND maint_mode NE transportieren AND
     &lt;status&gt;-dlclalrckd EQ space.
    IF vim_system_type NE &apos;SAP&apos; AND
       x_header-customauth CO sap_only_classes.
*     MESSAGE I137(SV). &quot;keine Ãnderungen, Daten gehören SAP
      PERFORM vim_process_message USING &apos;SV&apos; &apos;I&apos; &apos;I&apos; &apos;137&apos;
                                         space space space space.
    ENDIF.
    MOVE &apos;X&apos; TO &lt;status&gt;-dlclalrckd.
  ENDIF.
  IF x_header-subsetflag NE space AND &lt;status&gt;-sbsid_rcvd CO &apos; R&apos;.
    PERFORM init_subset_keyfields.
  ENDIF.
  IF x_header-selection NE space AND &lt;status&gt;-selcd_rcvd EQ space.
    LOOP AT dpl_sellist WHERE ddic EQ space OR ( operator EQ &apos;GE&apos; OR
                                                 operator EQ &apos;GT&apos; OR
                                                 operator EQ &apos;LE&apos; OR
                                                 operator EQ &apos;LT&apos; ).
      MOVE &apos;X&apos; TO state_init.
      EXIT.
    ENDLOOP.
    IF sy-subrc NE 0. &quot;no entries in DPL_SELLIST -&gt; all entries req.
      DESCRIBE TABLE total.
      IF &lt;status&gt;-maxlines NE sy-tfill AND  &quot;missing entries in EXTRACT
         &lt;status&gt;-st_data EQ gesamtdaten.   &quot;and no selection made
        IF x_header-delmdtflag NE space.
*         DESCRIBE TABLE VIM_COLLAPSED_MAINKEYS. &quot;SW int.M. 1599934/1999
*         IF &lt;STATUS&gt;-MAXLINES NE SY-TFILL.&quot;missing entries in EXTRACT
          IF &lt;status&gt;-maxlines = 0.    &quot;SW int.M. 1599934/1999
            MOVE &apos;X&apos; TO state_init.
          ENDIF.
        ELSE.
          MOVE &apos;X&apos; TO state_init.
        ENDIF.
      ENDIF.
    ENDIF.
    IF state_init NE space.
      CLEAR: &lt;status&gt;-maxlines,
             &lt;status&gt;-cur_field,
             &lt;status&gt;-cur_offset.
      MOVE: 1 TO &lt;status&gt;-cur_line,
            1 TO &lt;status&gt;-firstline,
            nicht_geloescht TO &lt;status&gt;-st_delete,
            maint_mode TO &lt;status&gt;-st_action,
            list_bild TO &lt;status&gt;-st_mode.
      PERFORM set_status_nokeyselcnds.
    ENDIF.
    MOVE &apos;X&apos; TO &lt;status&gt;-selcd_rcvd.
  ENDIF.
  IF &lt;status&gt;-initializd EQ &apos;x&apos;.
    PERFORM set_status_nokeyselcnds.
  ENDIF.
  IF maint_mode NE anzeigen AND
     corr_nbr NE space AND corr_nbr NE &lt;status&gt;-corr_nbr.
    MOVE: &lt;status&gt;-corr_nbr TO &lt;status&gt;-l_corr_nbr,
          corr_nbr TO &lt;status&gt;-corr_nbr.
  ENDIF.
  IF maint_mode EQ transportieren.
    PERFORM request_corr_number.
    IF x_header-flag EQ vim_transport_denied.
      MESSAGE i142(sv).
      function = ucomm = end. EXIT.
    ENDIF.
  ELSEIF maint_mode EQ aendern.
    PERFORM check_transp_objs_for_maint USING rc.
    CASE rc.
      WHEN 4.
        maint_mode = anzeigen.
        excl_cua_funct-function = &apos;AEND&apos;. COLLECT excl_cua_funct.
*       viewcluster dequeue flag XB H626152B
*        maint_mode = aendern.
        function = ucomm = &apos;ANZG&apos;.
*        f_return = &apos;X&apos;.
        f_return = &apos; &apos;.
*       viewcluster dequeue flag XB H626152E
      WHEN 8.
        RAISE missing_corr_number.
    ENDCASE.
  ELSE.
    vim_client_state = vim_noact.
  ENDIF.
  IF f_return &lt;&gt; &apos;X&apos;.
    MOVE: maint_mode          TO status-action,
          &lt;status&gt;-st_delete  TO status-delete,
          &lt;status&gt;-st_data    TO status-data,
          &lt;status&gt;-title      TO title,
          &lt;status&gt;-firstline  TO firstline,
          &lt;status&gt;-mk_xt      TO mark_extract,
          &lt;status&gt;-mk_to      TO mark_total,
          &lt;status&gt;-cur_line   TO l,
          &lt;status&gt;-cur_field  TO f,
          &lt;status&gt;-cur_offset TO o,
          &lt;status&gt;-maxlines   TO maxlines,
          maint_mode          TO title-action,
          firstline           TO nextline.
    IF status-action EQ aendern AND &quot;ignore history when mode was chngd.
       &lt;status&gt;-st_action EQ hinzufuegen.
      MOVE: &lt;status&gt;-st_action TO status-action,
            &lt;status&gt;-st_action TO title-action.
    ENDIF.
    IF &lt;status&gt;-st_delete EQ geloescht.
      DESCRIBE TABLE extract LINES maxlines.
      IF maxlines EQ 0.
        CLEAR status-delete.
        MOVE list_bild TO &lt;status&gt;-st_mode.
      ENDIF.
    ELSEIF &lt;status&gt;-st_mode = detail_bild&quot;SW (1248405/98) ..
       AND &lt;status&gt;-st_action &lt;&gt; hinzufuegen.
      DESCRIBE TABLE extract LINES maxlines.
      IF maxlines EQ 0.
        MOVE list_bild TO &lt;status&gt;-st_mode.
*    nur ein Eintrag  -&gt; automatisch wieder auf Detailbild verzweigt
*    mehrere Einträge -&gt; Listbild, da kein Eintrag ausgezeichnet
      ENDIF.                             &quot;.. SW
    ENDIF.
    IF ( status-action EQ transportieren AND
                                                            &quot;UF28042000
        &lt;status&gt;-l_corr_nbr NE &lt;status&gt;-corr_nbr )
     OR ( vim_client_state EQ vim_log AND &apos;ST&apos; NS status-action ) .
      PERFORM prepare_corr.
    ENDIF.
    IF status-action EQ transportieren AND get_corr_keytab NE space.
      PERFORM get_keytab.
    ENDIF.
    IF status-action EQ transportieren AND &lt;status&gt;-crcntsknwn EQ space.
      LOOP AT vim_addr_e071k_tab INTO addr_e071k.
        addr_e071k-trkorr = &lt;status&gt;-corr_nbr.
        MODIFY vim_addr_e071k_tab FROM addr_e071k.
      ENDLOOP.
      LOOP AT total.    &quot;note entries already contained in CORR_KEYTAB
        MOVE &lt;vim_total_struc&gt; TO &lt;table1&gt;.
        IF x_header-bastab EQ space.     &quot;view
          PERFORM (corr_formname) IN PROGRAM (sy-repid)
                                  USING pruefen rc.
        ELSE.                            &quot;base table
          corr_keytab =  e071k.
          corr_keytab-objname = x_header-maintview.
          IF x_header-keylen GT max_trsp_keylength_in_byte.
*        IF x_header-keylen GT vim_max_trsp_keylength.     &quot;UF170200b
            MOVE &lt;vim_xtotal_key&gt; TO &lt;vim_corr_keyx&gt;(x_header-maxtrkeyln).
*          MOVE total TO corr_keytab-tabkey(x_header-maxtrkeyln).
          ELSE.                                             &quot;UF170200e
            MOVE &lt;vim_xtotal_key&gt; TO &lt;vim_corr_keyx&gt;(x_header-keylen).
*          MOVE total TO corr_keytab-tabkey(x_header-keylen).
          ENDIF.                                            &quot;UF170200
          PERFORM update_corr_keytab USING pruefen rc.
          IF rc EQ 0.
            IF x_header-texttbexst NE space AND  &quot;text table
               &lt;vim_xtotal_text&gt; NE &lt;text_initial_x&gt;.
*             &lt;total_text&gt; NE &lt;text_initial&gt;.
              corr_keytab =  e071k.
              corr_keytab-objname = x_header-texttab.
              IF x_header-textkeylen GT max_trsp_keylength_in_byte.
*           IF x_header-textkeylen GT vim_max_trsp_keylength. &quot;UF170200b
                MOVE &lt;vim_xtotal_text&gt; TO
                               &lt;vim_corr_keyx&gt;(x_header-maxtrkeyln).
*              MOVE &lt;total_text&gt; TO
*                             corr_keytab-tabkey(x_header-maxtrtxkln).
              ELSE.                                         &quot;UF170200e
                MOVE &lt;vim_xtotal_text&gt; TO
                               &lt;vim_corr_keyx&gt;(x_header-textkeylen).
*              MOVE &lt;total_text&gt; TO
*                             corr_keytab-tabkey(x_header-textkeylen).
              ENDIF.                                        &quot;UF170200
              PERFORM update_corr_keytab USING pruefen rc.
            ENDIF.
          ENDIF.
        ENDIF.
        IF rc = 0 AND x_header-texttbexst &lt;&gt; space AND &quot;SW Texttransl ..
          vim_texttab_is_ro EQ space.
          PERFORM vim_text_keytab_entry USING &lt;vim_xtotal_key&gt; pruefen rc.
        ENDIF.                           &quot;.. Texttransl
        IF rc EQ 0.
          MOVE transportieren TO &lt;action&gt;.
          IF x_header-adrnbrflag EQ &apos;O&apos; AND &lt;address_number&gt; NE space.
            PERFORM vim_address_keytab_entries USING pruefen rc.
          ELSEIF x_header-adrnbrflag EQ &apos;N&apos; AND &lt;address_number&gt; NE space.
            APPEND LINES OF vim_addr_e071k_tab TO cd_addr_71ktab.
            ASSIGN object_key TO &lt;object_keyx&gt; CASTING.
            MOVE &lt;vim_xtotal_key&gt; TO &lt;object_keyx&gt;(x_header-keylen).
*          object_key = &lt;vim_total_key&gt;.
            CALL FUNCTION &apos;ADDR_TRANSPORT_ENTRIES&apos;
              EXPORTING
                addrnumber = &lt;address_number&gt;
                table_name = vim_addr_basetable
                field_name = vim_addr_bastab_field
                objkey     = object_key
              TABLES
                e071k_tab  = cd_addr_71ktab.
            vim_exit_11_12_active = &apos;X&apos;.
            LOOP AT cd_addr_71ktab INTO corr_keytab WHERE
             mastername = vim_addr_e071k_master_46 OR    &quot;UF688403/2000
             mastername = vim_addr_e071k_master.
* Rel &lt; 4.6A: ignore old type address entries inserted only for downward
*             compatibility
              PERFORM update_corr_keytab USING pruefen rc.
              IF rc NE 0. EXIT. ENDIF.
            ENDLOOP.
            CLEAR vim_exit_11_12_active.
            REFRESH cd_addr_71ktab.
          ENDIF.
          IF rc EQ 0.
            IF x_header-frm_e071ks NE space.
              vim_exit_11_12_active = &apos;X&apos;.
              MOVE pruefen TO corr_action.
              PERFORM (x_header-frm_e071ks) IN PROGRAM (sy-repid).
              IF sy-subrc NE 0. CLEAR &lt;action&gt;. ENDIF.
              CLEAR vim_exit_11_12_active.
            ENDIF.
          ELSE.
            CLEAR &lt;action&gt;.
          ENDIF.
        ELSE.
          CLEAR &lt;action&gt;.
        ENDIF.
        IF maxlines GT 0 AND
           vim_special_mode NE vim_extedit.                &quot;SW 1.4.1998
          READ TABLE extract WITH KEY &lt;f1_x&gt;.
          IF sy-subrc EQ 0.
            MOVE: &lt;mark&gt; TO &lt;xmark&gt;, &lt;action&gt; TO &lt;xact&gt;.
            MODIFY extract INDEX sy-tabix.
          ENDIF.
        ENDIF.
        MODIFY total.
      ENDLOOP.
      MOVE &apos;X&apos; TO &lt;status&gt;-crcntsknwn.
    ENDIF.
    IF vim_restore_mode NE space.
      status-mode = &lt;status&gt;-st_mode.
      CLEAR vim_restore_mode.
      EXIT.
    ENDIF.
    IF vim_special_mode NE vim_extedit.
      CASE vim_single_entry_function.
        WHEN space OR &apos;UPD&apos; OR &apos;SHOW&apos;.
          IF &lt;status&gt;-st_mode EQ detail_bild.
            MOVE: &apos;DETA&apos; TO function,
                  nextline TO firstline.
            IF old_nl NE 0.                                 &quot;GKPR - 0001009660
              nextline = old_nl.                            &quot;GKPR - 0001009660
              CLEAR old_nl.                                 &quot;GKPR - 0001009660
            ELSE.                                           &quot;GKPR - 0001009660
              nextline = firstline + l - 1.
            ENDIF.                                          &quot;GKPR - 0001009660
            DESCRIBE TABLE extract LINES maxlines.
            IF maxlines EQ 0.
              IF &lt;status&gt;-st_action EQ hinzufuegen.
                neuer = &apos;J&apos;.
              ELSE.
                PERFORM fill_extract.
              ENDIF.
            ENDIF.
*         CALL SCREEN DETAIL.
            PERFORM process_detail_screen USING &apos;C&apos;.
          ELSE.
            CALL SCREEN liste.
          ENDIF.
        WHEN &apos;INS&apos;.
          function = &apos;NEWL&apos;. PERFORM hinzufuegen.
        WHEN &apos;DEL&apos;.
          cd_specmode_safe = vim_special_mode.
          vim_special_mode = vim_extedit.
          READ TABLE total INTO extract INDEX 1. &lt;xact&gt; = geloescht.
          APPEND extract.
          PERFORM vim_external_edit.
          vim_special_mode = cd_specmode_safe.
          excl_cua_funct-function = &apos;UNDO&apos;. COLLECT excl_cua_funct.
          PERFORM selektiere USING geloescht.
      ENDCASE.
      MOVE: function TO ucomm.
* only relevant in viewcluster(navigation from detail screen):
      IF status-mode = detail_bild.
        last_act_entry = nextline.
      ELSE.
* navigation in viewcluster by tree-control: unuseable
        last_act_entry = &lt;status&gt;-firstline + &lt;status&gt;-cur_line - 1.
      ENDIF.
    ELSE.                                &quot;ext. edit.
      PERFORM vim_external_edit.
      &lt;status&gt;-maxlines = 0.             &quot;SW  int. Meldung 519239/1999
    ENDIF.
  ENDIF.
  IF function NE &apos;ORGD&apos; AND function NE &apos;ORGL&apos; AND
     function NE &apos;SAVE&apos; AND function NE &apos;TRSP&apos; AND function NE &apos;TRAE&apos;.
    IF x_header-subsetflag NE space AND &lt;status&gt;-sbsid_rcvd NE &apos;S&apos;.
      CLEAR &lt;status&gt;-sbsid_rcvd.
    ENDIF.
*   ELSEIF X_HEADER-SUBSETFLAG EQ SPACE AND
    IF x_header-selection NE space AND
       &lt;status&gt;-selcd_rcvd NE space.
      CLEAR &lt;status&gt;-selcd_rcvd.
    ENDIF.
    IF x_header-delmdtflag NE space.
      EXPORT vim_collapsed_mainkeys TO MEMORY ID vim_memory_id_1.
    ENDIF.
    ASSIGN dba_sellist-*sys* TO &lt;vim_sellist&gt;.
    vim_enqueue_range = x_header-subsetflag.
  ENDIF.
ENDFORM.                    &quot;call_dynpro</include_source>
   </include>
   <include NAME="LSVIMF2M" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000007" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122435" IDATE="20080721" ITIME="122435">
    <include_source>*---------------------------------------------------------------------*
*       FORM KOPIERE_EINTRAG                                          *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  --&gt;  ORIGIN                                                        *
*---------------------------------------------------------------------*
FORM kopiere_eintrag USING origin.
  DATA: ke_index LIKE sy-tabix, ke_rc LIKE sy-subrc, ke_hf TYPE i.
  field-symbols: &lt;x_origin&gt; type x.

  IF status-mode EQ list_bild AND function NE &apos;KOPF&apos; AND &quot;scrolling &amp;
     &lt;status&gt;-upd_flag EQ space.       &quot;no changes
    EXIT.
  ENDIF.
  assign origin to &lt;x_origin&gt; casting.
  IF vim_special_mode NE vim_delimit.
    IF x_header-guidflag &lt;&gt; space.
      PERFORM vim_make_guid using space.
    ENDIF.
    IF x_header-frm_on_new NE space.
      IF replace_mode NE space.
        &lt;status&gt;-mk_to = mark_total.
        &lt;status&gt;-mk_xt = mark_extract.
        vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
        EXIT.
      ENDIF.
      PERFORM (x_header-frm_on_new) IN PROGRAM (sy-repid).
    ENDIF.
    IF &lt;f1_x&gt; EQ &lt;x_origin&gt;.
      PERFORM set_pf_status USING &apos;ERROR&apos;.
      MESSAGE e015(sv).
      EXIT.
    ELSE.
      neuer = &apos;J&apos;.
      PERFORM check_key.
      neuer = &apos;N&apos;.
      CHECK sy-subrc NE 0.
      MOVE: sy-subrc TO ke_rc,
            sy-tabix TO ke_index.
    ENDIF.
  ELSE.
    READ TABLE total WITH KEY &lt;f1_x&gt; BINARY SEARCH.
    MOVE: sy-subrc TO ke_rc,
          sy-tabix TO ke_index.
  ENDIF.
* gültiger Eintrag.
  IF vim_special_mode NE vim_delimit.  &quot;copy mode
    IF x_header-bastab NE space AND x_header-texttbexst NE space AND
       &lt;status&gt;-upd_flag EQ &apos;E&apos;.
      PERFORM (vim_frm_text_upd_flag) IN PROGRAM.
    ENDIF.
    IF x_header-adrnbrflag NE space.
      PERFORM address_maintain.
    ENDIF.
    IF x_header-texttbexst &lt;&gt; space.   &quot;SW Textcopy
      PERFORM vim_copy_texttab_entry USING &lt;f1_x&gt; &lt;vim_xextract_key&gt;.
    ENDIF.
    IF vim_called_by_cluster NE space.
      PERFORM vim_store_state_info.
      CALL FUNCTION &apos;VIEWCLUSTER_COPY_DEPENDENT&apos;
           EXPORTING
                view_name   = x_header-viewname
                maintview   = x_header-maintview
                status_mode = status-mode
                workarea    = extract
                new_entry   = &lt;table1&gt;
                no_dialog   = vim_external_mode.
      PERFORM vim_restore_state_info.
    ENDIF.
  ENDIF.
  IF vim_special_mode NE vim_delimit OR ke_rc NE 0.
    &lt;action&gt; = neuer_eintrag.
    &lt;mark&gt; = nicht_markiert.
  ELSE.                                &quot;delimit mode and existing entry
    IF &lt;action&gt; EQ original. &lt;action&gt; = aendern. ENDIF.
  ENDIF.
  ADD 1 TO counter.
*  MOVE &lt;table1&gt; TO total(x_header-tablen).
  MOVE &lt;table1&gt; TO &lt;vim_total_struc&gt;.
  IF x_header-bastab NE space AND x_header-texttbexst NE space AND
     &lt;status&gt;-upd_flag EQ &apos;X&apos; OR &lt;status&gt;-upd_flag EQ &apos;T&apos;.
    MOVE &lt;table1_xtext&gt; TO &lt;vim_xtotal_text&gt;.
    IF vim_special_mode NE vim_delimit OR ke_rc NE 0.
      MOVE neuer_eintrag TO &lt;action_text&gt;.
    ELSE.
      IF &lt;action_text&gt; EQ original. &lt;action_text&gt; = aendern. ENDIF.
    ENDIF.
  ENDIF.
  vim_copied_indices-ex_ix = nextline.
  vim_copied_indices-level = vim_copy_call_level.
  CASE ke_rc.
    WHEN 0.
      MODIFY total INDEX ke_index.
      READ TABLE vim_copied_indices WITH KEY ix = ke_index
                                    BINARY SEARCH
                                    TRANSPORTING NO FIELDS.
      IF sy-subrc NE 0.
        vim_copied_indices-ix = ke_index.
        INSERT vim_copied_indices INDEX sy-tabix.
      ENDIF.
    WHEN 4.
      INSERT total INDEX ke_index.
      READ TABLE vim_copied_indices WITH KEY ix = ke_index
                                    BINARY SEARCH
                                    TRANSPORTING NO FIELDS.
      vim_copied_indices-ix = ke_index.
      INSERT vim_copied_indices INDEX sy-tabix.
      ke_hf = sy-tabix + 1.
      LOOP AT vim_copied_indices FROM ke_hf.
        ADD 1 TO vim_copied_indices-ix.
        MODIFY vim_copied_indices.
      ENDLOOP.
    WHEN 8.
      APPEND total.
      vim_copied_indices-ix = ke_index.
      APPEND vim_copied_indices.
  ENDCASE.
  neuer = &apos;N&apos;.
  &lt;status&gt;-upd_flag = space.
  READ TABLE total WITH KEY &lt;x_origin&gt; BINARY SEARCH.
  IF sy-subrc = 0 AND &lt;mark&gt; EQ markiert.
    &lt;mark&gt; = nicht_markiert.
    SUBTRACT 1 FROM mark_total.
    MODIFY total INDEX sy-tabix.
  ENDIF.
  IF status-mode EQ detail_bild.
    vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
  ENDIF.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF2N" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000011" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122435" IDATE="20080721" ITIME="122435">
    <include_source>*---------------------------------------------------------------------*
*       FORM KOPIERE                                                  *
*---------------------------------------------------------------------*
* Kopieren als... und teilweise Gültigkeit abgrenzen                  *
*---------------------------------------------------------------------*
FORM kopiere.
  DATA: z LIKE sy-tabix VALUE 1,
        stat TYPE c, dum1 TYPE i.
  status-action = kopieren.
  MOVE status-data TO stat.
  status-data = auswahldaten.
  title-data = auswahldaten.
  ADD 1 TO vim_copy_call_level.
  IF vim_special_mode EQ vim_delimit.
    title-action = vim_delimit.
*  ELSEIF &lt;STATUS&gt;-PROF_FOUND NE VIM_PR_INTO_DET.           &quot;UFprofile
*    TITLE-ACTION = KOPIEREN.
  ENDIF.
*  ASSIGN extract(x_header-keylen) TO &lt;orig_key&gt;.
  ASSIGN &lt;vim_xextract_key&gt; TO &lt;orig_key&gt;.
  IF status-mode EQ list_bild.
    LOOP AT extract.
      IF &lt;xmark&gt; NE markiert.
        DELETE extract.
      ELSE.
        &lt;xmark&gt; = nicht_markiert.
        MODIFY extract.
      ENDIF.
    ENDLOOP.
    mark_extract = &lt;status&gt;-mk_xt = 0.
    nextline = 1.
    DESCRIBE TABLE extract LINES maxlines.
    IF vim_copy_call_level = 1.
      VIM_NR_ENTRIES_TO_COPY = maxlines.            &quot;SW 510129/1999
    ENDIF.
    IF status-type EQ einstufig.
      IF vim_special_mode NE vim_delimit.
        MESSAGE s024(sv).
      ELSE.
        MESSAGE s124(sv).
      ENDIF.
      CALL SCREEN liste.
      IF function NE &apos;ABR &apos;.
        DESCRIBE TABLE vim_copied_indices.
        IF sy-tfill LT VIM_NR_ENTRIES_TO_COPY.     &quot;SW 510129/1999
          &quot;not all selected entries where proc.
          LOOP AT extract.
            READ TABLE vim_copied_indices
                 WITH KEY level = vim_copy_call_level ex_ix = z.
            IF sy-subrc EQ 0.
              DELETE extract.
            ELSE.
              &lt;xmark&gt; = markiert. MODIFY extract.
            ENDIF.
            ADD 1 TO z.
          ENDLOOP.
          PERFORM kopiere.
        ENDIF.
      ENDIF.
    ELSE.
      LOOP AT extract.
        IF vim_special_mode NE vim_delimit.
          neuer = &apos;J&apos;.
          MESSAGE s025(sv).
        ELSE.
          MESSAGE s125(sv).
        ENDIF.
        PERFORM move_extract_to_view_wa.
        PERFORM process_detail_screen USING &apos;C&apos;.
        neuer = &apos;N&apos;.
        &lt;status&gt;-upd_flag = space.
        IF temporal_delimitation_happened NE space.
          CLEAR temporal_delimitation_happened.
        ENDIF.
        IF vim_special_mode EQ vim_delimit.
          REFRESH vim_delim_entries.
        ENDIF.
        IF function EQ &apos;ABR &apos;.
          EXIT.
        ENDIF.
      ENDLOOP.
    ENDIF.
    IF vim_copy_call_level GT 1.
      SUBTRACT 1 FROM vim_copy_call_level.
      EXIT.
    ENDIF.
    IF vim_special_mode NE vim_delimit AND counter LE 1.
      PERFORM fill_extract.
      mark_extract = mark_total.
      title-data = gesamtdaten.
      IF counter EQ 1.
        READ TABLE vim_copied_indices INDEX 1.
        READ TABLE total INDEX vim_copied_indices-ix.
        IF x_header-delmdtflag EQ space.
          READ TABLE extract WITH KEY &lt;vim_xtotal_key&gt;
                             TRANSPORTING NO FIELDS.
          nextline = sy-tabix.
        ELSE.
          nextline = 0.
          LOOP AT vim_collapsed_mainkeys.
            check &lt;vim_collapsed_mkey_bfx&gt; = &lt;vim_tot_mkey_beforex&gt;.
*            WHERE mkey_bf EQ &lt;vim_tot_mkey_before&gt;.
            IF vim_mkey_after_exists NE space.
              CHECK &lt;vim_collapsed_key_afx&gt; EQ &lt;vim_tot_mkey_afterx&gt;.
*              CHECK &lt;vim_collapsed_key_af&gt; EQ &lt;vim_tot_mkey_after&gt;.
            ENDIF.
            READ TABLE extract WITH KEY &lt;vim_collapsed_keyx&gt;
*            READ TABLE extract WITH KEY &lt;vim_collapsed_key&gt;
                               TRANSPORTING NO FIELDS.
            nextline = sy-tabix.
            EXIT.
          ENDLOOP.
          IF sy-subrc NE 0 OR nextline EQ 0.
            READ TABLE extract WITH KEY &lt;vim_xtotal_key&gt;
                               TRANSPORTING NO FIELDS.
            IF sy-subrc NE 0.
              nextline = 1.
            ELSE.
              nextline = sy-tabix.
            ENDIF.
          ENDIF.
        ENDIF.
      ELSE.
        nextline = 1.
      ENDIF.
    ELSE.
      status-action = title-action = hinzufuegen.
      status-data = title-data = auswahldaten.
      &lt;status&gt;-selected = neuer_eintrag.
      REFRESH: extract, vim_delim_entries.
      CLEAR: vim_mainkey, temporal_delimitation_happened.
      TRANSLATE vim_no_mainkey_exists USING vim_no_mkey_not_procsd_patt.
      mark_extract = 0.
      LOOP AT vim_copied_indices.
        READ TABLE total INDEX vim_copied_indices-ix.
        extract = total.
        APPEND extract.
        IF x_header-delmdtflag NE space.
          LOOP AT vim_collapsed_mainkeys.
            check &lt;vim_collapsed_mkey_bfx&gt; = &lt;vim_ext_mkey_beforex&gt;.
*                             WHERE mkey_bf EQ &lt;vim_ext_mkey_before&gt;.
            IF vim_mkey_after_exists NE space.
              CHECK &lt;vim_collapsed_key_afx&gt; EQ &lt;vim_ext_mkey_afterx&gt;.
*              CHECK &lt;vim_collapsed_key_af&gt; EQ &lt;vim_ext_mkey_after&gt;.
            ENDIF.
            READ TABLE excl_cua_funct WITH KEY function = &apos;EXPA&apos;.
            IF sy-subrc NE 0.
              APPEND &apos;EXPA&apos; TO excl_cua_funct.
              vim_delim_expa_excluded = &apos;X&apos;.
            ENDIF.
            vim_collapsed_mainkeys-log_key =
                                        vim_collapsed_mainkeys-mkey_bf.
            CLEAR vim_collapsed_mainkeys-mkey_bf.
            MODIFY vim_collapsed_mainkeys. EXIT.
          ENDLOOP.
        ENDIF.
      ENDLOOP.
      vim_coll_mainkeys_beg_ix = 1.
      nextline = 1.
    ENDIF.
    l = 1.
    DESCRIBE TABLE extract LINES maxlines.
  ELSE.
* Detailbild
    CLEAR &lt;status&gt;-mark_only.          &quot;ufdetail
    IF vim_special_mode NE vim_delimit.
      neuer = &apos;J&apos;.
      MESSAGE s025(sv).
    ELSE.
      MESSAGE s125(sv).
    ENDIF.
    PERFORM process_detail_screen USING &apos;C&apos;.
    neuer = &apos;N&apos;.
    &lt;status&gt;-upd_flag = space.
    IF function NE &apos;IGN &apos; AND function NE &apos;ABR &apos;.
      IF vim_special_mode NE vim_delimit.
* copy mode
        IF status-mark EQ markiert.
          READ TABLE extract WITH KEY &lt;orig_key&gt; BINARY SEARCH.
          IF sy-subrc EQ 0.
            &lt;xmark&gt; = nicht_markiert.
            MODIFY extract INDEX sy-tabix.
            SUBTRACT 1 FROM mark_extract.
          ENDIF.
        ENDIF.
      ELSE.
* delimit mode
        IF temporal_delimitation_happened NE space.
          PERFORM after_temporal_delimitation.
        ENDIF.
      ENDIF.
      READ TABLE total WITH KEY &lt;f1_x&gt; BINARY SEARCH.
      extract = total.
*     IF &lt;STATUS&gt;-DISPL_MODE EQ EXPANDED OR SY-SUBRC NE 0.
      IF x_header-delmdtflag NE space.
        PERFORM check_if_entry_is_to_display USING &apos;L&apos; &lt;vim_xtotal_key&gt;
                                                   &apos;D&apos; &lt;vim_begdate&gt;.
        IF sy-subrc EQ 0.
          PERFORM check_new_mainkey.
          IF sy-subrc EQ 0.
            READ TABLE vim_collapsed_mainkeys
             WITH KEY &lt;vim_tot_mkey_beforex&gt;
*            READ TABLE vim_collapsed_mainkeys WITH KEY &lt;vim_total_key&gt;
                                             BINARY SEARCH
                                             TRANSPORTING NO FIELDS.
            &lt;vim_collapsed_keyx&gt; = &lt;vim_xtotal_key&gt;.
*            vim_collapsed_mainkeys-mainkey = &lt;vim_total_key&gt;.
            &lt;vim_collapsed_mkey_bfx&gt; = &lt;vim_tot_mkey_beforex&gt;.
*            vim_collapsed_mainkeys-mkey_bf = &lt;vim_tot_mkey_before&gt;.
            INSERT vim_collapsed_mainkeys INDEX sy-tabix.
          ENDIF.
          CLEAR sy-subrc.
        ENDIF.
      ENDIF.
      IF x_header-delmdtflag EQ space OR sy-subrc LT 8.
        READ TABLE extract WITH KEY &lt;vim_xextract_key&gt; BINARY SEARCH
         TRANSPORTING NO FIELDS.       &quot;UF 333778/1999
        CASE sy-subrc.
          WHEN 0.         &quot;UF 333778/1999, for temporal delimitation
            MODIFY extract INDEX sy-tabix.
          WHEN 4.
            INSERT extract INDEX sy-tabix.
          WHEN 8.
            APPEND extract.
        ENDCASE.
        MOVE: sy-tabix TO exind,
              sy-tabix TO nextline.
        CLEAR: old_nl.                                &quot;GKPR - 0001009660
      ENDIF.
      IF looplines GT 0.
        IF nextline LE firstline.
          dum1 = ( firstline - nextline ) / looplines.
          ADD 1 TO dum1.
          DO dum1 TIMES.
            firstline = firstline - looplines + 1.
          ENDDO.
          IF firstline LE 0. firstline = 1. ENDIF.
        ELSE.
          dum1 = firstline + looplines - 1.
          IF nextline GT dum1.
            dum1 = ( nextline - firstline ) / looplines.
            DO dum1 TIMES.
              firstline = firstline + looplines - 1.
            ENDDO.
          ENDIF.
        ENDIF.
        l = nextline - firstline + 1.
      ELSE.
        l = nextline.
      ENDIF.
      MOVE: firstline TO &lt;status&gt;-firstline,
            l         TO &lt;status&gt;-cur_line.
      DESCRIBE TABLE extract LINES maxlines.
    ENDIF.
    MOVE: stat TO status-data,
          stat TO title-data.
  ENDIF.
  REFRESH vim_copied_indices.
  SUBTRACT 1 FROM vim_copy_call_level.
  IF vim_special_mode NE vim_delimit.
    MESSAGE s014(sv) WITH counter.
  ELSE.
    IF counter EQ 1.
      MESSAGE s122(sv).
    ELSE.
      MESSAGE s123(sv) WITH counter.
    ENDIF.
  ENDIF.
  status-action = aendern.
  IF title-action NE hinzufuegen.
    title-action = aendern.
  ENDIF.
  CLEAR vim_old_viewkey.
  TRANSLATE vim_no_mainkey_exists USING vim_no_mkey_not_procsd_patt.
  IF function EQ &apos;ABR &apos;.
    vim_next_screen = liste. vim_leave_screen = &apos;X&apos;.
  ELSEIF function NE &apos;IGN &apos;.
    IF vim_special_mode EQ vim_delimit AND status-mode EQ detail_bild.
      function = &apos;DETA&apos;.
    ELSE.
      CLEAR function.
    ENDIF.
  ENDIF.
ENDFORM.                    &quot;kopiere</include_source>
   </include>
   <include NAME="LSVIMF2O" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000006" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122435" IDATE="20080721" ITIME="122435">
    <include_source>*---------------------------------------------------------------------*
*       FORM REPLACE                                                  *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM replace.
  DATA: firstline_safe TYPE i,
        w_field TYPE vimty_fields_type.

  DESCRIBE TABLE exclude_tab.
  IF sy-tfill GT 0.                    &quot;entries in old exclude_tab
    PERFORM consider_old_exclude_tab TABLES excl_rpl_tab.
  ENDIF.
  CALL FUNCTION &apos;REPLACE_GET_FIELD&apos;
    EXPORTING
      table                  = x_header-maintview
    IMPORTING
      name_of_selected_field = sel_field_for_replace
    TABLES
      exclude_fields         = excl_rpl_tab
    EXCEPTIONS
      cancelled_by_user      = 0004
      no_valid_fields        = 8.
  CASE sy-subrc.
    WHEN 4.
      function = &apos;ABR &apos;. EXIT.
    WHEN 8.
      MESSAGE s039(sv) WITH view_name. EXIT.
  ENDCASE.
**************&quot;HCG BC-Set Fix Values Authorithy-Check *****************
  IF vim_bc_chng_allowed = space. &quot;BC-Set Fixvalue change forbidden
    READ TABLE vim_bc_entry_list INTO vim_bc_entry_list_wa
                                     WITH KEY keys = &lt;vim_xtotal_key&gt;.

    READ TABLE vim_bc_entry_list_wa-fields INTO w_field
                WITH KEY fieldname = sel_field_for_replace.
    IF w_field-flag = vim_profile_fix.
      MESSAGE i184(sv).
    ENDIF.
    CHECK w_field-flag NE vim_profile_fix.
  ENDIF.
***********************************************************************
  LOOP AT x_namtab WHERE viewfield EQ sel_field_for_replace.&quot;#EC *
    IF x_header-bastab NE space AND x_header-texttbexst NE space
                                AND x_namtab-texttabfld NE space.
      ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE
                &lt;vim_ext_txt_struc&gt; TO &lt;replace_field&gt;.
    ELSE.
      ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE
                &lt;vim_extract_struc&gt; TO &lt;replace_field&gt;.
    ENDIF.
*    ASSIGN extract+x_namtab-position(x_namtab-flength)
*                              TO &lt;replace_field&gt; TYPE x_namtab-inttype.
    IF x_header-bastab NE space AND x_header-texttbexst NE space.
      MOVE x_namtab-texttabfld TO replace_texttable_field.
    ELSE.
      CLEAR replace_texttable_field.
    ENDIF.
  ENDLOOP.
  IF replace_texttable_field EQ space. &quot;view or base table field
    CONCATENATE x_header-maintview sel_field_for_replace
       INTO sel_field_for_replace_l SEPARATED BY &apos;-&apos;.
  ELSE.                                &quot;text table field
    CONCATENATE x_header-texttab sel_field_for_replace
       INTO sel_field_for_replace_l SEPARATED BY &apos;-&apos;.
  ENDIF.
  IF x_header-frm_bf_rpl NE space.
    PERFORM (x_header-frm_bf_rpl) IN PROGRAM (sy-repid).
  ENDIF.
* SET PF-STATUS &apos;REPLACE&apos;.
  PERFORM set_pf_status USING &apos;REPLACE&apos;.
  replace_mode = &apos;X&apos;. vim_special_mode = vim_replace.
  counter = 0.
  firstline_safe = firstline.
  LOOP AT extract.                                          &quot;#EC *
    CHECK &lt;xmark&gt; EQ markiert.
    nextline = exind = sy-tabix.
    IF replace_texttable_field EQ space.  &quot;view or base table field
      CALL FUNCTION &apos;REPLACE_SET_VALUE&apos;
        EXPORTING
          old_table = &lt;vim_xextract&gt;
        IMPORTING
          new_table = &lt;table1_x&gt;.
      IF x_header-bastab NE space AND x_header-texttbexst NE space.
        &lt;table1_xtext&gt; = &lt;vim_xextract_text&gt;.
      ENDIF.
    ELSE.                              &quot;text table field
      MOVE &lt;vim_extract_struc&gt; TO &lt;table1&gt;.
      CALL FUNCTION &apos;REPLACE_SET_VALUE&apos;
        EXPORTING
          old_table = &lt;vim_xextract_text&gt;
        IMPORTING
          new_table = &lt;table1_xtext&gt;.
    ENDIF.
    CASE status-type.
      WHEN einstufig.
        CALL SCREEN liste.
      WHEN zweistufig.
        PERFORM process_detail_screen USING &apos;C&apos;.
        &lt;vim_extract_struc&gt; = &lt;table1&gt;.
        IF x_header-bastab NE space AND x_header-texttbexst NE space.
          &lt;vim_xextract_text&gt; = &lt;table1_xtext&gt;.
        ENDIF.
    ENDCASE.
    CHECK ok_code NE &apos;IGN &apos;.
    IF function EQ &apos;ABR &apos;.
      EXIT.
    ENDIF.
    counter = counter + 1.
    SUBTRACT 1 FROM mark_extract.
    SUBTRACT 1 FROM mark_total.
  ENDLOOP.
  firstline = nextline = firstline_safe.
  replace_mode = vim_special_mode = space.
  MESSAGE s012(sv) WITH counter.
  IF x_header-frm_af_rpl NE space.
    PERFORM (x_header-frm_af_rpl) IN PROGRAM (sy-repid).
  ENDIF.
ENDFORM.                    &quot;replace</include_source>
   </include>
   <include NAME="LSVIMF2P" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000003" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122435" IDATE="20080721" ITIME="122435">
    <include_source>*---------------------------------------------------------------------*
*       FORM CONSIDER_OLD_EXCLUDE_TAB                                 *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM CONSIDER_OLD_EXCLUDE_TAB
                  TABLES NEW_EXCLUDE_TAB STRUCTURE VIMEXCLFLD.
  DATA: BEGIN OF VIEWNAME_PATTERN,
          VIEWNAME LIKE VIMDESC-VIEWNAME,
          WILDCARD(1) TYPE C VALUE &apos;*&apos;,
        END OF VIEWNAME_PATTERN.

  VIEWNAME_PATTERN-VIEWNAME = X_HEADER-MAINTVIEW.
  CONDENSE VIEWNAME_PATTERN NO-GAPS.
  LOOP AT EXCLUDE_TAB WHERE FIELD CP VIEWNAME_PATTERN.
    SHIFT EXCLUDE_TAB-FIELD UP TO &apos;-&apos;. SHIFT EXCLUDE_TAB-FIELD.
    NEW_EXCLUDE_TAB-FIELDNAME = EXCLUDE_TAB-FIELD.
    COLLECT NEW_EXCLUDE_TAB.
  ENDLOOP.
ENDFORM.                               &quot;consider_old_exclude_tab</include_source>
   </include>
   <include NAME="LSVIMF2Q" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000005" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122435" IDATE="20080721" ITIME="122435">
    <include_source>*---------------------------------------------------------------------*
*       FORM SUCHEN                                                   *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM suchen.
  DESCRIBE TABLE exclude_tab.
  IF sy-tfill GT 0.                    &quot;entries in old exclude_tab
    PERFORM consider_old_exclude_tab TABLES excl_que_tab.
  ENDIF.
  CALL FUNCTION &apos;QUERY_GET_OPERATION&apos;
       EXPORTING
            table             = x_header-maintview
       TABLES
            exclude_fields    = excl_que_tab
       EXCEPTIONS
            table_not_found   = 0004
            no_valid_fields   = 0008
            cancelled_by_user = 0012.
  CASE sy-subrc.
    WHEN 0.
    WHEN 8.
      MESSAGE s039(sv) WITH view_name.
      EXIT.
    WHEN OTHERS.
      EXIT.
  ENDCASE.
  status-data   = auswahldaten.
  title-data    = auswahldaten.
  IF title-action EQ geloescht.
    status-delete = nicht_geloescht.
    title-action = aendern.
  ENDIF.
  REFRESH extract.
  LOOP AT total.
    PERFORM select USING by_field_contents.
    CHECK sy-subrc EQ 0.
    extract = total.
    APPEND extract.
  ENDLOOP.
  &lt;status&gt;-selected = by_field_contents.
  DESCRIBE TABLE extract LINES maxlines.
  nextline = 1.
  IF maxlines EQ 0.
    PERFORM fill_extract.
    MESSAGE s004(sv).
    EXIT.
  ENDIF.
  IF maxlines EQ 1.
    MESSAGE s005(sv).
    IF status-type EQ zweistufig.
      PERFORM read_table USING maxlines.
      PERFORM process_detail_screen USING &apos;S&apos;.
    ENDIF.
  ELSE.
    IF status-mode EQ detail_bild.
      vim_next_screen = liste. vim_leave_screen = &apos;X&apos;.
    ENDIF.
  ENDIF.
  MESSAGE s006(sv) WITH maxlines.
  mark_extract = 0.
  LOOP AT extract.
    IF &lt;xmark&gt; EQ markiert.
      mark_extract = mark_extract + 1.
    ENDIF.
  ENDLOOP.
  IF x_header-delmdtflag &lt;&gt; space.        &quot;SW CSS-Problem 83157/1999
    LOOP AT extract.
      LOOP AT vim_collapsed_mainkeys.
        CHECK &lt;vim_collapsed_mkey_bfx&gt; = &lt;vim_ext_mkey_beforex&gt;
         AND &lt;vim_collapsed_keyx&gt; &lt;&gt; &lt;vim_xextract_key&gt;.
*      LOOP AT vim_collapsed_mainkeys WHERE
*                mkey_bf = &lt;vim_ext_mkey_before&gt;.
*        IF vim_collapsed_mainkeys-mainkey &lt;&gt; &lt;vim_extract_key&gt;.
        DELETE vim_collapsed_mainkeys.
*        ENDIF.
      ENDLOOP.
    ENDLOOP.
  ENDIF.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF2R" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000004" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122435" IDATE="20080721" ITIME="122435">
    <include_source>*---------------------------------------------------------------------*
*       FORM CHECK_IF_ENTRY_CAN_BE_DELETED                            *
*---------------------------------------------------------------------*
* check if entry of existency-M-table/view can be deleted             *
*---------------------------------------------------------------------*
* SY_SUBRC &lt;-- 0: yes, deleteable, others: no, not deleteable         *
*---------------------------------------------------------------------*
FORM check_if_entry_can_be_deleted.
  LOCAL: &lt;f1_x&gt;, total, &lt;vim_xextract_key&gt;.
  DATA: hf TYPE i, rec TYPE i VALUE 8.

  &lt;vim_xextract_key&gt; = &lt;f1_x&gt; = &lt;vim_xtotal_key&gt;.
  CLEAR &lt;vim_enddate_mask&gt;.
  READ TABLE total WITH KEY &lt;f1_x&gt; BINARY SEARCH TRANSPORTING NO FIELDS.
  hf = sy-tabix.
  LOOP AT total FROM hf.
    IF &lt;vim_tot_mkey_beforex&gt; NE &lt;vim_f1_beforex&gt; OR
       ( vim_mkey_after_exists NE space AND
         &lt;vim_tot_mkey_afterx&gt; NE &lt;vim_f1_afterx&gt; ).
*    IF &lt;vim_tot_mkey_before&gt; NE &lt;vim_f1_before&gt; OR
*       ( vim_mkey_after_exists NE space AND
*         &lt;vim_tot_mkey_after&gt; NE &lt;vim_f1_after&gt; ).
      EXIT.
    ENDIF.
    CHECK &lt;action&gt; NE geloescht AND &lt;action&gt; NE neuer_geloescht AND
          &lt;action&gt; NE update_geloescht AND
          &lt;vim_xtotal_key&gt; NE &lt;vim_xextract_key&gt;.
    CLEAR rec. EXIT.
  ENDLOOP.
  sy-subrc = rec.
ENDFORM.                               &quot;check_if_entry_can_be_deleted</include_source>
   </include>
   <include NAME="LSVIMF2S" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000006" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122435" IDATE="20080721" ITIME="122435">
    <include_source>*---------------------------------------------------------------------*
*       LOGICAL_DELETE_FROM_TOTAL                                     *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM logical_delete_from_total USING value(cur_index) TYPE i.
  CASE &lt;action&gt;.
    WHEN neuer_eintrag.
      &lt;action&gt;         = neuer_geloescht.
    WHEN original.
      &lt;action&gt;         = geloescht.
    WHEN aendern.
      &lt;action&gt;         = update_geloescht.
  ENDCASE.
*  perform vim_bc_logs_maintain using geloescht
*                                     x_header
*                               changing vim_bc_entry_list.
  IF x_header-bastab NE space AND x_header-texttbexst NE space.
    CASE &lt;action_text&gt;.
      WHEN neuer_eintrag.
        &lt;action_text&gt;         = neuer_geloescht.
      WHEN original.
        IF &lt;vim_xtotal_text&gt; NE &lt;text_initial_x&gt;.
*        IF &lt;total_text&gt; NE &lt;text_initial&gt;.
          &lt;action_text&gt;         = geloescht.
        ELSE.
          PERFORM (vim_frm_fill_textkey) IN PROGRAM (sy-repid)
                                       USING &lt;vim_total_struc&gt;
                                             &lt;vim_tot_txt_struc&gt;.
* Unicode: Form FILL_TEXTTAB_KEY_UC instead of FILL_TEXTTAB_KEY_UC
*                                       USING &lt;vim_total_key&gt;
*                                             &lt;total_text&gt;.
          &lt;action_text&gt;         = dummy_geloescht. &quot;always del texttbent
        ENDIF.
      WHEN aendern.
        &lt;action_text&gt;         = update_geloescht.
    ENDCASE.
  ENDIF.
  &lt;mark&gt;       = nicht_markiert.
  MODIFY total INDEX cur_index.
ENDFORM.                               &quot;logical_delete_from_total</include_source>
   </include>
   <include NAME="LSVIMF2T" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000006" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122435" IDATE="20080721" ITIME="122436">
    <include_source>*---------------------------------------------------------------------*
*       FORM LISTE_LOESCHE                                            *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM liste_loesche.
  DATA: rec LIKE sy-subrc,
        delete_fix_value(1) TYPE c,
        entry_contains_fix_val(1) TYPE c,
        w_field TYPE vimty_fields_type,
        bc_fix_del_info_sent(1) TYPE c VALUE &apos; &apos;.

  READ TABLE extract INDEX firstline.
  IF x_header-delmdtflag &lt;&gt; space.
    &lt;vim_h_old_mkey&gt;(x_header-keylen) = &lt;vim_xextract_key&gt;.
  ENDIF.
*  vim_old_viewkey = &lt;vim_extract_key&gt;.
  counter = 0.
  LOOP AT extract.
    CHECK &lt;xmark&gt; EQ markiert.
*   -------Authority check before deleting fix values from BC-Sets------
    delete_fix_value = vim_bc_chng_allowed.
    IF vim_bc_chng_allowed = space.  &quot;fix field changeability forced
      READ TABLE vim_bc_entry_list INTO vim_bc_entry_list_wa
      WITH TABLE KEY viewname = x_header-viewname
      keys = &lt;vim_xextract_key&gt;.
      IF sy-subrc = 0.
        CLEAR entry_contains_fix_val.
        LOOP at vim_bc_entry_list_wa-fields into w_field.
          IF w_field-flag = vim_profile_fix.
            entry_contains_fix_val = &apos;X&apos;.
          ENDIF.
        ENDLOOP.
        IF entry_contains_fix_val = &apos;X&apos;.
          IF bc_fix_del_info_sent EQ SPACE AND
             &lt;status&gt;-bcfixdelinfosent NE &apos;Y&apos;.&quot;HCG: del dependent VCL
            bc_fix_del_info_sent = &apos;X&apos;.
            &lt;status&gt;-bcfixdelinfosent = &apos;X&apos;.
            MESSAGE i177(SV).
          ENDIF.
        ELSE.
          delete_fix_value = &apos;X&apos;.
        ENDIF.
      ELSE.
        delete_fix_value = &apos;X&apos;.
      ENDIF.
    ENDIF.
    CHECK delete_fix_value EQ &apos;X&apos;.
*   -------------------------------------------------------------&quot;HCG---
    READ TABLE total WITH KEY &lt;vim_xextract_key&gt; BINARY SEARCH.
    rec = sy-tabix.
    IF x_header-existency EQ &apos;M&apos;.      &quot;no mainkey delete allowed
      PERFORM check_if_entry_can_be_deleted.
      IF sy-subrc NE 0.
        &lt;xmark&gt; = uebergehen. ignored_entries_exist = &apos;X&apos;.
        MODIFY extract.
        &lt;mark&gt; = uebergehen.
        MODIFY total INDEX rec.
        CONTINUE.
      ENDIF.
    ENDIF.
    PERFORM delete_check_keyrange.
    CASE sy-subrc.
      WHEN 0.
      WHEN 4. CONTINUE.
      WHEN 8. EXIT.
    ENDCASE.
    counter = counter + 1.
    PERFORM logical_delete_from_total USING rec.
    IF x_header-delmdtflag NE space.
      IF vim_special_mode NE vim_upgrade.
        PERFORM check_if_entry_is_to_display USING &apos;L&apos; &lt;vim_xtotal_key&gt;
                                                   space &lt;vim_begdate&gt;.
      ELSE.
        CLEAR sy-subrc.
      ENDIF.
      CASE sy-subrc.
        WHEN 0. DELETE extract.
        WHEN 4.
          &lt;f1_x&gt; = &lt;vim_xtotal_key&gt;. CLEAR &lt;vim_enddate_mask&gt;.
          &lt;vim_h_old_mkey&gt;(x_header-keylen) = &lt;f1_x&gt;.
*          vim_old_viewkey = &lt;f1&gt;.
          &lt;vim_h_mkey&gt; = &lt;vim_xtotal_key&gt;.
*          vim_mainkey = &lt;vim_total_key&gt;.
          rec = 8.
          LOOP AT total.
            PERFORM select USING &lt;status&gt;-selected.
            CHECK sy-subrc EQ 0.
            CHECK &lt;vim_tot_mkey_beforex&gt; EQ &lt;vim_f1_beforex&gt; AND
               ( vim_mkey_after_exists EQ space OR
               &lt;vim_tot_mkey_afterx&gt; EQ &lt;vim_f1_afterx&gt; ). &quot;same mainkey
*            CHECK &lt;vim_tot_mkey_before&gt; EQ &lt;vim_f1_before&gt; AND
*                  ( vim_mkey_after_exists EQ space OR
*                    &lt;vim_tot_mkey_after&gt; EQ &lt;vim_f1_after&gt; ).
            extract = total.
            PERFORM mod_extract_and_mainkey_tab USING &apos;M&apos; 0.
            CLEAR rec.
            EXIT.
          ENDLOOP.
          IF rec NE 0.
            DELETE extract.
          ENDIF.
      ENDCASE.
    ELSE.
      DELETE extract.
    ENDIF.
    mark_total  = mark_total - 1.
    mark_extract = mark_extract - 1.
  ENDLOOP.
  CHECK vim_special_mode NE vim_upgrade.
  DESCRIBE TABLE extract LINES maxlines.
  IF status-action EQ hinzufuegen.
    SUBTRACT nbr_of_added_dummy_entries FROM maxlines.
  ENDIF.
  IF ignored_entries_exist EQ space AND maxlines GT 0.
    MESSAGE s011(sv) WITH counter.
  ELSE.
    MESSAGE i011(sv) WITH counter.
  ENDIF.
  IF x_header-delmdtflag &lt;&gt; space.
    &lt;f1_x&gt; = &lt;vim_h_old_mkey&gt;.
  ENDIF.
*  &lt;f1&gt; = vim_old_viewkey.
  READ TABLE extract WITH KEY &lt;f1_x&gt;.
  IF sy-subrc EQ 0.           &quot;HCG Otherwise sy-tabix = 0; HW681892
    rec = firstline + looplines - 1.
    IF sy-tabix GT rec OR nextline GT maxlines.
      nextline = sy-tabix.
    ENDIF.
  ELSE.
    nextline = 1.
  ENDIF.
  IF maxlines EQ 0 AND status-action EQ hinzufuegen.
    status-action = aendern.
    title-action = aendern.
    l = 1. o = 0.
  ENDIF.
  CLEAR vim_old_viewkey.
  TRANSLATE vim_no_mainkey_exists USING vim_no_mkey_not_procsd_patt.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF2U" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000004" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122436" IDATE="20080721" ITIME="122436">
    <include_source>*---------------------------------------------------------------------*
*       FORM VIM_CK_APPEND_WHERETAB                                   *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM VIM_CK_APPEND_WHERETAB TABLES VCAW_WHERETAB STRUCTURE VIMWHERETB
                            USING VALUE(LINE) TYPE VIM_CK_SELCOND.
DATA: BEGIN OF HF, F1(1) TYPE C, F2 LIKE VIMSELLIST-VALUE, F3(1) TYPE C,
                  END OF HF.
DATA: len TYPE i,l_line(134) TYPE c.
CONSTANTS: wheretab_length TYPE i VALUE 72.
  CHECK NOT LINE IS INITIAL.
  IF LINE-VALUE EQ SPACE.
    HF = &apos;&apos;&apos; &apos;&apos;&apos;.
  ELSE.
    CONCATENATE: LINE-HK1
                 LINE-VALUE
                 LINE-HK2
      INTO HF.
  ENDIF.
  CONCATENATE: LINE-FIELD
               LINE-OPERATOR
               HF
               LINE-AND
    INTO VCAW_WHERETAB SEPARATED BY SPACE.
  IF SY-SUBRC EQ 0.
    APPEND VCAW_WHERETAB.
  ELSE.
    CONCATENATE: LINE-FIELD
                 LINE-OPERATOR
      INTO VCAW_WHERETAB SEPARATED BY SPACE.
    APPEND VCAW_WHERETAB.
    CONCATENATE: HF
                 LINE-AND
      INTO l_line SEPARATED BY SPACE.
    vcaw_wheretab = l_line.
    APPEND vcaw_wheretab.
    len = strlen( l_line ).
    IF len &gt; wheretab_length.
      CLEAR vcaw_wheretab.
      vcaw_wheretab = l_line+wheretab_length.
      APPEND vcaw_wheretab.
    ENDIF.
    IF line-and &lt;&gt; space.
      vcaw_wheretab = line-and.
        APPEND VCAW_WHERETAB.
    ENDIF.
  ENDIF.
ENDFORM.                               &quot;vim_ck_append_wheretab</include_source>
   </include>
   <include NAME="LSVIMF2V" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000010" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122436" IDATE="20080721" ITIME="122436">
    <include_source>*---------------------------------------------------------------------*
*       FORM CHECK_KEY                                                *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM check_key.
  DATA: s LIKE sy-tabix, mess_type(1) TYPE c VALUE &apos;E&apos;, ck_tabix TYPE i,
        ck_check_tab LIKE vimdesc-viewname, ck_slcnds_nokey(1) TYPE c,
        ck_clause TYPE vim_ck_selcond, ck_wa TYPE REF TO data,
        ck_wheretab LIKE vimwheretb OCCURS 10, ck_rc LIKE sy-subrc,
        oc_keys TYPE occheckkeyflds, n(1) TYPE n, ocmes TYPE fieldname,
        field1 TYPE fieldname, field2 TYPE fieldname,
        field3 TYPE fieldname, field4 TYPE fieldname,
        w_oc_keys TYPE occheckkey, fieldname TYPE fnam_____4.
  FIELD-SYMBOLS: &lt;ck_1&gt; TYPE ANY, &lt;noauth&gt; TYPE fieldname,
                 &lt;namtab&gt; TYPE vimnamtab, &lt;ck_wa&gt; TYPE ANY,
                 &lt;table1_txt_loc&gt; type any.

  CHECK neuer CO &apos;JX&apos;.
  IF vim_key_alr_checked NE space.
    READ TABLE total WITH KEY &lt;f1_x&gt; BINARY SEARCH.
    EXIT.
  ELSE.
    vim_key_alr_checked = &apos;X&apos;.
  ENDIF.
* first check namespace
  IF x_header-customauth CO sap_cust_classes OR
     vim_ale_keyspec_check NE space OR
     vim_sync_keyspec_check NE space.
    PERFORM check_allowed_keyranges.
  ENDIF.
* check if user is authorised for this key
  IF NOT vim_oc_inst IS INITIAL.
    CALL METHOD vim_oc_inst-&gt;build_key_value_tab
      EXPORTING
        entry     = &lt;table1&gt;
      IMPORTING
        keyvalues = oc_keys.
    CALL METHOD vim_oc_inst-&gt;check_oc_authority
      EXPORTING
        activity        = &apos;02&apos;
      CHANGING
        key_values      = oc_keys
      EXCEPTIONS
        no_auth         = 1
*        key_incomplete  = 2
        wrong_parameter = 3
        OTHERS          = 4.
    CASE sy-subrc.
      WHEN 1.
        PERFORM set_pf_status USING &apos;ERROR&apos;.
        CLEAR vim_key_alr_checked.
        LOOP AT oc_keys INTO w_oc_keys WHERE noauth = &apos;X&apos;.
          n = n + 1.
          CONCATENATE &apos;FIELD&apos; n INTO ocmes.
          IF n &lt;= &apos;4&apos;.
            ASSIGN (ocmes) TO &lt;noauth&gt;.
            READ TABLE x_namtab ASSIGNING &lt;namtab&gt; WITH KEY
             viewfield = w_oc_keys-keyname.
            CHECK sy-subrc = 0.
            IF &lt;namtab&gt;-scrtext_s &lt;&gt; space.
              &lt;noauth&gt; = &lt;namtab&gt;-scrtext_s.
            ELSE.
              &lt;noauth&gt; = w_oc_keys-keyname.
            ENDIF.
          ELSE.
*            ocmiss4 = text-001.
          ENDIF.
        ENDLOOP.
        MESSAGE e757(sv) WITH field1 field2 field3 field4.
      WHEN OTHERS.
*     MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*                WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
    ENDCASE.
  ENDIF.
* second check if entry fits selection conditions
  IF x_header-selection NE space.
    if x_header-bastab &lt;&gt; space and x_header-texttbexst &lt;&gt; space.
      assign &lt;table1_text&gt; to &lt;table1_txt_loc&gt;.
    else.
      assign &lt;table1&gt; to &lt;table1_txt_loc&gt;.
    endif.
    CALL FUNCTION &apos;TABLE_RANGE_CHECK&apos;
         EXPORTING
              tabname                   = x_header-maintview
              entry                     = &lt;table1&gt;
              entry_text                = &lt;table1_txt_loc&gt;
              ddic                      = &apos;J&apos;
              key                       = &apos;J&apos;
              ignore_blank_subsetfields = &apos;N&apos;
         TABLES
              x_namtab                  = x_namtab
              x_header                  = x_header
              sellist                   = &lt;vim_ck_sellist&gt;
         EXCEPTIONS
              entry_not_fits            = 1.
    IF sy-subrc EQ 1.
      PERFORM set_pf_status USING &apos;ERROR&apos;.
      CLEAR vim_key_alr_checked.
      MESSAGE e033(sv).
    ENDIF.
  ENDIF.                               &quot;x_header-selection ne space.
* Forkey-Check for subset fields in import mode
  IF vim_called_by_cluster = space AND
   ( vim_import_mode_active &lt;&gt; space OR
     vim_special_mode = vim_upgrade ).
    CALL FUNCTION &apos;VIEW_FORKEY_CHECK&apos;
         EXPORTING
              viewname     = view_name
              entry        = &lt;table1&gt;
         TABLES
              namtab       = x_namtab
         EXCEPTIONS
              forkey_error = 1.
    IF sy-subrc EQ 1.
      PERFORM set_pf_status USING &apos;ERROR&apos;.
      CLEAR vim_key_alr_checked.
      MESSAGE ID sy-msgid TYPE &apos;E&apos; NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.
  ENDIF.
* third check against TOTAL anyway
  READ TABLE total WITH KEY &lt;f1_x&gt; BINARY SEARCH.
  ck_tabix = sy-tabix.
* fourth check against db if not found and nokey-selconds exist
  IF sy-subrc NE 0 AND                 &quot;entry not found in TOTAL and
     x_header-selection NE space AND   &quot;selconds exist and
   &lt;status&gt;-nokeyslcds NE space.       &quot;nokey-selconds: check against db
    IF x_header-bastab EQ space.
      ck_check_tab = x_header-roottab.
    ELSE.
      ck_check_tab = x_header-maintview.
    ENDIF.
    LOOP AT x_namtab WHERE keyflag NE space. &quot;all keyfields
      IF x_header-bastab NE space AND x_header-texttbexst NE space.
        CHECK x_namtab-texttabfld EQ space. &quot;ignore texttab-keyfields
      ELSEIF x_header-bastab EQ space. &quot;view -&gt; safety check langu key
        CHECK x_namtab-bastabname EQ x_header-roottab.
      ENDIF.
      PERFORM vim_ck_append_wheretab TABLES ck_wheretab
                                     USING ck_clause.
      IF x_header-bastab EQ space.
        ck_clause-field = x_namtab-bastabfld.
      ELSE.
        ck_clause-field = x_namtab-viewfield.
      ENDIF.
      ck_clause-operator = &apos;EQ&apos;.
      ck_clause-hk1 = &apos;&apos;&apos;&apos;.
      ck_clause-hk2 = &apos;&apos;&apos;&apos;.
      ck_clause-and = &apos;AND&apos;.
      IF x_namtab-inttype CO &apos;DTN&apos;.
        ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE &lt;table1&gt;
         TO &lt;ck_1&gt; CASTING TYPE c.
*        ASSIGN &lt;f1&gt;+x_namtab-position(x_namtab-flength) TO &lt;ck_1&gt;
*                                                        TYPE &apos;C&apos;.
*      ELSEIF x_namtab-inttype CO &apos;IPX&apos;.
      ELSE.
       CONCATENATE x_header-maintview x_namtab-viewfield INTO fieldname
           SEPARATED BY &apos;-&apos;.
        ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE &lt;table1&gt;
         TO &lt;ck_1&gt; CASTING TYPE (fieldname).
*        ASSIGN &lt;f1&gt;+x_namtab-position(x_namtab-flength) TO &lt;ck_1&gt;
*                                            TYPE x_namtab-inttype.
*      ELSE.
*        ASSIGN &lt;f1&gt;+x_namtab-position(x_namtab-flength) TO &lt;ck_1&gt;.
      ENDIF.
      ck_clause-value = &lt;ck_1&gt;.
      CONDENSE ck_clause-value.             &quot;IG CM 446319 2005.
    ENDLOOP.
    CLEAR ck_clause-and.
    PERFORM vim_ck_append_wheretab TABLES ck_wheretab
                                   USING ck_clause.
    CREATE DATA ck_wa TYPE (ck_check_tab).
    ASSIGN ck_wa-&gt;* TO &lt;ck_wa&gt;.
    SELECT SINGLE * INTO &lt;ck_wa&gt; FROM (ck_check_tab)
                                 WHERE (ck_wheretab).
    IF sy-subrc EQ 8.                  &quot;key not qualified
      RAISE impossible_error.
    ENDIF.
    ck_rc = sy-subrc.
  ELSE. &quot;entry found in TOTAL or no nokey-selconds
    ck_rc = sy-subrc.
  ENDIF.                               &quot;x_header-selection ne space.
  IF ck_rc NE 0 AND vim_called_by_cluster NE space.
    CALL FUNCTION &apos;VIEWCLUSTER_CHECK_MASTER_ENTRY&apos;
         EXPORTING
              check_entry   = &lt;table1&gt;
              view_name     = x_header-viewname
         EXCEPTIONS
              invalid_key   = 1
              invalid_value = 2.
    IF sy-subrc NE 0.
      IF status-mode EQ list_bild.
        SET CURSOR FIELD sy-msgv1 LINE l.
      ELSE.
        SET CURSOR FIELD sy-msgv1.
      ENDIF.
      CLEAR vim_key_alr_checked.
      PERFORM set_pf_status USING &apos;ERROR&apos;.
      MESSAGE ID sy-msgid TYPE &apos;E&apos; NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.
  ENDIF.
  sy-subrc = ck_rc. sy-tabix = ck_tabix.
  CHECK ck_rc EQ 0.
  IF x_header-delmdtflag NE space AND status-mode EQ detail_bild.
    mess_type = &apos;S&apos;.
  ENDIF.
  PERFORM set_pf_status USING &apos;ERROR&apos;.
  CLEAR vim_key_alr_checked.
  IF &lt;action&gt; EQ geloescht
  OR &lt;action&gt; EQ neuer_geloescht
  OR &lt;action&gt; EQ update_geloescht.
    MESSAGE ID &apos;SV&apos; TYPE mess_type NUMBER &apos;010&apos;.
  ELSE.
    MESSAGE ID &apos;SV&apos; TYPE mess_type NUMBER &apos;009&apos;.
  ENDIF.
  IF x_header-delmdtflag NE space AND status-mode EQ detail_bild.
    &lt;vim_h_old_mkey&gt;(x_header-keylen) = &lt;f1_x&gt;.
*    vim_old_viewkey = &lt;f1&gt;.
    TRANSLATE neuer USING &apos;JX&apos;.
    CLEAR: function, ok_code. LEAVE SCREEN.
  ENDIF.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF2W" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000007" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122436" IDATE="20080721" ITIME="122436">
    <include_source>*---------------------------------------------------------------------*
*       FORM HINZUFUEGEN                                              *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM hinzufuegen.
  DATA: h_screenmode(1) TYPE c VALUE &apos;S&apos;.
  CASE status-action.
    WHEN hinzufuegen.
      nextline = maxlines.
    WHEN aendern.
      REFRESH extract.
      maxlines = 0.
      nextline = &lt;status&gt;-cur_line = 1.
      IF status-type EQ zweistufig.
        firstline = &lt;status&gt;-firstline = nextline.
      ENDIF.
      IF vim_single_entry_function EQ &apos;INS&apos;.
        h_screenmode = &apos;C&apos;.
      ENDIF.
    WHEN OTHERS.
      MESSAGE i001(sv).
      EXIT.
  ENDCASE.
  MOVE &lt;initial&gt; TO &lt;table1&gt;.
  IF x_header-clidep NE space.
    MOVE sy-mandt TO &lt;client&gt;.
  ENDIF.
  MOVE &lt;table1&gt; TO &lt;vim_extract_struc&gt;.
  IF x_header-bastab NE space AND x_header-texttbexst NE space.
    MOVE: &lt;text_initial&gt; TO &lt;table1_text&gt;,
          &lt;table1_xtext&gt; TO &lt;vim_xextract_text&gt;.
*          &lt;table1_text&gt; TO &lt;extract_text&gt;.
  ENDIF.
  status-action = hinzufuegen.
  &lt;status&gt;-selected = neuer_eintrag.
  status-data   = auswahldaten.
  title-action  = hinzufuegen.
  title-data    = auswahldaten.
  neuer  = &apos;J&apos;.
  IF status-type EQ zweistufig.
    PERFORM process_detail_screen USING h_screenmode.
  ELSE.
    IF vim_single_entry_function EQ &apos;INS&apos;.
      nbr_of_added_dummy_entries = 1.
    ELSEIF looplines EQ 0.
      MOVE 50 TO nbr_of_added_dummy_entries.
    ELSE.
      MOVE looplines TO nbr_of_added_dummy_entries.
    ENDIF.
    MOVE leer TO &lt;xact&gt;. clear &lt;xmark&gt;.
    DO nbr_of_added_dummy_entries TIMES.
      APPEND extract.
    ENDDO.
    IF h_screenmode EQ &apos;S&apos;.
      SET SCREEN liste.
      LEAVE SCREEN.
    ELSE.
      CALL SCREEN liste.
    ENDIF.
  ENDIF.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF2X" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000004" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122436" IDATE="20080721" ITIME="122436">
    <include_source>*---------------------------------------------------------------------*
*       FORM CHECK_NEW_MAINKEY                                        *
*---------------------------------------------------------------------*
* check if current mainkey is a new one                               *
*---------------------------------------------------------------------*
* &lt;-- SY-SUBRC : 0 -&gt; mainkey is new, others -&gt; mainkey already exists*
*---------------------------------------------------------------------*
FORM check_new_mainkey.
  LOCAL: total, &lt;table1&gt;.
  DATA: hf TYPE i, rec TYPE i.

  MOVE: &lt;vim_xtotal_key&gt; TO &lt;f1_x&gt;.
  READ TABLE total WITH KEY &lt;f1_x&gt; BINARY SEARCH TRANSPORTING NO FIELDS.
  IF sy-subrc EQ 0.&quot;new entry already inserted into TOTAL
    hf = sy-tabix - 1.
    READ TABLE total INDEX hf.         &quot;read previous entry
    IF &lt;vim_tot_mkey_beforex&gt; EQ &lt;vim_f1_beforex&gt; AND
       ( vim_mkey_after_exists EQ space OR
         &lt;vim_tot_mkey_afterx&gt; EQ &lt;vim_f1_afterx&gt; ). &quot;same mainkey
*    IF &lt;vim_tot_mkey_before&gt; EQ &lt;vim_f1_before&gt; AND
*       ( vim_mkey_after_exists EQ space OR
*         &lt;vim_tot_mkey_after&gt; EQ &lt;vim_f1_after&gt; ). &quot;same mainkey
      rec = 8.                         &quot;-&gt; mainkey already exists
    ELSE. &quot;not the same mainkey -&gt; check also next entry
      hf = hf + 2.
      READ TABLE total INDEX hf.       &quot;read next entry
      IF &lt;vim_tot_mkey_beforex&gt; EQ &lt;vim_f1_beforex&gt; AND
         ( vim_mkey_after_exists EQ space OR
           &lt;vim_tot_mkey_afterx&gt; EQ &lt;vim_f1_afterx&gt; ). &quot;same mainkey
*      IF &lt;vim_tot_mkey_before&gt; EQ &lt;vim_f1_before&gt; AND
*         ( vim_mkey_after_exists EQ space OR
*           &lt;vim_tot_mkey_after&gt; EQ &lt;vim_f1_after&gt; ). &quot;same mainkey
        rec = 8.                       &quot;-&gt; mainkey already exists
      ENDIF.
    ENDIF.
  ENDIF.
  sy-subrc = rec.
ENDFORM.                               &quot;check_new_mainkey</include_source>
   </include>
   <include NAME="LSVIMF2Y" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000008" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122436" IDATE="20080721" ITIME="122436">
    <include_source>*---------------------------------------------------------------------*
*       FORM NICHT_VORHANDEN                                          *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM nicht_vorhanden USING rc tabind.
  DATA: dum TYPE i VALUE 0.
  FIELD-SYMBOLS &lt;tot_mkey_beforex&gt; TYPE X.

*  MOVE &lt;table1&gt; TO total.
  move &lt;table1&gt; to &lt;vim_total_struc&gt;.
  IF x_header-bastab NE space AND x_header-texttbexst NE space.
    MOVE &lt;table1_xtext&gt; TO &lt;vim_xtotal_text&gt;.
* nec. if special types in texttab
*    MOVE &lt;table1_text&gt; TO &lt;total_text&gt;.
    IF &lt;status&gt;-upd_flag EQ &apos;X&apos; OR &lt;status&gt;-upd_flag EQ &apos;T&apos;.
      &lt;action_text&gt; = neuer_eintrag.
    ELSE.
      CLEAR &lt;action_text&gt;.
    ENDIF.
  ENDIF.
  &lt;action&gt;          = neuer_eintrag.
  CLEAR &lt;mark&gt;.                                          &quot;HCG HW785631
  CASE rc.                                                  &quot;aro
    WHEN 0.                                                 &quot;aro
      MODIFY total INDEX tabind.  &quot;#EC *                          &quot;aro
    WHEN 4.
      INSERT total INDEX tabind. &quot;#EC *
    WHEN 8.                                                 &quot;aro
      APPEND total. &quot;#EC *
  ENDCASE.                                                  &quot;aro
  IF vim_special_mode NE vim_upgrade AND                    &quot;aro
     status-action NE kopieren.                             &quot;aro
    IF status-mode EQ list_bild.
      IF vim_single_entry_function EQ space.
        CLEAR &lt;xmark&gt;.
        APPEND extract. &quot;#EC *
      ELSE.
        nbr_of_added_dummy_entries = 0.
      ENDIF.
      extract = total.
      MODIFY extract INDEX nextline. &quot;#EC *
    ELSE.
      IF x_header-delmdtflag NE space.
        PERFORM check_if_entry_is_to_display USING &apos;L&apos; &lt;vim_xtotal_key&gt;
                                                   &apos;D&apos; &lt;vim_begdate&gt;.
        IF sy-subrc EQ 0.
          PERFORM check_new_mainkey.
          IF sy-subrc EQ 0.
            READ TABLE vim_collapsed_mainkeys WITH KEY &lt;vim_xtotal_key&gt;
                                             BINARY SEARCH
                                         TRANSPORTING NO FIELDS. &quot;#EC *
            &lt;vim_collapsed_keyx&gt; = &lt;vim_xtotal_key&gt;.
*           vim_collapsed_mainkeys-mainkey = &lt;vim_total_key&gt;.
            ASSIGN &lt;vim_tot_mkey_before&gt; TO &lt;tot_mkey_beforex&gt; CASTING.
* &quot;HCG      &lt;vim_collapsed_mkey_bfx&gt; = &lt;vim_tot_mkey_before&gt;. hex=char!
            &lt;vim_collapsed_mkey_bfx&gt; = &lt;tot_mkey_beforex&gt;.
*           vim_collapsed_mainkeys-mkey_bf = &lt;vim_tot_mkey_before&gt;.
            INSERT vim_collapsed_mainkeys INDEX sy-tabix. &quot;#EC *
          ENDIF.
          CLEAR sy-subrc.
        ENDIF.
      ENDIF.
      IF x_header-delmdtflag EQ space OR sy-subrc LT 8.
        extract = total.
        APPEND extract. &quot;#EC *
        exind = sy-tabix.
      ENDIF.
    ENDIF.
  ENDIF.                                                    &quot;aro
  neuer = &apos;N&apos;.
  DESCRIBE TABLE extract LINES maxlines.
  IF status-mode EQ list_bild.                              &quot;aro
    SUBTRACT nbr_of_added_dummy_entries FROM maxlines.
    dum = maxlines - firstline - sy-loopc + 1.              &quot;aro
    IF dum EQ 0.                                            &quot;aro
      destpage = maxlines.
    ENDIF.                                                  &quot;aro
  ENDIF.                                                    &quot;aro
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF2Z" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000009" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122436" IDATE="20080721" ITIME="122436">
    <include_source>*---------------------------------------------------------------------*
*       FORM UPDATE_ENTRY                                             *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM update_entry USING value(ue_total_only).
  DATA: rec LIKE sy-subrc, tabix LIKE sy-tabix.
  tabix = sy-tabix.
  IF &lt;status&gt;-upd_flag EQ &apos;X&apos; OR &lt;status&gt;-upd_flag EQ &apos;E&apos; OR
     &lt;status&gt;-upd_flag EQ &apos;Y&apos;.
    IF x_header-customauth CO sap_cust_ctrl_classes OR
       vim_ale_keyspec_check NE space OR
       vim_sync_keyspec_check NE space.
      PERFORM check_allowed_keyranges.
    ENDIF.
    MOVE &lt;table1&gt; TO &lt;vim_total_struc&gt;.
*    WRITE &lt;table1&gt; TO total(x_header-tablen).
    IF &lt;xact&gt; EQ original.
      &lt;action&gt;          = aendern.
    ELSE.
      &lt;action&gt;          = &lt;xact&gt;.
    ENDIF.
  ENDIF.
  IF x_header-bastab NE space AND x_header-texttbexst NE space AND
     &lt;status&gt;-upd_flag EQ &apos;X&apos; OR &lt;status&gt;-upd_flag EQ &apos;T&apos; OR
     &lt;status&gt;-upd_flag EQ &apos;Y&apos;.
    IF x_header-customauth CO sap_cust_ctrl_classes OR
       vim_ale_keyspec_check NE space OR
       vim_sync_keyspec_check NE space.
      PERFORM check_allowed_keyranges.
    ENDIF.
    IF &lt;status&gt;-upd_flag NE &apos;Y&apos;.
      IF &lt;vim_xtotal_text&gt; EQ &lt;text_initial_x&gt;.
        &lt;action_text&gt; = neuer_eintrag.
      ELSE.
        IF &lt;xact_text&gt; EQ original.
          &lt;action_text&gt;          = aendern.
        ELSE.
          &lt;action_text&gt;          = &lt;xact_text&gt;.
        ENDIF.
      ENDIF.
    ENDIF.
    MOVE &lt;table1_xtext&gt; TO &lt;vim_xtotal_text&gt;.
*    MOVE &lt;table1_text&gt; TO &lt;total_text&gt;.
  ENDIF.
  IF replace_mode NE space.
    &lt;mark&gt; = nicht_markiert.
  ELSE.
    &lt;mark&gt; = &lt;xmark&gt;.
  ENDIF.
  MODIFY total  INDEX tabix.                                &quot;#EC *
  IF ue_total_only EQ space.
    IF x_header-delmdtflag NE space.
      PERFORM check_if_entry_is_to_display USING &apos;L&apos; &lt;vim_xtotal_key&gt;
                                                 &apos;X&apos; &lt;vim_begdate&gt;.
      rec = sy-subrc.
    ENDIF.
    extract = total.
    IF x_header-delmdtflag EQ space OR rec LT 8.
      IF vim_import_profile = space.
        READ TABLE extract WITH KEY &lt;vim_xextract_key&gt;
                                              TRANSPORTING NO FIELDS.
        IF sy-tabix NE 0.
          MODIFY extract INDEX sy-tabix.                &quot;HCG HW664505
        ELSE.
          MODIFY extract INDEX index.
        ENDIF.
      ELSE.
        MODIFY extract INDEX index.
      ENDIF.
    ENDIF.
  ENDIF.
ENDFORM.                               &quot;update_entry</include_source>
   </include>
   <include NAME="LSVIMF30" SQLX="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000001" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122436" IDATE="20080721" ITIME="122436">
    <include_source>*---------------------------------------------------------------------*
*       FORM VORHANDEN                                                *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM VORHANDEN.
  PERFORM UPDATE_ENTRY USING SPACE.
ENDFORM.                               &quot;vorhanden</include_source>
   </include>
   <include NAME="LSVIMF31" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000008" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122436" IDATE="20080721" ITIME="122436">
    <include_source>*---------------------------------------------------------------------*
*       FORM UPDATE_TAB                                               *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM update_tab.
  DATA: rc_safe LIKE sy-subrc, tabix LIKE sy-tabix, h_ix TYPE i,
        begdate_safe TYPE d, enddate_safe TYPE d.
  CHECK status-action NE anzeigen.
  CHECK status-action NE transportieren.
  CHECK status-delete NE geloescht.
  IF &lt;status&gt;-upd_flag EQ space.
    neuer = &apos;N&apos;.
    EXIT.
  ENDIF.
  IF status-type EQ einstufig AND status-action EQ hinzufuegen.
    IF ( ( x_header-bastab EQ space OR x_header-texttbexst EQ space )
           AND &lt;table2_x&gt; EQ &lt;initial_x&gt;
         OR x_header-bastab NE space AND x_header-texttbexst NE space
           AND &lt;vim_xextract_enti&gt; EQ &lt;initial_x&gt;
         OR ( vim_special_mode EQ vim_upgrade OR
           vim_single_entry_function NE space ) )
        AND &lt;xact&gt; EQ leer.            &quot;int943578/2000
      neuer = &apos;J&apos;.
    ELSE.
      neuer = &apos;N&apos;.
    ENDIF.
  ENDIF.
  IF x_header-frm_h_flds NE space.
    PERFORM (x_header-frm_h_flds) IN PROGRAM.               &quot;Zp 21
  ENDIF.
  IF neuer EQ &apos;J&apos;.
    IF x_header-guidflag &lt;&gt; space.
      PERFORM vim_make_guid USING space.
    ENDIF.
    IF x_header-frm_on_new NE space.
      PERFORM (x_header-frm_on_new) IN PROGRAM.             &quot;Zp 05
    ENDIF.
    PERFORM check_key.
    MOVE: sy-subrc TO rc_safe, sy-tabix TO tabix.
    IF x_header-adrnbrflag NE space.
      IF vim_special_mode NE vim_upgrade.
        PERFORM address_maintain.
      ELSE.
        PERFORM vim_address_adjust.
      ENDIF.
    ENDIF.
    IF vim_called_by_cluster NE space AND vim_extcopy_mode NE space.
      h_ix = nextline + 1.
      READ TABLE extract INDEX h_ix.
      DELETE extract INDEX h_ix.
      IF x_header-texttbexst &lt;&gt; space. &quot;SW Textcopy
        PERFORM vim_copy_texttab_entry USING &lt;f1_x&gt; &lt;vim_xextract_key&gt;.
      ENDIF.
      PERFORM vim_store_state_info.
      CALL FUNCTION &apos;VIEWCLUSTER_COPY_DEPENDENT&apos;
           EXPORTING
                view_name   = x_header-viewname
                maintview   = x_header-maintview
                status_mode = status-mode
                workarea    = extract
                new_entry   = &lt;table1&gt;
                no_dialog   = vim_external_mode.
    ENDIF.
    PERFORM nicht_vorhanden USING rc_safe tabix.
  ELSE.
    IF vim_special_mode EQ vim_upgrade.
      PERFORM vim_address_adjust.
    ENDIF.
    IF vim_called_by_cluster NE space.
      CALL FUNCTION &apos;VIEWCLUSTER_CHECK_MASTER_ENTRY&apos;
           EXPORTING
                check_entry   = &lt;table1&gt;
                view_name     = x_header-viewname
           EXCEPTIONS
                invalid_key   = 1
                invalid_value = 2.
      IF sy-subrc NE 0.
        IF status-mode EQ list_bild.
          SET CURSOR FIELD sy-msgv1 LINE l.
        ELSE.
          SET CURSOR FIELD sy-msgv1.
        ENDIF.
        MESSAGE ID sy-msgid TYPE &apos;E&apos; NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ENDIF.
    ENDIF.
    MOVE exind TO index.
    READ TABLE total WITH KEY &lt;f1_x&gt; BINARY SEARCH.
    IF vim_special_mode NE vim_upgrade.
      PERFORM vorhanden.               &quot;update both tables
    ELSE.
      PERFORM update_entry USING &apos;X&apos;.
    ENDIF.
  ENDIF.
  MOVE space TO &lt;status&gt;-upd_flag.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF32" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000004" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122437" IDATE="20080721" ITIME="122437">
    <include_source>*---------------------------------------------------------------------*
*       FORM READ_TABLE                                               *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  --&gt;  IND                                                           *
*---------------------------------------------------------------------*
FORM read_table USING ind.
  IF replace_mode NE space OR vim_special_mode EQ vim_delete.
    EXIT.
  ENDIF.
  READ TABLE extract INDEX ind.
  MOVE sy-tabix TO exind.
  IF sy-subrc NE 0.
    MOVE &lt;initial&gt; TO &lt;table1&gt;.
    MOVE &lt;table1&gt; TO &lt;vim_extract_struc&gt;.
    IF x_header-bastab NE space AND x_header-texttbexst NE space.
      MOVE: &lt;text_initial_x&gt; TO &lt;vim_xextract_text&gt;,
            &lt;text_initial_x&gt; to &lt;table1_xtext&gt;.
*            &lt;table1_text&gt; TO &lt;extract_text&gt;.
    ENDIF.
    IF status-mode EQ detail_bild AND status-action EQ hinzufuegen AND
       neuer EQ &apos;N&apos;.                   &quot;e.g. &apos;PREV&apos; without input
      neuer = &apos;J&apos;.
    ENDIF.
  ELSE.
    PERFORM move_extract_to_view_wa.
  ENDIF.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF33" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000005" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122437" IDATE="20080721" ITIME="122437">
    <include_source>*---------------------------------------------------------------------*
*       FORM CHECK_IF_ENTRY_IS_TO_DISPLAY                             *
*---------------------------------------------------------------------*
* &lt;--- SY_SUBRC - 0: display entry, expanded mode or new entry        *
*               - 4: display entry, collapsed mode and actual entry   *
*               - 8: don&apos;t display entry, collapsed mode              *
*---------------------------------------------------------------------*
FORM check_if_entry_is_to_display USING value(key_local) TYPE char01
                                        value(key_in)    TYPE any
                                        value(mod_flag)  TYPE char01
                                        value(begdate)   TYPE d.
  DATA: rec TYPE i, act_entry_flag(1) TYPE c.
  LOCAL: total, extract.
  FIELD-SYMBOLS: &lt;key_x&gt; TYPE x, &lt;key_h&gt; TYPE x.


  CLEAR: &lt;table1_wa&gt;.
  &lt;f1_wax&gt; = &lt;f1_x&gt;.
  ASSIGN: key_in TO &lt;key_h&gt; CASTING,
          &lt;key_h&gt;(x_header-keylen) TO &lt;key_x&gt;.
  MOVE &lt;key_x&gt; TO &lt;f1_x&gt;.
  IF mod_flag NE space AND
     x_header-delmdtflag EQ &apos;E&apos; AND begdate LE sy-datum AND
     &lt;vim_enddate_mask&gt; GE sy-datum OR x_header-delmdtflag EQ &apos;B&apos; AND
     begdate GE sy-datum AND &lt;vim_enddate_mask&gt; LE sy-datum.
    act_entry_flag = &apos;X&apos;.
  ENDIF.
  LOOP AT vim_collapsed_mainkeys FROM vim_coll_mainkeys_beg_ix.
    CHECK &lt;vim_collapsed_mkey_bfx&gt; = &lt;vim_f1_beforex&gt;.
*                                 WHERE mkey_bf EQ &lt;vim_f1_before&gt;.
    IF vim_mkey_after_exists NE space.
      CHECK &lt;vim_collapsed_key_afx&gt; EQ &lt;vim_f1_afterx&gt;.
*      CHECK &lt;vim_collapsed_key_af&gt; EQ &lt;vim_f1_after&gt;.
    ENDIF.
    vim_last_coll_mainkeys_ix = sy-tabix.
    IF act_entry_flag NE space.
      IF mod_flag EQ &apos;D&apos;.
        READ TABLE extract WITH KEY &lt;vim_collapsed_keyx&gt;
                           TRANSPORTING NO FIELDS.
        IF sy-subrc EQ 0.
          DELETE extract INDEX sy-tabix.
        ENDIF.
      ENDIF.
      IF &lt;key_x&gt; NE &lt;vim_collapsed_keyx&gt;.
*      IF key_in NE vim_collapsed_mainkeys-mainkey.
        &lt;vim_collapsed_keyx&gt; = &lt;key_x&gt;.
*        vim_collapsed_mainkeys-mainkey = key_in.
        &lt;vim_xtotal_key&gt; = &lt;key_x&gt;.
        if &lt;vim_collapsed_mkey_bfx&gt; ne &lt;vim_tot_mkey_beforex&gt;.
          &lt;vim_collapsed_mkey_bfx&gt; = &lt;vim_tot_mkey_beforex&gt;.
        endif.
*        vim_collapsed_mainkeys-mkey_bf = &lt;vim_tot_mkey_before&gt;.
        MODIFY vim_collapsed_mainkeys.
      ENDIF.
      rec = 4.
    ELSE.
      IF &lt;key_x&gt; NE &lt;vim_collapsed_keyx&gt;.
*      IF key_in NE vim_collapsed_mainkeys-mainkey.
        rec = 8.
      ELSE.
        rec = 4.
      ENDIF.
    ENDIF.
    EXIT.
  ENDLOOP.
  IF sy-subrc NE 0.
    CLEAR rec.
  ENDIF.
  IF key_local NE space.
    &lt;f1_x&gt; = &lt;f1_wax&gt;.
  ENDIF.
  sy-subrc = rec.
ENDFORM.                               &quot;check_if_entry_is_to_display</include_source>
   </include>
   <include NAME="LSVIMF35" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000002" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122437" IDATE="20080721" ITIME="122437">
    <include_source>*---------------------------------------------------------------------*
*       FORM CHECK_AND_MODIFY_MAINKEY_TAB                             *
*---------------------------------------------------------------------*
* ...............                                                     *
*---------------------------------------------------------------------*
FORM check_and_modify_mainkey_tab USING cammt_rec.
  CHECK vim_ignore_collapsed_mainkeys EQ space.
  IF vim_no_mainkey_exists EQ vim_no_mkey_not_procsd OR
     &lt;vim_tot_mkey_beforex&gt; NE &lt;vim_mkey_beforex&gt; OR
     ( vim_mkey_after_exists NE space AND
       &lt;vim_tot_mkey_afterx&gt; NE &lt;vim_mkey_afterx&gt; ).
*     &lt;vim_tot_mkey_before&gt; NE &lt;vim_mkey_before&gt; OR
*     ( vim_mkey_after_exists NE space AND
*       &lt;vim_tot_mkey_after&gt; NE &lt;vim_mkey_after&gt; ).
    IF cammt_rec NE 9 AND cammt_rec NE 0.
      PERFORM mod_extract_and_mainkey_tab USING &apos;A&apos; 0.
      CLEAR cammt_rec.
    ENDIF.
    &lt;vim_h_mkey&gt;(x_header-keylen) = &lt;vim_xtotal_key&gt;.
*    vim_mainkey = &lt;vim_total_key&gt;.
    extract = total. &quot;this statement is necessary, do not delete it !!
    TRANSLATE vim_no_mainkey_exists USING vim_no_mkey_procsd_patt.
  ELSE.
    CHECK cammt_rec NE 9 AND cammt_rec NE 0.
  ENDIF.
  PERFORM check_if_entry_is_to_display USING space &lt;vim_xtotal_key&gt;
                                             &apos;X&apos; &lt;vim_begdate&gt;.
  cammt_rec = sy-subrc.
ENDFORM.                               &quot;modify_mainkey_tab</include_source>
   </include>
   <include NAME="LSVIMF36" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000006" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122437" IDATE="20080721" ITIME="122437">
    <include_source>*---------------------------------------------------------------------*
*       FORM MOD_EXTRACT_AND_MAINKEY_TAB                              *
*---------------------------------------------------------------------*
*       Modify EXTRACT and mainkey table                              *
*---------------------------------------------------------------------*
FORM mod_extract_and_mainkey_tab USING value(meamt_mode) TYPE c
                                       value(meamt_index) TYPE i.
  CASE meamt_mode.
    WHEN &apos;A&apos;.
      APPEND extract.
    WHEN &apos;I&apos;.
      IF meamt_index EQ 0.
        INSERT extract.                                 &quot;#EC *
      ELSE.
        INSERT extract INDEX meamt_index.
      ENDIF.
    WHEN &apos;M&apos;.
      IF meamt_index EQ 0.
        MODIFY extract.                                 &quot;#EC *
      ELSE.
        MODIFY extract INDEX meamt_index.
      ENDIF.
  ENDCASE.
  LOOP AT vim_collapsed_mainkeys.
    CHECK &lt;vim_collapsed_mkey_bfx&gt; EQ &lt;vim_mkey_beforex&gt;
     AND &lt;vim_collapsed_keyx&gt; NE &lt;vim_xextract_key&gt;.
*  LOOP AT vim_collapsed_mainkeys WHERE mkey_bf EQ &lt;vim_mkey_before&gt;
*                                   AND mainkey NE &lt;vim_extract_key&gt;.
    IF vim_mkey_after_exists NE space.
      CHECK &lt;vim_collapsed_key_afx&gt; EQ &lt;vim_mkey_afterx&gt;.
*      CHECK &lt;vim_collapsed_key_af&gt; EQ &lt;vim_mkey_after&gt;.
    ENDIF.
    &lt;vim_collapsed_keyx&gt; = &lt;vim_xextract_key&gt;.
*    vim_collapsed_mainkeys-mainkey = &lt;vim_extract_key&gt;.
* changed XB. 12.06.02  BCEK060520/BCEK060521 -------begin----------
    if &lt;vim_collapsed_mkey_bfx&gt; NE &lt;vim_ext_mkey_beforex&gt;.
      &lt;vim_collapsed_mkey_bfx&gt; = &lt;vim_ext_mkey_beforex&gt;.
*    vim_collapsed_mainkeys-mkey_bf = &lt;vim_ext_mkey_before&gt;.
    endif.
* changed XB. 12.06.02  BCEK060520/BCEK060521 ---------end-----------
    MODIFY vim_collapsed_mainkeys.
  ENDLOOP.
ENDFORM.                               &quot;mod_extract_and_mainkey_tab.</include_source>
   </include>
   <include NAME="LSVIMF37" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000011" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122437" IDATE="20080721" ITIME="122437">
    <include_source>*---------------------------------------------------------------------*
*       FORM FILL_EXTRACT                                             *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM FILL_EXTRACT.
  DATA: REC LIKE SY-SUBRC VALUE 9, TOTAL_SAFE(4096) TYPE C, INDEI TYPE I,
                    HF TYPE I VALUE 1.
  FIELD-SYMBOLS: &lt;BEGDATE_MASK&gt;.
  REFRESH: EXTRACT. CLEAR EXTRACT.
  CLEAR VIM_MAINKEY.
  TRANSLATE VIM_NO_MAINKEY_EXISTS USING VIM_NO_MKEY_NOT_PROCSD_PATT.
  IF X_HEADER-DELMDTFLAG NE SPACE.
    ASSIGN &lt;VIM_NEW_BEGDATE&gt; TO &lt;BEGDATE_MASK&gt; TYPE &apos;C&apos;.
  ENDIF.
  LOOP AT TOTAL.
    PERFORM NORMAL_SELECT.
    CHECK SY-SUBRC EQ 0.
    IF X_HEADER-DELMDTFLAG NE SPACE AND
       VIM_IGNORE_COLLAPSED_MAINKEYS EQ SPACE.
      PERFORM CHECK_AND_MODIFY_MAINKEY_TAB USING REC.
      IF REC NE 0.
        VIM_COLL_MAINKEYS_BEG_IX = VIM_LAST_COLL_MAINKEYS_IX.
      ENDIF.
      CHECK REC LT 8.
      IF REC EQ 4. REC = 9. ENDIF.
    ENDIF.
    EXTRACT = TOTAL.
    APPEND EXTRACT.
  ENDLOOP.
  VIM_COLL_MAINKEYS_BEG_IX = 1.
  IF REC NE 9 AND REC NE 0.
    PERFORM MOD_EXTRACT_AND_MAINKEY_TAB USING &apos;A&apos; 0.
  ENDIF.
  DESCRIBE TABLE EXTRACT LINES MAXLINES.
  MARK_EXTRACT = MARK_TOTAL.
  STATUS-DATA = GESAMTDATEN.
  TITLE-DATA  = GESAMTDATEN.
  CLEAR &lt;STATUS&gt;-SELECTED.
* &lt;STATUS&gt;-DISPL_MODE = EXPANDED. &quot;default display mode
  IF MAXLINES EQ 0.
    PERFORM VIM_SEND_SV005_OR_SV766 USING &apos;766&apos;
                                          &apos;RESET&apos;.
    IF FUNCTION NE &apos;DELE&apos; AND FUNCTION NE &apos;SAVE&apos;.           &quot;HWR
      IF X_HEADER-SELECTION EQ SPACE AND FILL_EXTR_FIRST_PROC EQ SPACE.
        IF NOT VIM_OC_INST IS INITIAL
* data access restricted?
          AND ( ( &lt;STATUS&gt;-ST_ACTION = AENDERN
                AND NOT VIM_OC_INST-&gt;OC_SELCRIT_MAINT_TAB IS INITIAL )
          OR ( &apos;ST&apos; CS &lt;STATUS&gt;-ST_ACTION
                AND NOT VIM_OC_INST-&gt;OC_SELCRIT_READ_TAB IS INITIAL ) ).
          MESSAGE S766(SV).
*   Eingeschränkte Anzeige von Datensätzen.
        ELSE.
          MESSAGE S065(SV).            &quot;keine Einträge vorhanden
        ENDIF.
        MOVE &apos;X&apos; TO FILL_EXTR_FIRST_PROC.
      ELSE.
        CLEAR &lt;TABLE1&gt;.                                     &quot;GKPR/1045371
        MESSAGE S004(SV). &quot;keine Einträge gemäß Selektion gefunden
      ENDIF.
    ENDIF.                                                  &quot;HWR
    EXIT.
*  ELSEIF maxlines EQ 1.
  ELSEIF MAXLINES EQ 1 AND FUNCTION NE &apos;CMPR&apos;.              &quot;822766
    PERFORM VIM_MAINTAIN_SINGLE_SET.    &quot;UFint2329966/2000
  ELSEIF NOT VIM_OC_INST IS INITIAL AND
   FUNCTION NE &apos;DELE&apos; AND FUNCTION NE &apos;SAVE&apos;.
* data access restricted?
    IF ( &lt;STATUS&gt;-ST_ACTION = AENDERN
         AND NOT VIM_OC_INST-&gt;OC_SELCRIT_MAINT_TAB IS INITIAL )
     OR ( &apos;ST&apos; CS &lt;STATUS&gt;-ST_ACTION
          AND NOT VIM_OC_INST-&gt;OC_SELCRIT_READ_TAB IS INITIAL ).
      PERFORM VIM_SEND_SV005_OR_SV766 USING &apos;766&apos;
                                          &apos;SENDIT&apos;.
*   Eingeschränkte Anzeige von Datensätzen.
    ENDIF.
  ELSE.
    PERFORM VIM_SEND_SV005_OR_SV766 USING &apos;766&apos;
                                          &apos;RESET&apos;.
  ENDIF.
ENDFORM.                    &quot;fill_extract</include_source>
   </include>
   <include NAME="LSVIMF38" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000009" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122437" IDATE="20080721" ITIME="122437">
    <include_source>*---------------------------------------------------------------------*
*       FORM SELECT                                                   *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  --&gt;  PARAM                                                         *
*  &lt;--  SY-SUBRC                                                      *
*---------------------------------------------------------------------*
FORM select USING param.
  FIELD-SYMBOLS: &lt;vim_tot_txt_struc_loc&gt; TYPE ANY.

  sy-subrc = 8.
  IF param EQ space AND status-action NE transportieren.
    &quot;normal selection (not deleted entries)
    PERFORM normal_select.
  ELSE.
    CASE param.
      WHEN geloescht.
        CHECK &lt;action&gt;         EQ geloescht
        OR    &lt;action&gt;         EQ neuer_geloescht
        OR    &lt;action&gt;         EQ update_geloescht.
        CLEAR sy-subrc.
        IF x_header-selection NE space.
          IF x_header-bastab &lt;&gt; space AND x_header-texttbexst &lt;&gt; space.
            ASSIGN &lt;vim_tot_txt_struc&gt; TO &lt;vim_tot_txt_struc_loc&gt;.
          ELSE.
            ASSIGN &lt;vim_total_struc&gt; TO &lt;vim_tot_txt_struc_loc&gt;.
          ENDIF.
          CALL FUNCTION &apos;TABLE_RANGE_CHECK&apos;
            EXPORTING
              tabname                   = x_header-maintview
              entry                     = total
              entry_text                = &lt;vim_tot_txt_struc_loc&gt;
              ddic                      = &apos;N&apos;
              key                       = &apos;N&apos;
              ignore_blank_subsetfields = &apos;N&apos;
            TABLES
              x_namtab                  = x_namtab
              x_header                  = x_header
              sellist                   = dpl_sellist
            EXCEPTIONS
              entry_not_fits            = 1
              no_value_for_subset_ident = 2.
          IF sy-subrc EQ 2.
            RAISE no_value_for_subset_ident.
          ENDIF.
        ENDIF.
      WHEN markiert.
        IF status-delete EQ geloescht.
          CHECK &lt;action&gt; EQ geloescht OR &lt;action&gt; EQ neuer_geloescht OR
                &lt;action&gt; EQ update_geloescht.
        ENDIF.
        CHECK &lt;mark&gt;   EQ param.
        CLEAR sy-subrc.
        IF x_header-selection NE space.
          IF x_header-bastab &lt;&gt; space AND x_header-texttbexst &lt;&gt; space.
            ASSIGN &lt;vim_tot_txt_struc&gt; TO &lt;vim_tot_txt_struc_loc&gt;.
          ELSE.
            ASSIGN &lt;vim_total_struc&gt; TO &lt;vim_tot_txt_struc_loc&gt;.
          ENDIF.

          CALL FUNCTION &apos;TABLE_RANGE_CHECK&apos;
            EXPORTING
              tabname                   = x_header-maintview
              entry                     = total
              entry_text                = &lt;vim_tot_txt_struc_loc&gt;
              ddic                      = &apos;N&apos;
              key                       = &apos;N&apos;
              ignore_blank_subsetfields = &apos;N&apos;
            TABLES
              x_namtab                  = x_namtab
              x_header                  = x_header
              sellist                   = dpl_sellist
            EXCEPTIONS
              entry_not_fits            = 1
              no_value_for_subset_ident = 2.
          IF sy-subrc EQ 2.
            RAISE no_value_for_subset_ident.
          ENDIF.
        ENDIF.
      WHEN bcset_only.               &quot;HCG Display only data from BC-Set
        IF vim_actlinks NE x_header-viewname.
          PERFORM vim_bc_logs_get USING view_name x_header x_namtab[]
                          CHANGING vim_bc_entry_list.
          vim_actlinks = x_header-viewname.&quot;For which actlinks are valid
        ENDIF.
        READ TABLE vim_bc_entry_list INTO vim_bc_entry_list_wa
                 WITH TABLE KEY viewname = x_header-maintview &quot;HCG 9/04
                                  keys = &lt;vim_xtotal_key&gt;.
        IF sy-subrc NE 0. sy-subrc = 8. ENDIF.
        CHECK sy-subrc EQ 0.
        IF x_header-selection NE space.
          IF x_header-bastab &lt;&gt; space AND x_header-texttbexst &lt;&gt; space.
            ASSIGN &lt;vim_tot_txt_struc&gt; TO &lt;vim_tot_txt_struc_loc&gt;.
          ELSE.
            ASSIGN &lt;vim_total_struc&gt; TO &lt;vim_tot_txt_struc_loc&gt;.
          ENDIF.
          CALL FUNCTION &apos;TABLE_RANGE_CHECK&apos;
            EXPORTING
              tabname                   = x_header-maintview
              entry                     = total
              entry_text                = &lt;vim_tot_txt_struc_loc&gt;
              ddic                      = &apos;N&apos;
              key                       = &apos;N&apos;
              ignore_blank_subsetfields = &apos;N&apos;
            TABLES
              x_namtab                  = x_namtab
              x_header                  = x_header
              sellist                   = dpl_sellist
            EXCEPTIONS
              entry_not_fits            = 1
              no_value_for_subset_ident = 2.
          IF sy-subrc EQ 2.
            RAISE no_value_for_subset_ident.
          ENDIF.
        ENDIF.
      WHEN by_field_contents.
        PERFORM normal_select.
        CHECK sy-subrc EQ 0.
        IF x_header-bastab NE space AND x_header-texttbexst NE space.
* table with texttable
          CALL FUNCTION &apos;QUERY_CHECK&apos;
            EXPORTING
              record            = &lt;vim_total_struc&gt;
              textrecord        = &lt;vim_tot_txt_struc&gt;
            EXCEPTIONS
              no_hits_in_record = 4
              parameter_error   = 8.
        ELSE.
* view or single table
          CALL FUNCTION &apos;QUERY_CHECK&apos;
               EXPORTING
                    record            = &lt;vim_total_struc&gt;
*                  record            = total
               EXCEPTIONS
                    no_hits_in_record = 4
                    parameter_error   = 8.
        ENDIF.
      WHEN OTHERS.                     &quot;neuer_eintrag or aendern
       IF x_header-bastab NE space AND x_header-texttbexst NE space AND
                  param EQ aendern.
          CHECK &lt;action&gt; EQ param OR &lt;action_text&gt; EQ param OR
                &lt;action&gt; NE neuer_eintrag AND
                &lt;action_text&gt; EQ neuer_eintrag.
        ELSE.
          CHECK &lt;action&gt; EQ param.
        ENDIF.
        CLEAR sy-subrc.
        IF x_header-selection NE space.
          IF x_header-bastab &lt;&gt; space AND x_header-texttbexst &lt;&gt; space.
            ASSIGN &lt;vim_tot_txt_struc&gt; TO &lt;vim_tot_txt_struc_loc&gt;.
          ELSE.
            ASSIGN &lt;vim_total_struc&gt; TO &lt;vim_tot_txt_struc_loc&gt;.
          ENDIF.

          CALL FUNCTION &apos;TABLE_RANGE_CHECK&apos;
            EXPORTING
              tabname                   = x_header-maintview
              entry                     = total
              entry_text                = &lt;vim_tot_txt_struc_loc&gt;
              ddic                      = &apos;N&apos;
              key                       = &apos;N&apos;
              ignore_blank_subsetfields = &apos;N&apos;
            TABLES
              x_namtab                  = x_namtab
              x_header                  = x_header
              sellist                   = dpl_sellist
            EXCEPTIONS
              entry_not_fits            = 1
              no_value_for_subset_ident = 2.
          IF sy-subrc EQ 2.
            RAISE no_value_for_subset_ident.
          ENDIF.
        ENDIF.
    ENDCASE.
  ENDIF.&quot;param eq space and status-action ne transportieren
ENDFORM.                    &quot;select</include_source>
   </include>
   <include NAME="LSVIMF39" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000006" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122437" IDATE="20080721" ITIME="122437">
    <include_source>*---------------------------------------------------------------------*
*       FORM NORMAL_SELECT                                            *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
* &lt;--- sy-subrc                                                       *
*---------------------------------------------------------------------*
FORM normal_select.
  FIELD-SYMBOLS: &lt;ns_tab&gt; TYPE table, &lt;vim_tot_txt_struc_loc&gt; TYPE ANY.
  sy-subrc = 8.
  CHECK &lt;action&gt; NE neuer_geloescht
    AND &lt;action&gt; NE update_geloescht
    AND &lt;action&gt; NE geloescht.
  CLEAR sy-subrc.
  IF x_header-selection NE space.
    IF vim_special_adjust_mode NE space.
      ASSIGN dba_sellist[] TO &lt;ns_tab&gt;.
    ELSE.
      ASSIGN dpl_sellist[] TO &lt;ns_tab&gt;.
    ENDIF.
    IF x_header-bastab &lt;&gt; space AND x_header-texttbexst &lt;&gt; space.
      ASSIGN &lt;vim_tot_txt_struc&gt; TO &lt;vim_tot_txt_struc_loc&gt;.
    ELSE.
      ASSIGN &lt;vim_total_struc&gt; TO &lt;vim_tot_txt_struc_loc&gt;.
    ENDIF.
    CALL FUNCTION &apos;TABLE_RANGE_CHECK&apos;
      EXPORTING
        tabname                   = x_header-maintview
        entry                     = total
        entry_text                = &lt;vim_tot_txt_struc_loc&gt;
        ddic                      = &apos;N&apos;
        key                       = &apos;N&apos;
        ignore_blank_subsetfields = &apos;N&apos;
      TABLES
        x_namtab                  = x_namtab
        x_header                  = x_header
        sellist                   = &lt;ns_tab&gt;
      EXCEPTIONS
        entry_not_fits            = 1
        no_value_for_subset_ident = 2.
    IF sy-subrc EQ 2.
      RAISE no_value_for_subset_ident.
    ENDIF.
  ENDIF.
ENDFORM.                    &quot;NORMAL_SELECT</include_source>
   </include>
   <include NAME="LSVIMF3A" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000004" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122437" IDATE="20080721" ITIME="122437">
    <include_source>*---------------------------------------------------------------------*
*       FORM SELEKTIERE                                               *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  --&gt;  PARAM                                                         *
*---------------------------------------------------------------------*
FORM selektiere USING param.
  DATA: rec LIKE sy-subrc VALUE 9, s_screenmode(1) TYPE c VALUE &apos;S&apos;.
  IF status-action EQ hinzufuegen.
    status-action = aendern.
    title-action = aendern.
  ENDIF.
  IF status-mode EQ detail_bild.
    PERFORM update_tab.
  ENDIF.
  REFRESH extract. CLEAR vim_mainkey. l = 1.
  TRANSLATE vim_no_mainkey_exists USING vim_no_mkey_not_procsd_patt.
  LOOP AT total.
    PERFORM select USING param.
    CHECK sy-subrc EQ 0.
    IF x_header-delmdtflag NE space.
      PERFORM check_and_modify_mainkey_tab USING rec.
      IF rec NE 0.
        vim_coll_mainkeys_beg_ix = vim_last_coll_mainkeys_ix.
      ENDIF.
      CHECK rec LT 8.
      IF rec EQ 4. rec = 9. ENDIF.
    ENDIF.
    extract = total.
    APPEND extract.
  ENDLOOP.
  vim_coll_mainkeys_beg_ix = 1.
  IF rec NE 9 AND rec NE 0.
    PERFORM mod_extract_and_mainkey_tab USING &apos;A&apos; 0.
  ENDIF.
  IF param EQ geloescht.
    status-delete = geloescht.
    title-action  = geloescht.
  ENDIF.
  &lt;status&gt;-selected = param.
  DESCRIBE TABLE extract LINES maxlines.
  status-data   = auswahldaten.
  title-data    = auswahldaten.
  nextline = 1.
  IF maxlines EQ 0.
    status-delete = nicht_geloescht.
    title-action  = nicht_geloescht.
    PERFORM fill_extract.
    PERFORM set_pf_status USING status.
    MESSAGE i004(sv).
    SET SCREEN liste.
    LEAVE SCREEN.
  ENDIF.
  IF maxlines EQ 1.
    MESSAGE s005(sv).
    IF vim_single_entry_function NE space.
      IF status-type EQ zweistufig.
        &lt;status&gt;-firstline = &lt;status&gt;-cur_line = nextline.
        PERFORM process_detail_screen USING &apos;C&apos;.
      ELSE.
        CALL SCREEN liste.
      ENDIF.
    ELSE.
      IF status-type EQ zweistufig.
        &lt;status&gt;-firstline = &lt;status&gt;-cur_line = nextline.
        PERFORM process_detail_screen USING &apos;S&apos;.
      ENDIF.
    ENDIF.
  ELSE.
    IF status-mode EQ detail_bild.
      vim_next_screen = liste. vim_leave_screen = &apos;X&apos;.
    ENDIF.
    MESSAGE s006(sv) WITH maxlines.
  ENDIF.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF3B" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000006" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122437" IDATE="20080721" ITIME="122438">
    <include_source>*---------------------------------------------------------------------*
*       FORM LOGICAL_UNDELETE_TOTAL                                    *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM logical_undelete_total USING value(cur_index) TYPE i.
  CASE &lt;action&gt;.
    WHEN neuer_geloescht.
      &lt;action&gt; = neuer_eintrag.
    WHEN geloescht.
      &lt;action&gt; = original.
    WHEN update_geloescht.
      &lt;action&gt; = aendern.
  ENDCASE.
*  perform vim_bc_logs_maintain using zurueckholen
*                                           x_header
*                                     changing vim_bc_entry_list.
  IF x_header-bastab NE space AND x_header-texttbexst NE space.
    CASE &lt;action_text&gt;.
      WHEN neuer_geloescht.
        &lt;action_text&gt;         = neuer_eintrag.
      WHEN geloescht.
        &lt;action_text&gt;         = original.
      WHEN update_geloescht.
        &lt;action_text&gt;         = aendern.
      WHEN dummy_geloescht.
        &lt;action_text&gt;         = original.
        &lt;vim_xtotal_text&gt; = &lt;text_initial_x&gt;.
*        &lt;TOTAL_TEXT&gt; = &lt;TEXT_INITIAL&gt;.
    ENDCASE.
  ENDIF.
  &lt;mark&gt; = nicht_markiert.
  MODIFY total INDEX cur_index.
ENDFORM.                               &quot;logical_undelete_total</include_source>
   </include>
   <include NAME="LSVIMF3C" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000004" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122438" IDATE="20080721" ITIME="122438">
    <include_source>*---------------------------------------------------------------------*
*       FORM LISTE_ZURUECKHOLEN                                       *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM LISTE_ZURUECKHOLEN.
  DATA: IX TYPE I.
* IF STATUS-ACTION NE AENDERN OR STATUS-DELETE NE GELOESCHT.
*   MESSAGE I001(SV).
*   EXIT.
* ENDIF.
  COUNTER = 0.
  LOOP AT EXTRACT.
    CHECK &lt;XMARK&gt; EQ MARKIERT.
    IF X_HEADER-DELMDTFLAG NE SPACE.
      IX = SY-TABIX.
      PERFORM MOVE_EXTRACT_TO_VIEW_WA.
      PERFORM TEMPORAL_DELIMITATION.
    ENDIF.
    COUNTER = COUNTER + 1.
    READ TABLE TOTAL WITH KEY &lt;VIM_xEXTRACT_KEY&gt; BINARY SEARCH.
    PERFORM LOGICAL_UNDELETE_TOTAL USING SY-TABIX.
    MARK_TOTAL  = MARK_TOTAL - 1.
    MARK_EXTRACT = MARK_EXTRACT - 1.
    IF REPLACE_MODE NE SPACE AND VIM_EXTERNAL_MODE EQ SPACE.
      &lt;XACT&gt; = &lt;ACTION&gt;. &lt;XMARK&gt; = NICHT_MARKIERT.
      MODIFY EXTRACT.                  &quot;no deletion in upgrade mode
    ELSE.
      IF TEMPORAL_DELIMITATION_HAPPENED NE SPACE.
        CLEAR VIM_DELIM_ENTRIES.
        VIM_DELIM_ENTRIES-INDEX3 = IX.
        APPEND VIM_DELIM_ENTRIES.
      ELSE.
        DELETE EXTRACT.
      ENDIF.
    ENDIF.
  ENDLOOP.
  IF TEMPORAL_DELIMITATION_HAPPENED NE SPACE.
    PERFORM AFTER_TEMPORAL_DELIMITATION.
    CLEAR TEMPORAL_DELIMITATION_HAPPENED.
  ENDIF.
  CHECK REPLACE_MODE EQ SPACE.
  DESCRIBE TABLE EXTRACT LINES MAXLINES.
  IF IGNORED_ENTRIES_EXIST EQ SPACE.
    MESSAGE S002(SV) WITH COUNTER.
  ELSE.
    MESSAGE W002(SV) WITH COUNTER.
  ENDIF.
  IF MAXLINES EQ 0.
    TITLE-ACTION = AENDERN.
    STATUS-DELETE = NICHT_GELOESCHT.
  ENDIF.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF3D" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000004" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122438" IDATE="20080721" ITIME="122438">
    <include_source>*---------------------------------------------------------------------*
*       FORM MARKIERE_ALLE                                            *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  --&gt;  ACTION                                                        *
*---------------------------------------------------------------------*
FORM MARKIERE_ALLE USING ACTION.
  CHECK MAXLINES NE 0.
  LOOP AT EXTRACT.
    CHECK &lt;XACT&gt; NE LEER.
    CHECK &lt;XMARK&gt; NE ACTION.
    READ TABLE TOTAL WITH KEY &lt;VIM_xEXTRACT_KEY&gt; BINARY SEARCH.
    &lt;XMARK&gt; = ACTION.
    &lt;MARK&gt;  = ACTION.
    MODIFY TOTAL INDEX SY-TABIX.
    MODIFY EXTRACT.
    IF ACTION EQ MARKIERT.
      ADD: 1 TO MARK_EXTRACT,
           1 TO MARK_TOTAL.
    ELSE.
      SUBTRACT: 1 FROM MARK_EXTRACT,
                1 FROM MARK_TOTAL.
      CLEAR BLOCK_SW.
    ENDIF.
  ENDLOOP.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF3E" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000004" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122438" IDATE="20080721" ITIME="122438">
    <include_source>*---------------------------------------------------------------------*
*       FORM MARKIERE                                                 *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  --&gt;  I                                                             *
*---------------------------------------------------------------------*
FORM MARKIERE USING I.
  READ TABLE EXTRACT INDEX I.
  READ TABLE TOTAL WITH KEY &lt;VIM_xEXTRACT_KEY&gt; BINARY SEARCH.
  IF &lt;XMARK&gt; EQ MARKIERT.
    &lt;XMARK&gt; = NICHT_MARKIERT.
    &lt;MARK&gt;  = NICHT_MARKIERT.
    MARK_EXTRACT = MARK_EXTRACT - 1.
    MARK_TOTAL  = MARK_TOTAL  - 1.
  ELSE.
    &lt;XMARK&gt; = MARKIERT.
    &lt;MARK&gt;  = MARKIERT.
    MARK_EXTRACT = MARK_EXTRACT + 1.
    MARK_TOTAL  = MARK_TOTAL  + 1.
  ENDIF.
  MODIFY TOTAL INDEX SY-TABIX.
  MODIFY EXTRACT INDEX I.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF3F" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000004" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122438" IDATE="20080721" ITIME="122438">
    <include_source>*---------------------------------------------------------------------*
*       FORM MARKIERE_BLOCK                                           *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM MARKIERE_BLOCK.
  INDEX = FIRSTLINE + L - 1.
  IF L EQ 0 OR INDEX GT MAXLINES.
    MESSAGE S032(SV).
    EXIT.
  ENDIF.
  PERFORM MARKIERE USING INDEX.
  IF BLOCK_SW EQ MARKIERT.
    BLOCK_2 = INDEX.
    BLOCK_SW = NICHT_MARKIERT.
  ELSE.
    BLOCK_1 = INDEX.
    BLOCK_SW = MARKIERT.
    MESSAGE S066(SV).                  &quot;Bitte Blockende markieren
    EXIT.
  ENDIF.
  COUNTER = 0.
  LOOP AT EXTRACT.
    COUNTER = COUNTER + 1.
    IF BLOCK_1 LE BLOCK_2.
      CHECK COUNTER BETWEEN BLOCK_1 AND BLOCK_2.
    ELSE.
      CHECK COUNTER BETWEEN BLOCK_2 AND BLOCK_1.
    ENDIF.
    READ TABLE TOTAL WITH KEY &lt;VIM_xEXTRACT_KEY&gt; BINARY SEARCH.
    IF &lt;XMARK&gt; NE MARKIERT.
      MARK_EXTRACT = MARK_EXTRACT + 1.
      MARK_TOTAL  = MARK_TOTAL  + 1.
    ENDIF.
    &lt;XMARK&gt; = MARKIERT.
    &lt;MARK&gt;  = MARKIERT.
    MODIFY TOTAL INDEX SY-TABIX.
    MODIFY EXTRACT.
  ENDLOOP.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF3G" SQLX="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000001" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122438" IDATE="20080721" ITIME="122438">
    <include_source>*---------------------------------------------------------------------*
*       FORM LISTE_MARKIERE                                           *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM LISTE_MARKIERE.
  INDEX = FIRSTLINE + L - 1.
  IF L EQ 0 OR INDEX GT MAXLINES.
    MESSAGE S032(SV).
    EXIT.
  ENDIF.
  PERFORM MARKIERE USING INDEX.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF3H" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000008" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122438" IDATE="20080721" ITIME="122438">
    <include_source>*---------------------------------------------------------------------*
*       FORM F4_POSITIONIEREN                                         *
*---------------------------------------------------------------------*
*       called externally from POPUP_GET_VALUES_USER_HELP             *
*---------------------------------------------------------------------*
form f4_positionieren using value(tabname) type tabname
                            value(fieldname) type fieldname
                            value(display)
                      changing returncode
                               value type any.
  statics: field_tab type table of dfies initial size 20.

  data: tabval(132) type c,
        v_tab like table of tabval initial size 500,
        w_dfies type dfies,
        return_tab type table of ddshretval initial size 1,
        begin of out_conv_function,
         prefix(16) type c value &apos;CONVERSION_EXIT_&apos;,
         exit like vimnamtab-convexit,
         suffix(7) type c value &apos;_OUTPUT&apos;,
        end of out_conv_function,
        f4_length type i,    &quot;total length of to be displayed fields
        progname type sy-repid,
        value_bef_f4 type help_info-fldvalue.

  data: begin of  dynpfields  occurs 1.                     &quot;BEGIN GKPR/1020911
          include structure dynpread.
  data: end of dynpfields.
  data: sy_repid like sy-repid,
        sy_dynnr like sy-dynnr.                             &quot;END GKPR/1020911

  field-symbols: &lt;hf1&gt;, &lt;dfies&gt; type dfies, &lt;retval&gt; type ddshretval.

  move &apos;SAPLSPO4&apos; to sy_repid.                              &quot;BEGIN GKPR/1020911
  move &apos;0300&apos; to sy_dynnr.
  move &apos;SVALD-VALUE&apos; to dynpfields-fieldname.
*  dynpfields-stepl = 1.                                    &quot;GKPR/1021700
  append dynpfields.
  call function &apos;DYNP_VALUES_READ&apos;
            exporting
              dyname                         = sy_repid
              dynumb                         = sy_dynnr
*             TRANSLATE_TO_UPPER             = &apos; &apos;
*             REQUEST                        = &apos; &apos;
*             PERFORM_CONVERSION_EXITS       = &apos; &apos;
*             PERFORM_INPUT_CONVERSION       = &apos; &apos;
*             DETERMINE_LOOP_INDEX           = &apos; &apos;
            tables
              dynpfields                     = dynpfields
           exceptions
              invalid_abapworkarea           = 1
              invalid_dynprofield            = 2
              invalid_dynproname             = 3
              invalid_dynpronummer           = 4
              invalid_request                = 5
              no_fielddescription            = 6
              invalid_parameter              = 7
              undefind_error                 = 8
              double_conversion              = 9
              stepl_not_found                = 10
              others                         = 11.
  if sy-subrc &lt;&gt; 0.
    message i089(ec).
  endif.

  if sy-subrc eq 0.
    read table dynpfields index 1.
    move: dynpfields-fieldvalue to value_bef_f4.
  endif.                                                    &quot;END GKPR/1020911

  read table field_tab index 1 assigning &lt;dfies&gt;.
  if sy-subrc &lt;&gt; 0 or &lt;dfies&gt;-tabname &lt;&gt; x_header-maintview.
    refresh field_tab.

* xb  06.02 csn ext.237151 2002, BCEK061005 ---------begin----------
* check the total display length of F4-List
    f4_length = 0.
    if x_header-tablen &gt; 1000.
      loop at x_namtab.
        if x_header-clidep ne space.       &quot;ignore client field
          check sy-tabix ne 1.
        endif.
        if x_namtab-keyflag ne space or    &quot;all key fields or
           x_namtab-datatype eq &apos;CHAR&apos; and &quot;all possibly text fields
           x_namtab-flength  ge 10     and
           x_namtab-lowercase  ne space.

          f4_length = f4_length + x_namtab-outputlen.
        endif.
      endloop.
    endif.

    if f4_length &lt; 1000.          &quot;check the fields length
* xb  06.02 csn ext.237151 2002, BCEK061005 ----------end-----------
      loop at x_namtab.
        if x_header-clidep ne space.       &quot;ignore client field
          check sy-tabix ne 1.
        endif.
        check x_namtab-readonly &lt;&gt; vim_hidden.                  &quot;Subviews
        if x_header-bastab ne space and x_header-texttbexst ne space.
          check x_namtab-keyflag ne space and   &quot;all entity keyfields
                x_namtab-texttabfld eq space or                 &quot;or
            x_namtab-keyflag eq space and   &quot;all texttab function fields
                x_namtab-texttabfld ne space.
        else.
          check x_namtab-keyflag ne space or    &quot;all key fields or
               x_namtab-datatype eq &apos;CHAR&apos; and &quot;all possibly text fields
                x_namtab-flength  ge 10     and
                x_namtab-lowercase  ne space.
        endif.
        if x_namtab-texttabfld ne space.
          w_dfies-tabname = x_header-texttab.
        else.
          w_dfies-tabname = x_header-maintview.              &quot;Subviews
        endif.
        w_dfies-fieldname = x_namtab-viewfield.
        append w_dfies to field_tab.
      endloop.
    else.
* xb  06.02 csn ext.237151 2002, BCEK061005 ---------begin----------
      message i810(sv) with x_header-viewname.
*   Die gesamte Länge der View &amp; ist mehr als 1000 Charakter. Nur Key
*   Field wird gezeigt.
      loop at x_namtab.
        if x_header-clidep ne space.       &quot;ignore client field
          check sy-tabix ne 1.
        endif.
        check x_namtab-readonly &lt;&gt; vim_hidden.                  &quot;Subviews
        if x_header-bastab ne space and x_header-texttbexst ne space.
          check x_namtab-keyflag ne space and   &quot;all entity keyfields
                x_namtab-texttabfld eq space or                 &quot;or
            x_namtab-keyflag eq space and   &quot;all texttab function fields
                x_namtab-texttabfld ne space.
        else.
          check x_namtab-keyflag ne space.    &quot;all key fields
        endif.
        if x_namtab-texttabfld ne space.
          w_dfies-tabname = x_header-texttab.
        else.
          w_dfies-tabname = x_header-maintview.              &quot;Subviews
        endif.
        w_dfies-fieldname = x_namtab-viewfield.
        append w_dfies to field_tab.
      endloop.
* xb  06.02 csn ext.237151 2002, BCEK061005 ----------end-----------
    endif.
  endif.


  loop at extract.
    loop at field_tab assigning &lt;dfies&gt;.
      read table x_namtab with key viewfield = &lt;dfies&gt;-fieldname.
      if x_header-bastab ne space and x_header-texttbexst ne space.
        if x_namtab-keyflag eq space and x_namtab-texttabfld ne space.
* Type S: text field
          assign component x_namtab-viewfield
           of structure &lt;vim_ext_txt_struc&gt; to &lt;hf1&gt;.
        elseif x_namtab-keyflag ne space
         and x_namtab-texttabfld eq space.
* Type S: key field
          assign component x_namtab-viewfield
           of structure &lt;vim_extract_struc&gt; to &lt;hf1&gt;.
        endif.
      else.
* viewfield
        assign component x_namtab-viewfield
         of structure &lt;vim_extract_struc&gt; to &lt;hf1&gt;.
      endif.
      check &lt;hf1&gt; is assigned.
*        IF X_HEADER-BASTAB NE SPACE AND X_HEADER-TEXTTBEXST NE SPACE.
*          CHECK X_NAMTAB-KEYFLAG NE SPACE AND   &quot;all entity keyfields
*                X_NAMTAB-TEXTTABFLD EQ SPACE OR             &quot;or
*                X_NAMTAB-KEYFLAG EQ SPACE AND   &quot;all texttab function
*                X_NAMTAB-TEXTTABFLD NE SPACE.
*        ENDIF.
*        ASSIGN EXTRACT+X_NAMTAB-POSITION(X_NAMTAB-FLENGTH) TO &lt;HF1&gt;
*               TYPE &apos;C&apos;.
      write &lt;hf1&gt; to tabval(x_namtab-outputlen).
      append tabval to v_tab.
      clear tabval.
    endloop.
  endloop.
*  &quot;HCG Look first in valuetable of tables  for V_TCURR (Performance)
*  &quot;HCG Special handling due to cust issues 272054/2003 or 130305/2000
  if x_header-viewname = &apos;V_TCURR&apos;.
    read table x_namtab with key viewfield = fieldname.
    call function &apos;F4IF_FIELD_VALUE_REQUEST&apos;
            exporting
                tabname             = x_namtab-bastabname
                fieldname           = fieldname
*            SEARCHHELP          = &apos; &apos;
*            SHLPPARAM           = &apos; &apos;
*            dynpprog            = progname
*            dynpnr              = dynnr
*            dynprofield         = &apos; &apos;
*            stepl               = dynp_stepl
             value               = value_bef_f4             &quot;GKPR/1020911
*            MULTIPLE_CHOICE     = &apos; &apos;
*            DISPLAY             = &apos; &apos;
*            SUPPRESS_RECORDLIST = &apos; &apos;
*              callback_program    = progname
*              callback_form       = &apos;CALLBACK_F4&apos;
           tables
                return_tab          = return_tab
           exceptions
                field_not_found     = 1
                no_help_for_field   = 2
                inconsistent_help   = 3
                no_values_found     = 4
                others              = 5.
    case sy-subrc.
      when 0.
        read table return_tab index 1 assigning &lt;retval&gt;.
        if sy-subrc = 0.
          value = &lt;retval&gt;-fieldval.
        endif.
      when 2.
*     should not happen for V_TCURR
    endcase.
  else.
    call function &apos;F4IF_INT_TABLE_VALUE_REQUEST&apos;
      exporting
*     DDIC_STRUCTURE         = &apos; &apos;
        retfield               = fieldname
*     PVALKEY                = &apos; &apos;
*     DYNPPROG               = &apos; &apos;
*     DYNPNR                 = &apos; &apos;
*     DYNPROFIELD            = &apos; &apos;
*     STEPL                  = 0
*     WINDOW_TITLE           =
      value                  = value_bef_f4                 &quot;GKPR/1020911
*     VALUE_ORG              = &apos;C&apos;
*     MULTIPLE_CHOICE        = &apos; &apos;
        display                = display
*     CALLBACK_PROGRAM       = &apos; &apos;
*     CALLBACK_FORM          = &apos; &apos;
*     MARK_TAB               =
      tables
        value_tab              = v_tab
        field_tab              = field_tab
        return_tab             = return_tab
*     DYNPFLD_MAPPING        =
      exceptions
        parameter_error        = 1
        no_values_found        = 2
        others                 = 3.
    if sy-subrc = 0.
      read table return_tab index 1 assigning &lt;retval&gt;.
      if sy-subrc = 0.
        value = &lt;retval&gt;-fieldval.
      endif.
    else.
      message id sy-msgid type sy-msgty number sy-msgno
              with sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    endif.
  endif.
endform.                               &quot;f4_positionieren</include_source>
   </include>
   <include NAME="LSVIMF3I" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000005" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122438" IDATE="20080721" ITIME="122438">
    <include_source>*---------------------------------------------------------------------*
*       FORM POPUP_POSITIONIEREN                                      *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM popup_positionieren.
  DATA: pp_program LIKE sy-repid, hf1 TYPE i, hf2 TYPE i,
        dummy type xfeld.

  IF status-action NE anzeigen AND status-action NE transportieren
  AND status-mode NE list_bild.
    PERFORM update_tab.
  ENDIF.
  pp_program = sy-repid.
  &lt;table1&gt; = &lt;initial&gt;.
  CALL FUNCTION &apos;TABLE_GET_KEY_TO_SET_CUR_ROW&apos;
       EXPORTING
            table             = x_header-maintview          &quot;Subviews
            f4_programname    = pp_program
            f4_formname       = &apos;F4_POSITIONIEREN&apos;
       IMPORTING
            table_key         = dummy
       TABLES
            sellist           = &lt;vim_ck_sellist&gt;
            exclude_fields    = excl_pos_tab
       CHANGING
            table_key_new     = &lt;f1_x&gt;
       EXCEPTIONS
            cancelled_by_user = 01
            table_not_found   = 02.
  CHECK sy-subrc EQ 0000.
  IF x_header-frm_h_flds NE space.
    PERFORM (x_header-frm_h_flds) IN PROGRAM. &quot;#EC *
  ENDIF.
  IF x_header-frm_rp_pos NE space.
    PERFORM (x_header-frm_rp_pos) IN PROGRAM. &quot;#EC *
  ELSEIF status-action EQ hinzufuegen AND status-mode EQ list_bild.
    nextline = 0.
    LOOP AT extract. &quot;#EC *
      IF &lt;xact&gt; EQ leer. EXIT. ENDIF.
*      CHECK &lt;vim_extract_key&gt; LE &lt;f1&gt;.
      CHECK &lt;vim_xextract_key&gt; LE &lt;f1_x&gt;.
      hf1 = sy-tabix.
      CHECK &lt;vim_xextract_key&gt; EQ &lt;f1_x&gt;.
      nextline = sy-tabix. EXIT.
    ENDLOOP.
    IF nextline EQ 0.
      IF hf1 EQ maxlines.
        nextline = hf1.
      ELSE.
        nextline = hf1 + 1.
      ENDIF.
    ENDIF.
  ELSE.
*    READ TABLE extract WITH KEY &lt;f1&gt; BINARY SEARCH
*                                     TRANSPORTING NO FIELDS.
    READ TABLE extract WITH KEY &lt;f1_x&gt; BINARY SEARCH
                                       TRANSPORTING NO FIELDS. &quot;#EC *
    nextline = sy-tabix.
    CLEAR old_nl.                                           &quot;GKPR - 0001009660
    IF sy-subrc = 8 AND nextline GT 1.
      nextline = nextline - 1.                              &quot;last entry
    ENDIF.
  ENDIF.
  IF status-mode EQ detail_bild.
    READ TABLE extract INDEX nextline.   &quot;#EC *                   &quot;ufdetailb
    IF &lt;xmark&gt; &lt;&gt; markiert.
      CLEAR &lt;status&gt;-mark_only.
    ENDIF.                                                  &quot;ufdetaile
    hf2 = firstline + looplines - 1.
    IF looplines EQ 0.
      l = 1. MOVE: l TO &lt;status&gt;-cur_line,
                   nextline TO &lt;status&gt;-firstline.
      hf1 = 0.
    ELSEIF nextline GE firstline AND nextline LE hf2.
* nothing to scroll.
    ELSEIF nextline LT firstline.                  &quot;xb2002 int405493/99
* if the nextline less than firstline, move the nextline to firstline.
      firstline = nextline.
    ELSE.                                           &quot;xb2002 int405493/99
* if the nextline larger than firstline, move the nextline to firstline.
       firstline = nextline.
    ENDIF.
    l = nextline - firstline + 1.
    MOVE: firstline TO &lt;status&gt;-firstline,
          l         TO &lt;status&gt;-cur_line.
  ELSE.
    MOVE 1 TO l.
  ENDIF.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF3J" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000004" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122438" IDATE="20080721" ITIME="122439">
    <include_source>*---------------------------------------------------------------------*
*       FORM CHECK_UPD                                                *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM CHECK_UPD.
  data: leave.
  CHECK STATUS-ACTION NE ANZEIGEN.
  IF &lt;STATUS&gt;-UPD_FLAG EQ SPACE.
    IF STATUS-ACTION EQ TRANSPORTIEREN.
      MOVE &lt;STATUS&gt;-KEYTBMODFD TO &lt;STATUS&gt;-UPD_FLAG.
    ELSE.
      LOOP AT TOTAL.
*       CHECK &lt;ACTION&gt; NE NEUER_GELOESCHT AND &lt;ACTION&gt; NE ORIGINAL.
        CHECK &lt;ACTION&gt; NE ORIGINAL.
        MOVE &apos;X&apos; TO &lt;STATUS&gt;-UPD_FLAG.
        EXIT.
      ENDLOOP.
      IF &lt;STATUS&gt;-UPD_FLAG EQ SPACE AND X_HEADER-BASTAB NE SPACE AND
         X_HEADER-TEXTTBEXST NE SPACE.
        LOOP AT TOTAL.
*         CHECK &lt;ACTION_TEXT&gt; NE NEUER_GELOESCHT AND
          CHECK &lt;ACTION_TEXT&gt; NE ORIGINAL.
          MOVE &apos;X&apos; TO &lt;STATUS&gt;-UPD_FLAG.
          EXIT.
        ENDLOOP.
      ENDIF.
      IF &lt;STATUS&gt;-UPD_FLAG EQ SPACE AND X_HEADER-TEXTTBEXST &lt;&gt; SPACE.
        PERFORM VIM_CHECK_UPD_TEXTTAB. &quot;SW Texttransl
      ENDIF.
      IF &lt;STATUS&gt;-UPD_FLAG EQ SPACE AND X_HEADER-ADRNBRFLAG EQ &apos;N&apos;.
        DESCRIBE TABLE VIM_ADDRESSES_TO_SAVE.
        IF SY-TFILL GT 0.
          MOVE &apos;X&apos; TO &lt;STATUS&gt;-UPD_FLAG.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.
  IF X_HEADER-FRM_AF_CHK NE SPACE AND STATUS-ACTION NE TRANSPORTIEREN.
    PERFORM (X_HEADER-FRM_AF_CHK) IN PROGRAM (SY-REPID).
  ENDIF.
  if &lt;status&gt;-upd_flag = space and vim_called_by_cluster = space and
   ( function = back OR function = end ).
    perform vim_add_img_notices_pai using &apos;E&apos;
                                    changing leave.
    if leave = space.
      clear function.
    endif.
  endif.
  MOVE &apos;X&apos; TO &lt;STATUS&gt;-UPD_CHECKD.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF3K" SQLX="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000001" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122439" IDATE="20080721" ITIME="122439">
    <include_source>*---------------------------------------------------------------------*
*       FORM BLAETTERN                                                *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM BLAETTERN.
  DATA: B_OVERLAPPING(1) TYPE C VALUE &apos;X&apos;.
  IF MAXLINES EQ 0.
    EXIT.
  ENDIF.
  IF STATUS-ACTION EQ KOPIEREN OR LOOPLINES EQ 1.
    CLEAR B_OVERLAPPING.
  ENDIF.
  CALL FUNCTION &apos;SCROLLING_IN_TABLE&apos;
       EXPORTING
            ENTRY_TO       = MAXLINES
            LOOPS          = LOOPLINES
            OK_CODE        = FUNCTION
            ENTRY_ACT      = FIRSTLINE
            LAST_PAGE_FULL = &apos; &apos;
*           OVERLAPPING    = &apos;X&apos;
            OVERLAPPING    = B_OVERLAPPING
       IMPORTING
            ENTRY_NEW      = NEXTLINE.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF3L" SQLX="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000001" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122439" IDATE="20080721" ITIME="122439">
    <include_source>*---------------------------------------------------------------------*
*       FORM IGNORIEREN                                               *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM IGNORIEREN. &quot;wird nur noch auf Detailbild prozessiert
  &lt;STATUS&gt;-UPD_FLAG = SPACE.
  IF STATUS-ACTION EQ KOPIEREN OR VIM_SPECIAL_MODE EQ VIM_DELETE.
    SET SCREEN 0.
    LEAVE SCREEN.
  ENDIF.
* IF MAXLINES LE 1.
*   STATUS-ACTION = AENDERN.
*   TITLE-ACTION  = AENDERN.
*   PERFORM FILL_EXTRACT.
* ELSE.
*   SORT EXTRACT.
* ENDIF.
  NEUER = &apos;N&apos;.
  IF REPLACE_MODE EQ SPACE.
    CLEAR FUNCTION.
*   IF STATUS-MODE EQ DETAIL_BILD.
*     FUNCTION = &apos;DETA&apos;.
*     SET SCREEN DETAIL.
    IF STATUS-ACTION EQ HINZUFUEGEN.
      FUNCTION = &apos;NEWL&apos;.
      PERFORM HINZUFUEGEN.
    ELSE.
      SET SCREEN LISTE.
      LEAVE SCREEN.
    ENDIF.
*   ELSE.
*     NEXTLINE = 1.
*     SET SCREEN LISTE.
*   ENDIF.
  ELSE.
    CLEAR VIM_ACT_DYNP_VIEW. SET SCREEN 0. LEAVE SCREEN.
  ENDIF.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF3M" SQLX="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000001" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122439" IDATE="20080721" ITIME="122439">
    <include_source>*---------------------------------------------------------------------*
*       FORM LISTE_ABBRECHEN                                          *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM LISTE_ABBRECHEN.
* CHECK REPLACE_MODE EQ SPACE.
*(DEL)  IF STATUS-ACTION EQ ANZEIGEN.
*(DEL)    MESSAGE I001(SV).
*(DEL)    EXIT.
*(DEL)  ENDIF.
  IF SY-DATAR NE SPACE.
    CALL FUNCTION &apos;POPUP_TO_CONFIRM_STEP&apos;
         EXPORTING
              TITEL          = SVIM_TEXT_005
              TEXTLINE1      = SVIM_TEXT_009
              TEXTLINE2      = SVIM_TEXT_006
              DEFAULTOPTION  = &apos;N&apos;
              CANCEL_DISPLAY = &apos; &apos;
         IMPORTING
              ANSWER         = ANSWER.
    IF ANSWER EQ &apos;J&apos;.
      NEUER = &apos;N&apos;.
      IF STATUS-ACTION EQ KOPIEREN.
        SET SCREEN 0.
      ELSE.
        SET SCREEN LISTE.
        NEXTLINE = FIRSTLINE.
      ENDIF.
      CLEAR &lt;STATUS&gt;-UPD_FLAG.
      LEAVE SCREEN.
    ELSE.
      CLEAR FUNCTION.
    ENDIF.
  ELSE.
    IF VIM_SINGLE_ENTRY_FUNCTION NE SPACE.
      TRANSLATE STATUS-ACTION USING &apos;AU&apos;. STATUS-MODE = GESAMTDATEN.
    ENDIF.
    CASE STATUS-ACTION.
      WHEN HINZUFUEGEN. PERFORM LISTE_BACK.
      WHEN KOPIEREN.    SET SCREEN 0.
      WHEN OTHERS.
        FUNCTION = &apos;BACK&apos;. SET SCREEN 0. CLEAR VIM_ACT_DYNP_VIEW.
        PERFORM UPDATE_STATUS.
    ENDCASE.
    LEAVE SCREEN.
  ENDIF.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF3N" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000007" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122439" IDATE="20080721" ITIME="122439">
    <include_source>*---------------------------------------------------------------------*
*       FORM LISTE_BACK                                               *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM liste_back.
  IF status-action EQ hinzufuegen.
    status-action = &lt;status&gt;-st_action = aendern.
    title-action  = aendern.
    CLEAR &lt;status&gt;-selected.
    neuer = &apos;N&apos;.
  ENDIF.
  IF status-delete = geloescht.
    status-delete = &lt;status&gt;-st_delete = nicht_geloescht.
    title-action  = aendern.
    PERFORM markiere_alle USING nicht_markiert.
  ENDIF.
  IF x_header-delmdtflag NE space.
    LOOP AT vim_collapsed_mainkeys.
      IF vim_collapsed_mainkeys-mkey_bf EQ space.
        vim_collapsed_mainkeys-mkey_bf = vim_collapsed_mainkeys-log_key.
        CLEAR vim_collapsed_mainkeys-log_key.
      ENDIF.
      &lt;f1_x&gt; = &lt;vim_h_coll_mkey&gt;.
*      &lt;f1&gt; = vim_collapsed_mainkeys-mainkey.
      &lt;vim_enddate_mask&gt; = space.
      &lt;vim_h_coll_mkey&gt; = &lt;f1_x&gt;.
*      vim_collapsed_mainkeys-mainkey = &lt;f1&gt;.
      MODIFY vim_collapsed_mainkeys.
    ENDLOOP.
    IF vim_delim_expa_excluded NE space.
      DELETE excl_cua_funct WHERE function EQ &apos;EXPA&apos;.
      CLEAR vim_delim_expa_excluded.
    ENDIF.
    IF status-action = aendern AND title-action = hinzufuegen.
      title-action  = aendern.
    ENDIF.
  ENDIF.
  PERFORM fill_extract.
  nextline = 1.
  mark_extract = mark_total.
  SET SCREEN liste.
  LEAVE SCREEN.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF3O" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000004" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122439" IDATE="20080721" ITIME="122439">
    <include_source>*---------------------------------------------------------------------*
*       FORM BEENDEN                                                  *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM beenden.
  DATA: line1(30) TYPE c,
        handle TYPE ad_handle,
        adrnum TYPE ad_addrnum.

  CASE function.
    WHEN &apos;ANZG&apos;.
      line1 = svim_text_001.
    WHEN &apos;ATAB&apos;.
      line1 = svim_text_008.
    WHEN &apos;ENDE&apos;.
      line1 = svim_text_003.
  ENDCASE.
  CALL FUNCTION &apos;POPUP_TO_CONFIRM_STEP&apos;
       EXPORTING
            titel     = line1
            textline1 = svim_text_018  &quot;Daten wurden verändert.
            textline2 = svim_text_019  &quot;Änderungen vorher sichern ?
       IMPORTING
            answer    = answer.
  CASE answer.
    WHEN &apos;J&apos;.
      sy-subrc = 0.
    WHEN &apos;N&apos;.
      CLEAR &lt;status&gt;-upd_flag.
      IF maint_mode EQ transportieren.
        &lt;status&gt;-keytbinvld = &apos;X&apos;.
      ELSEIF maint_mode EQ aendern. &quot;AND x_header-adrnbrflag EQ &apos;N&apos;.
* reset unsaved addresses                          UF557286/2000b
        LOOP AT vim_addresses_to_save.
          IF vim_addresses_to_save-addrnumber CP &apos;@NEW*&apos;.
            CLEAR adrnum.
            handle = vim_addresses_to_save-handle.
          ELSE.
            CLEAR handle.
            adrnum = vim_addresses_to_save-addrnumber.
          ENDIF.
          CALL FUNCTION &apos;ADDR_SINGLE_RESET&apos;
               EXPORTING
                    address_number = adrnum
                    address_handle = handle
               EXCEPTIONS
                    OTHERS         = 1.
          IF sy-subrc &lt;&gt; 0.
* MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*         WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
          ENDIF.
        ENDLOOP.
        REFRESH vim_addresses_to_save.
      ENDIF.                                            &quot;UF557286/2000e
      sy-subrc = 8.
    WHEN &apos;A&apos;.
      sy-subrc = 12.
  ENDCASE.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF3P" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000014" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122439" IDATE="20080721" ITIME="122439">
    <include_source>*---------------------------------------------------------------------*
*       FORM ANZG_TO_AEND                                             *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM anzg_to_aend.
  DATA: rc LIKE sy-subrc, dummy TYPE scpr_id, value(200) TYPE c,
        value_is_external TYPE xfeld, lfieldname TYPE fnam_____4,
        keyvalues TYPE occheckkeyflds, w_keyvalue TYPE occheckkey,
        oc_rangetab TYPE TABLE OF vimsellist, lines TYPE i,
        any_substflds_initial TYPE xfeld, field1 LIKE sy-msgv1,
        field2 LIKE sy-msgv2, field3 LIKE sy-msgv3,
        field4 LIKE sy-msgv4.
  FIELD-SYMBOLS: &lt;w_dba_sel&gt; TYPE vimsellist, &lt;x_namtab&gt; TYPE vimnamtab,
                 &lt;value&gt; TYPE c.                             &quot;#EC *

  IF status-action NE anzeigen AND status-action NE transportieren.
    MESSAGE i001(sv).
  ELSE.
    IF status-action EQ anzeigen.
* check authority
      IF x_header-newgener EQ space. &quot;4.5a: support individual auth.chck
        CALL FUNCTION &apos;VIEW_AUTHORITY_CHECK&apos;
           EXPORTING
                view_action                = aendern
                view_name                  = view_name
                no_warning_for_clientindep = vim_no_warning_for_cliindep
           CHANGING
                org_crit_inst              = vim_oc_inst
           EXCEPTIONS
                no_authority                   = 8
                no_clientindependent_authority = 9
                no_linedependent_authority     = 11.
        rc = sy-subrc.
        IF sy-subrc = 11.
          MOVE: sy-msgid TO vim_auth_msgid,
                sy-msgno TO vim_auth_msgno,
                sy-msgv1 TO vim_auth_msgv1,
                sy-msgv2 TO vim_auth_msgv2,
                sy-msgv3 TO vim_auth_msgv3,
                sy-msgv4 TO vim_auth_msgv4.
        ENDIF.
      ENDIF.
      IF x_header-frm_on_aut NE space.
        vim_auth_action = aendern.
        vim_auth_event = vim_auth_switch_to_update_mode.
        ASSIGN &lt;vim_ck_sellist&gt; TO &lt;vim_auth_sellist&gt;.
        PERFORM (x_header-frm_on_aut) IN PROGRAM.
        IF vim_auth_rc NE 0. rc = 10. ENDIF.
      ENDIF.
    ENDIF.
    CASE rc.
      WHEN 0.
        IF NOT vim_oc_inst IS INITIAL AND vim_called_by_cluster = space.
* check line-dependent authorisation (viewclusters: will be done in
* viewcluster maintenance.)
* 1st: check non-subset-values
          INSERT LINES OF dba_sellist[] INTO TABLE oc_rangetab.
          LOOP AT x_namtab ASSIGNING &lt;x_namtab&gt; WHERE keyflag &lt;&gt; space
           AND readonly = subset.
            DELETE oc_rangetab WHERE viewfield = &lt;x_namtab&gt;-viewfield.
          ENDLOOP.
          IF sy-subrc = 0.
            DESCRIBE TABLE oc_rangetab LINES lines.
            if lines &gt; 0.
              READ TABLE oc_rangetab ASSIGNING &lt;w_dba_sel&gt; INDEX lines.
              CLEAR &lt;w_dba_sel&gt;-and_or.
            endif.
          ENDIF.
          CALL METHOD vim_oc_inst-&gt;check_oc_auth_vim_sellist
            EXPORTING
              sellist    = oc_rangetab
              action     = &apos;02&apos;
*          CHANGING
*            KEY_FIELDS =
            EXCEPTIONS
              no_auth    = 1
              OTHERS     = 2.
          IF sy-subrc &lt;&gt; 0.
            MESSAGE ID sy-msgid TYPE &apos;I&apos; NUMBER sy-msgno
             WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
            EXIT.
          ENDIF.
          IF x_header-subsetflag &lt;&gt; space.
* 2nd: check subset values
            CALL METHOD vim_oc_inst-&gt;build_key_value_tab
              EXPORTING
                entry     = &lt;initial&gt;
              IMPORTING
                keyvalues = keyvalues.
            LOOP AT keyvalues INTO w_keyvalue.
              READ TABLE x_namtab ASSIGNING &lt;x_namtab&gt;
               WITH KEY viewfield = w_keyvalue-keyname.
              CHECK &lt;x_namtab&gt;-readonly &lt;&gt; subset.
              DELETE keyvalues.
            ENDLOOP.
            CALL METHOD vim_oc_inst-&gt;check_oc_authority
              EXPORTING
                activity        = &apos;02&apos;
              CHANGING
                key_values      = keyvalues
              EXCEPTIONS
                no_auth         = 1
                key_incomplete  = 2
*              WRONG_PARAMETER = 3
                OTHERS          = 4.
            IF sy-subrc = 1.
              MOVE: sy-msgv1 TO field1, sy-msgv2 TO field2,
                    sy-msgv3 TO field3, sy-msgv4 TO field4.
* no authorisation for current subset values
              MESSAGE i763(sv) WITH field1 field2 field3 field4. &quot;#EC *
*   Sie haben keine Pflegeberechtigung für die angezeigten Datensätze.
              LOOP AT keyvalues INTO w_keyvalue WHERE noauth &lt;&gt; space.
                READ TABLE dba_sellist ASSIGNING &lt;w_dba_sel&gt;
                 WITH KEY viewfield = w_keyvalue-keyname.
                CLEAR: &lt;w_dba_sel&gt;-value, &lt;w_dba_sel&gt;-initial,
                       &lt;w_dba_sel&gt;-from_auth.                &quot;UF210200
              ENDLOOP.
*              CALL METHOD vim_oc_inst-&gt;convert_oc_selections
*                        EXPORTING
*                            activity   = &apos;02&apos;
*                        IMPORTING
*                            oc_vimsell = oc_rangetab.
** if possible: fill subset selection in RANGETAB from authority
** (authority object S_TABU_LIN)
*              PERFORM vim_merge_sellists USING    oc_rangetab
*                                                  x_namtab[]
*                                                  &apos;X&apos;
*                                         CHANGING x_header[]
*                                                  dba_sellist
*                                                  rc.
*              PERFORM check_all_substfields TABLES dba_sellist
*                      CHANGING any_substflds_initial.
*              IF any_substflds_initial &lt;&gt; space.
              CALL FUNCTION &apos;TABLE_RANGE_INPUT&apos;
                   EXPORTING
                        table             = x_header-viewname
                        oc_inst           = vim_oc_inst
                   TABLES
                        sellist           = dba_sellist
                        x_header          = x_header
                        x_namtab          = x_namtab
                   EXCEPTIONS
                        cancelled_by_user = 1
                        no_input          = 2
                        OTHERS            = 3.
              IF sy-subrc &lt;&gt; 0.
                EXIT.
              ENDIF.
*              refresh vim_dba_sel_kept.            &quot;UF210200
*              ENDIF.
            ENDIF.
          ELSE.
* new selection because of different authorisation? --&gt; Message
* &gt;&gt;&gt;check whether there&apos;s really a difference between upd and show&lt;&lt;&lt;
            MESSAGE s764(sv).
*   Veränderte Auswahl von Datensätzen.
          ENDIF.                       &quot;subsets exist
        ENDIF.                         &quot;oc exists
        IF status-action EQ transportieren.
          function = switch_transp_to_upd_mode.
          CLEAR &lt;status&gt;-crcntsknwn.
          IF &lt;status&gt;-corr_enqud NE space.
            CALL FUNCTION &apos;DEQUEUE_E_TRKORR&apos;
                 EXPORTING
                      trkorr = &lt;status&gt;-corr_nbr.
*             X_TRKORR = E02.
            CLEAR &lt;status&gt;-corr_enqud.
          ENDIF.
          IF x_header-cursetting NE space.
            CLEAR: vim_corr_obj_viewname, &lt;status&gt;-tr_alrchkd.
          ENDIF.
        ELSE.
          CLEAR vim_corr_obj_viewname.
          IF &lt;status&gt;-prof_found = vim_profile_found    &quot;UF profileb
             AND vim_pr_records = 0.
* get records the profile contains
            PERFORM get_pr_nbr_records USING vim_profile_values
                                             x_header
                                       CHANGING rc
                                                dummy
                                                vim_pr_records
                                                vim_pr_tab
                                                vim_pr_fields.
* check key-status
            PERFORM get_profile_status CHANGING vim_pr_tab
                                                vim_pr_fields.
            PERFORM bcset_key_check_in_total.
          ENDIF.                       &quot;UF profileb
        ENDIF.
*       SET SCREEN 0.
*       LEAVE SCREEN.
        vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
      WHEN 8.                          &quot;no authority for update
        MESSAGE i051(sv).              &quot;only show allowed
      WHEN 9.
        MESSAGE ID &apos;TB&apos; TYPE &apos;I&apos; NUMBER 109.      &quot;no cli-indep auth
      WHEN 10 OR 11.
        MESSAGE ID vim_auth_msgid TYPE &apos;I&apos; NUMBER vim_auth_msgno
                WITH vim_auth_msgv1 vim_auth_msgv2  vim_auth_msgv3
                     vim_auth_msgv4.
    ENDCASE.
  ENDIF.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF3Q" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000003" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122439" IDATE="20080721" ITIME="122439">
    <include_source>*---------------------------------------------------------------------*
*       FORM AEND_TO_ANZG                                             *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM aend_to_anzg.
* was not used &apos;til 4.6C
  IF status-action EQ anzeigen.
    MESSAGE i001(sv).
  ELSE.
    IF NOT vim_oc_inst IS INITIAL.
* new selection because of different authorisation? --&gt; Message
* &gt;&gt;&gt;check whether there&apos;s really a difference between upd and show&lt;&lt;&lt;
      MESSAGE s764(sv).
*   Veränderte Auswahl von Datensätzen.
    ENDIF.
*    CLEAR: &lt;status&gt;-mk_xt,
*           &lt;status&gt;-mk_to,
*           block_sw.
*    PERFORM beenden.
  ENDIF.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF3R" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000004" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122439" IDATE="20080721" ITIME="122440">
    <include_source>*---------------------------------------------------------------------*
*       FORM VIM_SAPSCRIPT_FORM_MAINT.                                *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM VIM_SAPSCRIPT_FORM_MAINT.
  LOCAL: STATUS-MODE.
  DATA: VSFM_TABLE LIKE VIMDESC-VIEWNAME, VSFM_FLAG(1) TYPE C,
        VSFM_FIELD LIKE VIMNAMTAB-VIEWFIELD, VSFM_HF TYPE I.

  IF X_HEADER-SCRFRMFLAG EQ SPACE.
    MESSAGE E001(SV).
    EXIT.
  ENDIF.
  IF VIM_NBR_OF_SCRFRM_POINTERS GT 1.
    IF STATUS-MODE EQ DETAIL_BILD. GET CURSOR FIELD F. ENDIF.
    SPLIT F AT &apos;-&apos; INTO VSFM_TABLE VSFM_FIELD.
    IF X_HEADER-BASTAB NE SPACE AND X_HEADER-TEXTTBEXST NE SPACE AND
       VSFM_TABLE EQ X_HEADER-TEXTTAB.
      VSFM_FLAG = &apos;X&apos;.
    ENDIF.
    READ TABLE X_NAMTAB WITH KEY VIEWFIELD = VSFM_FIELD
                                 TEXTTABFLD = VSFM_FLAG.
    IF X_NAMTAB-DOMNAME NE VIM_SCRFORM_DOMAIN.
      MESSAGE S161(SV). &quot; Bitte stellen Sie den Cursor auf einen Formula
      CLEAR FUNCTION.
      EXIT.
    ENDIF.
*    ASSIGN &lt;TABLE1&gt;+X_NAMTAB-POSITION(X_NAMTAB-FLENGTH)
*                                       TO &lt;VIM_SCRFORM_NAME&gt;.
    ASSIGN component x_namtab-viewfield of structure &lt;TABLE1&gt;
     TO &lt;VIM_SCRFORM_NAME&gt;.
    IF STATUS-MODE EQ LIST_BILD.
      VSFM_HF = FIRSTLINE + L - 1.
      STATUS-MODE = DETAIL_BILD.
    ELSE.
      VSFM_HF = NEXTLINE.
    ENDIF.
    READ TABLE EXTRACT INDEX VSFM_HF.
    PERFORM MOVE_EXTRACT_TO_VIEW_WA.
  ENDIF.
  IF STATUS-MODE EQ LIST_BILD.
    LOOP AT EXTRACT.
      CHECK &lt;XMARK&gt; EQ MARKIERT.
      PERFORM MOVE_EXTRACT_TO_VIEW_WA.
      CALL FUNCTION &apos;EDIT_FORM&apos;
           EXPORTING
                FORM              = &lt;VIM_SCRFORM_NAME&gt;
*           LANGUAGE          = SY-LANGU
                DISPLAY           = &apos;X&apos;
*           COMPONENT         = &apos;HEADER&apos;
           EXCEPTIONS
                UNKNOWN_ACTIVITY  = 1
                UNKNOWN_COMPONENT = 2.
      IF SY-SUBRC NE 0.
        MESSAGE ID SY-MSGID TYPE &apos;I&apos; NUMBER SY-MSGNO WITH
                SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
        CONTINUE.
      ENDIF.
      &lt;XMARK&gt; = NICHT_MARKIERT.
      MODIFY EXTRACT.
      READ TABLE TOTAL WITH KEY &lt;VIM_xEXTRACT_KEY&gt; BINARY SEARCH.
      &lt;MARK&gt; = NICHT_MARKIERT.
      MODIFY TOTAL INDEX SY-TABIX.
      SUBTRACT: 1 FROM MARK_EXTRACT,
                1 FROM MARK_TOTAL.
    ENDLOOP.
  ELSE.                                &quot;detail bild
    CALL FUNCTION &apos;EDIT_FORM&apos;
         EXPORTING
              FORM              = &lt;VIM_SCRFORM_NAME&gt;
*             LANGUAGE          = SY-LANGU
              DISPLAY           = &apos;X&apos;
*             COMPONENT         = &apos;HEADER&apos;
         EXCEPTIONS
              UNKNOWN_ACTIVITY  = 1
              UNKNOWN_COMPONENT = 2.
    IF SY-SUBRC NE 0.
      MESSAGE ID SY-MSGID TYPE &apos;I&apos; NUMBER SY-MSGNO WITH
              SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
      CLEAR FUNCTION. EXIT.
    ENDIF.
    IF &lt;XMARK&gt; EQ MARKIERT.
      &lt;XMARK&gt; = NICHT_MARKIERT.
      MODIFY EXTRACT INDEX NEXTLINE.
      READ TABLE TOTAL WITH KEY &lt;VIM_xEXTRACT_KEY&gt; BINARY SEARCH.
      &lt;MARK&gt; = NICHT_MARKIERT.
      MODIFY TOTAL INDEX SY-TABIX.
      SUBTRACT: 1 FROM MARK_EXTRACT,
                1 FROM MARK_TOTAL.
    ENDIF.
  ENDIF.                               &quot;status-mode eq list_bild
  CLEAR FUNCTION.
ENDFORM.                               &quot;vim_sapscript_form_maint</include_source>
   </include>
   <include NAME="LSVIMF3S" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000003" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122440" IDATE="20080721" ITIME="122440">
    <include_source>*---------------------------------------------------------------------*
*       FORM VIM_CHECK_ALE_EDIT_LOCK                                  *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM VIM_CHECK_ALE_EDIT_LOCK USING VALUE(VCAEL_OBJECT) LIKE E071-OBJECT
                                   VCAEL_LOCK TYPE C.
  DATA: OBJ_TYPE LIKE OBJH-OBJECTTYPE, OBJ_NAME LIKE OBJH-OBJECTNAME.

* OBJ_NAME = VIEW_NAME.
  OBJ_NAME = MASTER_NAME.
  CASE VCAEL_OBJECT.
    WHEN VIM_VIEW_TYPE.                &quot;-&gt; view
      OBJ_TYPE = VIM_VIEW.
    WHEN TRANSP_OBJECT.                &quot;-&gt; tables
      OBJ_TYPE = VIM_TABL.
    WHEN VIM_CLUS_TYPE.                &quot;-&gt; viewcluster
      OBJ_TYPE = VIM_CLST.
    WHEN VIM_TRAN_TYPE.                &quot;-&gt; individual transaction
      OBJ_TYPE = VIM_TRAN.
    WHEN OTHERS.                       &quot;-&gt; may be LOGO object ?
      OBJ_TYPE = VIM_LOGO. OBJ_NAME = VCAEL_OBJECT.
*     SELECT SINGLE * FROM OBJH WHERE OBJECTNAME EQ OBJ_NAME &quot;required ?
*                                 AND OBJECTTYPE EQ OBJ_TYPE.
*     IF SY-SUBRC NE 0. CLEARVCAEL_LOCK. EXIT. ENDIF. &quot;no logo-object
  ENDCASE.
  CALL FUNCTION &apos;ALE_EDIT_CHECK&apos;
       EXPORTING
            OBJECTTYPE      = OBJ_TYPE
            OBJECTNAME      = OBJ_NAME
       IMPORTING
            SOMEKEYS_NOEDIT = VIM_ALE_KEYSPEC_CHECK
       EXCEPTIONS
            NO_CALL         = 1
            NO_EDIT         = 2.
  IF SY-SUBRC GT 1.
    VCAEL_LOCK = &apos;X&apos;.
    VIM_ALE_MSGID = SY-MSGID. VIM_ALE_MSGNO = SY-MSGNO.
    VIM_ALE_MSGV1 = SY-MSGV1. VIM_ALE_MSGV2 = SY-MSGV2.
    VIM_ALE_MSGV3 = SY-MSGV3. VIM_ALE_MSGV4 = SY-MSGV4.
  ELSE.
    CLEAR VCAEL_LOCK.
    IF VIM_ALE_KEYSPEC_CHECK NE SPACE AND OBJ_TYPE NE VIM_LOGO.
      VIM_ALE_KEYSPEC_OBJTAB-ONAME = OBJ_NAME.
      VIM_ALE_KEYSPEC_OBJTAB-OTYPE = OBJ_TYPE.
      APPEND VIM_ALE_KEYSPEC_OBJTAB.
    ENDIF.
  ENDIF.
ENDFORM.                               &quot;vim_check_ale_edit_lock</include_source>
   </include>
   <include NAME="LSVIMF3T" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000004" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122440" IDATE="20080721" ITIME="122440">
    <include_source>*---------------------------------------------------------------------*
*       FORM VIM_SET_ALE_EDIT_LOCK                                    *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM VIM_SET_ALE_EDIT_LOCK.
  DATA: I_EDITLOCK(1) TYPE C.

  VIM_LAST_OBJH_VIEW = VIEW_NAME.
  REFRESH VIM_ALE_KEYSPEC_OBJTAB.
  IF X_HEADER-FLAG EQ SPACE.           &quot;standard transport required
    PERFORM VIM_CHECK_ALE_EDIT_LOCK USING E071-OBJECT I_EDITLOCK.
    VIM_ALE_EDIT_LOCK = I_EDITLOCK.
    IF VIM_ALE_EDIT_LOCK NE SPACE. EXIT. ENDIF.
  ENDIF.
  IF X_HEADER-FRM_E071 NE SPACE. &quot;individual transport objects exist
    IF VIM_CORR_OBJ_VIEWNAME NE X_HEADER-VIEWNAME.
      PERFORM (X_HEADER-FRM_E071) IN PROGRAM (SY-REPID).
      CLEAR VIM_CORR_OBJ_VIEWNAME.
    ENDIF.
    LOOP AT VIM_CORR_OBJTAB.
      PERFORM VIM_CHECK_ALE_EDIT_LOCK USING VIM_CORR_OBJTAB-OBJECT
                                            I_EDITLOCK.
      VIM_ALE_EDIT_LOCK = I_EDITLOCK.
      IF VIM_ALE_EDIT_LOCK NE SPACE. EXIT. ENDIF.
    ENDLOOP.
  ENDIF.
ENDFORM.                               &quot;vim_set_ale_edit_lock</include_source>
   </include>
   <include NAME="LSVIMF3U" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000015" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122440" IDATE="20080721" ITIME="122440">
    <include_source>*---------------------------------------------------------------------*
*       FORM JUSTIFY_ACTION_MODE                                      *
*---------------------------------------------------------------------*
* ggf. VIEW_ACTION aendern und View entsperren                        *
*---------------------------------------------------------------------*
FORM justify_action_mode.
  TABLES: scdtsync.
  DATA: action_changed(1) TYPE c, assigned(1) TYPE c.
  DATA: i_statetab LIKE adrstatus OCCURS 0 WITH HEADER LINE,
        i_messnbr LIKE sy-msgno, viewtype,
        msg_v1 LIKE sy-msgv1.
  STATICS: vim_old_cluster TYPE vcl_name.&quot;Avoid sync_key_lock messages

  FIELD-SYMBOLS: &lt;f_fld_value&gt; TYPE ANY.  &quot; XB H612358

  IF fcode = vim_read_text.            &quot;SW Textimp ...
    PERFORM vim_read_texttab_all_langus.
    EXIT.
  ENDIF.                               &quot;... SW Textimp

* XB H612358B
* check if the time-field exists: Yes, then reset initial value.
  LOOP AT x_namtab WHERE datatype = &apos;TIMS&apos;.
    ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE &lt;initial&gt;
         TO &lt;f_fld_value&gt;.
    IF &lt;f_fld_value&gt; &lt;&gt; space.
      CLEAR &lt;f_fld_value&gt; WITH space.
    ENDIF.
  ENDLOOP.
* XB H612358B

  IF x_header-selection EQ space.
    DESCRIBE TABLE dba_sellist.
    IF sy-tfill GT 0.
      MOVE &apos;X&apos; TO x_header-selection.
      MODIFY x_header INDEX 1.
*      IF last_view_info EQ view_name.                       &quot;UF443580b
** &lt;initial&gt; not yet filled in INITIALISIEREN
*        PERFORM vim_set_init_from_sellist USING x_header-maintview
*                                                x_namtab[]
*                                                dba_sellist[]
*                                                vim_hidden
*                                          CHANGING &lt;initial&gt;.
*      ENDIF.                                                &quot;UF443580e
    ELSE.
      DESCRIBE TABLE dpl_sellist.
      IF sy-tfill GT 0.
        MOVE &apos;X&apos; TO x_header-selection.
        MODIFY x_header INDEX 1.
      ENDIF.
    ENDIF.
  ELSEIF x_header-selection = &apos;X&apos;.     &quot;XB BCEK064860 begin
*&lt;inital&gt; not filled because the F3. XB int4436226
    DESCRIBE TABLE dba_sellist.
    IF sy-tfill GT 0.
      IF last_view_info EQ view_name.                       &quot;UF443580b
* &lt;initial&gt; not yet filled in INITIALISIEREN
* because with F3 the last_view_info exists.
        PERFORM vim_set_init_from_sellist USING x_header-maintview
                                                x_namtab[]
                                                dba_sellist[]
                                                vim_hidden
                                          CHANGING &lt;initial&gt;.
      ENDIF.                                                &quot;UF443580e
    ENDIF.           &quot;XB BCEK064860 end
  ENDIF.
  IF x_header-adrnbrflag NE space.
* 4.0: check if new version of address maintenance must be used
    CALL FUNCTION &apos;ADDR_TSADRV_READ&apos;
      EXPORTING
        ddic_tablename  = vim_addr_basetable
        ddic_fieldname  = vim_addr_bastab_field
      IMPORTING
        tsadrv_wa       = vim_tsadrv
      EXCEPTIONS
        entry_not_found = 1.
    IF sy-subrc NE 0.                  &quot;no tsadrv entry found...
      IF x_header-adrnbrflag EQ &apos;N&apos;.   &quot;new version requires entry
        MESSAGE i287(am) WITH vim_addr_basetable vim_addr_bastab_field.
        CLEAR x_header-adrnbrflag. MODIFY x_header INDEX 1.
      ELSE. &quot;old version runs but is old fashioned....
        IF vim_system_type EQ &apos;SAP&apos;.   &quot;sap system
          MESSAGE i290(am) WITH vim_addr_basetable  &quot;...send message
                                vim_addr_bastab_field.
        ELSE.
          MESSAGE i291(am) WITH vim_addr_basetable  &quot;...send message
                                vim_addr_bastab_field.
        ENDIF.
      ENDIF.
    ELSE.                              &quot;entry found....
      IF vim_tsadrv-addr_group IS INITIAL. &quot;...but not complete
*       I_TSADRV-ADDR_GROUP = &apos;CA01&apos;. &quot;default: Customizing Address
        IF x_header-adrnbrflag EQ &apos;N&apos;. &quot;new version
          i_messnbr = &apos;292&apos;.
        ELSE.                          &quot;old version
          IF vim_system_type EQ &apos;SAP&apos;. &quot;sap system
            i_messnbr = &apos;288&apos;.
          ELSE.                        &quot;customer system
            i_messnbr = &apos;289&apos;.
          ENDIF.
        ENDIF.
        MESSAGE ID &apos;AM&apos; TYPE &apos;I&apos; NUMBER i_messnbr
                        WITH vim_addr_basetable
                             vim_addr_bastab_field
                             vim_tsadrv-tablename
                             vim_tsadrv-fieldname.
        CLEAR x_header-adrnbrflag. MODIFY x_header INDEX 1.
      ELSE.                            &quot;entry in TSADRV is complete
        vim_addr_group = vim_tsadrv-addr_group.
        IF x_header-adrnbrflag EQ &apos;O&apos;.
          CALL FUNCTION &apos;ADDR_GET_STATUS_INFO&apos;
            TABLES
              status_table = i_statetab.
          READ TABLE i_statetab WITH KEY
               constant = vim_tsadrv-addr_group.
          IF sy-subrc NE 0. CLEAR i_statetab-value. ENDIF.
          TRANSLATE i_statetab-value USING &apos; OXN&apos;.
          x_header-adrnbrflag = i_statetab-value.
          MODIFY x_header INDEX 1.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.
  PERFORM vim_process_assigns.
  IF &lt;status&gt;-initializd EQ space.     &quot;not processed yet
* reset dropdown lists
    CALL FUNCTION &apos;VRM_REFRESH_VALUES&apos;.
    IF x_header-frm_af_ini NE space.   &quot;user exit exists AND
* set environment for user exit.
      ASSIGN dba_sellist-*sys* TO &lt;vim_sellist&gt;.
      vim_enqueue_range = x_header-subsetflag. assigned = &apos;X&apos;.
* perform user exit -&gt; 3.0B processed in JUSTIFY_ACTION_MODE
      PERFORM (x_header-frm_af_ini) IN PROGRAM (sy-repid).
    ENDIF.
* backup DBA_SELLIST
*    REFRESH vim_dba_sel_kept.                        &quot;UF210200b
*    APPEND LINES OF dba_sellist TO vim_dba_sel_kept.
* remove multiple values for subsets
    DELETE dba_sellist WHERE ddic = &apos;M&apos;.
    DESCRIBE TABLE dba_sellist.
    IF sy-tfill GT 0.
      READ TABLE dba_sellist INDEX sy-tfill.
      CLEAR dba_sellist-and_or.
      MODIFY dba_sellist INDEX sy-tabix.
    ENDIF.                                                  &quot;UF210200e
  ENDIF.
  IF view_action EQ aendern AND
     function EQ switch_to_update_mode AND
     vim_enq_s_u_rc NE 0.
    MOVE anzeigen TO view_action. action_changed = &apos;X&apos;.
  ENDIF.
  IF x_header-existency EQ rdonly AND  &quot;read only view
     ( view_action EQ aendern OR       &quot;update or
       view_action EQ transportieren ).&quot;transport request
    MOVE anzeigen TO view_action. action_changed = &apos;X&apos;.
    MESSAGE i044(sv).
  ENDIF.
  IF &lt;status&gt;-corr_nbr EQ vim_locked_in_corr AND &quot;object locked and
     ( view_action EQ aendern OR       &quot;update or
       view_action EQ transportieren ).&quot;transport request
    MOVE anzeigen TO view_action. action_changed = &apos;X&apos;.
  ENDIF.
  IF view_action EQ aendern AND fcode NE read.  &quot;BC-Set Flag not set yet
*---Lock for Synchronizer--------------------------------HCG 08/2003---*
    IF vim_last_objh_view NE view_name.
      IF x_header-bastab EQ space.
        viewtype = &apos;V&apos;.
      ELSE.
        viewtype = &apos;S&apos;.
      ENDIF.
      SELECT SINGLE * FROM scdtsync.                    &quot;#EC CI_GENBUFF
      IF sy-subrc EQ 0.
        CALL FUNCTION &apos;SCTM_CHECK_VIEW_EDIT&apos;
          EXPORTING
            viewname        = view_name
            viewtype        = viewtype
            bcset           = vim_bcset_id &quot;if NE space -&gt; BC-set act.
          IMPORTING
            edit_flag       = vim_sync_edit_lock
            kespec_flag     = vim_sync_keyspec_check
            sourcesys       = vim_sctm_sourcesys
          EXCEPTIONS
            no_sync_present
            old_sync_system
            rfc_failure.
        IF sy-subrc = 3.   &quot;1 and 2: Message already sent by function
          IF vim_import_profile EQ space.
            MESSAGE w183(sv) WITH sy-msgv1 sy-msgv2.        &quot;#EC *
          ELSE.
            vim_import_no_message = &apos;X&apos;.
            PERFORM vim_process_message USING &apos;SV&apos; &apos;W&apos; &apos;W&apos; &apos;183&apos;
                                        sy-msgv1 sy-msgv2 space space.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.                            &quot;vim_last_objh_view NE view_name
    IF vim_sync_edit_lock NE space AND      &quot;Table locked completely
       vim_sync_keyspec_check EQ space.
      MOVE anzeigen TO view_action. action_changed = &apos;X&apos;.
      MOVE vim_sctm_sourcesys TO msg_v1.
      IF vim_import_profile NE space.
        vim_no_dialog = &apos;X&apos;.
        vim_import_no_message = &apos;X&apos;.
        PERFORM vim_process_message
                USING
                  &apos;SV&apos; &apos;E&apos; &apos;E&apos; &apos;181&apos; msg_v1 space space space.
      ELSE.
        PERFORM vim_process_message
                          USING
                          &apos;SV&apos; &apos;I&apos; &apos;I&apos; &apos;181&apos; msg_v1 space space space.
      ENDIF.
    ELSEIF vim_sync_keyspec_check NE space.      &quot;Table locked partly
      IF vim_import_profile EQ space.       &quot;BC-Set act: only message
        MOVE vim_sctm_sourcesys TO msg_v1. &quot;in log when key is locked
        IF vim_calling_cluster NE vim_old_cluster OR
          vim_called_by_cluster EQ space.
          MOVE vim_calling_cluster TO vim_old_cluster.
          PERFORM vim_process_message
                  USING
                    &apos;SV&apos; &apos;I&apos; &apos;I&apos; &apos;180&apos; msg_v1 space space space.
        ENDIF.
      ENDIF.
    ENDIF.
*----------------------------------------------------------------------*
    IF vim_last_objh_view NE view_name.
      PERFORM vim_set_ale_edit_lock.
    ENDIF.
    IF vim_ale_edit_lock NE space.
      MOVE anzeigen TO view_action. action_changed = &apos;X&apos;.
      PERFORM vim_process_message
            USING
              vim_ale_msgid &apos;I&apos; &apos;I&apos; vim_ale_msgno
              vim_ale_msgv1 vim_ale_msgv2
              vim_ale_msgv3 vim_ale_msgv4.
    ENDIF.
  ENDIF.
  IF x_header-frm_on_aut NE space AND  &quot;45a: support indiv. auth. chck
     &lt;status&gt;-initializd EQ space.     &quot;not processed yet
    vim_auth_action = view_action.
    vim_auth_event = vim_auth_initial_check.
    ASSIGN dba_sellist[] TO &lt;vim_auth_sellist&gt;.
    PERFORM (x_header-frm_on_aut) IN PROGRAM.
    IF vim_auth_rc NE 0.
      MESSAGE ID vim_auth_msgid TYPE &apos;I&apos; NUMBER vim_auth_msgno
              WITH vim_auth_msgv1 vim_auth_msgv2
                   vim_auth_msgv3 vim_auth_msgv4.
      CASE vim_auth_rc.
        WHEN 4.                        &quot;show only
          MOVE anzeigen TO view_action. action_changed = &apos;X&apos;.
        WHEN 8.                        &quot;exit
          RAISE missing_corr_number.
      ENDCASE.
    ENDIF.
  ENDIF.
  IF action_changed NE space.
    IF assigned EQ space.
      ASSIGN dba_sellist-*sys* TO &lt;vim_sellist&gt;.
      vim_enqueue_range = x_header-subsetflag.
    ENDIF.
    PERFORM enqueue USING &apos;D&apos; x_header-frm_af_enq. &quot;dequeue view
  ENDIF.
  IF x_header-texttbexst &lt;&gt; space.     &quot;SW Texttransl
    PERFORM vim_actualize_d0100.
  ENDIF.
ENDFORM.                    &quot;justify_action_mode</include_source>
   </include>
   <include NAME="LSVIMF3V" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000002" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122440" IDATE="20080721" ITIME="122440">
    <include_source>*---------------------------------------------------------------------*
*       FORM SET_TITLE                                                *
*---------------------------------------------------------------------*
* Titel setzen: entweder allgemein oder angegeb. Programm             *
*---------------------------------------------------------------------*
FORM set_title USING st_title st_title_text.
  DATA: st_state LIKE sy-pfkey.
  CASE x_header-gui_prog.
    WHEN master_fpool.
      MOVE st_title TO st_state.
      CALL FUNCTION &apos;VIEW_SET_PF_STATUS&apos;
        EXPORTING
          status         = st_state
          title          = &apos;X&apos;
          title_text     = st_title_text
          objimp         = x_header-importable
        TABLES
          excl_cua_funct = excl_cua_funct.
    WHEN sy-repid.
      SET TITLEBAR st_title WITH st_title_text.
    WHEN OTHERS.
      RAISE wrong_gui_programm.
  ENDCASE.
ENDFORM.                    &quot;SET_TITLE</include_source>
   </include>
   <include NAME="LSVIMF3W" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000003" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122440" IDATE="20080721" ITIME="122440">
    <include_source>*---------------------------------------------------------------------*
*       FORM SET_PF_STATUS                                            *
*---------------------------------------------------------------------*
* PF-Status setzen: entweder allgemein oder angegeb. Programm         *
*---------------------------------------------------------------------*
FORM set_pf_status USING value(sps_status).
  DATA: sps_state LIKE sy-pfkey, sps_stat TYPE state_vector.
  CASE x_header-gui_prog.
    WHEN master_fpool.
      MOVE sps_status TO sps_state.
      CALL FUNCTION &apos;VIEW_SET_PF_STATUS&apos;
        EXPORTING
          status         = sps_state
          objimp         = x_header-importable
        TABLES
          excl_cua_funct = excl_cua_funct.
    WHEN sy-repid.
      MOVE sps_status TO sps_stat.
      IF sps_stat-action EQ anzeigen OR
         sps_stat-action EQ transportieren OR
         ( sy-mandt EQ &apos;000&apos; AND vim_system_type NE &apos;SAP&apos; ) OR
         x_header-importable = vim_not_importable.
        vim_comp_menue_text = svim_text_045.
      ELSE.
        vim_comp_menue_text = svim_text_046.
      ENDIF.
      vim_pr_stat_txt_ch = svim_text_prb.
      vim_pr_stat_txt_ta = svim_text_prc.
      vim_pr_stat_txt_me = svim_text_pri.
      vim_pr_stat_txt_or = svim_text_prj.
      SET PF-STATUS sps_status EXCLUDING excl_cua_funct.
    WHEN OTHERS.
      RAISE wrong_gui_programm.
  ENDCASE.
ENDFORM.                    &quot;SET_PF_STATUS</include_source>
   </include>
   <include NAME="LSVIMF3X" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000008" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122440" IDATE="20080721" ITIME="122440">
    <include_source>*---------------------------------------------------------------------*
*       FORM EXCLUDE_CUA_FUNCTIONS                                    *
*---------------------------------------------------------------------*
* ggf. Funktionen ausschließen                                        *
*---------------------------------------------------------------------*
FORM exclude_cua_functions.
  MOVE &apos;SLCT&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
  IF x_header-delmdtflag EQ space.
    MOVE &apos;DELM&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
    MOVE &apos;EXPA&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
    TRANSLATE x_header-existency USING &apos;MU&apos;.
    MODIFY x_header INDEX 1.
  ELSEIF vim_begdate_is_ro NE space.
    MOVE &apos;DELM&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
    MODIFY x_header INDEX 1.
  ENDIF.
  CASE x_header-existency.
    WHEN &apos;U&apos;.                          &quot;update only
      MOVE &apos;NEWL&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
      MOVE &apos;ALNW&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
      MOVE &apos;ALOE&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
      MOVE &apos;DELE&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
      MOVE &apos;KOPE&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
      MOVE &apos;DELM&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
    WHEN &apos;M&apos;.                          &quot;update only for main key
      MOVE &apos;NEWL&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
    WHEN &apos;R&apos;.                          &quot;read only
      MOVE &apos;AEND&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
  ENDCASE.
  IF x_header-clidep EQ space OR sy-mandt EQ &apos;000&apos;.
    MOVE &apos;COMP&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
    IF x_header-clidep EQ space.
      MOVE &apos;CMPO&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
    ENDIF.
  ENDIF.
  IF x_header-flag NE space AND x_header-cursetting EQ &apos;Y&apos; AND
     NOT ( x_header-frm_e071 NE space OR x_header-frm_e071ks NE space OR
           x_header-frm_e071ka NE space ).
    MOVE &apos;TRSP&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
  ENDIF.
  IF x_header-adrnbrflag EQ space.
    MOVE &apos;ADDR&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
  ELSE.
    LOOP AT excl_cua_funct WHERE function EQ &apos;ADDR&apos;.
      DELETE excl_cua_funct.
    ENDLOOP.
  ENDIF.
  IF x_header-scrfrmflag EQ space.
    MOVE &apos;SCRF&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
  ELSE.
    LOOP AT excl_cua_funct WHERE function EQ &apos;SCRF&apos;.
      DELETE excl_cua_funct.
    ENDLOOP.
  ENDIF.
  IF x_header-texttbexst EQ space.     &quot;SW Texttransl
    MOVE &apos;LANG&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
    MOVE &apos;TEXT&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
  ENDIF.
  IF vim_coming_from_img = &apos;N&apos;.        &quot;UF profiles
* profiles can&apos;t be activated
    MOVE &apos;GPRF&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
    MOVE &apos;UPRF&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
  ELSE.
    IF maint_mode = anzeigen.
* profile activating not allowed
      MOVE &apos;UPRF&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
    ELSE.
      DELETE excl_cua_funct WHERE function = &apos;UPRF&apos;.
    ENDIF.
  ENDIF.
  IF &lt;status&gt;-bcfixnochg = space.
    MOVE &apos;BCCH&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
*   MOVE &apos;BCSH&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
  ELSE.
    DELETE excl_cua_funct WHERE function = &apos;BCCH&apos;.
*    DELETE excl_cua_funct WHERE function = &apos;BCSH&apos;.   &quot;HCG HW681286
  ENDIF.
ENDFORM.                    &quot;EXCLUDE_CUA_FUNCTIONS</include_source>
   </include>
   <include NAME="LSVIMF3Y" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000003" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122440" IDATE="20080721" ITIME="122440">
    <include_source>*---------------------------------------------------------------------*
*       FORM SET_STATUS_NOKEYSELCNDS                                  *
*---------------------------------------------------------------------*
* ........                                                            *
*---------------------------------------------------------------------*
FORM SET_STATUS_NOKEYSELCNDS.
  CLEAR &lt;STATUS&gt;-NOKEYSLCDS.
* LOOP AT DPL_SELLIST.
  LOOP AT &lt;VIM_CK_SELLIST&gt; INTO DPL_SELLIST.
    READ TABLE X_NAMTAB INDEX DPL_SELLIST-TABIX.
    IF X_NAMTAB-KEYFLAG EQ SPACE.
      &lt;STATUS&gt;-NOKEYSLCDS = &apos;X&apos;. EXIT.
    ENDIF.
  ENDLOOP.
  &lt;STATUS&gt;-INITIALIZD = &apos;X&apos;.
ENDFORM.                               &quot;set_status_nokeyselcnds</include_source>
   </include>
   <include NAME="LSVIMF3Z" SQLX="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000001" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122440" IDATE="20080721" ITIME="122440">
    <include_source>*---------------------------------------------------------------------*
*       FORM INIT_STATE_VECTOR                                        *
*---------------------------------------------------------------------*
* viewspezif. Statusvektor initialisieren                             *
*---------------------------------------------------------------------*
FORM INIT_STATE_VECTOR.
* IF &lt;STATUS&gt;-ALR_SETUP EQ SPACE.
  NEXTLINE = 1.
  MOVE: NICHT_GELOESCHT   TO &lt;STATUS&gt;-ST_DELETE,
        GESAMTDATEN       TO &lt;STATUS&gt;-ST_DATA,
        GESAMTDATEN       TO TITLE-DATA,
        LIST_BILD         TO &lt;STATUS&gt;-ST_MODE,
        LIST_BILD         TO TITLE-MODE,
        MAINT_MODE        TO &lt;STATUS&gt;-ST_ACTION,
        MAINT_MODE        TO TITLE-ACTION,
        &lt;STATUS&gt;-CORR_NBR TO &lt;STATUS&gt;-L_CORR_NBR,
        CORR_NBR          TO &lt;STATUS&gt;-CORR_NBR,
        TITLE             TO &lt;STATUS&gt;-TITLE,
        1                 TO &lt;STATUS&gt;-CUR_LINE,
        1                 TO &lt;STATUS&gt;-FIRSTLINE,
        0                 TO &lt;STATUS&gt;-MK_XT,
        0                 TO &lt;STATUS&gt;-MK_TO,
        0                 TO &lt;STATUS&gt;-MAXLINES,
        0                 TO &lt;STATUS&gt;-CUR_OFFSET,
        SPACE             TO &lt;STATUS&gt;-FCODE,
        SPACE             TO &lt;STATUS&gt;-CUR_FIELD,
        SPACE             TO &lt;STATUS&gt;-UPD_FLAG,
        SPACE             TO &lt;STATUS&gt;-CRCNTSKNWN,
        SPACE             TO &lt;STATUS&gt;-KEYTBMODFD,
        SPACE             TO &lt;STATUS&gt;-DLCLALRCKD,
        SPACE             TO &lt;STATUS&gt;-TR_ALRCHKD,
*         &apos;X&apos;               TO &lt;STATUS&gt;-ALR_SETUP,
        &apos;x&apos;               TO &lt;STATUS&gt;-INITIALIZD,
        NICHT_MARKIERT    TO BLOCK_SW.
  IF MAINT_MODE = STATUS-ACTION OR MAINT_MODE = ANZEIGEN.  &quot;UF profilesb
    CLEAR &lt;STATUS&gt;-PROF_FOUND.
  ENDIF.                               &quot;UF profilese
  CLEAR &lt;STATUS&gt;-NEWADRCNT.
* ENDIF.
  CLEAR FILL_EXTR_FIRST_PROC.
* Übergangslösung Sortierungsproblem Anfang
* CLEAR &lt;STATUS&gt;-ALR_SORTED.
  TRANSLATE &lt;STATUS&gt;-ALR_SORTED USING &apos;RXX &apos;.
* Übergangslösung Sortierungsproblem Ende
  CLEAR: VIM_OLD_VIEWKEY, VIM_OLD_ST_SELECTED.
  TRANSLATE VIM_NO_MAINKEY_EXISTS USING VIM_NO_MKEY_NOT_PROCSD_PATT.
  LAST_CORR_NUMBER = &lt;STATUS&gt;-L_CORR_NBR.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF40" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000003" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122440" IDATE="20080721" ITIME="122441">
    <include_source>*---------------------------------------------------------------------*
*       FORM SET_NUMBERED_TEXTS                                       *
*---------------------------------------------------------------------*
* numerierte Texte aus Textpool übernehmen                            *
*---------------------------------------------------------------------*
FORM SET_NUMBERED_TEXTS.
  DATA: NAME(20) TYPE C.
  FIELD-SYMBOLS: &lt;M1&gt;.
  READ TEXTPOOL MASTER_FPOOL INTO TEXTPOOL_TAB LANGUAGE SY-LANGU.
  SORT TEXTPOOL_TAB BY ID KEY.
  MOVE NBRD_TEXTS_PREFIX TO NAME.
  LOOP AT TEXTPOOL_TAB WHERE ID EQ &apos;I&apos;.
    WRITE TEXTPOOL_TAB-KEY TO NAME+NBRD_TEXTS_PREFIX_LENGTH.
    ASSIGN (NAME) TO &lt;M1&gt;.
    IF SY-SUBRC = 0.
      &quot; not all text elements are needed ???
      MOVE TEXTPOOL_TAB-ENTRY TO &lt;M1&gt;.
    ENDIF.
  ENDLOOP.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF41" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000003" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122441" IDATE="20080721" ITIME="122441">
    <include_source>*---------------------------------------------------------------------*
*       FORM SET_POSITION_INFO                                        *
*---------------------------------------------------------------------*
* fill position info                                                  *
*---------------------------------------------------------------------*
* SPI_POSITION      ---&gt; current position                             *
* SPI_ENTRIES       ---&gt; total number of entries                      *
* VIM_POSITION_INFO &lt;--- (global) string filled with position info    *
*---------------------------------------------------------------------*
FORM SET_POSITION_INFO USING VALUE(SPI_POSITION) TYPE I
                             VALUE(SPI_ENTRIES) TYPE I.
  DATA: HF1 TYPE I, HF2 TYPE I, HF3 TYPE I,
        P_VIM_POSITION_INFO_LEN TYPE I.

  MOVE VIM_POSITION_INFO_MASK TO VIM_POSITION_INFO.
  HF1 = VIM_POSITION_INFO_LG1 + 1.
  IF SPI_ENTRIES EQ 0.
    HF3 = 0.
  ELSE.
    HF3 = SPI_POSITION.
  ENDIF.
  WRITE HF3 TO
    VIM_POSITION_INFO+HF1(VIM_POSITION_INFO_LG3) NO-SIGN.
  HF1 = VIM_POSITION_INFO_LG1 + VIM_POSITION_INFO_LG2
                                    + VIM_POSITION_INFO_LG3 + 3.
  WRITE SPI_ENTRIES TO
    VIM_POSITION_INFO+HF1(VIM_POSITION_INFO_LG3) NO-SIGN.
  DO.
    CONDENSE VIM_POSITION_INFO.
* XB 585898B
* call methode to caculat the visible length of vim_position_info
    CALL METHOD cl_scp_linebreak_util=&gt;get_visual_stringlength
      EXPORTING
        im_string               = VIM_POSITION_INFO
        IM_LANGU                = SY-LANGU
      IMPORTING
        EX_POS_VIS              = P_VIM_POSITION_INFO_LEN
*      EXCEPTIONS
*        INVALID_TEXT_ENVIROMENT = 1
*        others                  = 2
        .
    IF sy-subrc &lt;&gt; 0.
*     MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*                WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
    ENDIF.

*    HF2 = VIM_POSITION_INFO_LEN - STRLEN( VIM_POSITION_INFO ).
    HF2 = VIM_POSITION_INFO_LEN - P_VIM_POSITION_INFO_LEN.
* XB 585898E
    IF HF2 GT 0.
      SHIFT VIM_POSITION_INFO RIGHT BY HF2 PLACES.
    ENDIF.
    IF HF2 GE 0. EXIT. ENDIF.
    HF1 = STRLEN( SVIM_TEXT_028 ).
    REPLACE SVIM_TEXT_028 LENGTH HF1 WITH &apos;/&apos; INTO VIM_POSITION_INFO.
    IF SY-SUBRC NE 0.
      HF1 = STRLEN( SVIM_TEXT_027 ) + HF2 - 1.
      IF HF1 GT 0.
        WRITE &apos;.&apos; TO VIM_POSITION_INFO+HF1(1).
        ADD 1 TO HF1. HF2 = - HF2.
        WRITE &apos;          &apos; TO VIM_POSITION_INFO+HF1(HF2).
      ELSE.
        EXIT.
      ENDIF.
    ENDIF.
  ENDDO.
ENDFORM.                               &quot;set_position_info</include_source>
   </include>
   <include NAME="LSVIMF42" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000002" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122441" IDATE="20080721" ITIME="122441">
    <include_source>*---------------------------------------------------------------------*
*       FORM VIM_ASSIGN_MAINKEY_AFTER                                 *
*---------------------------------------------------------------------*
* assign symbols to after-date-part of mainkey                        *
*---------------------------------------------------------------------*
FORM vim_assign_mainkey_after USING value(vama_tabix) TYPE i.
  DATA: vama_ix TYPE i, length TYPE i.
  FIELD-SYMBOLS: &lt;x_namtab&gt; TYPE vimnamtab.

  vama_ix = vama_tabix + 1.
  READ TABLE x_namtab ASSIGNING &lt;x_namtab&gt; INDEX vama_ix.
  IF sy-subrc EQ 0 AND                 &quot;entry found and
   &lt;x_namtab&gt;-texttabfld EQ space AND  &quot;key continues
   &lt;x_namtab&gt;-position LT x_header-keylen. &quot;after date field
    vama_ix = x_header-keylen - &lt;x_namtab&gt;-position.
    ASSIGN: &lt;table1_x&gt;+&lt;x_namtab&gt;-position(vama_ix)
                              TO &lt;vim_f1_afterx&gt;,
            &lt;vim_h_coll_mkey&gt;+&lt;x_namtab&gt;-position(vama_ix)
                              TO &lt;vim_collapsed_key_afx&gt;,
            &lt;vim_h_mkey&gt;+&lt;x_namtab&gt;-position(vama_ix)
                              TO &lt;vim_mkey_afterx&gt;,
            &lt;vim_h_old_mkey&gt;+&lt;x_namtab&gt;-position(vama_ix)
                              TO &lt;vim_old_mkey_afterx&gt;. &quot; TYPE &apos;C&apos;.
    IF x_header-generictrp &lt;&gt; &apos;X&apos;.
** charlike key or non-unicode-system (FS is only assigned for
** downward compatibility).
      length = &lt;x_namtab&gt;-position
                DIV cl_abap_char_utilities=&gt;charsize.
      vama_ix = vama_ix DIV cl_abap_char_utilities=&gt;charsize.
      ASSIGN: &lt;table1&gt;+length(vama_ix)
                                TO &lt;vim_f1_after&gt;,
              vim_collapsed_mainkeys-mainkey+length(vama_ix)
                                TO &lt;vim_collapsed_key_af&gt;,
              vim_mainkey+length(vama_ix)
                                TO &lt;vim_mkey_after&gt;,
              vim_old_viewkey+length(vama_ix)
                                TO &lt;vim_old_mkey_after&gt;.
    ELSE.
      ASSIGN: &lt;vim_f1_afterx&gt; TO &lt;vim_f1_after&gt;,
              &lt;vim_collapsed_key_afx&gt; TO &lt;vim_collapsed_key_af&gt;,
              &lt;vim_mkey_afterx&gt; TO &lt;vim_mkey_after&gt;,
              &lt;vim_old_mkey_afterx&gt; TO &lt;vim_old_mkey_after&gt;.
    ENDIF.
    vim_mkey_after_exists = &apos;X&apos;.
    CLEAR vim_no_mainkey_exists.
  ELSE.
    CLEAR vim_mkey_after_exists.
  ENDIF.
ENDFORM.                               &quot;vim_asign_mainkey_after</include_source>
   </include>
   <include NAME="LSVIMF43" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000004" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122441" IDATE="20080721" ITIME="122441">
    <include_source>*---------------------------------------------------------------------*
*       FORM VIM_ASSIGN_MKEY_AFTER_2                                  *
*---------------------------------------------------------------------*
* assign symbols to after-date-part of mainkey part 2                 *
*---------------------------------------------------------------------*
FORM vim_assign_mkey_after_2 USING value(vama2_tabix) TYPE i.
  LOCAL:x_namtab.
  DATA: vama_ix TYPE i, keylen TYPE i, position TYPE i.
  FIELD-SYMBOLS: &lt;x_namtab&gt; TYPE vimnamtab.

  check vim_mkey_after_exists &lt;&gt; space.
  vama_ix = vama2_tabix + 1.
  READ TABLE x_namtab ASSIGNING &lt;x_namtab&gt; INDEX vama_ix.
  vama_ix = x_header-keylen - &lt;x_namtab&gt;-position.
  ASSIGN: &lt;vim_xtotal&gt;+&lt;x_namtab&gt;-position(vama_ix)
                            TO &lt;vim_tot_mkey_afterx&gt;,
          &lt;vim_xextract&gt;+&lt;x_namtab&gt;-position(vama_ix)
                            TO &lt;vim_ext_mkey_afterx&gt;.
  IF x_header-generictrp &lt;&gt; &apos;X&apos;.
* charlike key or non-unicode-system (FS is only assigned for
* downward compatibility).
    keylen = x_header-keylen / cl_abap_char_utilities=&gt;charsize.
    position = &lt;x_namtab&gt;-position / cl_abap_char_utilities=&gt;charsize.
    vama_ix = keylen - position.
    ASSIGN: &lt;vim_ctotal&gt;+position(vama_ix)
                              TO &lt;vim_tot_mkey_after&gt; TYPE &apos;C&apos;,
            &lt;vim_cextract&gt;+position(vama_ix)
                              TO &lt;vim_ext_mkey_after&gt; TYPE &apos;C&apos;.
  ELSE.
    ASSIGN: &lt;vim_xtotal&gt;+&lt;x_namtab&gt;-position(vama_ix)
             TO &lt;vim_tot_mkey_after&gt;,
            &lt;vim_xextract&gt;+&lt;x_namtab&gt;-position(vama_ix)
             TO &lt;vim_ext_mkey_after&gt;.
  ENDIF.
ENDFORM.                               &quot;vim_assign_mkey_after_2</include_source>
   </include>
   <include NAME="LSVIMF44" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000008" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122441" IDATE="20080721" ITIME="122441">
    <include_source>*---------------------------------------------------------------------*
*       FORM VIM_PROCESS_ASSIGNS                                      *
*---------------------------------------------------------------------*
* process assigns                                                     *
*---------------------------------------------------------------------*
FORM vim_process_assigns.
  DATA: length TYPE i, keydate_alr_assigned(1) TYPE c,
        tablength TYPE i, texttablength TYPE i, keylen_bef_date TYPE i,
        xlength type i.

  TRANSLATE vim_prtfky_assigned USING &apos;XY&apos;.
  ASSIGN: &lt;initial&gt; TO &lt;initial_x&gt; CASTING,
          total TO &lt;vim_ctotal&gt; CASTING TYPE c,
          total TO &lt;vim_total_struc&gt; CASTING TYPE (x_header-maintview),
          total to &lt;vim_xtotal&gt; casting,
          extract TO &lt;vim_cextract&gt; CASTING TYPE c,
          extract TO &lt;vim_extract_struc&gt;
           CASTING TYPE (x_header-maintview),
          extract to &lt;vim_xextract&gt; casting,
          corr_keytab-tabkey to &lt;vim_corr_keyx&gt; casting.
  tablength = x_header-after_tabc / cl_abap_char_utilities=&gt;charsize.
  texttablength =
   x_header-aft_txttbc / cl_abap_char_utilities=&gt;charsize.

  IF x_header-bastab NE space AND x_header-texttbexst NE space.
    length = tablength + texttablength.
    xlength = x_header-texttablen + x_header-tablen.
    ASSIGN: &lt;vim_ctotal&gt;+tablength(texttablength) TO &lt;total_text&gt;,
            &lt;vim_xtotal&gt;+x_header-after_tabc(x_header-texttablen)
             to &lt;vim_xtotal_text&gt;,
            &lt;vim_xtotal_text&gt; to &lt;vim_tot_txt_struc&gt;
             casting type (x_header-texttab),
            &lt;vim_cextract&gt;(tablength) TO &lt;extract_enti&gt;,
            &lt;vim_cextract&gt;+tablength(texttablength) TO &lt;extract_text&gt;,
            &lt;vim_xextract&gt;+x_header-after_tabc(x_header-texttablen)
             to &lt;vim_xextract_text&gt;,
            &lt;vim_xextract_text&gt; to &lt;vim_ext_txt_struc&gt;
             casting type (x_header-texttab).
ELSE.
    length = tablength.
    xlength = x_header-tablen.
  ENDIF.
  ASSIGN: &lt;vim_ctotal&gt;+length(1) TO &lt;action&gt;,
          &lt;action&gt;+1(1) TO &lt;mark&gt;,
          &lt;vim_cextract&gt;(length) TO &lt;table2&gt;,
          &lt;vim_xextract&gt;(xlength) to &lt;table2_x&gt;,
          &lt;vim_xextract&gt;(x_header-tablen) to &lt;vim_xextract_enti&gt;,
          &lt;vim_cextract&gt;+length(1) TO &lt;xact&gt;,
          &lt;xact&gt;+1(1)  TO &lt;xmark&gt;,
          &lt;vim_ctotal&gt;(vim_ctabkeylen) TO &lt;vim_total_key&gt;,
          &lt;vim_cextract&gt;(vim_ctabkeylen) TO &lt;vim_extract_key&gt;,
          &lt;vim_xtotal&gt;(x_header-keylen) TO &lt;vim_xtotal_key&gt;,
          &lt;vim_xextract&gt;(x_header-keylen) TO &lt;vim_xextract_key&gt;.

  IF x_header-bastab NE space AND x_header-texttbexst NE space.
    ASSIGN: &lt;mark&gt;+1(1) TO &lt;action_text&gt;,
            &lt;xmark&gt;+1(1) TO &lt;xact_text&gt;.
  ENDIF.
  IF x_header-adrnbrflag NE space.
    assign vim_addresses_to_save-handle to &lt;vim_addr_handle_x&gt; casting.
    LOOP AT x_namtab WHERE domname IN adrnbr_domain.
      ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE
       &lt;vim_total_struc&gt; TO &lt;vim_total_address_number&gt;.
      EXIT.
    ENDLOOP.
  ENDIF.
  IF x_header-delmdtflag NE space.
    LOOP AT x_namtab WHERE domname EQ vim_delim_date_domain
                       AND ( rollname in vim_begda_types or
                             rollname in vim_endda_types ).
      IF x_namtab-rollname in vim_begda_types.
* begin date
        IF x_header-delmdtflag EQ &apos;E&apos;.
* end date is key field
          IF x_namtab-texttabfld EQ space.
            ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE
             &lt;vim_total_struc&gt; TO &lt;vim_begdate&gt;.
*            ASSIGN total+x_namtab-position(x_namtab-flength)
*                                   TO &lt;vim_begdate&gt; TYPE &apos;D&apos;.
          ENDIF.
        ELSE.                          &quot;begin date is key field
          CHECK keydate_alr_assigned EQ space OR
                keydate_alr_assigned EQ &apos;E&apos; AND
                x_namtab-texttabfld NE space OR
                keydate_alr_assigned EQ &apos;T&apos; AND
                x_namtab-texttabfld EQ space.
          IF x_namtab-texttabfld EQ space.
            TRANSLATE keydate_alr_assigned USING &apos; ETX&apos;.
            ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE
             &lt;vim_total_struc&gt; TO &lt;vim_enddate&gt;.
*            ASSIGN total+x_namtab-position(x_namtab-flength)
*                                  TO &lt;vim_enddate&gt; TYPE &apos;D&apos;.
            IF x_namtab-position GT 0.
              ASSIGN: &lt;vim_xtotal&gt;(x_namtab-position)
                       TO &lt;vim_tot_mkey_beforex&gt; casting,
                      &lt;vim_xextract&gt;(x_namtab-position)
                       TO &lt;vim_ext_mkey_beforex&gt; casting.
* for downward compatibility only:
              keylen_bef_date =
               x_namtab-position DIV cl_abap_char_utilities=&gt;charsize.
              ASSIGN: &lt;vim_ctotal&gt;(keylen_bef_date)
                                     TO &lt;vim_tot_mkey_before&gt; TYPE &apos;C&apos;,
                      &lt;vim_cextract&gt;(keylen_bef_date)
                                     TO &lt;vim_ext_mkey_before&gt; TYPE &apos;C&apos;.
            ELSE.
              ASSIGN:
*      begin correction if position &lt;= 0, should be fitted to unicode.
                      vim_dummy_mainkey TO &lt;vim_tot_mkey_beforex&gt;
                                                              casting ,
                      vim_dummy_mainkey TO &lt;vim_tot_mkey_beforex&gt;
                                                              casting ,
*      end correction von XB am 22.03.02 for csn int1332679 2002
                      vim_dummy_mainkey TO &lt;vim_tot_mkey_before&gt;
                                                              TYPE &apos;C&apos;,
                      &lt;vim_tot_mkey_before&gt; TO &lt;vim_ext_mkey_before&gt;
                                                              TYPE &apos;C&apos;.
            ENDIF.
            IF vim_mkey_after_exists NE space.
              PERFORM vim_assign_mkey_after_2 USING sy-tabix.
            ENDIF.
          ELSE.
            TRANSLATE keydate_alr_assigned USING &apos; TEX&apos;.
            ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE
             &lt;vim_tot_txt_struc&gt; TO &lt;vim_text_enddate&gt;.
*            ASSIGN total+x_namtab-position(x_namtab-flength)
*                                  TO &lt;vim_text_enddate&gt; TYPE &apos;D&apos;.
          ENDIF.
        ENDIF.                         &quot;x_header-delmdtflag eq &apos;E&apos;
      ELSE.
* end date
        IF x_header-delmdtflag EQ &apos;E&apos;.
* end date is key field
          CHECK keydate_alr_assigned EQ space OR
                keydate_alr_assigned EQ &apos;E&apos; AND
                x_namtab-texttabfld NE space OR
                keydate_alr_assigned EQ &apos;T&apos; AND
                x_namtab-texttabfld EQ space.
          IF x_namtab-texttabfld EQ space.
            TRANSLATE keydate_alr_assigned USING &apos; ETX&apos;.
            ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE
             &lt;vim_total_struc&gt; TO &lt;vim_enddate&gt;.
*            ASSIGN total+x_namtab-position(x_namtab-flength)
*                                  TO &lt;vim_enddate&gt; TYPE &apos;D&apos;.
            IF x_namtab-position GT 0.
              ASSIGN: &lt;vim_xtotal&gt;(x_namtab-position)
                       TO &lt;vim_tot_mkey_beforex&gt; casting,
                      &lt;vim_xextract&gt;(x_namtab-position)
                       TO &lt;vim_ext_mkey_beforex&gt; casting.
* for downward compatibility only:
              keylen_bef_date =
               x_namtab-position DIV cl_abap_char_utilities=&gt;charsize.
              ASSIGN:
                      &lt;vim_ctotal&gt;(keylen_bef_date)
                                     TO &lt;vim_tot_mkey_before&gt; TYPE &apos;C&apos;,
                      &lt;vim_cextract&gt;(keylen_bef_date)
                                     TO &lt;vim_ext_mkey_before&gt; TYPE &apos;C&apos;.
*              ASSIGN: total(x_namtab-position)
*                                     TO &lt;vim_tot_mkey_before&gt; TYPE &apos;C&apos;,
*                      extract(x_namtab-position)
*                                     TO &lt;vim_ext_mkey_before&gt; TYPE &apos;C&apos;.
            ELSE.
              ASSIGN:
*      begin correction if position &lt;= 0, should be fitted to unicode.
                      vim_dummy_mainkey TO &lt;vim_tot_mkey_beforex&gt;
                                                              casting ,
                      vim_dummy_mainkey TO &lt;vim_ext_mkey_beforex&gt;
                                                              casting ,
*      end correction von XB am 22.03.02 for csn int1332679 2002
                      vim_dummy_mainkey TO &lt;vim_tot_mkey_before&gt;
                                                              TYPE &apos;C&apos;,
                      &lt;vim_tot_mkey_before&gt; TO &lt;vim_ext_mkey_before&gt;
                                                              TYPE &apos;C&apos;.
            ENDIF.
            IF vim_mkey_after_exists NE space.
              PERFORM vim_assign_mkey_after_2 USING sy-tabix.
            ENDIF.
          ELSE.
            TRANSLATE keydate_alr_assigned USING &apos; TEX&apos;.
            ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE
             &lt;vim_tot_txt_struc&gt; TO &lt;vim_text_enddate&gt;.
*            ASSIGN total+x_namtab-position(x_namtab-flength)
*                                  TO &lt;vim_text_enddate&gt; TYPE &apos;D&apos;.
          ENDIF.
        ELSE.                          &quot;begin date is key field
          IF x_namtab-texttabfld EQ space.
            ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE
             &lt;vim_total_struc&gt; TO &lt;vim_begdate&gt;.
*            ASSIGN total+x_namtab-position(x_namtab-flength)
*                                   TO &lt;vim_begdate&gt; TYPE &apos;D&apos;.
          ENDIF.
        ENDIF.                         &quot;x_header-delmdtflag eq &apos;E&apos;
      ENDIF.
    ENDLOOP.
  ENDIF.
ENDFORM.                               &quot;vim_process_assigns</include_source>
   </include>
   <include NAME="LSVIMF45" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000030" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122441" IDATE="20080721" ITIME="122441">
    <include_source>*---------------------------------------------------------------------*
*       FORM INITIALISIEREN                                           *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM initialisieren.
  LOCAL: counter.                                           &quot;#EC *
  TYPES: BEGIN OF i_fnamecnt,
           name LIKE vimsellist-viewfield,                  &quot;#EC *
           cnt TYPE i,
         END OF i_fnamecnt.
  DATA: keydate_alr_assigned(1) TYPE c,
        program LIKE d020s-prog,                            &quot;#EC *
        namlen TYPE i,
        length TYPE i,
        name(25) TYPE c,
        fname(50) TYPE c,
        dynnr LIKE liste,
        i_fnametb TYPE SORTED TABLE OF i_fnamecnt WITH UNIQUE KEY name,
        i_fnameln TYPE i_fnamecnt, initexclfldtabs(1) TYPE c,
        i_objtype LIKE objh-objecttype,
        f_fieldname(50) TYPE c.
  DATA: h_f1(70) TYPE c, h_f2(8)  TYPE c, h_f3(20) TYPE c.
  FIELD-SYMBOLS: &lt;m1&gt;, &lt;mili&gt; TYPE ANY, &lt;x_namtab&gt; TYPE vimnamtab,&quot;#EC *
                 &lt;f_fld_value&gt; TYPE ANY.

  IF nbrd_texts_alr_read EQ space.
    CALL &apos;C_SAPGPARAM&apos; ID &apos;NAME&apos;  FIELD &apos;transport/systemtype&apos;
                       ID &apos;VALUE&apos; FIELD vim_system_type.
    PERFORM set_numbered_texts.
    length = vim_position_info_lg1 + 2 + vim_position_info_lg3.
** XB 585898B - remove the unused characters &apos;;;&apos;.
*    IF sy-langu = &apos;J&apos;.
*      REPLACE &apos;;;&apos; IN svim_text_027 WITH &apos;  &apos;.
*    ENDIF.
** XB 585898E
*   HW804856 remove disturbing &apos;;&apos;or &apos;;;..&apos; from translated texts
    REPLACE ALL OCCURRENCES OF &apos;;&apos; IN svim_text_027 WITH &apos;    &apos;.
    REPLACE ALL OCCURRENCES OF &apos;;&apos; IN svim_text_028 WITH &apos;    &apos;.
    REPLACE ALL OCCURRENCES OF &apos;;&apos; IN svim_text_029 WITH &apos;    &apos;.
    WRITE: svim_text_027 TO
             vim_position_info_mask(vim_position_info_lg1),
           svim_text_028 TO
             vim_position_info_mask+length(vim_position_info_lg2).
    vim_posi_push = &apos;@3Y@&apos;. vim_posi_push+4 = svim_text_029.
    MOVE: &apos;I&apos;   TO mark_functions-sign,
          &apos;I&apos;   TO adrnbr_domain-sign,
          &apos;I&apos;   TO exted_functions-sign,
          &apos;EQ&apos;  TO mark_functions-option,
          &apos;EQ&apos;  TO adrnbr_domain-option,
          &apos;EQ&apos;  TO exted_functions-option,
          space TO mark_functions-high,
          space TO adrnbr_domain-high,
          space TO exted_functions-high.
    MOVE &apos;ADDR&apos; TO mark_functions-low. APPEND mark_functions.&quot;#EC *
    MOVE &apos;ALMK&apos; TO mark_functions-low. APPEND mark_functions.&quot;#EC *
    MOVE &apos;DELE&apos; TO mark_functions-low. APPEND mark_functions.&quot;#EC *
    MOVE &apos;DELM&apos; TO mark_functions-low. APPEND mark_functions.&quot;#EC *
    MOVE &apos;EXPA&apos; TO mark_functions-low. APPEND mark_functions.&quot;#EC *
    MOVE &apos;KOPE&apos; TO mark_functions-low. APPEND mark_functions.&quot;#EC *
    MOVE &apos;MKLO&apos; TO mark_functions-low. APPEND mark_functions.&quot;#EC *
    MOVE &apos;ORGI&apos; TO mark_functions-low. APPEND mark_functions.&quot;#EC *
    MOVE &apos;REPL&apos; TO mark_functions-low. APPEND mark_functions.&quot;#EC *
    MOVE &apos;TEXT&apos; TO mark_functions-low. APPEND mark_functions.&quot;#EC *
    MOVE &apos;TREX&apos; TO mark_functions-low. APPEND mark_functions.&quot;#EC *
    MOVE &apos;TRIN&apos; TO mark_functions-low. APPEND mark_functions.&quot;#EC *
    MOVE &apos;UNDO&apos; TO mark_functions-low. APPEND mark_functions.&quot;#EC *
    MOVE &apos;BCSH&apos; TO mark_functions-low. APPEND mark_functions.&quot;#EC *
    MOVE &apos;UNDO&apos; TO exted_functions-low. APPEND exted_functions.&quot;#EC *
    MOVE &apos;DELE&apos; TO exted_functions-low. APPEND exted_functions.&quot;#EC *
    MOVE &apos;TRIN&apos; TO exted_functions-low. APPEND exted_functions.&quot;#EC *
    MOVE &apos;TREX&apos; TO exted_functions-low. APPEND exted_functions.&quot;#EC *
    PERFORM vim_fill_vim_guid_domain.
    PERFORM vim_fill_date_type.
    DO.
      ASSIGN COMPONENT sy-index OF STRUCTURE vim_adrnbr_domains TO &lt;m1&gt;.
      IF sy-subrc NE 0. EXIT. ENDIF.
      MOVE &lt;m1&gt; TO adrnbr_domain-low. APPEND adrnbr_domain. &quot;#EC *
    ENDDO.
    PERFORM vim_initialize_d0100.      &quot; SW Texttransl
    MOVE &apos;X&apos; TO nbrd_texts_alr_read.
  ENDIF.
  READ TABLE x_header INDEX 1.                              &quot;#EC *
  IF x_header-existency NE &apos;R&apos;.
* SOBJ-Eintrag da?
    IF x_header-bastab EQ space OR
     ( x_header-maintview NE x_header-viewname AND          &quot;UF160998
       x_header-bastab NE space ).
      i_objtype = &apos;V&apos;.
    ELSE.
      i_objtype = &apos;S&apos;.
    ENDIF.
    SELECT SINGLE * FROM objh WHERE objectname EQ x_header-viewname
                                AND objecttype EQ i_objtype.&quot;#EC *
    IF sy-subrc NE 0.                  &quot;no obj.descr. -&gt; run RSVIM30A
      MESSAGE a138(sv) WITH x_header-viewname x_header-area.
    ENDIF.
  ENDIF.
  CLEAR: vim_nbr_of_scrfrm_pointers.
  vim_view_name = vim_addresses_to_save-viewname = x_header-viewname.
  MOVE: x_header-liste TO liste,
        x_header-detail TO detail.
  CASE x_header-type.
    WHEN &apos;1&apos;. MOVE einstufig TO status-type.
    WHEN &apos;2&apos;. MOVE zweistufig TO status-type.
  ENDCASE.
  counter = STRLEN( x_header-ddtext ).
  IF counter EQ 0. counter = 1. x_header-ddtext(1) = &apos;?&apos;. ENDIF.
  vim_title_name = x_header-ddtext.
  ASSIGN: vim_title_name(counter) TO &lt;name&gt;.
  MOVE &lt;name&gt; TO vim_frame_field.
* set up status vector
  IF x_header-bastab NE space.
    MOVE: &apos;STATUS_&apos; TO name,
          x_header-maintview TO name+7.                     &quot;Subviews
    ASSIGN (name) TO &lt;status&gt;.
    MOVE: &apos;*&apos; TO name,
          x_header-maintview TO name+1.
    ASSIGN (x_header-maintview) TO &lt;table1&gt;.
    IF sy-subrc = 4.
      MESSAGE a173(sv) WITH x_header-maintview x_header-area.  &quot;#EC *
    ENDIF.
    ASSIGN (name) TO &lt;initial&gt; CASTING TYPE (x_header-maintview).
* XB H606530B
* check if the time-field exists: Yes, then reset initial value.
    LOOP AT x_namtab WHERE datatype = &apos;TIMS&apos; AND
                       texttabfld EQ space.         &quot;HCG HW681596
      CONCATENATE &apos;&lt;initial&gt;&apos; x_namtab-viewfield INTO f_fieldname
              SEPARATED BY &apos;-&apos;.
      ASSIGN (f_fieldname) TO &lt;f_fld_value&gt;.
      CLEAR &lt;f_fld_value&gt; WITH space.
    ENDLOOP.
* XB H606530B
    IF x_header-texttbexst NE space.
      MOVE x_header-texttab TO name+1.
      ASSIGN: (x_header-texttab)  TO &lt;table1_text&gt;,
              (name)              TO &lt;text_initial&gt;,
              &lt;table1_text&gt;       TO &lt;table1_xtext&gt; CASTING,
              &lt;table1_xtext&gt;(x_header-textkeylen)  TO &lt;textkey_x&gt;,
              &lt;text_initial&gt;      TO &lt;text_initial_x&gt; CASTING,
              &lt;text_initial_x&gt;(x_header-textkeylen)
               TO &lt;initial_textkey_x&gt;.
      IF x_header-generictrp &lt;&gt; &apos;X&apos;
       AND cl_abap_char_utilities=&gt;charsize = 1.
* charlike key and non-unicode-system (FS only assigned for
* downward compatibility).
        ASSIGN: &lt;table1_text&gt;(x_header-textkeylen) TO &lt;textkey&gt;,
           &lt;text_initial&gt;(x_header-textkeylen) TO &lt;initial_textkey&gt;.
      ELSE.
        ASSIGN: &lt;table1_xtext&gt; TO &lt;textkey&gt;,
               &lt;initial_textkey_x&gt; TO &lt;initial_textkey&gt;.
      ENDIF.
    ENDIF.
    IF x_header-viewname = x_header-maintview.              &quot;Subviews
      CLEAR e071k-viewname.
      master_type = transp_object.
    ELSE.      &quot;View auf Tab.                              &quot;Subviews ..
      e071k-viewname = view_name.
      master_type = vim_view_type.
    ENDIF.                             &quot;.. Subviews
  ELSE.                                                     &quot;view
* XB H606530B
* check if the time-field exists: Yes, then reset initial value.
    LOOP AT x_namtab WHERE datatype = &apos;TIMS&apos;.               &quot;#EC *
      CONCATENATE &apos;&lt;initial&gt;&apos; x_namtab-viewfield INTO f_fieldname
              SEPARATED BY &apos;-&apos;.
      ASSIGN (f_fieldname) TO &lt;f_fld_value&gt;.
      CLEAR &lt;f_fld_value&gt; WITH space.
    ENDLOOP.
* XB H606530B
    WRITE: x_header-maintview TO compl_formname+compl_form_offs,
           x_header-maintview TO corr_formname+corr_form_offs.
    MOVE: view_name     TO e071k-viewname,
          vim_view_type TO master_type.
  ENDIF.
* set up screens
  MOVE: &apos;TCTRL_&apos; TO name,
        x_header-maintview TO name+6.
* Übergangslösung Tablecontrol Anfang
  DATA: h LIKE d020s, f LIKE d021s OCCURS 10, e LIKE d022s OCCURS 10,&quot;#EC *
        m LIKE d023s OCCURS 10, e_h LIKE d022s,             &quot;#EC *
        i_dynid(44) TYPE c.            &quot;VALUE &apos;SAPL&apos;.
  i_dynid  = x_header-fpoolname.                            &quot;4.0B
  i_dynid+40(4) = x_header-liste.
  IMPORT DYNPRO h f e m ID i_dynid.
  IF sy-subrc EQ 0.
    LOOP AT e INTO e_h WHERE LINE CS name.
      EXIT.
    ENDLOOP.
    IF sy-subrc EQ 0.
      vim_tabctrl_active = &apos;X&apos;.
    ELSE.
      CLEAR vim_tabctrl_active.
    ENDIF.
    ASSIGN h-mili TO &lt;mili&gt; CASTING TYPE x.
    IF &lt;mili&gt; O vim_template_dynpro.   &quot;SW: gen. Dynpros sind evtl.
      h-mili = h-mili - vim_template_dynpro.   &quot;fälschlicherweise als
      EXPORT DYNPRO h f e m ID i_dynid.&quot;Vorlagedynpros gekennzeichnet
      GENERATE DYNPRO h f e m ID i_dynid
                              MESSAGE h_f1 LINE h_f2 WORD h_f3.
    ENDIF.
  ELSE.
    CLEAR vim_tabctrl_active.
  ENDIF.
  IF x_header-type = &apos;2&apos;.
    i_dynid+40(4) = x_header-detail.
    IMPORT DYNPRO h f e m ID i_dynid.
    ASSIGN h-mili TO &lt;mili&gt; CASTING TYPE x.
    IF sy-subrc = 0
     AND &lt;mili&gt; O vim_template_dynpro. &quot;UF: Auch Einzelbilder sind
      h-mili = h-mili - vim_template_dynpro.   &quot;evtl. fälschlicherweise
      EXPORT DYNPRO h f e m ID i_dynid.&quot;als Vorlagedynpros
      GENERATE DYNPRO h f e m ID i_dynid       &quot;gekennzeichnet
       MESSAGE h_f1 LINE h_f2 WORD h_f3.
    ENDIF.
  ENDIF.
  IF vim_tabctrl_active NE space.
* Übergangslösung Tablecontrol Ende
    ASSIGN (name) TO &lt;vim_tctrl&gt;.
    IF sy-subrc EQ 0.
      vim_tabctrl_active = &apos;X&apos;.
      IF last_view_info &lt;&gt; space.      &quot;Subviews ..
        REFRESH CONTROL name FROM SCREEN x_header-liste.
      ENDIF.                           &quot;.. Subviews
      IF vim_restore_mode EQ space.
        &lt;status&gt;-l_sel_mode = &lt;vim_tctrl&gt;-line_sel_mode.
      ENDIF.
*     IF x_header-maintview &lt;&gt; x_header-viewname. &quot;Subviews or Switch-ID
      LOOP AT x_namtab WHERE readonly = vim_hidden.         &quot;#EC *
        CONCATENATE x_header-maintview &apos;-&apos; x_namtab-viewfield
                                                           INTO fname.
        LOOP AT &lt;vim_tctrl&gt;-cols INTO vim_tc_cols
                                 WHERE screen-name = fname.
          vim_tc_cols-vislength = 0.
          vim_tc_cols-invisible = &apos;1&apos;.
          MODIFY &lt;vim_tctrl&gt;-cols FROM vim_tc_cols.
          EXIT.
        ENDLOOP.
      ENDLOOP.
*     ENDIF.                                   &quot;.. Subviews or Switch-ID
    ELSE.
      CLEAR vim_tabctrl_active.
    ENDIF.
  ENDIF.
* process assigns to structure
  vim_ctabkeylen =
   x_header-after_keyc / cl_abap_char_utilities=&gt;charsize.
  IF x_header-clidep NE space.
    READ TABLE x_namtab ASSIGNING &lt;x_namtab&gt;
     WITH KEY datatype = &apos;CLNT&apos;.
    ASSIGN COMPONENT &lt;x_namtab&gt;-viewfield OF STRUCTURE &lt;table1&gt;
     TO &lt;client&gt;.
    ASSIGN COMPONENT &lt;x_namtab&gt;-viewfield OF STRUCTURE &lt;initial&gt;
     TO &lt;vim_client_initial&gt;.
    &lt;vim_client_initial&gt; = sy-mandt.
  ELSE.
    ASSIGN mandant TO &lt;vim_client_initial&gt;.
  ENDIF.
  master_name = view_name.
  ASSIGN: (x_header-maintview) TO &lt;table1_x&gt; CASTING,
          &lt;table1_x&gt;(x_header-keylen) TO &lt;f1_x&gt;,
          vim_view_wax TO &lt;table1_wa&gt;
           CASTING TYPE (x_header-maintview),
          vim_view_wax TO &lt;table1_wax&gt; CASTING,
          &lt;table1_wax&gt;(x_header-keylen) TO &lt;f1_wax&gt; CASTING.
  IF x_header-generictrp &lt;&gt; &apos;X&apos;
   AND cl_abap_char_utilities=&gt;charsize = 1.
* charlike key or non-unicode-system (&lt;f1&gt; is only assigned for
* downward compatibility).
    ASSIGN &lt;table1&gt;(vim_ctabkeylen) TO &lt;f1&gt;.
  ELSE.
    ASSIGN &lt;f1_x&gt; TO &lt;f1&gt;.
  ENDIF.
  PERFORM vim_set_init_from_sellist USING x_header-maintview
                                          x_namtab[]
                                          dba_sellist[]
                                          vim_hidden
                                    CHANGING &lt;initial&gt;.
  IF last_view_info NE space.          &quot;store old exclfldtabs
    MOVE: last_view_info TO vim_excl_xxx_tab_safe-viewname,
          excl_pos_tab[] TO vim_excl_xxx_tab_safe-excl_pos_tab,
          excl_rpl_tab[] TO vim_excl_xxx_tab_safe-excl_rpl_tab,
          excl_que_tab[] TO vim_excl_xxx_tab_safe-excl_que_tab.
    MODIFY TABLE vim_excl_xxx_tab_safe.                     &quot;#EC *
    IF sy-subrc NE 0.
      INSERT TABLE vim_excl_xxx_tab_safe.                   &quot;#EC *
    ENDIF.
  ENDIF.
  READ TABLE vim_excl_xxx_tab_safe WITH TABLE KEY
                                   viewname = x_header-viewname.&quot;#EC *
  IF sy-subrc EQ 0.
    excl_pos_tab[] = vim_excl_xxx_tab_safe-excl_pos_tab.
    excl_rpl_tab[] = vim_excl_xxx_tab_safe-excl_rpl_tab.
    excl_que_tab[] = vim_excl_xxx_tab_safe-excl_que_tab.
  ELSE.
    REFRESH: excl_rpl_tab, excl_que_tab, excl_pos_tab, exclude_tab.
    CLEAR: excl_rpl_tab, excl_que_tab, excl_pos_tab, exclude_tab.
    initexclfldtabs = &apos;X&apos;.
  ENDIF.
  IF x_header-subsetflag NE space OR x_header-adrnbrflag NE space OR
     x_header-rdonlyflag NE space OR x_header-usrexiflag NE space OR
     x_header-hiddenflag NE space OR x_header-scrfrmflag NE space OR
     x_header-guidflag NE space.
* no positioning or replacing for certain kinds of fields
    LOOP AT x_namtab WHERE readonly NE space
                        OR domname IN adrnbr_domain
                        OR domname EQ vim_scrform_domain
                        OR domname IN vim_guid_domain.      &quot;#EC *
      IF x_namtab-domname IN adrnbr_domain.
*        ASSIGN &lt;table1&gt;+x_namtab-position(x_namtab-flength)
*                    TO &lt;address_number&gt;.
        ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE &lt;table1&gt;
         TO &lt;address_number&gt;.
        MOVE x_namtab-readonly TO adrnbr_roflag.
        vim_addr_basetable = x_namtab-bastabname.
        vim_addr_bastab_field = x_namtab-bastabfld.
        CHECK initexclfldtabs NE space.
        MOVE x_namtab-viewfield TO excl_rpl_tab-fieldname.
        MOVE x_namtab-viewfield TO excl_que_tab-fieldname.
        MOVE x_namtab-viewfield TO excl_pos_tab-fieldname.
        COLLECT excl_rpl_tab.                               &quot;#EC *
        COLLECT excl_que_tab.                               &quot;#EC *
        COLLECT excl_pos_tab.                               &quot;#EC *
        CONTINUE.
      ELSEIF x_namtab-domname EQ vim_scrform_domain.
*        ASSIGN &lt;table1&gt;+x_namtab-position(x_namtab-flength)
*                    TO &lt;vim_scrform_name&gt;.
        ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE &lt;table1&gt;
         TO &lt;vim_scrform_name&gt;.
        ADD 1 TO vim_nbr_of_scrfrm_pointers.
      ELSEIF x_namtab-domname IN vim_guid_domain.
        MOVE x_namtab-viewfield TO excl_rpl_tab-fieldname.
        MOVE x_namtab-viewfield TO excl_que_tab-fieldname.
        MOVE x_namtab-viewfield TO excl_pos_tab-fieldname.
        COLLECT excl_rpl_tab.                               &quot;#EC *
        COLLECT excl_que_tab.                               &quot;#EC *
        COLLECT excl_pos_tab.                               &quot;#EC *
        CONTINUE.
      ENDIF.
      CHECK initexclfldtabs NE space.
      CASE x_namtab-readonly.
        WHEN subset.
          MOVE x_namtab-viewfield TO excl_rpl_tab-fieldname.
          MOVE x_namtab-viewfield TO excl_que_tab-fieldname.
          APPEND excl_rpl_tab.                              &quot;#EC *
          APPEND excl_que_tab.                              &quot;#EC *
        WHEN usrexi.
*         check initexclfldtabs ne space.
          MOVE x_namtab-viewfield TO excl_rpl_tab-fieldname.
          MOVE x_namtab-viewfield TO excl_que_tab-fieldname.
          MOVE x_namtab-viewfield TO excl_pos_tab-fieldname.
          APPEND excl_rpl_tab.                              &quot;#EC *
          APPEND excl_que_tab.                              &quot;#EC *
          APPEND excl_pos_tab.                              &quot;#EC *
        WHEN vim_hidden.
          MOVE x_namtab-viewfield TO excl_rpl_tab-fieldname.
          MOVE x_namtab-viewfield TO excl_que_tab-fieldname.
          MOVE x_namtab-viewfield TO excl_pos_tab-fieldname.
          APPEND excl_rpl_tab.                              &quot;#EC *
          APPEND excl_que_tab.                              &quot;#EC *
          APPEND excl_pos_tab.                              &quot;#EC *
        WHEN rdonly.
          MOVE x_namtab-viewfield TO excl_rpl_tab-fieldname.
          APPEND excl_rpl_tab.                              &quot;#EC *
      ENDCASE.
    ENDLOOP.
  ENDIF.
  IF x_header-scrfrmflag NE space AND vim_nbr_of_scrfrm_pointers EQ 1.
    mark_functions-low = &apos;SCRF&apos;. APPEND mark_functions.     &quot;#EC *
  ELSE.
    DELETE mark_functions WHERE low EQ &apos;SCRF&apos;.
  ENDIF.
  IF x_header-selection NE space AND initexclfldtabs NE space.
    i_fnameln-cnt = 1.
    LOOP AT dba_sellist WHERE ddic CO ddic_marks
                        AND ( negation EQ space AND operator EQ &apos;EQ&apos; OR
                              negation EQ &apos;NOT&apos; AND operator EQ &apos;NE&apos; ).&quot;#EC *
      i_fnameln-name = dba_sellist-viewfield.
      COLLECT i_fnameln INTO i_fnametb.
    ENDLOOP.
    LOOP AT i_fnametb INTO i_fnameln WHERE cnt EQ 1.
      excl_rpl_tab-fieldname = i_fnameln-name.
      COLLECT excl_rpl_tab.                                 &quot;#EC *
      excl_que_tab-fieldname = i_fnameln-name.
      COLLECT excl_que_tab.                                 &quot;#EC *
    ENDLOOP.
  ENDIF.
  IF x_header-delmdtflag NE space.
    vim_tdep_title = svim_text_104.
    CLEAR: vim_old_viewkey, vim_old_st_selected.          &quot;SW wegen Vcl
    REFRESH vim_sval_tab. CLEAR vim_sval_tab.
    MOVE: x_header-viewname TO vim_sval_tab-tabname,
          x_header-maintview TO vim_begdate_name-tabname,
          x_header-maintview TO vim_enddate_name-tabname,
          &apos;X&apos; TO vim_sval_tab-field_obl,
          sy-datum TO vim_sval_tab-value.
    vim_begdate_name-dash = vim_enddate_name-dash = &apos;-&apos;.
    IF x_header-delmdtflag EQ &apos;E&apos;.
      ASSIGN d0001_field_tab-end TO &lt;key_date&gt;.
    ELSE.
      ASSIGN d0001_field_tab-begin TO &lt;key_date&gt;.
    ENDIF.
    ASSIGN: vim_mainkey TO &lt;vim_h_mkey&gt; CASTING,
            vim_old_viewkey TO &lt;vim_h_old_mkey&gt; CASTING,
            vim_collapsed_mainkeys-mainkey TO &lt;vim_h_coll_mkey&gt; CASTING,
            vim_collapsed_mainkeys-log_key TO &lt;vim_h_coll_logkey&gt;
             CASTING,
            vim_collapsed_mainkeys-mkey_bf TO &lt;vim_h_coll_bfkey&gt;
             CASTING,
            vim_merged_entries-merged_key TO &lt;vim_h_merged_key&gt; CASTING.
    LOOP AT x_namtab WHERE domname EQ vim_delim_date_domain
                       AND ( rollname IN vim_begda_types OR
                             rollname IN vim_endda_types ). &quot;#EC *
      IF x_namtab-rollname IN vim_begda_types.
* begin date
        IF x_header-delmdtflag EQ &apos;E&apos;.
* end date is key field
          IF x_namtab-texttabfld EQ space.
*            ASSIGN: &lt;table1&gt;+x_namtab-position(x_namtab-flength)
*                                   TO &lt;vim_new_begdate&gt; TYPE &apos;D&apos;,
*                    &lt;table1&gt;+x_namtab-position(x_namtab-flength)
*                                   TO &lt;vim_begdate_mask&gt; TYPE &apos;C&apos;.
            ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE &lt;table1&gt;
             TO &lt;vim_new_begdate&gt;.
            ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE &lt;table1&gt;
             TO &lt;vim_begdate_mask&gt; CASTING TYPE c.
            MOVE: x_namtab-viewfield TO vim_sval_tab-fieldname,
                  x_namtab-viewfield TO vim_begdate_name-fieldname.
            vim_begdate_is_ro = x_namtab-readonly.
          ENDIF.
        ELSE.
* begin date is key field
          CHECK keydate_alr_assigned EQ space.
          keydate_alr_assigned = &apos;X&apos;.
          IF x_namtab-texttabfld EQ space.
*            ASSIGN: &lt;table1&gt;+x_namtab-position(x_namtab-flength)
*                                   TO &lt;vim_enddate_mask&gt; TYPE &apos;C&apos;.
            ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE &lt;table1&gt;
             TO &lt;vim_enddate_mask&gt; CASTING TYPE c.
            IF x_namtab-position GT 0.
              IF x_header-generictrp &lt;&gt; &apos;X&apos;.
** charlike key or non-unicode-system (FS is only assigned for
** downward compatibility).
                length = x_namtab-position
                          DIV cl_abap_char_utilities=&gt;charsize.
                ASSIGN: &lt;table1&gt;(length)
                         TO &lt;vim_f1_before&gt; CASTING TYPE c,
                        vim_mainkey(length)
                          TO &lt;vim_mkey_before&gt; CASTING TYPE c,
                        vim_old_viewkey(length)
                          TO &lt;vim_old_mkey_before&gt; CASTING TYPE c.
              ENDIF.
              IF NOT ( &lt;vim_f1_before&gt; IS ASSIGNED
                       OR &lt;vim_mkey_before&gt; IS ASSIGNED
                       OR &lt;vim_old_mkey_before&gt; IS ASSIGNED ).
** could not be assigned because unicode flag is set in function
** group and key is non charlike
                ASSIGN: &lt;table1_x&gt;(x_namtab-position)
                         TO &lt;vim_f1_before&gt; CASTING TYPE x,
                        &lt;vim_h_mkey&gt;(x_namtab-position)
                          TO &lt;vim_mkey_before&gt; CASTING TYPE x,
                        &lt;vim_h_old_mkey&gt;(x_namtab-position)
                          TO &lt;vim_old_mkey_before&gt; CASTING TYPE x.
              ENDIF.
              ASSIGN: &lt;table1_x&gt;(x_namtab-position)
                       TO &lt;vim_f1_beforex&gt;,
                      &lt;vim_h_mkey&gt;(x_namtab-position)
                        TO &lt;vim_mkey_beforex&gt;,
                      &lt;vim_h_old_mkey&gt;(x_namtab-position)
                        TO &lt;vim_old_mkey_beforex&gt;,
                      &lt;vim_h_coll_bfkey&gt;(x_namtab-position)
                        TO &lt;vim_collapsed_mkey_bfx&gt;.
              CLEAR vim_no_mainkey_exists.
            ELSE.
              ASSIGN: vim_dummy_mainkey TO &lt;vim_mkey_before&gt; TYPE &apos;C&apos;,&quot;#EC *
                      &lt;vim_mkey_before&gt; TO &lt;vim_old_mkey_before&gt;,
                      &lt;vim_mkey_before&gt; TO &lt;vim_f1_before&gt;,
                      vim_dummy_mainkey TO &lt;vim_mkey_beforex&gt; CASTING,
                      &lt;vim_mkey_beforex&gt; TO &lt;vim_old_mkey_beforex&gt;,
                      &lt;vim_mkey_beforex&gt; TO &lt;vim_f1_beforex&gt;,
                      &lt;vim_mkey_beforex&gt; TO &lt;vim_collapsed_mkey_bfx&gt;.
              vim_no_mainkey_exists = &apos;X&apos;.
            ENDIF.
            MOVE x_namtab-viewfield TO vim_enddate_name-fieldname.
            PERFORM vim_assign_mainkey_after USING sy-tabix.
          ENDIF.
        ENDIF.                         &quot;x_header-delmdtflag eq &apos;E&apos;
      ELSE.
* end date
        IF x_header-delmdtflag EQ &apos;E&apos;.
* end date is key field
          CHECK keydate_alr_assigned EQ space.
          keydate_alr_assigned = &apos;X&apos;.
          IF x_namtab-texttabfld EQ space.
*            ASSIGN: &lt;table1&gt;+x_namtab-position(x_namtab-flength)
*                                   TO &lt;vim_enddate_mask&gt; TYPE &apos;C&apos;.
            ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE &lt;table1&gt;
             TO &lt;vim_enddate_mask&gt; CASTING TYPE c.
            IF x_namtab-position GT 0.
              IF x_header-generictrp &lt;&gt; &apos;X&apos;.
** charlike key or non-unicode-system (FS is only assigned for
** downward compatibility).
                length = x_namtab-position
                          DIV cl_abap_char_utilities=&gt;charsize.
                ASSIGN: &lt;table1&gt;(length)
                         TO &lt;vim_f1_before&gt; CASTING TYPE c,
                        vim_mainkey(length)
                          TO &lt;vim_mkey_before&gt; CASTING TYPE c,
                        vim_old_viewkey(length)
                          TO &lt;vim_old_mkey_before&gt; CASTING TYPE c.
              ENDIF.
              IF NOT ( &lt;vim_f1_before&gt; IS ASSIGNED
                       OR &lt;vim_mkey_before&gt; IS ASSIGNED
                       OR &lt;vim_old_mkey_before&gt; IS ASSIGNED ).
** could not be assigned because unicode flag is set in function
** group and key is non charlike
                ASSIGN: &lt;table1_x&gt;(x_namtab-position)
                         TO &lt;vim_f1_before&gt; CASTING TYPE x,
                        vim_mainkey(x_namtab-position)
                          TO &lt;vim_mkey_before&gt; CASTING TYPE x,
                        vim_old_viewkey(x_namtab-position)
                          TO &lt;vim_old_mkey_before&gt; CASTING TYPE x.
              ENDIF.
              ASSIGN: &lt;table1_x&gt;(x_namtab-position)
                       TO &lt;vim_f1_beforex&gt;,
                      &lt;vim_h_mkey&gt;(x_namtab-position)
                        TO &lt;vim_mkey_beforex&gt;,
                      &lt;vim_h_old_mkey&gt;(x_namtab-position)
                        TO &lt;vim_old_mkey_beforex&gt;,
                      &lt;vim_h_coll_bfkey&gt;(x_namtab-position)
                        TO &lt;vim_collapsed_mkey_bfx&gt;.
*              ASSIGN: &lt;table1&gt;(x_namtab-position)
*                                     TO &lt;vim_f1_before&gt; TYPE &apos;C&apos;,
*                      vim_mainkey(x_namtab-position)
*                                     TO &lt;vim_mkey_before&gt; TYPE &apos;C&apos;,
*                      vim_old_viewkey(x_namtab-position)
*                                     TO &lt;vim_old_mkey_before&gt; TYPE &apos;C&apos;.
              CLEAR vim_no_mainkey_exists.
            ELSE.
              ASSIGN: vim_dummy_mainkey TO &lt;vim_mkey_before&gt; TYPE &apos;C&apos;,&quot;#EC *
                      &lt;vim_mkey_before&gt; TO &lt;vim_old_mkey_before&gt;,
                      &lt;vim_mkey_before&gt; TO &lt;vim_f1_before&gt;,
                      vim_dummy_mainkey TO &lt;vim_mkey_beforex&gt; CASTING,
                      &lt;vim_mkey_beforex&gt; TO &lt;vim_old_mkey_beforex&gt;,
                      &lt;vim_mkey_beforex&gt; TO &lt;vim_f1_beforex&gt;,
                      &lt;vim_mkey_beforex&gt; TO &lt;vim_collapsed_mkey_bfx&gt;.
              vim_no_mainkey_exists = &apos;X&apos;.
            ENDIF.
            MOVE x_namtab-viewfield TO vim_enddate_name-fieldname.
            PERFORM vim_assign_mainkey_after USING sy-tabix.
          ENDIF.
        ELSE.
* begin date is key field
          IF x_namtab-texttabfld EQ space.
*            ASSIGN: &lt;table1&gt;+x_namtab-position(x_namtab-flength)
*                                   TO &lt;vim_new_begdate&gt; TYPE &apos;D&apos;,
*                    &lt;table1&gt;+x_namtab-position(x_namtab-flength)
*                                   TO &lt;vim_begdate_mask&gt; TYPE &apos;C&apos;.
            ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE &lt;table1&gt;
             TO &lt;vim_new_begdate&gt;.
            ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE &lt;table1&gt;
             TO &lt;vim_begdate_mask&gt; CASTING TYPE c.
            MOVE: x_namtab-viewfield TO vim_sval_tab-fieldname,
                  x_namtab-viewfield TO vim_begdate_name-fieldname.
            vim_begdate_is_ro = x_namtab-readonly.
          ENDIF.
        ENDIF.                         &quot;x_header-delmdtflag eq &apos;E&apos;
      ENDIF.
    ENDLOOP.
    APPEND vim_sval_tab.                                    &quot;#EC *
    CONDENSE: vim_begdate_name NO-GAPS, vim_enddate_name NO-GAPS.
    MOVE: x_header-viewname TO vim_memory_id_1-viewname,
          sy-uname          TO vim_memory_id_1-user.
    IMPORT vim_collapsed_mainkeys FROM MEMORY ID vim_memory_id_1.&quot;#EC *
    IF sy-subrc NE 0.
      REFRESH vim_collapsed_mainkeys.
    ENDIF.
    ASSIGN: &lt;vim_h_coll_mkey&gt;(x_header-keylen)
                              TO &lt;vim_collapsed_keyx&gt;,
            &lt;vim_h_coll_logkey&gt;(x_header-keylen)
                              TO &lt;vim_collapsed_logkeyx&gt;,
            &lt;vim_h_merged_key&gt;(x_header-keylen)
                              TO &lt;vim_merged_keyx&gt;.
    IF x_header-generictrp &lt;&gt; &apos;X&apos;.
      ASSIGN: vim_collapsed_mainkeys-mainkey(x_header-keylen)
                                    TO &lt;vim_collapsed_key&gt;,
              vim_collapsed_mainkeys-log_key(x_header-keylen)
                                    TO &lt;vim_collapsed_logkey&gt;,
              vim_merged_entries-merged_key(x_header-keylen)
                                    TO &lt;vim_merged_key&gt;.
    ELSE.
      ASSIGN: &lt;vim_collapsed_keyx&gt; TO &lt;vim_collapsed_key&gt;,
              &lt;vim_collapsed_logkeyx&gt; TO &lt;vim_collapsed_logkey&gt;,
              &lt;vim_merged_keyx&gt; TO &lt;vim_merged_key&gt;.
    ENDIF.
  ENDIF.                               &quot;x_header-delmdtflag ne space
* if necessary. -&gt; how to decide this ? X_HEADER-PTFRKYEXST, later
  ASSIGN vim_mainkey(x_header-keylen) TO &lt;vim_mainkey_mask&gt;.
  CLEAR vim_prtfky_assigned.
* endif.
* consider clusters in transport defaults
  IF vim_called_by_cluster NE space.
    master_type = vim_clus_type.
    master_name = vim_calling_cluster.
  ENDIF.
* set transport defaults.....
  MOVE: transporter   TO e071-pgmid,
        master_type   TO e071-object,
        master_name   TO e071-obj_name,
        e071_objfunc  TO e071-objfunc,
        transporter   TO e071k-pgmid,
        transp_object TO e071k-object,
        space         TO e071k-as4pos,
        master_type   TO e071k-mastertype,
        master_name   TO e071k-mastername,
        space         TO e071k-objfunc,
        space         TO e071k-flag.
  PERFORM vim_get_img_activity
   CHANGING e071k-activity.           &quot;UF738595/2001
  IF x_header-existency EQ space OR x_header-existency EQ &apos;M&apos;.
    MOVE sortflag_with_existency TO e071k-sortflag.
  ELSE.
    MOVE sortflag_without_existency TO e071k-sortflag.
  ENDIF.
  REFRESH vim_corr_objtab. CLEAR vim_corr_obj_viewname.
  IF x_header-texttbexst &lt;&gt; space.     &quot;SW Texttransl
    PERFORM vim_initialize_texttab.
    vim_texttab_is_ro = &apos;X&apos;.
    LOOP AT x_namtab WHERE keyflag EQ space
                       AND bastabname EQ x_header-texttab
                       AND readonly NE rdonly.              &quot;#EC *
      CLEAR vim_texttab_is_ro.
      EXIT.
    ENDLOOP.
  ENDIF.
  CLEAR looplines.
* possible to select profiles?
  vim_coming_from_img = &apos;N&apos;.
  IF vim_called_by_cluster = space.
*    IF x_header-adrnbrflag = space.
*      CALL FUNCTION &apos;SCPR_MEMORY_FLAG&apos;
*        IMPORTING
*          coming_from_img = vim_coming_from_img.
*    ENDIF.
  ELSE.
    CALL FUNCTION &apos;VIEWCLUSTER_PR_IMPORT_CTRL&apos;
      EXPORTING
        viewname        = x_header-viewname
        action          = &apos;P&apos;
      CHANGING
        coming_from_img = vim_coming_from_img
      EXCEPTIONS
        wrong_parameter = 1
        OTHERS          = 2.
  ENDIF.
  last_view_info = view_name.
  PERFORM vim_maint_selflag USING    &apos;I&apos;
                            CHANGING x_header-selection.
ENDFORM.                    &quot;initialisieren

*---------------------------------------------------------------------*
*       FORM VIM_INITIALIZE_TEXTTAB                                   *
*---------------------------------------------------------------------*
* Initialisierung vin &lt;VIM_TEXTTAB&gt; und &lt;VIM_READ_LANGUS&gt;
*---------------------------------------------------------------------*
FORM vim_initialize_texttab.
  DATA: idx LIKE sy-tabix,
        texttab_l TYPE i.

  READ TABLE vim_texttab_container WITH KEY viewname = view_name
                                   BINARY SEARCH.           &quot;#EC *
  vim_texttab_container_index = sy-tabix.
  IF sy-subrc &lt;&gt; 0.
    CLEAR vim_texttab_container-tabdata-valid_idx.
    REFRESH vim_texttab_container-tabdata-tab_us.
    REFRESH vim_texttab_container-tabdata-tab_vs.
    REFRESH vim_texttab_container-tabdata-tab_s.
    REFRESH vim_texttab_container-tabdata-tab_m.
    REFRESH vim_texttab_container-tabdata-tab_l.
    REFRESH vim_texttab_container-tabdata-tab_vl.
    REFRESH vim_texttab_container-tabdata-tab_ul.
    REFRESH vim_texttab_container-sel_langus.
    CLEAR vim_texttab_container.

    vim_texttab_container-viewname = view_name.
*   Texttabellenbreite bestimmen
    texttab_l = ( x_header-after_keyc + x_header-aft_txttbc )
                 / cl_abap_char_utilities=&gt;charsize + 1.
*    texttab_l = x_header-keylen + x_header-texttablen + 1.
    IF texttab_l LE ultra_short_tab.
      vim_texttab_container-tabdata-valid_idx = 2.
    ELSEIF texttab_l LE very_short_tab.
      vim_texttab_container-tabdata-valid_idx = 3.
    ELSEIF texttab_l LE short_tab.
      vim_texttab_container-tabdata-valid_idx = 4.
    ELSEIF texttab_l LE middle_tab.
      vim_texttab_container-tabdata-valid_idx = 5.
    ELSEIF texttab_l LE long_tab.
      vim_texttab_container-tabdata-valid_idx = 6.
    ELSEIF texttab_l LE very_long_tab.
      vim_texttab_container-tabdata-valid_idx = 7.
    ELSEIF texttab_l LE ultra_long_tab.
      vim_texttab_container-tabdata-valid_idx = 8.
    ENDIF.
    INSERT vim_texttab_container INDEX vim_texttab_container_index.&quot;#EC *
  ENDIF.
  idx = vim_texttab_container-tabdata-valid_idx.
  ASSIGN COMPONENT idx OF STRUCTURE
         vim_texttab_container-tabdata TO &lt;vim_texttab&gt;.
  ASSIGN vim_texttab_container-sel_langus TO &lt;vim_read_langus&gt;.
ENDFORM.                               &quot;VIM_INITIALIZE_TEXTTAB
*&amp;---------------------------------------------------------------------*
*&amp;      Form  vim_fill_vim_guid_domain
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM vim_fill_vim_guid_domain.
  MOVE: &apos;I&apos;   TO vim_guid_domain-sign,
        &apos;EQ&apos;  TO vim_guid_domain-option.
  MOVE &apos;SYSUUID&apos; TO vim_guid_domain-low. APPEND vim_guid_domain.&quot;#EC *
  MOVE &apos;SYSUUID_C&apos; TO vim_guid_domain-low. APPEND vim_guid_domain.&quot;#EC *
  MOVE &apos;SYSUUID_22&apos; TO vim_guid_domain-low. APPEND vim_guid_domain.&quot;#EC *
  MOVE &apos;SYSUUID_25&apos; TO vim_guid_domain-low. APPEND vim_guid_domain.&quot;#EC *
ENDFORM.                    &quot; vim_fill_vim_guid_domain
*&amp;---------------------------------------------------------------------*
*&amp;      Form  vim_set_init_from_sellist
*&amp;---------------------------------------------------------------------*
*       If sellist defines values unambiguously, set them into initial
*       WA.
*----------------------------------------------------------------------*
*      --&gt;P_TABNAME   tabname
*      --&gt;P_NAMTAB[]  nametab info
*      --&gt;P_SELLIST   selection
*      &lt;--P_INIT      initial view-wa
*----------------------------------------------------------------------*
FORM vim_set_init_from_sellist USING    p_tabname TYPE tabname
                                        p_namtab LIKE x_namtab[]
                                        p_sellist LIKE dba_sellist[]
                                        p_maintdesc TYPE vfldroflag
                               CHANGING p_init TYPE any.

  DATA: count TYPE i, h_ix TYPE i, rcode TYPE xfeld,
        tabfld TYPE tabfield.
  FIELD-SYMBOLS: &lt;namtab&gt; TYPE vimnamtab, &lt;sel_wa&gt; TYPE vimsellist,
                 &lt;value&gt; TYPE ANY.

  LOOP AT p_namtab ASSIGNING &lt;namtab&gt; WHERE readonly = p_maintdesc.
    CLEAR: rcode, count, h_ix.
    LOOP AT p_sellist ASSIGNING &lt;sel_wa&gt;
     WHERE viewfield EQ &lt;namtab&gt;-viewfield
           AND ( negation EQ space AND operator EQ &apos;EQ&apos; OR
                 negation EQ &apos;NOT&apos; AND operator EQ &apos;NE&apos; )
           AND ( ddic      CO &apos;XB&apos; OR
                 ddic      CO &apos;SB&apos; ).
      ADD 1 TO count.
      CHECK &lt;sel_wa&gt;-and_or EQ space OR &lt;sel_wa&gt;-and_or EQ &apos;AND&apos;.
      rcode = &apos;X&apos;. h_ix = sy-tabix.
    ENDLOOP.
    IF rcode = space OR count &gt; 1.
      CLEAR: rcode, count.
      LOOP AT p_sellist ASSIGNING &lt;sel_wa&gt;
       WHERE viewfield EQ &lt;namtab&gt;-viewfield
        AND ( negation EQ space AND operator EQ &apos;EQ&apos; OR
                   negation EQ &apos;NOT&apos; AND operator EQ &apos;NE&apos; )
             AND ( ddic EQ &apos;A&apos; ).
        ADD 1 TO count.
        CHECK &lt;sel_wa&gt;-and_or EQ space OR &lt;sel_wa&gt;-and_or EQ &apos;AND&apos;.
        rcode = &apos;X&apos;. h_ix = sy-tabix.
      ENDLOOP.
    ENDIF.
    IF rcode &lt;&gt; space AND count = 1.
      ASSIGN COMPONENT &lt;namtab&gt;-viewfield OF STRUCTURE p_init TO &lt;value&gt;.
      CHECK sy-subrc = 0.
      tabfld-tabname = p_tabname.
      tabfld-fieldname = tabfld-lfieldname = &lt;namtab&gt;-viewfield.
      CALL FUNCTION &apos;RS_CONV_EX_2_IN&apos;
        EXPORTING
          input_external  = &lt;sel_wa&gt;-value
          table_field     = tabfld
        IMPORTING
          output_internal = &lt;value&gt;
        EXCEPTIONS
          OTHERS          = 1.
      IF sy-subrc &lt;&gt; 0.
        CLEAR &lt;value&gt;.
      ENDIF.
    ENDIF.
  ENDLOOP.
ENDFORM.                    &quot; vim_set_init_from_sellist
*&amp;---------------------------------------------------------------------*
*&amp;      Form  vim_fill_date_type
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM vim_fill_date_type.

  MOVE: &apos;I&apos;   TO vim_begda_types-sign,
        &apos;EQ&apos;  TO vim_begda_types-option.
  MOVE vim_begdate_dtel1 TO vim_begda_types-low. APPEND vim_begda_types.&quot;#EC *
  MOVE vim_begdate_dtel2 TO vim_begda_types-low. APPEND vim_begda_types.&quot;#EC *
  MOVE vim_begdate_dtel3 TO vim_begda_types-low. APPEND vim_begda_types.&quot;#EC *
  MOVE vim_begdate_dtel4 TO vim_begda_types-low. APPEND vim_begda_types.&quot;#EC *
  MOVE vim_enddate_dtel1 TO vim_begda_types-low.
  APPEND vim_begda_types TO vim_endda_types.
  MOVE vim_enddate_dtel2 TO vim_begda_types-low.
  APPEND vim_begda_types TO vim_endda_types.
  MOVE vim_enddate_dtel3 TO vim_begda_types-low.
  APPEND vim_begda_types TO vim_endda_types.
  MOVE vim_enddate_dtel4 TO vim_begda_types-low.
  APPEND vim_begda_types TO vim_endda_types.
ENDFORM.                    &quot; vim_fill_date_type</include_source>
   </include>
   <include NAME="LSVIMF46" VARCL="X" SUBC="I" APPL="S" CNAM="SAP" CDAT="19990105" UNAM="SAP" UDAT="20080721" VERN="000008" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122441" IDATE="20080721" ITIME="122441">
    <include_source>*----------------------------------------------------------------------*
*   INCLUDE LSVIMF46                                                   *
*----------------------------------------------------------------------*
* &lt;Address_Number&gt; -&gt; &lt;table1&gt; = View-Workarea (= zu übernehmender
*      Eintrag, aber Adreßnummer des akt. Mandant/System;
*      Adreßnummer wurde in VIM_MODIFY_VIEW_ENTRY ausgetauscht)
* &lt;F1&gt;             -&gt; &lt;table1&gt;(keylen)
* VIM_UPGR_ADDRESS_NUMBER -&gt; Adresse des zu übernehmenden Eintrages
* Achtung: in TOTAL steht NICHT(!) mehr der Eintrag aus akt. Mandant/Sys
*          zur Verfügung wegen Zuweisung  &apos;move &lt;table1&gt; to total&apos;
*          in liste_initialisieren im &apos;Replace_mode&apos;.
*----------------------------------------------------------------------*
FORM vim_address_adjust.
  DATA: addr_comp_tab TYPE szadr_compare_addr1_tab,
        addr_comp_line TYPE szadr_compare_addr1_line,
        handle TYPE ad_handle,
        create_address(1) TYPE c,
        retcode LIKE  szad_field-returncode,
        error_info LIKE addr_error OCCURS 0 WITH HEADER LINE,
        einfo      LIKE addr_error,
        i_msgv1 LIKE sy-msgv1,
        space_msgv LIKE sy-msgv1 VALUE space,
        dum TYPE i, pos_char TYPE i.

  FIELD-SYMBOLS: &lt;handle_x&gt; TYPE x, &lt;field_loc&gt; TYPE ANY.

* nur neue Adreßpflege!
  CHECK x_header-adrnbrflag = &apos;N&apos; AND adrnbr_roflag = space.
  ASSIGN handle TO &lt;handle_x&gt; CASTING.
  IF vim_import_mode_active = space.             &quot;interaktive Übernahme
    IF vim_upgr_address_number &lt;&gt; &apos;@ADJUSTED@&apos;.   &quot;cmpwl_addr_adjusted
      EXIT.
    ENDIF.
    IF &lt;address_number&gt; = space.
      &lt;handle_x&gt; = &lt;f1_x&gt;.
*      HANDLE = &lt;F1&gt;.
      create_address = &apos;X&apos;.
    ELSE.
      READ TABLE vim_locked_addresses FROM &lt;address_number&gt;
                                        TRANSPORTING NO FIELDS.
      IF sy-subrc &lt;&gt; 0.                &quot;not yet locked
        CALL FUNCTION &apos;ADDR_ENQUEUE&apos;
             EXPORTING
                  address_number    = &lt;address_number&gt;
*               MODE_ADRC         = &apos;E&apos;
             EXCEPTIONS
                  address_not_exist = 1
                  foreign_lock      = 2
                  system_failure    = 3
                  internal_error    = 4.
        CASE sy-subrc.
          WHEN 0.
            INSERT &lt;address_number&gt; INTO TABLE vim_locked_addresses.
          WHEN 1.
            &lt;handle_x&gt; = &lt;f1_x&gt;.
*            HANDLE = &lt;F1&gt;.
            create_address = &apos;X&apos;.
            CLEAR &lt;address_number&gt;.
          WHEN 2.
            PERFORM vim_process_message
                USING &apos;SV&apos; &apos;E&apos; &apos;E&apos; &apos;049&apos;
                      sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
          WHEN OTHERS.
*            i_msgv1 = &lt;table1&gt;.   &quot;HCG Dump when nonchar field in view
            LOOP AT x_namtab.       &quot;HCG write field by field instead
* XB H644658B
              CHECK x_namtab-keyflag NE space.
* Beim Feld f wurden Offset oder Länge angegeben und der Datentyp des
* zuzuweisenden Felds erlaubt keine Teilzugriffe. (Dies ist bei den
* Datentypen I, F und P der Fall.)
              CHECK x_namtab-inttype NE &apos;I&apos;.
              CHECK x_namtab-inttype NE &apos;P&apos;.
              CHECK x_namtab-inttype NE &apos;F&apos;.
* XB H644658E
              ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE &lt;table1&gt;
                                              TO &lt;field_loc&gt;.
              dum = ( x_namtab-position + x_namtab-flength ) /
                            cl_abap_char_utilities=&gt;charsize.
              pos_char = x_namtab-position /
                                      cl_abap_char_utilities=&gt;charsize.
              IF dum &lt;= 50.         &quot;End of field &lt;= Length of sy-msgv1
                WRITE &lt;field_loc&gt; TO i_msgv1+pos_char.
              ELSE.
                dum = 50 - pos_char.
                IF dum GT 0. &quot;Otherwise i_msgv1 just filled up to 50
                  WRITE &lt;field_loc&gt;(dum) TO i_msgv1+pos_char.
                ENDIF.
                EXIT.                               &quot;HCG i_msgv1 filled
              ENDIF.
            ENDLOOP.
            PERFORM vim_process_message
              USING &apos;SV&apos; &apos;E&apos; &apos;E&apos; &apos;050&apos;
                  i_msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        ENDCASE.
      ENDIF.  &quot; SY-SUBRC &lt;&gt; 0.
    ENDIF.   &quot;&lt;Address_Number&gt; = SPACE

  ELSE.  &quot;automat. Übernahme
    IF vim_upgr_address_number = space.
*      i_msgv1 = &lt;table1&gt;.   &quot;HCG Dump when nonchar field in view
      LOOP AT x_namtab.       &quot;HCG write field by field instead
* XB H647964B
              CHECK x_namtab-keyflag NE space.
* Beim Feld f wurden Offset oder Länge angegeben und der Datentyp des
* zuzuweisenden Felds erlaubt keine Teilzugriffe. (Dies ist bei den
* Datentypen I, F und P der Fall.)
              CHECK x_namtab-inttype NE &apos;I&apos;.
              CHECK x_namtab-inttype NE &apos;P&apos;.
              CHECK x_namtab-inttype NE &apos;F&apos;.
* XB H647964E
        ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE &lt;table1&gt;
                                        TO &lt;field_loc&gt;.
        dum = ( x_namtab-position + x_namtab-flength ) /
                      cl_abap_char_utilities=&gt;charsize.
        pos_char = x_namtab-position /
                                cl_abap_char_utilities=&gt;charsize.
        IF dum &lt;= 50.         &quot;End of field &lt;= Length of sy-msgv1
          WRITE &lt;field_loc&gt; TO i_msgv1+pos_char.
        ELSE.
          dum = 50 - pos_char.
          IF dum GT 0. &quot;Otherwise i_msgv1 just filled up to 50
            WRITE &lt;field_loc&gt;(dum) TO i_msgv1+pos_char.
          ENDIF.
          EXIT.                               &quot;HCG i_msgv1 filled
        ENDIF.
      ENDLOOP.
      PERFORM vim_process_message
                USING &apos;SV&apos; &apos;I&apos; &apos;I&apos;  &apos;165&apos;
                    i_msgv1 space_msgv space_msgv space_msgv.
      EXIT.                                          &quot;keine Löschung
    ENDIF.

    addr_comp_line-addrnumber = &lt;address_number&gt;.
    IF &lt;address_number&gt; = space.
      &lt;handle_x&gt; = &lt;f1_x&gt;.
      addr_comp_line-addrhandle = handle.
*      ADDR_COMP_LINE-ADDRHANDLE = &lt;F1&gt;.
*      HANDLE = &lt;F1&gt;.
      create_address = &apos;X&apos;.
    ENDIF.
    addr_comp_line-remote_addrnumber = vim_upgr_address_number.
    APPEND addr_comp_line TO addr_comp_tab.
    CALL FUNCTION &apos;ADDR_COMPARE&apos;
      EXPORTING
        rfc_destination = vim_default_rfc_dest-rfcdest
      TABLES
        compare_tab     = addr_comp_tab
      EXCEPTIONS
        rfc_error       = 1
        OTHERS          = 2.
    IF sy-subrc &lt;&gt; 0.
      PERFORM vim_process_message
            USING sy-msgid &apos;E&apos; &apos;E&apos;  sy-msgno
                  sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      EXIT.
    ENDIF.
    READ TABLE addr_comp_tab INDEX 1 INTO addr_comp_line.
    IF addr_comp_line-parameter_error = &apos;X&apos; OR
       addr_comp_line-internal_error = &apos;X&apos;.
      einfo = addr_comp_line-error_table.
      PERFORM vim_process_message
        USING einfo-msg_id &apos;E&apos; &apos;E&apos;  einfo-msg_number
            einfo-msg_var1 einfo-msg_var2 einfo-msg_var3 einfo-msg_var4.
*     Adresse kann nicht abgeglichen werden -&gt; Eintrag verwerfen
      EXIT.
    ENDIF.

    IF addr_comp_line-rem_address_not_exist = &apos;X&apos;.    &quot;keine Löschung!
*      i_msgv1 = &lt;table1&gt;.   &quot;HCG Dump when nonchar field in view
      LOOP AT x_namtab.       &quot;HCG write field by field instead
* XB H647964B
              CHECK x_namtab-keyflag NE space.
* Beim Feld f wurden Offset oder Länge angegeben und der Datentyp des
* zuzuweisenden Felds erlaubt keine Teilzugriffe. (Dies ist bei den
* Datentypen I, F und P der Fall.)
              CHECK x_namtab-inttype NE &apos;I&apos;.
              CHECK x_namtab-inttype NE &apos;P&apos;.
              CHECK x_namtab-inttype NE &apos;F&apos;.
* XB H647964E
        ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE &lt;table1&gt;
                                        TO &lt;field_loc&gt;.
        dum = ( x_namtab-position + x_namtab-flength ) /
                      cl_abap_char_utilities=&gt;charsize.
        pos_char = x_namtab-position /
                                cl_abap_char_utilities=&gt;charsize.
        IF dum &lt;= 50.         &quot;End of field &lt;= Length of sy-msgv1
          WRITE &lt;field_loc&gt; TO i_msgv1+pos_char.
        ELSE.
          dum = 50 - pos_char.
          IF dum GT 0. &quot;Otherwise i_msgv1 just filled up to 50
            WRITE &lt;field_loc&gt;(dum) TO i_msgv1+pos_char.
          ENDIF.
          EXIT.                               &quot;HCG i_msgv1 filled
        ENDIF.
      ENDLOOP.
      PERFORM vim_process_message
              USING &apos;SV&apos; &apos;I&apos; &apos;I&apos;  &apos;165&apos;
                    i_msgv1 space_msgv space_msgv space_msgv.
      EXIT.
    ELSEIF addr_comp_line-address_not_exist = &apos;X&apos; AND
           create_address = space.
      &lt;handle_x&gt; = &lt;f1_x&gt;.
*      HANDLE = &lt;F1&gt;.
      create_address = &apos;X&apos;.
      CLEAR: &lt;address_number&gt;, &lt;vim_total_address_number&gt;.
      REFRESH addr_comp_tab. CLEAR addr_comp_line.
      addr_comp_line = handle.
*      ADDR_COMP_LINE-ADDRHANDLE = &lt;F1&gt;.
      addr_comp_line-remote_addrnumber = vim_upgr_address_number.
      APPEND addr_comp_line TO addr_comp_tab.
      CALL FUNCTION &apos;ADDR_COMPARE&apos;
        EXPORTING
          rfc_destination = vim_default_rfc_dest-rfcdest
        TABLES
          compare_tab     = addr_comp_tab
        EXCEPTIONS
          rfc_error       = 1
          OTHERS          = 2.
      IF sy-subrc &lt;&gt; 0.
        PERFORM vim_process_message
              USING sy-msgid &apos;E&apos; &apos;E&apos;  sy-msgno
                    sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        EXIT.
      ENDIF.
      READ TABLE addr_comp_tab INDEX 1 INTO addr_comp_line.
      IF addr_comp_line-parameter_error = &apos;X&apos; OR
         addr_comp_line-internal_error = &apos;X&apos;.
        einfo = addr_comp_line-error_table.
        PERFORM vim_process_message
          USING einfo-msg_id &apos;E&apos; &apos;E&apos;  einfo-msg_number
            einfo-msg_var1 einfo-msg_var2 einfo-msg_var3 einfo-msg_var4.
*       Adresse kann nicht abgeglichen werden -&gt; Eintrag verwerfen
        EXIT.
      ENDIF.
*     Überprüfung von REM_ADDRESS_NOT_EXIST, .. hier nicht nötig

    ELSEIF addr_comp_line-address_is_equal = &apos;X&apos;.
      EXIT.
    ELSEIF create_address = space.
      READ TABLE vim_locked_addresses FROM &lt;address_number&gt;
                                        TRANSPORTING NO FIELDS.
      IF sy-subrc &lt;&gt; 0.                &quot;not yet locked
        CALL FUNCTION &apos;ADDR_ENQUEUE&apos;
             EXPORTING
                  address_number    = &lt;address_number&gt;
*               MODE_ADRC         = &apos;E&apos;
             EXCEPTIONS
                  address_not_exist = 1
                  foreign_lock      = 2
                  system_failure    = 3
                  internal_error    = 4.
        CASE sy-subrc.
          WHEN 0.
            INSERT &lt;address_number&gt; INTO TABLE vim_locked_addresses.
          WHEN 1.  &quot; würde schon in ADDR_COMPARE auftreten
            PERFORM vim_process_message    &quot;eigentlich überflüssig
                USING &apos;SV&apos; &apos;E&apos; &apos;E&apos; &apos;049&apos;
                      sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
          WHEN 2.
            PERFORM vim_process_message
                USING &apos;SV&apos; &apos;E&apos; &apos;E&apos; &apos;049&apos;
                      sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
          WHEN OTHERS.
*            i_msgv1 = &lt;table1&gt;.   &quot;HCG Dump when nonchar field in view
            LOOP AT x_namtab.       &quot;HCG write field by field instead
* XB H647964B
              CHECK x_namtab-keyflag NE space.
* Beim Feld f wurden Offset oder Länge angegeben und der Datentyp des
* zuzuweisenden Felds erlaubt keine Teilzugriffe. (Dies ist bei den
* Datentypen I, F und P der Fall.)
              CHECK x_namtab-inttype NE &apos;I&apos;.
              CHECK x_namtab-inttype NE &apos;P&apos;.
              CHECK x_namtab-inttype NE &apos;F&apos;.
* XB H647964E
              ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE &lt;table1&gt;
                                              TO &lt;field_loc&gt;.
              dum = ( x_namtab-position + x_namtab-flength ) /
                            cl_abap_char_utilities=&gt;charsize.
              pos_char = x_namtab-position /
                                      cl_abap_char_utilities=&gt;charsize.
              IF dum &lt;= 50.         &quot;End of field &lt;= Length of sy-msgv1
                WRITE &lt;field_loc&gt; TO i_msgv1+pos_char.
              ELSE.
                dum = 50 - pos_char.
                IF dum GT 0. &quot;Otherwise i_msgv1 just filled up to 50
                  WRITE &lt;field_loc&gt;(dum) TO i_msgv1+pos_char.
                ENDIF.
                EXIT.                               &quot;HCG i_msgv1 filled
              ENDIF.
            ENDLOOP.
            PERFORM vim_process_message
              USING &apos;SV&apos; &apos;E&apos; &apos;E&apos; &apos;050&apos;
                  i_msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        ENDCASE.
      ENDIF.   &quot;SY-SUBRC
    ENDIF.
  ENDIF.     &quot; vim_import_mode_active

  CALL FUNCTION &apos;ADDR_ADJUST&apos;
    EXPORTING
      addrnumber           = &lt;address_number&gt;
      addrhandle           = handle
      address_group        = &apos;CA01&apos;
    IMPORTING
      returncode           = retcode
    TABLES
      error_table          = error_info
    EXCEPTIONS
      parameter_error      = 1
      address_not_exist    = 2
      handle_exist         = 3
      internal_error       = 4
      address_not_compared = 5
      OTHERS               = 6.
  IF sy-subrc &lt;&gt; 0.
    PERFORM vim_process_message
           USING sy-msgid &apos;E&apos; &apos;E&apos; sy-msgno
                 sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ELSE.
    IF retcode = &apos;E&apos;.
      READ TABLE error_info INDEX 1.
      PERFORM vim_process_message
             USING error_info-msg_id &apos;E&apos; &apos;E&apos; error_info-msg_number
                   error_info-msg_var1 error_info-msg_var2
                   error_info-msg_var3 error_info-msg_var4.
    ELSE.    &quot;ok
      IF create_address = &apos;X&apos;.
        &lt;address_number&gt; = &apos;@NEW&apos;.
        &lt;address_number&gt;+4(6) = &lt;status&gt;-newadrcnt.
        ADD 1 TO &lt;status&gt;-newadrcnt.
        &lt;status&gt;-upd_flag = &apos;X&apos;.
      ENDIF.
      &lt;vim_total_address_number&gt; = &lt;address_number&gt;.
      READ TABLE vim_addresses_to_save
                              WITH KEY viewname = x_header-viewname
                                       addrnumber = &lt;address_number&gt;
                              BINARY SEARCH TRANSPORTING NO FIELDS.
      IF sy-subrc NE 0.
        vim_addresses_to_save-viewname = x_header-viewname.
        vim_addresses_to_save-addrnumber = &lt;address_number&gt;.
        &lt;vim_addr_handle_x&gt; = &lt;f1_x&gt;.
*        VIM_ADDRESSES_TO_SAVE-HANDLE = &lt;F1&gt;.
        INSERT vim_addresses_to_save INDEX sy-tabix.
      ENDIF.
      IF vim_client_state EQ vim_log AND
        x_header-flag NE vim_transport_denied and
        vim_actopts-transp_off NE bc_transport_denied.
        &lt;status&gt;-upd_flag = &apos;X&apos;. &quot;nec. for transport of master entry
      ENDIF.
    ENDIF.                                                  &quot;RETCODE
  ENDIF.            &quot;SY-SUBRC
ENDFORM.                    &quot;vim_address_adjust</include_source>
   </include>
   <include NAME="LSVIMF50" VARCL="X" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981203" UNAM="SAP" UDAT="20080721" VERN="000003" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122441" IDATE="20080721" ITIME="122441">
    <include_source>*----------------------------------------------------------------------*
*   INCLUDE LSVIMF50                                                   *
*----------------------------------------------------------------------*

FORM VIM_VCLDOCKING_CONTROL.
DATA: DISABLE_NAVI(1) TYPE C.

  IF VIM_EXTERNAL_MODE = &apos;X&apos; OR VIM_SPECIAL_MODE = VIM_DIRECT_UPGRADE
     OR STATUS-ACTION = &apos;C&apos;.
    DISABLE_NAVI = &apos;X&apos;.
  ENDIF.
  CALL FUNCTION &apos;VIEWCLUSTER_NAVI_CONTROL&apos;
       EXPORTING
            OWNER_REPID        = X_HEADER-FPOOLNAME
            OWNER_DYNNR        = SY-DYNNR
            DISABLE_NAVIGATION = DISABLE_NAVI
       EXCEPTIONS
            OTHERS             = 1.
  IF SY-SUBRC = 0.
    MOVE &apos;ATAB&apos; TO EXCL_CUA_FUNCT-FUNCTION. COLLECT EXCL_CUA_FUNCT.
  ENDIF.
ENDFORM.                                  &quot; VIM_VCLDOCKING_CONTROL</include_source>
   </include>
   <include NAME="LSVIMF51" VARCL="X" SUBC="I" APPL="S" CNAM="SAP" CDAT="19990217" UNAM="SAP" UDAT="20080721" VERN="000003" RSTAT="T" RMAND="000" RLOAD="D" SDATE="20080721" STIME="122441" IDATE="20080721" ITIME="122441">
    <include_source>*----------------------------------------------------------------------*
*   INCLUDE LSVIMF51                                                   *
*----------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp;      Form  VIM_ADD_IMG_NOTICES_PBO
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_DYNPRO  Dynpro number
*----------------------------------------------------------------------*
FORM vim_add_img_notices_pbo USING    value(p_dynpro) TYPE list_scr.

  DATA: progname LIKE sy-repid, exit, dynpro TYPE sydynnr.

  CHECK vim_special_mode &lt;&gt; vim_upgrade AND vim_import_profile = space.
  progname = sy-repid.
  dynpro = p_dynpro.
  CALL FUNCTION &apos;SPROJECT_CONTROL_PBO&apos;
       EXPORTING
            repid = progname
            dynnr = dynpro.
ENDFORM.                               &quot; VIM_ADD_IMG_NOTICES_PBO

*&amp;---------------------------------------------------------------------*
*&amp;      Form  VIM_ADD_IMG_NOTICES_PAI
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_MODE   text
*      &lt;--P_EXIT_OK  text
*----------------------------------------------------------------------*
FORM vim_add_img_notices_pai USING    p_mode TYPE char1
                             CHANGING exit_ok TYPE char1.

  DATA: leave TYPE char1, save TYPE char1.

  CHECK vim_special_mode &lt;&gt; vim_upgrade AND vim_import_profile = space.
  CASE p_mode.
    WHEN &apos;S&apos;.                          &quot;Save notices
      save = &apos;X&apos;.
    WHEN &apos;E&apos;.                          &quot;Exit and eventually save changes
      leave = &apos;X&apos;.
  ENDCASE.
  CALL FUNCTION &apos;SPROJECT_CONTROL_PAI&apos;
       EXPORTING
            i_exit    = leave
            save_note = save
       IMPORTING
            e_exit    = exit_ok.
ENDFORM.                               &quot; VIM_ADD_IMG_NOTICES_PAI</include_source>
   </include>
   <include NAME="LSVIMF5A" SQLX="X" VARCL="X" SUBC="I" APPL="S" CNAM="SAP" CDAT="19990422" UNAM="SAP" UDAT="20080721" VERN="000030" LEVL="50A" RSTAT="T" RMAND="000" RLOAD="D" SDATE="20080721" STIME="122441" IDATE="20080721" ITIME="122441">
    <include_source>*----------------------------------------------------------------------*
***INCLUDE LSVIMF5A .
*----------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp;      Form  VIM_BC_LOGS_PUT
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      &lt;--P_BC_ENTRY_LIST  text
*----------------------------------------------------------------------*
FORM vim_bc_logs_put CHANGING p_bc_entry_list LIKE
                              vim_bc_entry_list.

  DATA: corr_keytab_save LIKE TABLE OF e071k, first,
        dummy LIKE sy-subrc, transport_active LIKE t000-cccoractiv,
        w_tabkey_value TYPE scpractr,
        tabkey_values_n TYPE vim_bc_tab_logs,
        tabkey_values_u TYPE vim_bc_tab_logs,
        tabkey_values_d TYPE vim_bc_tab_logs,
        w_bc_entry TYPE scpr_viewdata, bc_entries TYPE scpr_viewdatas,
        w_bc_entry_list TYPE vimty_bc_entry_list_type,
        bc_keytab TYPE bc_keytab_type,
        bc_keytab_wa LIKE LINE OF bc_keytab,
        p_msgid, p_msgty, p_msgno, bc_key_needed(1) TYPE c,
        foreign_langu TYPE sy-langu,
        rc LIKE sy-subrc, keys_identical TYPE xfeld,
        subrc TYPE sy-subrc, tabix TYPE sy-tabix,
        same_view(1), proceed(1) TYPE c.

  STATICS: viewname_old TYPE vimdesc-viewname,
           keylen_real TYPE i.

  CONSTANTS: bc_id_length TYPE i VALUE 32,
             bc_recno_length TYPE i VALUE 10.

  FIELD-SYMBOLS: &lt;bc_entry_keyx&gt; TYPE x,
                 &lt;key&gt; TYPE x,                              &quot;#EC *
                 &lt;vim_bc_keyx&gt; TYPE x, &lt;w_bc_entry_x&gt; TYPE x,
                 &lt;xlangu&gt; TYPE x, &lt;namtab&gt; TYPE vimnamtab.

*-----------&quot;HCG HW686163 Option: Write no Activation links -----------*
  CHECK vim_actopts-actlinks NE &apos;N&apos;.

  ASSIGN: w_bc_entry_list-keys(x_header-keylen) TO &lt;bc_entry_keyx&gt;.
  ASSIGN: bc_keytab_wa-bc_tabkey TO &lt;vim_bc_keyx&gt; CASTING.
  ASSIGN: w_bc_entry-data TO &lt;w_bc_entry_x&gt; CASTING.

  same_view = &apos;X&apos;.                                          &quot;IG 1034145
  proceed = &apos;X&apos;.                                            &quot;IG 1034145
  IF x_header-viewname NE viewname_old. &quot;HCG: has table align gap?
    same_view = space.
    viewname_old = x_header-viewname.
    CLEAR keylen_real.
    LOOP AT x_namtab ASSIGNING &lt;namtab&gt; WHERE keyflag = &apos;X&apos; AND
                                                texttabfld IS INITIAL.
      keylen_real = keylen_real + &lt;namtab&gt;-flength.
    ENDLOOP.
  ENDIF.
  IF x_header-subsetflag EQ &apos;X&apos;.                            &quot;IG 1034145
    IF same_view EQ &apos;X&apos;.
      LOOP AT p_bc_entry_list INTO w_bc_entry_list WHERE
         viewname = x_header-viewname AND action &lt;&gt; original.
        EXIT.
      ENDLOOP.
      IF vim_first_recnum NE w_bc_entry_list-recnumber.
        vim_first_recnum = w_bc_entry_list-recnumber.
      ELSE.
        proceed = space.
      ENDIF.
    ELSE.
      LOOP AT p_bc_entry_list INTO w_bc_entry_list WHERE
         viewname = x_header-viewname AND action &lt;&gt; original.
        vim_first_recnum = w_bc_entry_list-recnumber.
        EXIT.
      ENDLOOP.
    ENDIF.
  ENDIF.                                                    &quot;IG 1034145
  IF proceed = &apos;X&apos;.                                         &quot;IG 1034145
    LOOP AT p_bc_entry_list INTO w_bc_entry_list WHERE
     viewname = x_header-viewname AND action &lt;&gt; original.
*    IF w_bc_entry_list-action = neuer_geloescht.   Obsolete, was only
*      DELETE p_bc_entry_list. CONTINUE.            possible at bc-set
*    ENDIF.                              activation in dialog via SM30
      IF first = space.
        first = &apos;X&apos;.
        INSERT lines of corr_keytab INTO TABLE corr_keytab_save.
        REFRESH corr_keytab.
        CLEAR &lt;table1&gt;.
        transport_active = vim_client_state.
      ENDIF.
* fill corr_keytab
      IF x_header-keylen = keylen_real.
        READ TABLE total WITH KEY &lt;bc_entry_keyx&gt; BINARY SEARCH.
      ELSE.
        PERFORM vim_read_table_with_gap
                      TABLES   total
                      USING    &lt;bc_entry_keyx&gt;
                               x_namtab[]
                      CHANGING subrc
                               tabix.
        IF subrc = 0.
          READ TABLE total INDEX tabix.
        ENDIF.
      ENDIF.
      IF x_header-bastab EQ space.                            &quot;view
        MOVE &lt;bc_entry_keyx&gt; TO &lt;f1_x&gt;.
        PERFORM (corr_formname) IN PROGRAM (sy-repid) USING
                                              vim_writing_bc_imp_log
                                              dummy.
        REFRESH bc_keytab.
        CLEAR bc_key_needed.
      IF x_header-keylen &gt; vim_max_trsp_keylength. &quot;HCG tabkey up to 255
          bc_key_needed = &apos;X&apos;.
        ENDIF.
      IF bc_key_needed NE &apos;X&apos;.           &quot;Look for non-char field in key
          LOOP AT x_namtab WHERE keyflag = &apos;X&apos;.
            IF &apos;CNDT&apos; NS x_namtab-inttype. &quot;non charlike field
              bc_key_needed = &apos;X&apos;.
              EXIT.
            ENDIF.
          ENDLOOP.
        ENDIF.
      IF bc_key_needed NE &apos;X&apos;.             &quot;Look if viewkey &gt; primtabkey
          CLEAR keys_identical.
          PERFORM vim_comp_roottabkey USING x_header
                                            x_namtab[]
                                   CHANGING keys_identical
                                            rc.
          IF keys_identical EQ space. bc_key_needed = &apos;X&apos;. ENDIF.
        ENDIF.
      IF bc_key_needed NE space.                 &quot;Tabkeys via new coding
          LOOP AT corr_keytab.
            MOVE-CORRESPONDING corr_keytab TO bc_keytab_wa.
            APPEND bc_keytab_wa TO bc_keytab.
          ENDLOOP.
          PERFORM vim_build_bc_tabkeys USING w_bc_entry_list
                                    CHANGING bc_keytab.
      ELSE.  &quot;Tabkeys as up to now via generated coding (corr_maint_...)
          LOOP AT corr_keytab.
            MOVE-CORRESPONDING corr_keytab TO bc_keytab_wa.
            MOVE corr_keytab-tabkey TO bc_keytab_wa-bc_tabkey.
            APPEND bc_keytab_wa TO bc_keytab.
          ENDLOOP.
*     Look for other languages in bc-set and append to corr_keytab too
          IF x_header-texttbexst NE space.
            READ TABLE bc_keytab INTO bc_keytab_wa
                                 WITH KEY objname = x_header-texttab.
            LOOP AT w_bc_entry_list-forlangu INTO foreign_langu.
              ASSIGN foreign_langu TO &lt;xlangu&gt; CASTING.
              MOVE &lt;xlangu&gt; TO
    &lt;vim_bc_keyx&gt;+x_header-sprasfdpos(cl_abap_char_utilities=&gt;charsize).
              APPEND bc_keytab_wa TO bc_keytab.
            ENDLOOP.
          ENDIF.
        ENDIF.
     ELSE.                                                   &quot;base table
        MOVE &lt;vim_xtotal&gt; TO &lt;table1_x&gt;.
        MOVE-CORRESPONDING e071k TO bc_keytab_wa.
        MOVE e071k-tabkey TO bc_keytab_wa-bc_tabkey.
        bc_keytab_wa-objname = x_header-maintview.
        MOVE &lt;bc_entry_keyx&gt; TO &lt;vim_bc_keyx&gt;(x_header-keylen).
        APPEND bc_keytab_wa TO bc_keytab.
        IF x_header-bastab &lt;&gt; space AND
           x_header-texttbexst NE space AND         &quot;base table with
           &lt;vim_xtotal_text&gt; NE &lt;text_initial_x&gt;.   &quot;text table
          MOVE-CORRESPONDING e071k TO bc_keytab_wa.
          MOVE e071k-tabkey TO bc_keytab_wa-bc_tabkey.
          bc_keytab_wa-objname = x_header-texttab.
          MOVE &lt;vim_xtotal_text&gt; TO &lt;vim_bc_keyx&gt;(x_header-textkeylen).
          APPEND bc_keytab_wa TO bc_keytab.
*       other languages
         READ TABLE x_namtab WITH KEY keyflag = &apos;X&apos;         &quot;langu field
                                primtabkey = &apos;0000&apos;.
          LOOP AT w_bc_entry_list-forlangu INTO foreign_langu.
            ASSIGN foreign_langu TO &lt;xlangu&gt; CASTING.
            MOVE &lt;xlangu&gt; TO
                 &lt;vim_bc_keyx&gt;+x_namtab-texttabpos(x_namtab-flength).
            APPEND bc_keytab_wa TO bc_keytab.
          ENDLOOP.
        ENDIF.
      ENDIF.                             &quot;base table or view
      CASE w_bc_entry_list-action.
        WHEN neuer_eintrag.
* bc-set imported
          PERFORM bc_entry_log_fill USING     x_header
                                              x_namtab[]
                                              bc_keytab[]
                                              w_bc_entry_list
                                        CHANGING tabkey_values_n.
          CLEAR w_bc_entry_list-action.
        WHEN aendern.
* bc-set entry modified
          PERFORM bc_entry_log_fill USING     x_header
                                              x_namtab[]
                                              bc_keytab[]
                                              w_bc_entry_list
                                        CHANGING tabkey_values_u.
          CLEAR w_bc_entry_list-action.
          MOVE: w_bc_entry_list-id TO w_bc_entry-bcset_id,
                w_bc_entry_list-recnumber TO w_bc_entry-recnumber,
                x_header-viewname TO w_bc_entry-viewname,
                &lt;vim_xtotal&gt; TO &lt;w_bc_entry_x&gt;.
          APPEND w_bc_entry TO bc_entries.
        WHEN geloescht.
* bc-set entry deleted.
          PERFORM bc_entry_log_fill USING     x_header
                                              x_namtab[]
                                              bc_keytab[]
                                              w_bc_entry_list
                                        CHANGING tabkey_values_d.
          DELETE p_bc_entry_list.
      ENDCASE.
      REFRESH corr_keytab.   &quot;weg???
      REFRESH bc_keytab.
    ENDLOOP.
    IF NOT tabkey_values_n IS INITIAL.
      DELETE ADJACENT DUPLICATES FROM tabkey_values_n COMPARING ALL
       FIELDS.
      LOOP AT tabkey_values_n INTO w_tabkey_value.
        CALL FUNCTION &apos;SCPR_EXT_SCPRACTR_FILL&apos;
          EXPORTING
            tablename         = w_tabkey_value-tablename
            profid            = w_tabkey_value-profid
            recnumber         = w_tabkey_value-recnumber
            viewname          = x_header-maintview
            viewvar           = x_header-viewname
            del_record        = &apos; &apos;
            new_record        = &apos;X&apos;
            key               = w_tabkey_value-tabkey
          EXCEPTIONS
            wrong_parameters  = 1
            internal_error    = 2
            key_not_supportet = 3
            fielddescr_error  = 4
            OTHERS            = 5.
        IF sy-subrc &lt;&gt; 0.
          p_msgid = &apos;SCPR&apos;.
          CASE sy-subrc.
            WHEN 1.
              p_msgty = &apos;E&apos;.
              p_msgno = &apos;273&apos;.
            WHEN 3.
              p_msgty = &apos;W&apos;.
              p_msgno = &apos;408&apos;.
            WHEN 4.
              p_msgty = &apos;E&apos;.
              p_msgno = &apos;395&apos;.
            WHEN OTHERS.
              p_msgty = &apos;E&apos;.
              p_msgno = &apos;320&apos;.
          ENDCASE.
          PERFORM vim_process_message USING sy-msgid sy-msgty sy-msgty
                                    sy-msgno space space space space.
        ENDIF.
      ENDLOOP.
    ENDIF.
    IF NOT tabkey_values_u IS INITIAL.
      DELETE ADJACENT DUPLICATES FROM tabkey_values_u COMPARING ALL
       FIELDS.
      LOOP AT tabkey_values_u INTO w_tabkey_value.
        CALL FUNCTION &apos;SCPR_EXT_SCPRACTR_FILL&apos;
          EXPORTING
            tablename         = w_tabkey_value-tablename
            profid            = w_tabkey_value-profid
            recnumber         = w_tabkey_value-recnumber
            viewname          = x_header-maintview
            viewvar           = x_header-viewname
            del_record        = &apos; &apos;
            new_record        = &apos; &apos;
            key               = w_tabkey_value-tabkey
          EXCEPTIONS
            wrong_parameters  = 1
            internal_error    = 2
            key_not_supportet = 3
            fielddescr_error  = 4
            OTHERS            = 5.
        IF sy-subrc &lt;&gt; 0.
          p_msgid = &apos;SCPR&apos;.
          CASE sy-subrc.
            WHEN 1.
              p_msgty = &apos;E&apos;.
              p_msgno = &apos;273&apos;.
            WHEN 3.
              p_msgty = &apos;W&apos;.
              p_msgno = &apos;408&apos;.
            WHEN 4.
              p_msgty = &apos;E&apos;.
              p_msgno = &apos;395&apos;.
            WHEN OTHERS.
              p_msgty = &apos;E&apos;.
              p_msgno = &apos;320&apos;.
          ENDCASE.
          PERFORM vim_process_message USING sy-msgid sy-msgty sy-msgty
                                    sy-msgno space space space space.
        ENDIF.
      ENDLOOP.
    ENDIF.
    IF NOT tabkey_values_d IS INITIAL.
      DELETE ADJACENT DUPLICATES FROM tabkey_values_d COMPARING ALL
       FIELDS.
      LOOP AT tabkey_values_d INTO w_tabkey_value.
        CALL FUNCTION &apos;SCPR_EXT_SCPRACTR_FILL&apos;
          EXPORTING
            tablename         = w_tabkey_value-tablename
            profid            = w_tabkey_value-profid
            recnumber         = w_tabkey_value-recnumber
            viewname          = x_header-maintview
            viewvar           = x_header-viewname
            del_record        = &apos;X&apos;
            new_record        = &apos; &apos;
            key               = w_tabkey_value-tabkey
          EXCEPTIONS
            wrong_parameters  = 1
            internal_error    = 2
            key_not_supportet = 3
            fielddescr_error  = 4
            OTHERS            = 5.
        IF sy-subrc &lt;&gt; 0.
          p_msgid = &apos;SCPR&apos;.
          CASE sy-subrc.
            WHEN 1.
              p_msgty = &apos;E&apos;.
              p_msgno = &apos;273&apos;.
            WHEN 3.
              p_msgty = &apos;W&apos;.
              p_msgno = &apos;408&apos;.
            WHEN 4.
              p_msgty = &apos;E&apos;.
              p_msgno = &apos;395&apos;.
            WHEN OTHERS.
              p_msgty = &apos;E&apos;.
              p_msgno = &apos;320&apos;.
          ENDCASE.
          PERFORM vim_process_message USING sy-msgid sy-msgty sy-msgty
                                    sy-msgno space space space space.
        ENDIF.
      ENDLOOP.
    ENDIF.
    IF NOT corr_keytab_save IS INITIAL.
      INSERT lines of corr_keytab_save INTO TABLE corr_keytab.
    ENDIF.
  ENDIF.
ENDFORM.                               &quot; VIM_BC_LOGS_PUT

*&amp;---------------------------------------------------------------------*
*&amp;      Form  bc_entry_log_fill
*&amp;---------------------------------------------------------------------*
*       fills value table for BC-set activation log for every fix entity
*       field
*----------------------------------------------------------------------*
*      --&gt;P_HEADER  text
*      --&gt;P_NAMTAB  text
*      --&gt;P_CORR_KEYTAB  text
*      --&gt;P_BC_ENTRY  text
*      &lt;--P_TABKEY_VALUE  text
*----------------------------------------------------------------------*
FORM bc_entry_log_fill USING        p_header TYPE vimdesc
                                    p_namtab LIKE x_namtab[]
                                    p_bc_keytab TYPE bc_keytab_type
                               p_bc_entry TYPE vimty_bc_entry_list_type
                          CHANGING p_tabkey_values TYPE vim_bc_tab_logs.

  STATICS: dd28j_tab TYPE TABLE OF dd28j.
  DATA: w_dd28j TYPE dd28j, w_tabkey_value TYPE scpractr,
        w_fields TYPE vimty_fields_type.
  FIELD-SYMBOLS: &lt;namtab&gt; TYPE vimnamtab,
                 &lt;dfies&gt; TYPE dfies,                        &quot;#EC *
                 &lt;keytab&gt; TYPE bc_key_type.

  IF p_header-bastab = space.
    READ TABLE dd28j_tab INTO w_dd28j INDEX 1.
    IF sy-subrc &lt;&gt; 0 OR p_header-viewname &lt;&gt; w_dd28j-viewname.
* get join-conditions
      REFRESH dd28j_tab.
      CALL FUNCTION &apos;DDIF_VIEW_GET&apos;
        EXPORTING
          name          = p_header-viewname
        TABLES
          dd28j_tab     = dd28j_tab
        EXCEPTIONS
          illegal_input = 1
          OTHERS        = 2.
      IF sy-subrc &lt;&gt; 0.
* MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*         WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
      ENDIF.
    ENDIF.
  ENDIF.
  w_tabkey_value-client = sy-mandt.
  w_tabkey_value-profid = p_bc_entry-id.
  w_tabkey_value-recnumber = p_bc_entry-recnumber.
  w_tabkey_value-viewname = p_header-maintview.             &quot;HCG 6.8.02
  LOOP AT p_namtab ASSIGNING &lt;namtab&gt; WHERE keyflag = space OR
   texttabfld = space.
    READ TABLE p_bc_entry-fields INTO w_fields WITH KEY fieldname =
     &lt;namtab&gt;-viewfield.
    CHECK sy-subrc = 0.
    READ TABLE p_tabkey_values WITH KEY client = sy-mandt
      tablename = &lt;namtab&gt;-bastabname profid = p_bc_entry-id
      recnumber = p_bc_entry-recnumber viewname = p_header-viewname
      TRANSPORTING NO FIELDS.
    IF sy-subrc &lt;&gt; 0.
      LOOP AT p_bc_keytab ASSIGNING &lt;keytab&gt; WHERE
                                pgmid = &apos;R3TR&apos; AND
                               object = &apos;TABU&apos; AND
                              objname = &lt;namtab&gt;-bastabname.
        w_tabkey_value-tablename = &lt;namtab&gt;-bastabname.
        w_tabkey_value-tabkey = &lt;keytab&gt;-bc_tabkey.
        APPEND w_tabkey_value TO p_tabkey_values.
      ENDLOOP.
      CHECK sy-subrc = 0.
    ENDIF.
    IF x_header-bastab = space.
* view
      LOOP AT dd28j_tab INTO w_dd28j WHERE viewname = p_header-viewname
       AND ltab = &lt;namtab&gt;-bastabname AND lfield = &lt;namtab&gt;-viewfield.
        READ TABLE p_tabkey_values WITH KEY client = sy-mandt
          tablename = w_dd28j-rtab profid = p_bc_entry-id
          recnumber = p_bc_entry-recnumber viewname = p_header-viewname
          TRANSPORTING NO FIELDS.
        IF sy-subrc &lt;&gt; 0.
          READ TABLE p_bc_keytab WITH KEY pgmid = &apos;R3TR&apos;
                            object = &apos;TABU&apos;
                           objname = w_dd28j-rtab ASSIGNING &lt;keytab&gt;.
          CHECK sy-subrc = 0.
          w_tabkey_value-tablename = w_dd28j-rtab.
          w_tabkey_value-tabkey = &lt;keytab&gt;-bc_tabkey.
          APPEND w_tabkey_value TO p_tabkey_values.
        ENDIF.
      ENDLOOP.
      LOOP AT dd28j_tab INTO w_dd28j WHERE viewname = p_header-viewname
       AND rtab = &lt;namtab&gt;-bastabname AND rfield = &lt;namtab&gt;-viewfield.
        READ TABLE p_tabkey_values WITH KEY client = sy-mandt
          tablename = w_dd28j-ltab profid = p_bc_entry-id
          recnumber = p_bc_entry-recnumber viewname = p_header-viewname
          TRANSPORTING NO FIELDS.
        IF sy-subrc &lt;&gt; 0.
          LOOP AT p_bc_keytab ASSIGNING &lt;keytab&gt; WHERE
                                pgmid = &apos;R3TR&apos; AND
                               object = &apos;TABU&apos; AND
                              objname = w_dd28j-ltab.
            w_tabkey_value-tablename = w_dd28j-ltab.
            w_tabkey_value-tabkey = &lt;keytab&gt;-bc_tabkey.
            APPEND w_tabkey_value TO p_tabkey_values.
          ENDLOOP.
          CHECK sy-subrc = 0.
        ENDIF.
      ENDLOOP.
    ENDIF.
  ENDLOOP.
ENDFORM.                               &quot; bc_entry_log_fill
*&amp;---------------------------------------------------------------------*
*&amp;      Form  VIM_BC_LOGS_GET
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      &lt;--P_C_ENTRY_LIST  text
*      --&gt;P_VIEW_NAME  text
*      --&gt;P_HEADER  text
*      --&gt;P_NAMTAB  text
*----------------------------------------------------------------------*
FORM vim_bc_logs_get USING    p_view_name TYPE tabname
                              p_header TYPE vimdesc
                              p_namtab LIKE x_namtab[]
                CHANGING p_bc_entry_list TYPE vimty_bc_entry_list_ttype.

  STATICS: tablist TYPE TABLE OF scprxtabl, viewname TYPE tabname.

  DATA:    tabkeys TYPE TABLE OF scpractr, w_tablist TYPE scprxtabl,
           bc_entry_list_wa TYPE vimty_bc_entry_list_type, failed(1),
           rc LIKE sy-subrc, keys_identical TYPE xfeld,
           x030l_root TYPE x030l,
           x030l_bastab TYPE x030l,
           root_entry TYPE REF TO data,
           bastab_entry TYPE REF TO data,
           tabflags TYPE scpr_actfs, tabflags_wa TYPE scpr_actf,
*           tabflags_quick TYPE HASHED TABLE OF scpr_actf
*            WITH UNIQUE KEY tablename fieldname bcset_id
           tabflags_quick TYPE SORTED TABLE OF scpr_actf
            WITH NON-UNIQUE KEY tablename fieldname bcset_id
            recnumber tabkey INITIAL SIZE 100,
           fields_wa TYPE vimty_fields_type,
           bc_entry_list TYPE STANDARD TABLE OF
            vimty_bc_entry_list_type WITH KEY viewname keys,
            tabkey_wa TYPE scpractr-tabkey,
            tabkeys_wa TYPE scpractr,
            tabix TYPE sy-tabix,
            tabkey_struc(1024) TYPE c,
            flagind TYPE i, data_end TYPE i.
  FIELD-SYMBOLS: &lt;namtab&gt; TYPE vimnamtab, &lt;sektabkey&gt; TYPE scpractr,
                 &lt;tabkeys_main&gt; TYPE scpractr,
                 &lt;bastab&gt; TYPE ANY, &lt;bastab_x&gt; TYPE x,
                 &lt;roottab&gt; TYPE ANY, &lt;roottab_x&gt; TYPE x,
                 &lt;rootfld&gt; TYPE ANY,
                 &lt;tabkey&gt; TYPE x, &lt;viewfld&gt; TYPE ANY,
                 &lt;sektabkeyx&gt; TYPE x,
                 &lt;clnt&gt; TYPE ANY,
                 &lt;tabkey_c&gt; TYPE c.

  DELETE p_bc_entry_list WHERE viewname = p_header-maintview.&quot;HCG 6.8.02
  CHECK vim_import_profile = space.
*  CHECK &apos;TS&apos; NS maint_mode.   &quot;HCG Necessary in show and transport mode
*                    too, e.g. for selection show only data from BC-Sets
  IF viewname &lt;&gt; p_header-viewname.                  &quot;HCG 9/04 HW771997
* make table list
    viewname = p_header-maintview.
    REFRESH tablist.
    w_tablist-sign = &apos;I&apos;. w_tablist-option = &apos;EQ&apos;.
    IF p_header-bastab EQ &apos;X&apos;.                              &quot;S-table
      w_tablist-low = viewname.         &quot;HCG only roottab in tablist
      COLLECT w_tablist INTO tablist.
    ELSE.                                                      &quot;View
      w_tablist-low = p_header-roottab. &quot;HCG only roottab in tablist
      COLLECT w_tablist INTO tablist.
      LOOP AT p_namtab ASSIGNING &lt;namtab&gt;.
        IF &lt;namtab&gt;-keyflag NE space &quot;HCG Field from sektab in Viewkey
           AND &lt;namtab&gt;-bastabname NE w_tablist-low.
          w_tablist-low = &lt;namtab&gt;-bastabname.
          APPEND w_tablist TO tablist.
        ENDIF.
      ENDLOOP.
    ENDIF.
  ENDIF.
* &quot;HCG 9/04: tabkeys does only contain data to the table/view which
* needs to be regarded and tabflags-tablename contains eventually the
* name of a viewvariant, which is in the bcset but not known here.
*  For this reason the content of tabflags-tablename is not known yet.
  CALL FUNCTION &apos;SCPR_BCSET_PROT_GET_TABKEYS&apos;
    EXPORTING
      viewname = viewname
      clidep   = p_header-clidep                            &quot;824950
    IMPORTING
      actkeys  = tabkeys
      tabflags = tabflags
    TABLES
      tabnames = tablist
    EXCEPTIONS
      no_data  = 1
      OTHERS   = 2.
  CHECK sy-subrc = 0 AND NOT tabkeys IS INITIAL.
* &quot;HCG 04.01.2005 HW806401
* For Perfomance problems with very brad tables (&gt;100 fields)
* delete all lines in tabflags with flag = USE or VAR in SM30 mode
* In BC-Set activation no deletion, due to actopts-no_standrd mode
  IF vim_import_profile EQ space.
    LOOP AT tabflags INTO tabflags_wa.
      IF tabflags_wa-flag EQ vim_profile_use    or
         tabflags_wa-flag EQ vim_profile_fixkey or          &quot;824950
         tabflags_wa-flag EQ vim_profile_key    or          &quot;824950
         tabflags_wa-flag EQ vim_profile_var.               &quot;824950
        DELETE tabflags INDEX sy-tabix.
      ENDIF.
    ENDLOOP.
  ENDIF.
  LOOP AT tabkeys INTO tabkeys_wa.
    tabkey_wa = tabkeys_wa-tabkey.
    tabix = sy-tabix.
    CALL FUNCTION &apos;SCPR_EXT_ACTKEY_TO_KEY&apos;
      EXPORTING
        tablename        = tabkeys_wa-tablename  &quot;in case: Sektabname
        tablekey         = tabkey_wa
      IMPORTING
        key              = tabkey_struc
      EXCEPTIONS
        wrong_parameters = 1
        key_too_large    = 2
        fielddescr_error = 3
        internal_error   = 4
        OTHERS           = 5.
    IF sy-subrc NE 0.
      MESSAGE ID sy-msgid TYPE &apos;I&apos; NUMBER sy-msgno
       WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.
    ASSIGN tabkey_struc TO &lt;tabkey_c&gt; CASTING.
    tabkeys_wa-tabkey = &lt;tabkey_c&gt;.
    MODIFY tabkeys FROM tabkeys_wa INDEX tabix.
  ENDLOOP.
  bc_entry_list_wa-viewname = p_header-maintview.           &quot;HCG 6.8.02
  IF p_header-clidep &lt;&gt; space.
    READ TABLE p_namtab ASSIGNING &lt;namtab&gt;
     WITH KEY datatype = &apos;CLNT&apos;.
    ASSIGN COMPONENT &lt;namtab&gt;-viewfield
     OF STRUCTURE &lt;table1_wa&gt; TO &lt;clnt&gt;.
  ENDIF.
  SORT tabflags BY bcset_id recnumber.              &quot;HCG 1.9.03 9/04
  IF p_header-bastab = space.
* build up viewkeys and put&apos;em into entry list
***********************************************************************
* viewkey and roottabkey identical?
    PERFORM vim_comp_roottabkey USING p_header
                                      p_namtab
                                CHANGING keys_identical
                                         rc.
    CHECK rc = 0.
    IF keys_identical = space.
      PERFORM vim_get_x030l USING p_header-roottab
                            CHANGING x030l_root
                                     rc.
      CHECK rc = 0.
      CREATE DATA root_entry TYPE (p_header-roottab).
      ASSIGN: root_entry-&gt;* TO &lt;roottab&gt;,
              &lt;roottab&gt; TO &lt;roottab_x&gt; CASTING.
    ENDIF.
    INSERT lines of tabflags INTO TABLE tabflags_quick.
    LOOP AT tabkeys ASSIGNING &lt;tabkeys_main&gt;.               &quot;HCG 9/04
*     tablename = p_header-roottab.
      CLEAR: failed, &lt;table1_wa&gt;.
* get all primary table entries
      bc_entry_list_wa-id = &lt;tabkeys_main&gt;-profid.
      bc_entry_list_wa-recnumber = &lt;tabkeys_main&gt;-recnumber.
      ASSIGN &lt;tabkeys_main&gt;-tabkey TO &lt;tabkey&gt; CASTING.
      IF keys_identical &lt;&gt; space.
* move complete table key to view key
        MOVE &lt;tabkey&gt;(p_header-keylen) TO &lt;f1_wax&gt;.
      ELSE.
* fill view key field by field
        CLEAR: &lt;roottab&gt;.
        MOVE &lt;tabkey&gt;(x030l_root-keylen)
         TO &lt;roottab_x&gt;(x030l_root-keylen).
        LOOP AT p_namtab ASSIGNING &lt;namtab&gt; WHERE keyflag &lt;&gt; space AND
         texttabfld = space.
* build viewkey...
          CHECK &lt;namtab&gt;-datatype &lt;&gt; &apos;CLNT&apos; OR p_header-clidep = space.
          ASSIGN COMPONENT &lt;namtab&gt;-viewfield
           OF STRUCTURE &lt;table1_wa&gt; TO &lt;viewfld&gt;.
          IF &lt;namtab&gt;-bastabname = p_header-roottab.
* ... from primary table
            ASSIGN COMPONENT &lt;namtab&gt;-bastabfld OF STRUCTURE &lt;roottab&gt;
             TO &lt;rootfld&gt;.
            MOVE &lt;rootfld&gt; TO &lt;viewfld&gt;.
          ELSE.
* ... from secondary table
            failed = &apos;X&apos;.
            IF NOT &lt;sektabkey&gt; IS ASSIGNED
             OR &lt;sektabkey&gt;-tablename &lt;&gt; &lt;namtab&gt;-bastabname.
              READ TABLE tabkeys ASSIGNING &lt;sektabkey&gt;
               WITH KEY tablename = &lt;namtab&gt;-bastabname
                        recnumber = &lt;tabkeys_main&gt;-recnumber
                        profid = &lt;tabkeys_main&gt;-profid.
              IF sy-subrc &lt;&gt; 0.
                UNASSIGN &lt;sektabkey&gt;.
                EXIT.
              ENDIF.
              PERFORM vim_get_x030l USING &lt;namtab&gt;-bastabname
                                    CHANGING x030l_bastab
                                             rc.
              CHECK rc = 0.
              CREATE DATA bastab_entry TYPE (&lt;namtab&gt;-bastabname).
              ASSIGN: bastab_entry-&gt;* TO &lt;bastab&gt;,
                      &lt;bastab&gt; TO &lt;bastab_x&gt; CASTING.
            ENDIF.
            ASSIGN &lt;sektabkey&gt;-tabkey TO &lt;sektabkeyx&gt; CASTING.
            MOVE &lt;sektabkeyx&gt;(x030l_bastab-keylen)
             TO &lt;bastab_x&gt;(x030l_bastab-keylen).
            ASSIGN COMPONENT &lt;namtab&gt;-bastabfld OF STRUCTURE &lt;bastab&gt;
             TO &lt;rootfld&gt;.
            MOVE &lt;rootfld&gt; TO &lt;viewfld&gt;.
            CLEAR failed.
          ENDIF.
        ENDLOOP.
        CHECK failed IS INITIAL.
      ENDIF.
      IF p_header-clidep &lt;&gt; space.
* fill client-field
        MOVE sy-mandt TO &lt;clnt&gt;.
      ENDIF.
      MOVE &lt;f1_wax&gt; TO bc_entry_list_wa-keys.
      REFRESH bc_entry_list_wa-fields.
      LOOP AT p_namtab ASSIGNING &lt;namtab&gt;.
        CHECK &lt;namtab&gt;-datatype &lt;&gt; &apos;CLNT&apos; OR p_header-clidep = space.
* get bc-set field attributes
        READ TABLE tabflags_quick INTO tabflags_wa WITH KEY
*         tablename = p_header-viewname               &quot;HCG 9/04
         fieldname = &lt;namtab&gt;-viewfield &quot;HCH 8.8.2002 separat portiert
         bcset_id = bc_entry_list_wa-id
         recnumber = bc_entry_list_wa-recnumber.
        CHECK sy-subrc = 0.
        fields_wa-fieldname = &lt;namtab&gt;-viewfield.
        fields_wa-flag = tabflags_wa-flag.
        APPEND fields_wa TO bc_entry_list_wa-fields.
      ENDLOOP.
      INSERT bc_entry_list_wa INTO TABLE bc_entry_list.
      UNASSIGN &lt;sektabkey&gt;.
    ENDLOOP.
  ELSE.
* move table keys into entry list
***********************************************************************
    LOOP AT tabkeys ASSIGNING &lt;tabkeys_main&gt; WHERE
     tablename = p_header-maintview.
      bc_entry_list_wa-id = &lt;tabkeys_main&gt;-profid.
      bc_entry_list_wa-recnumber = &lt;tabkeys_main&gt;-recnumber.
      ASSIGN &lt;tabkeys_main&gt;-tabkey TO &lt;tabkey&gt; CASTING.
      MOVE &lt;tabkey&gt;(p_header-keylen) TO &lt;table1_wax&gt;(p_header-keylen).
      IF p_header-clidep &lt;&gt; space.
* fill client-field
        MOVE sy-mandt TO &lt;clnt&gt;.
      ENDIF.
      MOVE &lt;f1_wax&gt; TO bc_entry_list_wa-keys.
      REFRESH bc_entry_list_wa-fields.
* get bc-set field attributes                               &quot;HCG 1.9.03
*      LOOP AT tabflags INTO tabflags_wa WHERE ( tablename =
*       p_header-viewname OR tablename = p_header-texttab ) AND
*       bcset_id = bc_entry_list_wa-id
*       AND recnumber = bc_entry_list_wa-recnumber.
*        fields_wa-fieldname = tabflags_wa-fieldname.
*        fields_wa-flag = tabflags_wa-flag.
*        APPEND fields_wa TO bc_entry_list_wa-fields.
*      ENDLOOP.
*------------------get bc-set field attributes (New)----&quot;HCG 1.9.03----*
      READ TABLE tabflags INTO tabflags_wa WITH KEY
*         tablename = p_header-viewname          &quot;HCG 9/04
          bcset_id = bc_entry_list_wa-id
         recnumber = bc_entry_list_wa-recnumber BINARY SEARCH.
      IF sy-subrc = 0.
        flagind = sy-tabix.
        fields_wa-fieldname = tabflags_wa-fieldname.
        fields_wa-flag = tabflags_wa-flag.
        APPEND fields_wa TO bc_entry_list_wa-fields.
        CLEAR data_end.
        WHILE data_end = 0.     &quot;HCG all fields for 1 dataset in a row
          flagind = flagind + 1.
          READ TABLE tabflags INTO tabflags_wa INDEX flagind.
          IF sy-subrc = 0.            &quot;Otherwise end of table tabflags
*           IF tabflags_wa-tablename = p_header-viewname AND &quot;HCG 9/04
            IF tabflags_wa-bcset_id = bc_entry_list_wa-id AND
               tabflags_wa-recnumber = bc_entry_list_wa-recnumber.
              fields_wa-fieldname = tabflags_wa-fieldname.
              fields_wa-flag = tabflags_wa-flag.
              APPEND fields_wa TO bc_entry_list_wa-fields.
            ELSE.
              data_end = 1.
            ENDIF.
          ELSE.
            data_end = 1.               &quot;End of table tabflags reached
          ENDIF.
        ENDWHILE.
*-------------------&quot;HCG 1.9.03-----End of Performance optimization----*
        INSERT bc_entry_list_wa INTO TABLE bc_entry_list.
      ENDIF.
    ENDLOOP.
  ENDIF.
  SORT bc_entry_list.
* should normally not be necessary:
  DELETE ADJACENT DUPLICATES FROM bc_entry_list.
  DESCRIBE TABLE bc_entry_list.
* changing of fix BC-set-entries?
  CLEAR &lt;status&gt;-bcfixnochg.
  IF sy-tfill &gt; 0.
    INSERT lines of bc_entry_list INTO TABLE p_bc_entry_list.
    CALL FUNCTION &apos;SCPR_AUTHORITY_CHECK&apos;
      EXPORTING
        task             = &apos;CHGFIXVAL&apos;
      EXCEPTIONS
        wrong_parameters = 1
        no_authority     = 2
        OTHERS           = 3.
    IF sy-subrc &lt;&gt; 0.
      &lt;status&gt;-bcfixnochg = &apos;N&apos;.
    ELSE.
      &lt;status&gt;-bcfixnochg = &apos;Y&apos;.
    ENDIF.
  ENDIF.
ENDFORM.                               &quot; VIM_GET_BC_LOGS
*&amp;---------------------------------------------------------------------*
*&amp;      Form  VIM_BC_LOGS_MAINTAIN
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_HEADER         Header info of maintenance dialog
*      --&gt;P_BACKGROUND     Flag: &apos;X&apos; means BC-set import in background
*                                running.
*      &lt;--P_BC_ENTRY_LIST  List of entries coming from BC-set
*----------------------------------------------------------------------*
FORM vim_bc_logs_maintain USING    p_header TYPE vimdesc
                                   p_background TYPE xfeld
                          CHANGING p_bc_entry_list LIKE
                                   vim_bc_entry_list.

  DATA: fields_wa TYPE vimty_fields_type,
        subrc TYPE sy-subrc, tabix TYPE sy-tabix.
  STATICS:       viewname_old TYPE vimdesc-viewname,
                 keylen_real TYPE i.
  FIELD-SYMBOLS: &lt;bc_entry&gt; TYPE vimty_bc_entry_list_type,
                 &lt;key&gt; TYPE x, &lt;namtab&gt; TYPE vimnamtab.

  IF p_background = space.
* bc import running in dialogue
    LOOP AT total.
      CHECK &apos; N&apos; NS &lt;action&gt;.
      READ TABLE p_bc_entry_list ASSIGNING &lt;bc_entry&gt; WITH KEY
       viewname = p_header-viewname keys = &lt;vim_xtotal_key&gt;.
      CHECK sy-subrc = 0.
      CASE &lt;action&gt;.
        WHEN aendern.
* Rel. 4.6 only: does entry contain fix values?
*          LOOP AT &lt;bc_entry&gt;-fields INTO fields_wa
*           WHERE flag = vim_profile_fix.
*            TRANSLATE &lt;bc_entry&gt;-action USING &apos; U&apos;.
*            EXIT.
*          ENDLOOP.
        WHEN geloescht.
* deleting bc-set-entry
          CASE &lt;bc_entry&gt;-action.
            WHEN neuer_eintrag.
              &lt;bc_entry&gt;-action = neuer_geloescht.
            WHEN OTHERS.
              &lt;bc_entry&gt;-action = geloescht.
          ENDCASE.
*      WHEN zurueckholen.
** undeleting BC-set-entry --&gt; maintain table of BC-Set-entries
*        CASE &lt;bc_entry&gt;-action.
*          WHEN neuer_geloescht.
*            &lt;bc_entry&gt;-action = neuer_eintrag.
*          WHEN OTHERS.
*            &lt;bc_entry&gt;-action = original.
      ENDCASE.
    ENDLOOP.
  ELSE.
* bc import running in background
    DELETE vim_bc_entry_list WHERE viewname = p_header-viewname.  &quot;#EC *
    PERFORM vim_get_global_table IN PROGRAM saplsvim
                USING &apos;VIM_BC_ENTRY_LIST&apos;
                       vim_bc_entry_list
                       sy-subrc.
    IF sy-subrc &lt;&gt; 0.
      EXIT.
    ENDIF.
    IF p_header-viewname NE viewname_old. &quot;HCG: has table align gap?
      viewname_old = p_header-viewname.
      CLEAR keylen_real.
      LOOP AT x_namtab ASSIGNING &lt;namtab&gt; WHERE keyflag = &apos;X&apos; AND
                                                texttabfld IS INITIAL.
        keylen_real = keylen_real + &lt;namtab&gt;-flength.
      ENDLOOP.
    ENDIF.
    LOOP AT vim_bc_entry_list ASSIGNING &lt;bc_entry&gt; WHERE
     viewname = p_header-viewname.
      ASSIGN &lt;bc_entry&gt;-keys(x_header-keylen) TO &lt;key&gt;.
      IF p_header-keylen = keylen_real.
        READ TABLE total WITH KEY &lt;key&gt; BINARY SEARCH.
        subrc = sy-subrc.
      ELSE.
        PERFORM vim_read_table_with_gap
                    TABLES   total
                    USING    &lt;key&gt;
                             x_namtab[]
                    CHANGING subrc
                             tabix.
        IF subrc = 0.
          READ TABLE total INDEX tabix.
        ENDIF.
      ENDIF.
* bc-set entry really imported?
      IF subrc &lt;&gt; 0 OR &apos;NUD&apos; NS &lt;action&gt;.
        DELETE vim_bc_entry_list.
      ENDIF.
    ENDLOOP.
  ENDIF.
ENDFORM.                               &quot; VIM_BC_LOGS_MAINTAIN
*&amp;---------------------------------------------------------------------*
*&amp;      Form  VIM_BC_LOGS_USE
*&amp;---------------------------------------------------------------------*
*       delivers field attribute defined in BC-sets
*----------------------------------------------------------------------*
*      --&gt;P_FIELD         text
*      --&gt;P_VIM_BC_ENTRY  text
*      &lt;--P_SCREEN_INPUT  text
*      &lt;--P_MODIFY_SCREEN  text
*----------------------------------------------------------------------*
FORM vim_bc_logs_use USING p_field TYPE fieldname
                           p_vim_bc_entry TYPE vimty_bc_entry_list_type
                     CHANGING p_screen LIKE screen
                              p_modify_screen TYPE xfeld.

  DATA w_field TYPE vimty_fields_type.

  READ TABLE p_vim_bc_entry-fields INTO w_field
   WITH TABLE KEY fieldname = p_field.
  CHECK sy-subrc = 0.
  IF w_field-flag = vim_profile_fix.
    p_screen-input = 0.
    p_modify_screen = &apos;X&apos;.
  ENDIF.
ENDFORM.                               &quot; VIM_BC_LOGS_USE
*&amp;---------------------------------------------------------------------*
*&amp;      Form  vim_chng_fix_flds
*&amp;---------------------------------------------------------------------*
*       make fix values form bc-sets modifiable
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM vim_chng_fix_flds.
  IF vim_actlinks NE x_header-viewname.
    PERFORM vim_bc_logs_get USING view_name x_header x_namtab[]
                          CHANGING vim_bc_entry_list.
    vim_actlinks = x_header-viewname. &quot;For which actlinks are valid
  ENDIF.
  IF &lt;status&gt;-bcfixnochg = &apos;Y&apos;.
    vim_bc_chng_allowed = &apos;X&apos;.
  ELSE.
    MESSAGE e202(sv).
*   Sie haben keine Berechtigung, Felder mit fixen BC-Set-Werten zu ände
  ENDIF.
ENDFORM.                               &quot; vim_chng_fix_flds
*&amp;---------------------------------------------------------------------*
*&amp;      Form  vim_get_x030l
*&amp;---------------------------------------------------------------------*
*       Delivers X030l fron dictionary.
*----------------------------------------------------------------------*
*      --&gt;P_TABNAME     tablename
*      &lt;--P_X030L
*      &lt;--P_RC
*----------------------------------------------------------------------*
FORM vim_get_x030l  USING    p_tabname TYPE tabname
                    CHANGING p_x030l TYPE x030l
                             p_rc LIKE sy-subrc.
  CALL FUNCTION &apos;DDIF_NAMETAB_GET&apos;
    EXPORTING
      tabname  = p_tabname
    IMPORTING
      x030l_wa = p_x030l
    EXCEPTIONS
      OTHERS   = 1.
  p_rc = sy-subrc.
ENDFORM.                    &quot; vim_get_x030l
*&amp;---------------------------------------------------------------------*
*&amp;      Form  vim_show_fix_flds
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM vim_bc_show_fix_flds.
  DATA: p_tabtype TYPE objh-objecttype,
        p_tabname TYPE scpr_tabl.


  IF vim_actlinks NE x_header-viewname.
    PERFORM vim_bc_logs_get USING view_name x_header x_namtab[]
                          CHANGING vim_bc_entry_list.
    vim_actlinks = x_header-viewname. &quot;For which actlinks are valid
  ENDIF.
  p_tabname = x_header-maintview. &quot;HCG 6.8.02 actlinks for maintview
  IF x_header-bastab = space.
    p_tabtype = &apos;V&apos;.
  ELSE.
    p_tabtype = &apos;S&apos;.
  ENDIF.
  LOOP AT extract.
    IF &lt;xmark&gt; NE markiert.
      CONTINUE.
    ELSE.
      MOVE &lt;vim_extract_struc&gt; TO &lt;table1&gt;.
      CALL FUNCTION &apos;SCPR_ACTIVATION_INFOS_SHOW&apos;
        EXPORTING
          tablename             = p_tabname
          tabletype             = p_tabtype
          record                = &lt;table1&gt;
        EXCEPTIONS
          fielddefinition_error = 1
          no_tvdir_entry        = 2
          table_not_found       = 3
          table_to_large        = 4
          ddif_internal_error   = 5
          wrong_parameters      = 6
          internal_error        = 7
          no_actlinks           = 8
          key_too_large         = 9
          OTHERS                = 10.
      CASE sy-subrc.
        WHEN 0.
        WHEN 1.
          MESSAGE e395(scpr) RAISING fielddefinition_error.
        WHEN 2.
          MESSAGE e028(scpr) WITH p_tabname RAISING no_tvdir_entry.
        WHEN 3.
          MESSAGE e120(scpr) WITH p_tabname RAISING table_not_found.
        WHEN 4.
          MESSAGE e026(scpr) WITH p_tabname RAISING table_to_large.
        WHEN 5.
          MESSAGE e035(scpr) RAISING ddif_internal_error.
        WHEN 6.
          MESSAGE e273(scpr) RAISING wrong_parameters.
        WHEN 8.
          MESSAGE s399(scpr) RAISING no_actlinks.
        WHEN 9.
          MESSAGE e408(scpr) RAISING key_too_large.
        WHEN OTHERS.
          MESSAGE e320(scpr) RAISING internal_error.
      ENDCASE.
    ENDIF.
  ENDLOOP.

ENDFORM.                    &quot; vim_show_fix_flds
*&amp;---------------------------------------------------------------------*
*&amp;      Form  vim_build_bc_tabkeys
*&amp;---------------------------------------------------------------------*
*   To build up table keys for views with keylen &gt; 120 up to 256
*   and / or non-character like fields.
*----------------------------------------------------------------------*
*      &lt;--P_BC_KEYTAB  text
*----------------------------------------------------------------------*
FORM vim_build_bc_tabkeys USING bc_entry_list_wa TYPE
                                       vimty_bc_entry_list_type
                       CHANGING p_bc_keytab TYPE bc_keytab_type.

  TYPES: BEGIN OF tablist_type,
           tabname TYPE objs-tabname,
         END OF tablist_type.

  STATICS: cg_dd28j_tab LIKE dd28j OCCURS 30,
           old_viewname LIKE vimdesc-viewname,
           all_dfiestab LIKE dfies OCCURS 40.

  DATA: objstablist TYPE TABLE OF tablist_type,
        namtab_wa TYPE vimnamtab,
        tabname_wa TYPE objs-tabname,
        dd28j_wa LIKE LINE OF cg_dd28j_tab,
        primtab_entry TYPE REF TO data,
        sektab_entry TYPE REF TO data,
        p_bc_keytab_wa LIKE LINE OF p_bc_keytab,
        keytab_index TYPE sy-tabix,
        bc_keylen TYPE i, flag(1) TYPE c,
        cg_langu(1) TYPE c,
        cg_dfiestab LIKE dfies OCCURS 10,
        dfies_wa LIKE LINE OF cg_dfiestab,
        piecelist TYPE TABLE OF objs-tabname,
        foreign_langu LIKE sy-langu,
        langu_fieldname TYPE dfies-fieldname,
        p_bc_keytab_langu TYPE bc_keytab_type,
        w_bc_entry_list TYPE vimty_bc_entry_list_type.

  FIELD-SYMBOLS: &lt;primtab&gt; TYPE ANY, &lt;sektab&gt; TYPE ANY,
                 &lt;viewfld&gt; TYPE ANY,
                 &lt;primtabfld&gt; TYPE ANY, &lt;sektabfld&gt; TYPE ANY,
                 &lt;bc_tabkey&gt; TYPE bc_key_type-bc_tabkey,    &quot;#EC *
                 &lt;tabkey_x&gt; TYPE x, &lt;tabkey_struc_x&gt; TYPE x.

  IF x_header-viewname NE old_viewname.
    old_viewname = x_header-viewname.
    CALL FUNCTION &apos;DDIF_VIEW_GET&apos;
      EXPORTING
        name          = x_header-viewname
        state         = &apos;A&apos;
        langu         = sy-langu
      IMPORTING
        gotstate      = flag
      TABLES
        dd28j_tab     = cg_dd28j_tab
      EXCEPTIONS
        illegal_input = 1
        OTHERS        = 2.
    IF sy-subrc &lt;&gt; 0.
      MESSAGE e164(sv) WITH tabname_wa RAISING view_not_found.
    ENDIF.
    IF flag = space.
      MESSAGE e306(sv) WITH tabname_wa RAISING view_not_found.
    ENDIF.
*   Get tables from piecelist
    SELECT tabname FROM objs INTO tabname_wa
                       WHERE objectname = x_header-viewname
                         AND objecttype = &apos;V&apos;.
      APPEND tabname_wa TO piecelist.
    ENDSELECT.
    REFRESH all_dfiestab.
    LOOP AT piecelist INTO tabname_wa.
      REFRESH cg_dfiestab.
      CALL FUNCTION &apos;DDIF_NAMETAB_GET&apos;
        EXPORTING
          tabname   = tabname_wa
        TABLES
          dfies_tab = cg_dfiestab[]
        EXCEPTIONS
          not_found = 1
          OTHERS    = 2.
      IF sy-subrc NE 0.
        MESSAGE e028(sv) WITH tabname_wa RAISING view_not_found.
      ENDIF.
      LOOP AT cg_dfiestab INTO dfies_wa.
        APPEND dfies_wa TO all_dfiestab.
      ENDLOOP.
    ENDLOOP.
  ENDIF.
  LOOP AT p_bc_keytab INTO p_bc_keytab_wa.
    keytab_index = sy-tabix.
    IF p_bc_keytab_wa-objname = x_header-roottab.
*-----Build tabkey for root-table from viewkey-------------------------
      CREATE DATA primtab_entry TYPE (x_header-roottab).
      ASSIGN primtab_entry-&gt;* TO &lt;primtab&gt;.
      LOOP AT x_namtab WHERE keyflag = &apos;X&apos; AND
                           bastabname = x_header-roottab.
        ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE
                   &lt;vim_total_struc&gt; TO &lt;viewfld&gt;.
        ASSIGN COMPONENT x_namtab-bastabfld OF STRUCTURE &lt;primtab&gt;
                   TO &lt;primtabfld&gt;.
        MOVE &lt;viewfld&gt; TO &lt;primtabfld&gt;.
      ENDLOOP.                 &quot; Primtabkey completely in &lt;primtab&gt;
      PERFORM vim_get_bc_keylen    &quot;Analog corr_maint_&gt;&gt;viewname&lt;&lt;
              USING x_header-roottab
           CHANGING bc_keylen.
      ASSIGN &lt;primtab&gt; TO &lt;tabkey_struc_x&gt; CASTING.
      ASSIGN p_bc_keytab_wa-bc_tabkey TO &lt;tabkey_x&gt; CASTING.
      MOVE &lt;tabkey_struc_x&gt;(bc_keylen) TO &lt;tabkey_x&gt;(bc_keylen).
      MODIFY p_bc_keytab INDEX keytab_index FROM p_bc_keytab_wa.
    ELSEIF p_bc_keytab_wa-objname EQ x_header-texttab.
*-----Build tabkeys for textable of view from viewkey field by field---
      REFRESH p_bc_keytab_langu.
      tabname_wa = p_bc_keytab_wa-objname.
      CREATE DATA sektab_entry TYPE (tabname_wa).
      ASSIGN sektab_entry-&gt;* TO &lt;sektab&gt;.
      PERFORM vim_get_bc_keylen    &quot;Analog corr_maint_&gt;&gt;viewname&lt;&lt;
                  USING tabname_wa
                  CHANGING bc_keylen.
      LOOP AT all_dfiestab INTO dfies_wa WHERE tabname = tabname_wa
                                          AND keyflag = &apos;X&apos;.
        CLEAR cg_langu.
        READ TABLE cg_dd28j_tab WITH KEY rtab = tabname_wa
                                       rfield = dfies_wa-fieldname
                                    INTO dd28j_wa.
        IF sy-subrc EQ 0.
          READ TABLE x_namtab WITH KEY bastabname = dd28j_wa-ltab
                                        bastabfld = dd28j_wa-lfield.
        ELSE.       &quot;Field not in join -&gt; additional keyfield in view
          READ TABLE x_namtab WITH KEY bastabname = tabname_wa
                                    bastabfld = dfies_wa-fieldname.
          IF sy-subrc NE 0.    &quot;Then it must be langu field of texttab
            cg_langu = &apos;X&apos;.
          ENDIF.
        ENDIF.
        IF cg_langu EQ space.                 &quot;Field is not langu field
          ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE
                     &lt;vim_total_struc&gt; TO &lt;viewfld&gt;.
          ASSIGN COMPONENT dfies_wa-fieldname OF STRUCTURE
                                           &lt;sektab&gt; TO &lt;sektabfld&gt;.
          MOVE &lt;viewfld&gt; TO &lt;sektabfld&gt;.
        ELSE.                                     &quot;Field is langu field
          langu_fieldname = dfies_wa-fieldname.
          ASSIGN COMPONENT dfies_wa-fieldname OF STRUCTURE
                                           &lt;sektab&gt; TO &lt;sektabfld&gt;.
          MOVE sy-langu TO &lt;sektabfld&gt;.
        ENDIF.
        ASSIGN &lt;sektab&gt; TO &lt;tabkey_struc_x&gt; CASTING.
        ASSIGN p_bc_keytab_wa-bc_tabkey TO &lt;tabkey_x&gt; CASTING.
        MOVE &lt;tabkey_struc_x&gt;(bc_keylen) TO &lt;tabkey_x&gt;(bc_keylen).
      ENDLOOP.
      MODIFY p_bc_keytab INDEX keytab_index FROM p_bc_keytab_wa.
*     Look for other languages in bc-set and append to p_bc_keytab too
      ASSIGN COMPONENT langu_fieldname OF STRUCTURE
                                           &lt;sektab&gt; TO &lt;sektabfld&gt;.
      LOOP AT bc_entry_list_wa-forlangu INTO foreign_langu.
        MOVE foreign_langu TO &lt;sektabfld&gt;.
        MOVE &lt;tabkey_struc_x&gt;(bc_keylen) TO &lt;tabkey_x&gt;(bc_keylen).
        APPEND p_bc_keytab_wa TO p_bc_keytab_langu.
      ENDLOOP.
    ELSE.
*-----Build tabkeys for secondary tabs from viewkey field by field-----
      tabname_wa = p_bc_keytab_wa-objname.
      CREATE DATA sektab_entry TYPE (tabname_wa).
      ASSIGN sektab_entry-&gt;* TO &lt;sektab&gt;.
      PERFORM vim_get_bc_keylen    &quot;Analog corr_maint_&gt;&gt;viewname&lt;&lt;
                  USING tabname_wa
                  CHANGING bc_keylen.
      LOOP AT all_dfiestab INTO dfies_wa WHERE tabname = tabname_wa
                                          AND keyflag = &apos;X&apos;.
        CLEAR cg_langu.
        READ TABLE cg_dd28j_tab WITH KEY rtab = tabname_wa
                                       rfield = dfies_wa-fieldname
                                    INTO dd28j_wa.
        IF sy-subrc EQ 0.
          READ TABLE x_namtab WITH KEY bastabname = dd28j_wa-ltab
                                        bastabfld = dd28j_wa-lfield.
        ELSE.       &quot;Field not in join -&gt; additional keyfield in view
          READ TABLE x_namtab WITH KEY bastabname = tabname_wa
                                    bastabfld = dfies_wa-fieldname.
          IF sy-subrc NE 0.                 &quot;Then it must be an error
*            error.!!!!
          ENDIF.
        ENDIF.
        ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE
                   &lt;vim_total_struc&gt; TO &lt;viewfld&gt;.
        ASSIGN COMPONENT dfies_wa-fieldname OF STRUCTURE
                                         &lt;sektab&gt; TO &lt;sektabfld&gt;.
        MOVE &lt;viewfld&gt; TO &lt;sektabfld&gt;.
        ASSIGN &lt;sektab&gt; TO &lt;tabkey_struc_x&gt; CASTING.
        ASSIGN p_bc_keytab_wa-bc_tabkey TO &lt;tabkey_x&gt; CASTING.
        MOVE &lt;tabkey_struc_x&gt;(bc_keylen) TO &lt;tabkey_x&gt;(bc_keylen).
      ENDLOOP.
      MODIFY p_bc_keytab INDEX keytab_index FROM p_bc_keytab_wa.
    ENDIF.
  ENDLOOP.
***********************************************************************
  &quot;HCG Look for sektab, which is not in piecelist but has keyfield
  &quot;in viewkey and write actlink anyway &quot;HW664698
  LOOP AT x_namtab WHERE keyflag = &apos;X&apos;.
*   View Variant may not have all the key fields selected
    IF x_namtab-bastabname NE space.                        &quot;IG 1020971
      READ TABLE p_bc_keytab WITH KEY objname = x_namtab-bastabname
                                             TRANSPORTING NO FIELDS.
      IF sy-subrc NE 0. &quot;bastab of keyfield not in piecelist -&gt; add
        READ TABLE p_bc_keytab INTO p_bc_keytab_wa INDEX 1.
        p_bc_keytab_wa-objname = x_namtab-bastabname.
        CLEAR p_bc_keytab_wa-bc_tabkey.
        REFRESH cg_dfiestab.
        tabname_wa = x_namtab-bastabname.
        CALL FUNCTION &apos;DDIF_NAMETAB_GET&apos;
          EXPORTING
            tabname   = tabname_wa
          TABLES
            dfies_tab = cg_dfiestab[]
          EXCEPTIONS
            not_found = 1
            OTHERS    = 2.
        IF sy-subrc NE 0.
          MESSAGE e028(sv) WITH tabname_wa RAISING view_not_found.
        ENDIF.
        LOOP AT cg_dfiestab INTO dfies_wa.
          APPEND dfies_wa TO all_dfiestab.
        ENDLOOP.
*-----Build tabkeys for secondary tabs from viewkey field by field-----
        CREATE DATA sektab_entry TYPE (tabname_wa).
        ASSIGN sektab_entry-&gt;* TO &lt;sektab&gt;.
        PERFORM vim_get_bc_keylen    &quot;Analog corr_maint_&gt;&gt;viewname&lt;&lt;
                    USING tabname_wa
                    CHANGING bc_keylen.
        LOOP AT all_dfiestab INTO dfies_wa WHERE tabname = tabname_wa
                                            AND keyflag = &apos;X&apos;.
          CLEAR cg_langu.
          READ TABLE cg_dd28j_tab WITH KEY rtab = tabname_wa
                                         rfield = dfies_wa-fieldname
                                      INTO dd28j_wa.
          IF sy-subrc EQ 0.
            READ TABLE x_namtab WITH KEY bastabname = dd28j_wa-ltab
                                          bastabfld = dd28j_wa-lfield.
          ELSE.       &quot;Field not in join -&gt; additional keyfield in view
            READ TABLE x_namtab WITH KEY bastabname = tabname_wa
                                      bastabfld = dfies_wa-fieldname.
          ENDIF.
          IF sy-subrc NE 0.
            IF dfies_wa-datatype = &apos;CLNT&apos;.
              ASSIGN COMPONENT dfies_wa-fieldname OF STRUCTURE
                                             &lt;sektab&gt; TO &lt;sektabfld&gt;.
             &lt;sektabfld&gt; = sy-mandt.&quot;HCG clnt in namtab with primtabname
            ELSE.
*            error. Field/SEKTAB not in join cond. and not in namtab.
            ENDIF.
          ELSE.
            ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE
                       &lt;vim_total_struc&gt; TO &lt;viewfld&gt;.
            ASSIGN COMPONENT dfies_wa-fieldname OF STRUCTURE
                                             &lt;sektab&gt; TO &lt;sektabfld&gt;.
            MOVE &lt;viewfld&gt; TO &lt;sektabfld&gt;.
          ENDIF.
          ASSIGN &lt;sektab&gt; TO &lt;tabkey_struc_x&gt; CASTING.
          ASSIGN p_bc_keytab_wa-bc_tabkey TO &lt;tabkey_x&gt; CASTING.
          MOVE &lt;tabkey_struc_x&gt;(bc_keylen) TO &lt;tabkey_x&gt;(bc_keylen).
        ENDLOOP.
        APPEND p_bc_keytab_wa TO p_bc_keytab.
      ENDIF.
    ENDIF.
  ENDLOOP.
***********************************************************************
  APPEND LINES OF p_bc_keytab_langu TO p_bc_keytab.
ENDFORM.                    &quot; vim_build_bc_tabkeys
*&amp;---------------------------------------------------------------------*
*&amp;      Form  vim_read_table_with_gap
*&amp;---------------------------------------------------------------------*
*       Implementierung des
*         READ TABLE &lt;it_data&gt; WITH KEY &lt;key&gt; BINARY SEARCH
*       für Tabellen mit Alignment-Lücken (Nicht-Character-Feld wie
*       z.B. ein INT4-Feld im Schlüssel)
*
*       Voraussetzung zum Aufruf: gap_table ist sortiert
*
*       Rückgabewert: SUBRC = 0    1. Datensatz passend zum KEY
*       (analog                    wurde gefunden (wichtig für
*        BINARY                    BC-Sets mit Schlüsselkonflikt)
*        SEARCH)                   Datensatznummer in TABIX
*
*                     SUBRC = 4    Eintrag wurde nicht gefunden
*                                  Datensatznummer + 1 in TABIX
*
*                     SUBRC = 8    Eintrag wurde nicht gefunden
*                                  Letzte Datensatznummer + 1 in TABIX
*----------------------------------------------------------------------*
*     To use function SCPR_CTRL_CT_COMP_TWO_RECORDS table of field
*     description in SCPR format is created and filled partly.
*----------------------------------------------------------------------*
FORM vim_read_table_with_gap TABLES   gap_table
                         USING    key   TYPE x
                                  namtab LIKE x_namtab[]
                         CHANGING subrc TYPE sy-subrc
                                  tabix TYPE sy-tabix.

  TYPES: scpr_x8192(8192) TYPE x.
  DATA: result  TYPE scpr_txt20,
        tab_i   TYPE sy-tabix,
        tab_j   TYPE sy-tabix,
        tab_k   TYPE sy-tabix,
        tab_len TYPE sy-tabix.

  DATA: align TYPE f, wa_8192 TYPE scpr_x8192,
        it_fldnames TYPE STANDARD TABLE OF scpr_flddescr,
        fldnames_wa LIKE LINE OF it_fldnames.
*        gap_table_wa(2048) TYPE c.
  FIELD-SYMBOLS: &lt;wa_it_data&gt; TYPE x,
                 &lt;namtab&gt; TYPE vimnamtab.

* Fill necessary fields in it_fieldnames from namtab
  LOOP AT namtab ASSIGNING &lt;namtab&gt; WHERE keyflag = &apos;X&apos;
                                    AND texttabfld = space.
    fldnames_wa-fieldname = &lt;namtab&gt;-viewfield.
    fldnames_wa-position = &lt;namtab&gt;-position.
    fldnames_wa-intlen = &lt;namtab&gt;-flength.
    fldnames_wa-keyflag = &apos;X&apos;.
    fldnames_wa-flag = &apos;FKY&apos;. &quot;KEY would do the same job...
    APPEND fldnames_wa TO it_fldnames.
  ENDLOOP.

  DESCRIBE TABLE gap_table LINES tab_len.
  tab_i = 1.
  tab_j = tab_len.
  subrc = 8.
  tabix = tab_len + 1.
  ASSIGN wa_8192 TO &lt;wa_it_data&gt;.
* sturkturierte oder non-sturkturierte sollte beobachten
  ASSIGN gap_table TO &lt;wa_it_data&gt; CASTING.                 &quot;XB H628871


  DO.
    IF tab_i &gt; tab_j.
*     Datensatz wurde nicht gefunden
      subrc = 4.
      tabix = tab_k + 1.
      EXIT.
    ENDIF.
    tab_k = ( tab_i + tab_j ) / 2.

*    READ TABLE gap_table INTO gap_table_wa INDEX tab_k.
    READ TABLE gap_table INDEX tab_k.                       &quot;XB H628871

    CALL FUNCTION &apos;SCPR_CTRL_CT_COMP_TWO_RECORDS&apos;
      EXPORTING
        cu_lines      = &lt;wa_it_data&gt;
        bc_lines      = key
        compare_key   = &apos;X&apos;
        ip_align_data = &apos;X&apos;
      IMPORTING
        RESULT        = RESULT
      TABLES
        it_fldnames   = it_fldnames.

    IF result = &apos;LT&apos;.
      tab_j = tab_k - 1.
    ELSEIF result = &apos;GT&apos;.
      tab_i = tab_k + 1.
    ELSE.
      subrc = 0.
      tabix = tab_k.
      EXIT.
    ENDIF.
  ENDDO.
ENDFORM.                    &quot; read_table_with_gap</include_source>
   </include>
   <include NAME="LSVIMF5B" SQLX="X" VARCL="X" SUBC="I" APPL="S" CNAM="SAP" CDAT="19991122" UNAM="SAP" UDAT="20080721" VERN="000003" LEVL="50A" RSTAT="T" RMAND="000" RLOAD="D" SDATE="20080721" STIME="122441" IDATE="20080721" ITIME="122442">
    <include_source>*----------------------------------------------------------------------*
***INCLUDE LSVIMF5B .
*----------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp;      Form  CHECK_LIST_BEFORE_ALV
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM check_list_before_alv CHANGING rc LIKE sy-subrc.

  DATA:          counter TYPE i, index type i,
                 variant LIKE disvariant,
                 fcat_var TYPE slis_t_fieldcat_alv.
  FIELD-SYMBOLS: &lt;fcat&gt; TYPE slis_fieldcat_alv.
  CONSTANTS:     alv_maxcols TYPE i VALUE 99.

  CLEAR: counter, rc.
  LOOP AT vim_alv_fcat TRANSPORTING NO FIELDS WHERE no_out &lt;&gt; &apos;X&apos;.
    ADD 1 TO counter.
  ENDLOOP.
  CHECK counter &gt; alv_maxcols.
* suitable standard variant defined?
  CONCATENATE x_header-viewname sy-repid INTO variant-report.
  CALL FUNCTION &apos;REUSE_ALV_VARIANT_SELECT&apos;
       EXPORTING
            i_dialog            = space
            i_user_specific     = &apos;X&apos;
            i_default           = &apos;X&apos;  &quot;vim_var_default
*         I_TABNAME_HEADER    =
*         I_TABNAME_ITEM      =
            it_default_fieldcat = vim_alv_fcat
            i_layout            = vim_alv_layout
       IMPORTING
*         E_EXIT              =
            et_fieldcat         = fcat_var
*         ET_SORT             =
*         ET_FILTER           =
            es_layout           = vim_alv_layout
       CHANGING
            cs_variant          = variant
       EXCEPTIONS
            wrong_input         = 1
            fc_not_complete     = 2
            not_found           = 3
            program_error       = 4
            OTHERS              = 5.
  IF sy-subrc = 0 AND NOT variant-variant IS INITIAL.
    CLEAR: counter.
    LOOP AT fcat_var TRANSPORTING NO FIELDS WHERE no_out &lt;&gt; &apos;X&apos;.
      ADD 1 TO counter.
    ENDLOOP.
    CHECK counter &gt; alv_maxcols.
  ENDIF.
* no variant with less than 99 columns exists
*  WHILE counter &gt; alv_maxcols.
*    MESSAGE i807(sv) WITH counter.
**    Bitte wählen Sie max. 99 Felder für die Liste aus.
*    CALL FUNCTION &apos;REUSE_ALV_VARIANT_MAINTAIN&apos;
*         EXPORTING
**         I_TABNAME_HEADER  =
**         I_TABNAME_ITEM    =
*              i_save            = vim_var_save
**         I_POPUP           = &apos;X&apos;
*              is_layout         = vim_alv_layout
**         IT_SPECIAL_GROUPS =
**         IT_SORT           =
**    IMPORTING
**         E_SAVE            =
*         CHANGING
*              ct_fieldcat       = vim_alv_fcat
*         EXCEPTIONS
*              no_change         = 1
**         PROGRAM_ERROR     = 2
*              OTHERS            = 3.
*    rc = sy-subrc.
*    IF rc &lt;&gt; 0. EXIT. ENDIF.
*    CLEAR counter.
*    LOOP AT vim_alv_fcat TRANSPORTING NO FIELDS WHERE no_out &lt;&gt; &apos;X&apos;.
*      ADD 1 TO counter.
*    ENDLOOP.
**    check counter &lt; alv_maxcols.
** field catalogue changed =&gt; rearrange value tab
*&gt;&gt;&gt;&gt;Complete field catalogue needs to be rearranged here: too lavish
*&gt;&gt;&gt;&gt;for this rare case. Let&apos;s try an easier attempt at first.
*  ENDWHILE.
  MESSAGE i808(sv) with COUNTER.
*   Es können nicht alle Spalten der Tabelle auf der Liste angezeigt wer
  index = alv_maxcols + 1.
  LOOP AT vim_alv_fcat ASSIGNING &lt;fcat&gt; FROM index.
    &lt;fcat&gt;-no_out = &apos;X&apos;.
  ENDLOOP.
ENDFORM.                               &quot; CHECK_LIST_BEFORE_ALV</include_source>
   </include>
   <include NAME="LSVIMF5C" SQLX="X" VARCL="X" SUBC="I" APPL="S" CNAM="SAP" CDAT="20000119" UNAM="SAP" UDAT="20080721" VERN="000001" LEVL="50A" RSTAT="T" RMAND="000" RLOAD="D" SDATE="20080721" STIME="122442" IDATE="20080721" ITIME="122442">
    <include_source>*----------------------------------------------------------------------*
***INCLUDE LSVIMF5C .
*----------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp;      Form  VIM_SET_OC
*&amp;---------------------------------------------------------------------*
*       Called from external to create reference to organisation
*       criterion
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM vim_set_oc USING value(p_obj)
                       TYPE REF TO cl_viewfields_org_crit.

  clear vim_oc_inst.
  check not p_obj is initial.
  vim_oc_inst = p_obj.
ENDFORM.                               &quot; VIM_SET_GLOBAL_OBJECT</include_source>
   </include>
   <include NAME="LSVIMF5D" VARCL="X" SUBC="I" APPL="S" CNAM="SAP" CDAT="20000119" UNAM="SAP" UDAT="20080721" VERN="000004" RSTAT="T" RMAND="000" RLOAD="D" SDATE="20080721" STIME="122442" IDATE="20080721" ITIME="122442">
    <include_source>*----------------------------------------------------------------------*
*   INCLUDE LSVIMF5D                                                   *
*----------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp;      Form  VIM_MAINT_SELFLAG
*&amp;---------------------------------------------------------------------*
*       Sets or resets X_HEADER-SELECTION and keeps initial value
*       Purpose: additional check vs. sellist in form
*       CHECK_DYNAMIC_SELECT_OPTIONS
*----------------------------------------------------------------------*
*      --&gt;mode   S = set flag to &apos;X&apos;, I = initialize,
*                R = get and reset to initial value
*      &lt;--p_selflag value of X_HEADER-SELECTION
*----------------------------------------------------------------------*
FORM vim_maint_selflag USING    value(p_mode) TYPE sychar01
                   CHANGING p_selflag     TYPE xfeld.

  STATICS: init_val TYPE xfeld.

  CASE p_mode.
    WHEN &apos;I&apos;.
      init_val = p_selflag.
    WHEN &apos;S&apos;.
      x_header-selection = &apos;X&apos;.   &quot;#EC *
    WHEN &apos;R&apos;.
      p_selflag = x_header-selection.
      x_header-selection = init_val.
  ENDCASE.
ENDFORM.                               &quot; VIM_MAINT_SELFLAG</include_source>
   </include>
   <include NAME="LSVIMF5E" VARCL="X" SUBC="I" APPL="S" CNAM="SAP" CDAT="20000328" UNAM="SAP" UDAT="20080721" VERN="000002" RSTAT="T" RMAND="000" RLOAD="D" SDATE="20080721" STIME="122442" IDATE="20080721" ITIME="122442">
    <include_source>*----------------------------------------------------------------------*
*   INCLUDE LSVIMF5E                                                   *
*----------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp;      Form  vim_make_guid
*&amp;---------------------------------------------------------------------*
*       Sets GUID values in a dataset. Only used if a new entry is
*       created. If p_viewfield is set, only one GUID is filled.
*----------------------------------------------------------------------*
*  --&gt;  p_viewfield   Name of GUID field in table/view
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM vim_make_guid USING p_viewfield TYPE viewfield.

  DATA: fieldname TYPE fnam_____4,
        old_guid TYPE REF TO data.
  FIELD-SYMBOLS: &lt;x_namtab&gt; TYPE vimnamtab, &lt;guid&gt; TYPE ANY,
                 &lt;old_guid&gt; TYPE ANY, &lt;work_area&gt; TYPE ANY.

  IF p_viewfield = space.
* set all GUIDs in structure
    LOOP AT x_namtab ASSIGNING &lt;x_namtab&gt; WHERE keyflag = space
     AND bastabname &lt;&gt; x_header-texttab AND domname IN vim_guid_domain.
* non-key and non-textfields only
      CONCATENATE x_header-maintview &lt;x_namtab&gt;-viewfield
       INTO fieldname SEPARATED BY &apos;-&apos;.
      ASSIGN (fieldname) TO &lt;guid&gt; CASTING TYPE (fieldname).
      IF &lt;status&gt;-prof_found = vim_pr_into_view
* importing BC-set manually
       OR vim_import_profile &lt;&gt; space
* importing BC-set in background
       OR vim_special_mode = vim_upgrade.
* importing from remote system/client
        CHECK &lt;guid&gt; IS INITIAL.
      ENDIF.
      CREATE DATA old_guid TYPE (fieldname).
      ASSIGN old_guid-&gt;* TO &lt;old_guid&gt;.
      CASE &lt;x_namtab&gt;-domname.
        WHEN &apos;SYSUUID&apos;.
          ASSIGN (fieldname) TO &lt;guid&gt; CASTING TYPE guid_16.
          MOVE &lt;guid&gt; TO &lt;old_guid&gt;.
          CALL FUNCTION &apos;GUID_CREATE&apos;
               IMPORTING
                    ev_guid_16 = &lt;guid&gt;.
        WHEN &apos;SYSUUID_C&apos;.
          ASSIGN (fieldname) TO &lt;guid&gt; CASTING TYPE guid_32.
          MOVE &lt;guid&gt; TO &lt;old_guid&gt;.
          CALL FUNCTION &apos;GUID_CREATE&apos;
               IMPORTING
                    ev_guid_32 = &lt;guid&gt;.
        WHEN &apos;SYSUUID_22&apos;.
          ASSIGN (fieldname) TO &lt;guid&gt; CASTING TYPE guid_22.
          MOVE &lt;guid&gt; TO &lt;old_guid&gt;.
          CALL FUNCTION &apos;GUID_CREATE&apos;
               IMPORTING
                    ev_guid_22 = &lt;guid&gt;.
        WHEN &apos;SYSUUID_25&apos;.
          ASSIGN (fieldname) TO &lt;guid&gt; CASTING TYPE rssguid25.
          MOVE &lt;guid&gt; TO &lt;old_guid&gt;.
          CALL FUNCTION &apos;RSS_SYSTEM_GET_UNIQUE_ID&apos;
               IMPORTING
                    e_uni_idc25 = &lt;guid&gt;.
      ENDCASE.
      IF x_header-frm_af_uid &lt;&gt; space.
        ASSIGN (x_header-maintview) TO &lt;work_area&gt;
         CASTING TYPE (x_header-maintview).
        PERFORM (x_header-frm_af_uid) IN PROGRAM (x_header-fpoolname)
                                      USING &lt;old_guid&gt;
                                      CHANGING &lt;guid&gt;
                                               &lt;work_area&gt;.
      ENDIF.
    ENDLOOP.
  ELSE.
* set GUID for p_viewfield only
    READ TABLE x_namtab ASSIGNING &lt;x_namtab&gt;
     WITH KEY viewfield = p_viewfield.
    CHECK sy-subrc = 0 AND &lt;x_namtab&gt;-domname IN vim_guid_domain.
* non-key and non-textfields only
    CONCATENATE x_header-maintview &lt;x_namtab&gt;-viewfield
     INTO fieldname SEPARATED BY &apos;-&apos;.
    ASSIGN (fieldname) TO &lt;guid&gt; CASTING TYPE (fieldname).
    IF &lt;status&gt;-prof_found = vim_pr_into_view
* importing BC-set manually
     OR vim_import_profile &lt;&gt; space
* importing BC-set in background
     OR vim_special_mode = vim_upgrade.
* importing from remote system/client
      CHECK &lt;guid&gt; IS INITIAL.
    ENDIF.
    CREATE DATA old_guid TYPE (fieldname).
    ASSIGN old_guid-&gt;* TO &lt;old_guid&gt;.
    CASE &lt;x_namtab&gt;-domname.
      WHEN &apos;SYSUUID&apos;.
        ASSIGN (fieldname) TO &lt;guid&gt; CASTING TYPE guid_16.
        MOVE &lt;guid&gt; TO &lt;old_guid&gt;.
        CALL FUNCTION &apos;GUID_CREATE&apos;
             IMPORTING
                  ev_guid_16 = &lt;guid&gt;.
      WHEN &apos;SYSUUID_C&apos;.
        ASSIGN (fieldname) TO &lt;guid&gt; CASTING TYPE guid_32.
        MOVE &lt;guid&gt; TO &lt;old_guid&gt;.
        CALL FUNCTION &apos;GUID_CREATE&apos;
             IMPORTING
                  ev_guid_32 = &lt;guid&gt;.
      WHEN &apos;SYSUUID_22&apos;.
        ASSIGN (fieldname) TO &lt;guid&gt; CASTING TYPE guid_22.
        MOVE &lt;guid&gt; TO &lt;old_guid&gt;.
        CALL FUNCTION &apos;GUID_CREATE&apos;
             IMPORTING
                  ev_guid_22 = &lt;guid&gt;.
      WHEN &apos;SYSUUID_25&apos;.
        ASSIGN (fieldname) TO &lt;guid&gt; CASTING TYPE rssguid25.
        MOVE &lt;guid&gt; TO &lt;old_guid&gt;.
        CALL FUNCTION &apos;RSS_SYSTEM_GET_UNIQUE_ID&apos;
             IMPORTING
                  e_uni_idc25 = &lt;guid&gt;.
    ENDCASE.
    IF x_header-frm_af_uid &lt;&gt; space.
      ASSIGN (x_header-maintview) TO &lt;work_area&gt;
       CASTING TYPE (x_header-maintview).
      PERFORM (x_header-frm_af_uid) IN PROGRAM (x_header-fpoolname)
                                    USING &lt;old_guid&gt;
                                    CHANGING &lt;guid&gt;
                                             &lt;work_area&gt;.
    ENDIF.
  ENDIF.
ENDFORM.                               &quot; vim_make_guid</include_source>
   </include>
   <include NAME="LSVIMF5F" SQLX="X" VARCL="X" SUBC="I" APPL="S" CNAM="SAP" CDAT="20010205" UNAM="SAP" UDAT="20080721" VERN="000001" RSTAT="T" RMAND="000" RLOAD="D" SDATE="20080721" STIME="122442" IDATE="20080721" ITIME="122442" UCCHECK="X">
    <include_source>*----------------------------------------------------------------------*
***INCLUDE LSVIMF5F .
*----------------------------------------------------------------------*</include_source>
   </include>
   <include NAME="LSVIMF60" VARCL="X" SUBC="I" APPL="S" CNAM="SAP" CDAT="20010125" UNAM="SAP" UDAT="20080721" VERN="000004" RSTAT="T" RMAND="000" RLOAD="D" SDATE="20080721" STIME="122442" IDATE="20080721" ITIME="122442" UCCHECK="X">
    <include_source>*&amp;---------------------------------------------------------------------*
*&amp;  Include           LSVIMF60                                         *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp;      Form  vim_maintain_single_set
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM vim_maintain_single_set.
  Data: msgno like sy-msgno,
        client_key_field_only(1) type c.

  IF vim_single_entry_function EQ space AND
     ( function NE &apos;DELE&apos; AND function NE &apos;SAVE&apos; ).       &quot;HWR
      IF vim_oc_inst IS INITIAL.
        msgno = &apos;005&apos;.
      ELSE.
        READ TABLE dpl_sellist WITH KEY from_auth = space
         TRANSPORTING NO FIELDS.
        IF sy-subrc = 0.
          msgno = &apos;005&apos;.
        ELSE.
          msgno = &apos;766&apos;.
*   Eingeschränkte Anzeige von Datensätzen.
        ENDIF.
      ENDIF.
    PERFORM vim_send_sv005_or_sv766 USING msgno
                                          &apos;SENDIT&apos;.
  ENDIF.                                                  &quot;HWR
  IF status-type EQ zweistufig AND function NE &apos;ABR &apos;
     AND function NE &apos;KOPF&apos;
     AND function NE &apos;IGN &apos;.&quot;SW: nicht ex. Status ZCDGM (1211787/98)
    &lt;status&gt;-firstline = &lt;status&gt;-cur_line = nextline.
    function = &apos;DETA&apos;.
    IF x_header-delmdtflag NE space.
      TRANSLATE vim_no_mainkey_exists USING
                                        vim_no_mkey_not_procsd_patt.
    ENDIF.
*   Modify EXCL_CUA_FUNCT to remove the &quot;new entries&quot; and &quot;copy entry&quot;
*   functions only in the case of a view with Client as a key field and
*   no other key fields.
    client_key_field_only = &apos;X&apos;.                          &quot;IG 953007
    LOOP AT x_namtab WHERE keyflag EQ &apos;X&apos;
                       AND datatype NE &apos;CLNT&apos;.
      client_key_field_only = &apos; &apos;.
      EXIT.
    ENDLOOP.
    IF client_key_field_only EQ &apos;X&apos;.
      IF &lt;status&gt;-st_action EQ &apos;U&apos; OR &lt;status&gt;-st_action EQ &apos;A&apos;.
        MOVE &apos;NEWL&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
        MOVE &apos;KOPE&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
        MOVE &apos;PREV&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
        MOVE &apos;NEXT&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
      ENDIF.
    ENDIF.
    PERFORM process_detail_screen USING &apos;S&apos;.
  ENDIF.
ENDFORM.                    &quot; vim_maintain_single_set
*&amp;---------------------------------------------------------------------*
*&amp;      Form  vim_send_sv005_or_sv766
*&amp;---------------------------------------------------------------------*
*       Send messages only once unless status has not been resetted
*----------------------------------------------------------------------*
*      --&gt;P_MSGNO Message number to be sent as s-message
*      --&gt;P_MODE  SENDIT: Send S-Message if it hasn&apos;t been sent before.
*                 RESET:  Reset status.
*----------------------------------------------------------------------*
FORM vim_send_sv005_or_sv766  USING p_msgno like sy-msgno
                                    p_mode TYPE char6.

  STATICS: sent_already TYPE xfeld,
           viewname TYPE viewname.

  IF viewname &lt;&gt; x_header-viewname.
    viewname = x_header-viewname.
    CLEAR sent_already.
  ENDIF.
  CASE p_mode.
    WHEN &apos;SENDIT&apos;.
      CHECK sent_already = space.
      sent_already = &apos;X&apos;.
      MESSAGE ID &apos;SV&apos; TYPE &apos;S&apos; NUMBER p_msgno.
    WHEN &apos;RESET&apos;.
      CLEAR sent_already.
  ENDCASE.
ENDFORM.                    &quot; vim_send_sv005_or_sv766</include_source>
   </include>
   <include NAME="LSVIMF61" VARCL="X" SUBC="I" APPL="S" CNAM="SAP" CDAT="20010205" UNAM="SAP" UDAT="20080721" VERN="000005" RSTAT="T" RMAND="000" RLOAD="D" SDATE="20080721" STIME="122442" IDATE="20080721" ITIME="122442" UCCHECK="X">
    <include_source>*&amp;---------------------------------------------------------------------*
*&amp;  Include           LSVIMF61
**&amp;---------------------------------------------------------------------
*
*&amp;---------------------------------------------------------------------*
*&amp;      Form  MAP_TEXTTABKEY_TO_VIEWKEY
*&amp;---------------------------------------------------------------------*
* Texttabellen-Schlüssel aus Transportauftrag in zugehörigen
* View-/Primärtabellenschlüssel transformieren
*----------------------------------------------------------------------*
* --&gt; NAMTAB
* --&gt; HEADER
* --&gt; TEXTTABKEY     Importschlüssel der Texttabelle
*$$$ Release 5.0: included in HEADER $$$
* --&gt; SPRASFDPOS     Offset des Sprachenschlüssels
*$$$
* --&gt; TEXTTAB_KEYLEN Länge des zu berücksichtigenden Schlüsselteils
*                    (i.A. tatsächliche Schlüssellänge,
*                    bei generischem Transport: nichtgen. Schlüsselteil)
* --&gt; IS_GENERIC_KEY &apos;X&apos; =&gt; Texttabellen-Schlüssel is generisch
*
* &lt;-- VIEWKEY        View/Primärtabellenschlüssel
* &lt;-- MAP_ERROR      &apos;X&apos; -&gt; Fehler bei der Abb., VIEWKEY nicht gefüllt
*                    (nur bei GENKEY = &apos;X&apos; relevant)
*----------------------------------------------------------------------*
FORM map_texttabkey_to_viewkey TABLES namtab STRUCTURE vimnamtab
                               USING  header TYPE vimdesc
                                      texttabkey TYPE x
                                      texttab_keylen TYPE syfleng
                                      is_generic_key TYPE xfeld
                               CHANGING viewkey TYPE x
                                        map_error.
  DATA: o1 TYPE i, o2 TYPE i,
        t_keylen TYPE i, l TYPE i, h_viewkey TYPE tabl8000.
  FIELD-SYMBOLS: &lt;namtab&gt; TYPE vimnamtab,
                 &lt;texttab_struc&gt; TYPE ANY,
                 &lt;texttab_fld&gt; TYPE ANY,
                 &lt;txt_struc&gt; TYPE ANY,
                 &lt;viewfld&gt; TYPE ANY.

  CLEAR: map_error, viewkey.

  ASSIGN: texttabkey TO &lt;texttab_struc&gt; CASTING TYPE (header-texttab),
          h_viewkey TO &lt;txt_struc&gt; CASTING TYPE (header-maintview).
  MOVE viewkey TO h_viewkey.
  IF is_generic_key = space.
*  IF is_generic_key = space.
    LOOP AT namtab ASSIGNING &lt;namtab&gt;
      WHERE keyflag &lt;&gt; space AND txttabfldn &lt;&gt; space.
      ASSIGN: COMPONENT &lt;namtab&gt;-viewfield OF STRUCTURE &lt;txt_struc&gt;
               TO &lt;viewfld&gt;,
              COMPONENT &lt;namtab&gt;-txttabfldn
               OF STRUCTURE &lt;texttab_struc&gt; TO &lt;texttab_fld&gt;.
      &lt;viewfld&gt; = &lt;texttab_fld&gt;.
    ENDLOOP.
* &quot;HCG HW723732 fill additional view-keyfields with dataset value
* CustMSG 20963/2004 otherwise # will be stored in these view-keyfields
    IF header-bastab NE &apos;X&apos;.             &quot;Only neccessary in view case
      LOOP AT namtab ASSIGNING &lt;namtab&gt;
           WHERE keyflag &lt;&gt; space AND txttabfldn EQ space.
        ASSIGN: COMPONENT &lt;namtab&gt;-viewfield OF STRUCTURE &lt;txt_struc&gt;
                 TO &lt;viewfld&gt;.
*  value for additional view-keyfield must specified unique in sellist
*  otherwise SE11 view-definition is wrong
        READ TABLE dba_sellist WITH KEY viewfield = &lt;namtab&gt;-viewfield.
        MOVE dba_sellist-value TO &lt;viewfld&gt;.
      ENDLOOP.
    ENDIF.
  ELSE.
    IF header-sprasfdpos &lt; texttab_keylen.
* Sprache im nichtgen. Teil
      t_keylen = texttab_keylen - vim_spras_length.
    ELSE.
      t_keylen = texttab_keylen.
    ENDIF.
    LOOP AT namtab ASSIGNING &lt;namtab&gt;
*      WHERE keyflag = space AND texttabfld = &apos;X&apos;.
      WHERE keyflag &lt;&gt; space AND txttabfldn &lt;&gt; space.
      o1 = &lt;namtab&gt;-position + &lt;namtab&gt;-flength.
      o2 = &lt;namtab&gt;-texttabpos + &lt;namtab&gt;-flength.
      ASSIGN: COMPONENT &lt;namtab&gt;-viewfield OF STRUCTURE &lt;txt_struc&gt;
               TO &lt;viewfld&gt;,
              COMPONENT &lt;namtab&gt;-txttabfldn
               OF STRUCTURE &lt;texttab_struc&gt; TO &lt;texttab_fld&gt;.
      IF o1 &lt;= t_keylen AND o2 &lt;= texttab_keylen.
        &lt;viewfld&gt; = &lt;texttab_fld&gt;.
      ELSEIF o1 &gt; t_keylen AND o2 &gt; texttab_keylen. &quot;gen. Teil
        IF &lt;namtab&gt;-position &lt; t_keylen
         AND &lt;namtab&gt;-texttabpos &lt; texttab_keylen
         AND &apos;CNDT&apos; CS &lt;namtab&gt;-inttype.
          l = ( texttab_keylen - &lt;namtab&gt;-texttabpos )
              DIV cl_abap_char_utilities=&gt;charsize.
          &lt;viewfld&gt;(l) = &lt;texttab_fld&gt;(l).
        ENDIF.
      ELSE.
        map_error = &apos;X&apos;. EXIT.
      ENDIF.
    ENDLOOP.
  ENDIF.
  MOVE h_viewkey TO viewkey.
*  LOOP AT namtab WHERE keyflag = &apos;X&apos; AND txttabfldn &lt;&gt; space.
*    IF is_generic_key = space.
*      viewkey+namtab-position(namtab-flength) =
*         texttabkey+namtab-texttabpos(namtab-flength).
*    ELSE.
*      IF sprasfdpos &lt; texttab_keylen.   &quot;Sprache im nichtgen. Teil
*        t_keylen = texttab_keylen - vim_spras_length.
*      ELSE.
*        t_keylen = texttab_keylen.
*      ENDIF.
*      o1 = namtab-position + namtab-flength.
*      o2 = namtab-texttabpos + namtab-flength.
*      IF o1 &lt;= t_keylen AND o2 &lt;= texttab_keylen.
*        viewkey+namtab-position(namtab-flength) =
*          texttabkey+namtab-texttabpos(namtab-flength).
*      ELSEIF o1 &gt; t_keylen AND o2 &gt; texttab_keylen. &quot;gen. Teil
*        IF namtab-position &lt; t_keylen AND
*           namtab-texttabpos &lt; texttab_keylen.
*          l = texttab_keylen - namtab-texttabpos.
*          viewkey+namtab-position(l) = texttabkey+namtab-texttabpos(l).
*        ENDIF.
*      ELSE.
*        map_error = &apos;X&apos;. EXIT.
*      ENDIF.
*    ENDIF.
*  ENDLOOP.
ENDFORM.                    &quot; MAP_TEXTTABKEY_TO_VIEWKEY

*&amp;--------------------------------------------------------------------*
*&amp;      Form  MAP_VIEWKEY_TO_TEXTTABKEY                               *
*&amp;--------------------------------------------------------------------*
* Schlüssel von Texttabelle anhand des View-/Tabellenschlüssels und
* der Sprache zusammensetzen
*&amp;--------------------------------------------------------------------*
* --&gt; X_NAMTAB
* --&gt; VIEW_WA  WA of view                                             *
* --&gt; SPRAS    Sprachschlüssel                                        *
* &lt;-- TEXT_WA  Key of text table                                      *
*&amp;--------------------------------------------------------------------*
FORM map_viewkey_to_texttabkey TABLES namtab STRUCTURE vimnamtab
                                USING header TYPE vimdesc
                                      spras LIKE t002-spras
                                      view_wa TYPE x
                             CHANGING text_wa TYPE x.

  DATA: align TYPE f,
        h_view_wa TYPE tabl8000,
        h_texttab_wa TYPE tabl8000.

  FIELD-SYMBOLS: &lt;namtab&gt; TYPE vimnamtab,
                 &lt;texttab_struc&gt; TYPE ANY,
                 &lt;texttab_fld&gt; TYPE ANY,
                 &lt;view_struc&gt; TYPE ANY,
                 &lt;viewfld&gt; TYPE ANY.

  ASSIGN h_texttab_wa TO &lt;texttab_struc&gt; CASTING TYPE (header-texttab).
  MOVE: text_wa TO h_texttab_wa,
        view_wa TO h_view_wa.
* Sprachschlüssel
  ASSIGN COMPONENT header-sprasfield OF STRUCTURE &lt;texttab_struc&gt;
   TO &lt;texttab_fld&gt;.
  &lt;texttab_fld&gt; = spras.
*  text_wa+spras_pos(vim_spras_length) = spras.
* Schlüsselfelder der Text-Tabelle
  ASSIGN: h_view_wa(header-tablen) TO &lt;view_struc&gt;
             CASTING TYPE (header-maintview).
  LOOP AT namtab ASSIGNING &lt;namtab&gt;
    WHERE txttabfldn &lt;&gt; space AND keyflag &lt;&gt; space.
    ASSIGN: COMPONENT &lt;namtab&gt;-viewfield OF STRUCTURE &lt;view_struc&gt;
             TO &lt;viewfld&gt;,
            COMPONENT &lt;namtab&gt;-txttabfldn
             OF STRUCTURE &lt;texttab_struc&gt; TO &lt;texttab_fld&gt;.
    &lt;texttab_fld&gt; = &lt;viewfld&gt;.
  ENDLOOP.
  MOVE h_texttab_wa TO text_wa.
*  LOOP AT namtab WHERE txttabfldn &lt;&gt; space AND keyflag &lt;&gt; space.
*    text_wa+namtab-texttabpos(namtab-flength) =
*         view_wa+namtab-position(namtab-flength).
*  ENDLOOP.
ENDFORM.                               &quot; MAP_VIEWKEY_TO_TEXTTABKEY</include_source>
   </include>
   <include NAME="LSVIMF62" SQLX="X" VARCL="X" SUBC="I" APPL="S" CNAM="SAP" CDAT="20010424" UNAM="SAP" UDAT="20080721" VERN="000003" RSTAT="T" RMAND="000" RLOAD="D" SDATE="20080721" STIME="122442" IDATE="20080721" ITIME="122442" UCCHECK="X">
    <include_source>*----------------------------------------------------------------------*
***INCLUDE LSVIMF62 .
*----------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp;      Form  vim_get_trspkeylen
*&amp;---------------------------------------------------------------------*
*       Delivers key length in bytes of tables whithin a view. Called
*       by generated forms CORR_MAINT_yxz
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM vim_get_trspkeylen USING    p_tabname TYPE tabname
                        CHANGING p_keylength TYPE syfleng.

  TYPES: BEGIN OF tabkeylen_type,
          tabname TYPE tabname,
          keylen TYPE syfleng,
         END OF tabkeylen_type.
  STATICS: tabkeylen_tab TYPE HASHED TABLE OF tabkeylen_type
            WITH UNIQUE KEY tabname.
  DATA: w_tabkeylen TYPE tabkeylen_type,
        x030l_wa TYPE x030l.

  READ TABLE tabkeylen_tab INTO w_tabkeylen
   WITH TABLE KEY tabname = p_tabname.
  IF sy-subrc &lt;&gt; 0.
    CALL FUNCTION &apos;DDIF_NAMETAB_GET&apos;
      EXPORTING
        tabname  = p_tabname
      IMPORTING
        x030l_wa = x030l_wa.
    w_tabkeylen-tabname = p_tabname.
    w_tabkeylen-keylen  = x030l_wa-keylen.
    IF p_tabname = x_header-texttab AND x_header-genertxtrp &lt;&gt; space.
      w_tabkeylen-keylen = x_header-maxtrtxkln.
    ELSEIF x_header-generictrp &lt;&gt; space.
      w_tabkeylen-keylen = x_header-maxtrkeyln.
    ENDIF.
    INSERT w_tabkeylen INTO TABLE tabkeylen_tab.
  ENDIF.
  p_keylength = w_tabkeylen-keylen.
ENDFORM.                    &quot; vim_get_trspkeylen

*&amp;---------------------------------------------------------------------*
*&amp;      Form  vim_get_bc_keylen
*&amp;---------------------------------------------------------------------*
*       Delivers key length in bytes of tables whithin a view up to
*       255 char. Necessary for writing activation links
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM vim_get_bc_keylen USING    p_tabname TYPE tabname
                        CHANGING p_keylength TYPE syfleng.

  CONSTANTS max_bc_keylen TYPE i VALUE 255.

  TYPES: BEGIN OF tabkeylen_type,
          tabname TYPE tabname,
          keylen TYPE syfleng,
         END OF tabkeylen_type.
  STATICS: tabkeylen_tab TYPE HASHED TABLE OF tabkeylen_type
            WITH UNIQUE KEY tabname.
  DATA: w_tabkeylen TYPE tabkeylen_type,
        x030l_wa TYPE x030l, max_keylen_byte TYPE i.

  READ TABLE tabkeylen_tab INTO w_tabkeylen
   WITH TABLE KEY tabname = p_tabname.
  IF sy-subrc &lt;&gt; 0.
    CALL FUNCTION &apos;DDIF_NAMETAB_GET&apos;
      EXPORTING
        tabname  = p_tabname
      IMPORTING
        x030l_wa = x030l_wa.
    w_tabkeylen-tabname = p_tabname.
    w_tabkeylen-keylen  = x030l_wa-keylen.
    max_keylen_byte = max_bc_keylen * cl_abap_char_utilities=&gt;charsize.
    IF w_tabkeylen-keylen &gt; max_keylen_byte.
      w_tabkeylen-keylen = max_keylen_byte.
    ENDIF.
    INSERT w_tabkeylen INTO TABLE tabkeylen_tab.
  ENDIF.
  p_keylength = w_tabkeylen-keylen.
ENDFORM.                    &quot; vim_get_bc_keylen</include_source>
   </include>
   <include NAME="LSVIMF63" SQLX="X" VARCL="X" SUBC="I" APPL="S" CNAM="SAP" CDAT="20011113" UNAM="SAP" UDAT="20080721" VERN="000001" RSTAT="T" RMAND="000" RLOAD="D" SDATE="20080721" STIME="122442" IDATE="20080721" ITIME="122442" UCCHECK="X">
    <include_source>*----------------------------------------------------------------------*
***INCLUDE LSVIMF63 .
*----------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp;      Form  vim_comp_roottabkey
*&amp;---------------------------------------------------------------------*
*       Check if view and root table have identical keys.
*----------------------------------------------------------------------*
*      --&gt;P_HEADER  text
*      --&gt;P_NAMTAB  text
*      &lt;--P_KEYS_IDENTICAL  text
*      &lt;--P_RC  text
*----------------------------------------------------------------------*
FORM vim_comp_roottabkey  USING    p_header TYPE vimdesc
                                   p_namtab TYPE vimnamtab_type
                          CHANGING p_keys_identical TYPE xfeld
                                   p_rc TYPE sy-subrc.
  TYPES: BEGIN OF flagstruc_type,
          viewname TYPE viewname,
          keys_ident,
         END OF flagstruc_type.

  STATICS: flagtab TYPE HASHED TABLE OF flagstruc_type
           WITH UNIQUE KEY viewname.
  DATA: w_flagtab TYPE flagstruc_type,
        x031l_tab TYPE TABLE OF x031l.
  FIELD-SYMBOLS: &lt;namtab&gt; TYPE vimnamtab,
                 &lt;x031l&gt; TYPE x031l.

  CLEAR p_rc.
  READ TABLE flagtab WITH TABLE KEY viewname = p_header-viewname
   INTO w_flagtab.
  IF sy-subrc &lt;&gt; 0.
    w_flagtab-viewname = p_header-viewname.
    w_flagtab-keys_ident = &apos;X&apos;.
    CALL FUNCTION &apos;DDIF_NAMETAB_GET&apos;
      EXPORTING
        tabname   = p_header-roottab
      TABLES
        x031l_tab = x031l_tab
      EXCEPTIONS
        OTHERS    = 2.
    IF sy-subrc &lt;&gt; 0.
      p_rc = sy-subrc.
    ENDIF.
    LOOP AT p_namtab ASSIGNING &lt;namtab&gt; WHERE keyflag = &apos;X&apos;.
      IF &lt;namtab&gt;-bastabname &lt;&gt; p_header-roottab.
        sy-subrc = 4.
      ELSE.
        READ TABLE x031l_tab INDEX sy-tabix ASSIGNING &lt;x031l&gt;.
      ENDIF.
      IF sy-subrc &lt;&gt; 0 OR &lt;x031l&gt;-fieldname &lt;&gt; &lt;namtab&gt;-bastabfld.
        clear w_flagtab-keys_ident.
        exit.
      ENDIF.
    ENDLOOP.
    INSERT w_flagtab INTO TABLE flagtab.
  ENDIF.
  p_keys_identical = w_flagtab-keys_ident.
ENDFORM.                    &quot; vim_comp_roottabkey</include_source>
   </include>
   <include NAME="LSVIMF64" SQLX="X" VARCL="X" SUBC="I" APPL="S" CNAM="SAP" CDAT="20011113" UNAM="SAP" UDAT="20080721" VERN="000005" RSTAT="T" RMAND="000" RLOAD="D" SDATE="20080721" STIME="122442" IDATE="20080721" ITIME="122442" UCCHECK="X">
    <include_source>*----------------------------------------------------------------------*
***INCLUDE LSVIMF64 .
*----------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp;      Form  vim_synchronizer_call
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_CU_KO200_TAB[]  text
*      --&gt;P_CORR_KEYTAB[]  text
*      --&gt;P_SPACE  text
*----------------------------------------------------------------------*
FORM vim_synchronizer_call  USING
                                 p_cu_ko200_tab TYPE vim_ko200_tab_type
                                 p_corr_keytab TYPE tr_keys
                                 p_synchronizer_flag TYPE xfeld.

  STATICS: e071k_loc TYPE TABLE OF e071k,
          e071_loc TYPE TABLE OF e071.
  STATICS: sv_trkorr     TYPE trkorr,       &quot;VG 31 Mar 2004
           sv_at_tr_change,
           sv_project_id TYPE project_id,
           sv_strkorr    TYPE trkorr.
  DATA: e071k_loc_wa TYPE e071k,
        e071_loc_wa TYPE e071.

  IF p_synchronizer_flag = space.
    CLEAR: e071k_loc, e071_loc.
    REFRESH: e071k_loc, e071_loc.
    LOOP AT p_corr_keytab INTO e071k_loc_wa.
      APPEND e071k_loc_wa TO e071k_loc.
    ENDLOOP.
    LOOP AT p_cu_ko200_tab INTO e071_loc_wa.
      APPEND e071_loc_wa TO e071_loc.
    ENDLOOP.
  ELSE.
    READ TABLE e071k_loc INDEX 1 INTO e071k_loc_wa.
*----------------------------------------------------------------------
* Signal for Wulf Kruempelmann&apos;s Synchronizer (data written)
    IF e071k_loc_wa-trkorr = space.
      READ TABLE p_corr_keytab INDEX 1 INTO e071k_loc_wa.
    ENDIF.    &quot;HCG p_corr_keytab-trkorr could be empty in VCL HW658985

    IF e071k_loc_wa-trkorr &lt;&gt; sv_trkorr.    &quot;VG 31 Mar 2004
      sv_trkorr = e071k_loc_wa-trkorr.
      CALL FUNCTION &apos;SCTM_CHECK_TRIGGER_METHOD_TRK&apos;
        EXPORTING
          iv_trkorr              = e071k_loc_wa-trkorr
        IMPORTING
*         EV_AT_TR_RELEASE       =
          ev_at_tr_change        = sv_at_tr_change
*         EV_POLLING             =
*         EV_NO_SYNC             =
*         EV_IS_TARGET           =
          ev_project_id          = sv_project_id
          ev_strkorr             = sv_strkorr.
    ENDIF.
    CHECK sv_at_tr_change = &apos;X&apos;.

    CALL FUNCTION &apos;SCDC_DISTRIBUTE_TABLE_KEYS&apos;
      EXPORTING
        project_id = sv_project_id
        trkorr     = sv_strkorr
      TABLES
        e071_tab   = e071_loc
        e071k_tab  = e071k_loc
      EXCEPTIONS
        no_project = 1
        OTHERS     = 2.
    IF sy-subrc &lt;&gt; 0.
* MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*         WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
    ENDIF.
*----------------------------------------------------------------------
  ENDIF.
ENDFORM.                    &quot; vim_synchronizer_call
*&amp;---------------------------------------------------------------------*
*&amp;      Form  check_sync_key_lock
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      &lt;--P_VIM_SYNC_KEY_LOCK  text
*----------------------------------------------------------------------*
FORM check_sync_key_lock USING p_check_all
                         CHANGING p_vim_sync_key_lock.

  DATA:    keytab_loc TYPE TABLE OF tbl8096,
           keytab_wa LIKE LINE OF keytab_loc,
           allowed_keys TYPE TABLE OF tbl8096,
           n TYPE i, viewtype.
  DATA:    sctm_fill_cache TYPE oax.
  STATICS: old_viewname TYPE vimdesc-viewname.

  CHECK &lt;xact&gt; NE &apos;L&apos;. &quot;Avoids empty checks on add new entry in list
  IF x_header-bastab EQ space.
    viewtype = &apos;V&apos;.
  ELSE.
    viewtype = &apos;S&apos;.
  ENDIF.
  IF p_check_all EQ space.                           &quot;check entry
    REFRESH keytab_loc.
    REFRESH allowed_keys.
    keytab_wa-line = &lt;vim_xextract&gt;.
    CLEAR sctm_fill_cache.
    IF &lt;xact&gt; NE space.
      sctm_fill_cache = &apos;X&apos;.
    ENDIF.
    APPEND keytab_wa TO keytab_loc.          &quot;Table with 1 line only to
    CALL FUNCTION &apos;SCTM_CHECK_VIEW_KEY&apos; &quot;grey out locked data in screen
      EXPORTING
        viewname              = x_header-viewname
        viewtype              = viewtype
        bcset                 = vim_bcset_id  &quot;if NE space: BC-set act
        fill_cache            = sctm_fill_cache
*     IMPORTING               &quot;HCG: Already set in justify_action_mode
*       EDIT_FLAG           = vim_sync_edit_lock
*       KESPEC_FLAG         = vim_sync_keyspec_check
      TABLES
        query_tab             = keytab_loc
        allowed_tab           = allowed_keys
      EXCEPTIONS
        no_sync_present       = 1
        old_sync_system       = 2
        OTHERS                = 3.
    IF sy-subrc &lt;&gt; 0.     &quot;Ignore check_result but no message to user
*       MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*                WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
      CLEAR p_vim_sync_key_lock.          &quot;If no connection: open all
    ELSE.
      DESCRIBE TABLE allowed_keys LINES n.
      IF n EQ 0.
        p_vim_sync_key_lock = &apos;X&apos;.
      ELSE.
        CLEAR p_vim_sync_key_lock.
      ENDIF.
    ENDIF.
  ELSEIF old_viewname NE x_header-viewname.
    old_viewname = x_header-viewname.&quot;Just fill cache in sync, no check
    REFRESH keytab_loc.
    REFRESH allowed_keys.
    LOOP AT total.                                          &quot;#EC *
      keytab_wa-line = &lt;vim_xtotal&gt;.
      APPEND keytab_wa TO keytab_loc.                &quot;Provide all data
    ENDLOOP.
    CALL FUNCTION &apos;SCTM_CHECK_VIEW_KEY&apos;
      EXPORTING
        viewname              = x_header-viewname
        viewtype              = viewtype
        bcset                 = vim_bcset_id  &quot;if NE space: BC-set act
        fill_cache            = &apos;X&apos;    &quot;fill cache for first call
*     IMPORTING               &quot;HCG: Already set in justify_action_mode
*       EDIT_FLAG           = vim_sync_edit_lock
*       KESPEC_FLAG         = vim_sync_keyspec_check
      TABLES
        query_tab             = keytab_loc
        allowed_tab           = allowed_keys
      EXCEPTIONS
        no_sync_present       = 1
        old_sync_system       = 2
        OTHERS                = 3.
    IF sy-subrc &lt;&gt; 0.     &quot;Ignore check_result but no message to user
*       MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*                WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
    ENDIF.
  ENDIF.
ENDFORM.                    &quot; check_sync_key_lock</include_source>
   </include>
   <include NAME="LSVIMF65" VARCL="X" SUBC="I" APPL="S" CNAM="SAP" CDAT="20011113" UNAM="SAP" UDAT="20080721" VERN="000002" RSTAT="T" RMAND="000" RLOAD="D" SDATE="20080721" STIME="122442" IDATE="20080721" ITIME="122442" UCCHECK="X">
    <include_source>*&amp;---------------------------------------------------------------------*
*&amp;  Include           LSVIMF65                                         *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp;      Form  check_nonkey
*&amp;---------------------------------------------------------------------*
*       to check selection condiotions for nonkey fields only
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
FORM check_nonkey.


  FIELD-SYMBOLS: &lt;table1_txt_loc&gt; TYPE ANY.


  IF x_header-bastab &lt;&gt; space AND x_header-texttbexst &lt;&gt; space.
    ASSIGN &lt;table1_text&gt; TO &lt;table1_txt_loc&gt;.
  ELSE.
    ASSIGN &lt;table1&gt; TO &lt;table1_txt_loc&gt;.
  ENDIF.
  CALL FUNCTION &apos;TABLE_RANGE_CHECK&apos;
    EXPORTING
      tabname                   = x_header-maintview
      entry                     = &lt;table1&gt;
      entry_text                = &lt;table1_txt_loc&gt;
      ddic                      = &apos;J&apos;
      key                       = &apos;F&apos;
      ignore_blank_subsetfields = &apos;N&apos;
    TABLES
      x_namtab                  = x_namtab
      x_header                  = x_header
      sellist                   = &lt;vim_ck_sellist&gt;
    EXCEPTIONS
      entry_not_fits            = 1.
  IF sy-subrc EQ 1.
*    PERFORM set_pf_status USING &apos;ERROR&apos;.
    MESSAGE w174(sv).
  ENDIF.
ENDFORM.        &quot;check_nonkey</include_source>
   </include>
   <include NAME="LSVIMFL1" VARCL="X" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981027" UNAM="SAP" UDAT="20080721" VERN="000010" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122442" IDATE="20080721" ITIME="122442">
    <include_source>*----------------------------------------------------------------------*
*   INCLUDE LSVIMFL1
**----------------------------------------------------------------------
*
*---------------------------------------------------------------------*
*       FORM VIM_GET_TEXTTAB_DATA                                     *
*---------------------------------------------------------------------*
* Texteinträge von der DB nachlesen für angeg. Sprachen               *
* UFProbl251070/1998: Falls X_NAMTAB-Reihenfolge nicht mit
*                     DBA-SELLIST-Reihenfolge übereinstimmt, werden
*                     ANDs oder ORs verschluckt.
*---------------------------------------------------------------------*
*  --&gt; LANGUS         ausgewählte Sprachen
* &lt;--&gt; TEXTTAB
*---------------------------------------------------------------------*
FORM vim_get_texttab_data TABLES langus STRUCTURE h_t002
                          CHANGING texttab TYPE table.
*                                  Type VIM_LINE_US/../VIM_LINE_UL
  DATA: tgd_sellist LIKE vimsellist OCCURS 10, tgd_sel LIKE vimsellist,
        wheretab_line LIKE vimwheretb,
        spras_value(3) TYPE c,
*        curr_spras(1) TYPE c,
        keylen TYPE i,
        l TYPE i, sellist_l TYPE i, tbx TYPE i,
        and_or_str(6) TYPE c, left_par(1) TYPE c,
        tmp_texttab TYPE REF TO data,
        tmp_texttab_wa TYPE REF TO data,
*        tmp_texttab TYPE vim_tab_ul WITH HEADER LINE,
        texttab_tabix LIKE sy-tabix,
        align1 type f,
        texttab_wa TYPE vim_line_ul,
        align2 type f,
        view_wa TYPE tabl8000, map_error TYPE xfeld.
  FIELD-SYMBOLS: &lt;tmp_texttab&gt; TYPE STANDARD TABLE,
                 &lt;tmp_texttab_wa&gt; TYPE ANY, &lt;tmp_texttab_wax&gt; TYPE x,
                 &lt;view_key&gt; TYPE x, &lt;next_spras&gt; TYPE spras,
                 &lt;curr_spras&gt; TYPE spras,
                 &lt;h_texttab&gt; TYPE x, &lt;h_texttab_wa&gt; TYPE x,
                 &lt;viewkey_in_texttab&gt; TYPE x, &lt;texttab_struc&gt; TYPE ANY.

  CREATE DATA: tmp_texttab TYPE STANDARD TABLE OF (x_header-texttab),
               tmp_texttab_wa TYPE (x_header-texttab).
  ASSIGN: tmp_texttab-&gt;* TO &lt;tmp_texttab&gt;,
          tmp_texttab_wa-&gt;* TO &lt;tmp_texttab_wa&gt;,
          &lt;tmp_texttab_wa&gt; TO &lt;tmp_texttab_wax&gt; CASTING.

  IF x_header-selection NE space.
    LOOP AT dba_sellist INTO tgd_sel       &quot;UFProbl251070/1998
     WHERE value &lt;&gt; space OR initial = &apos;X&apos;.
      LOOP AT x_namtab WHERE viewfield EQ tgd_sel-viewfield
                       AND keyflag NE space AND txttabfldn NE space.
        tgd_sel-viewfield = x_namtab-txttabfldn.
        tgd_sel-tabix     = sy-tabix.
        APPEND tgd_sel TO tgd_sellist.
        EXIT.
      ENDLOOP.
    ENDLOOP.                                &quot;UFProbl251070/1998
  ENDIF.                               &quot;X_HEADER-SELECTION

  DESCRIBE TABLE tgd_sellist LINES sellist_l.
  IF sellist_l &gt; 0.
    READ TABLE tgd_sellist INDEX sellist_l INTO tgd_sel.
    IF tgd_sel-and_or NE space.
      CLEAR tgd_sel-and_or.
      MODIFY tgd_sellist INDEX sellist_l FROM tgd_sel.
    ENDIF.
    CALL FUNCTION &apos;VIEW_FILL_WHERETAB&apos;
         EXPORTING
              tablename               = x_header-texttab
              only_cnds_for_keyflds   = &apos;X&apos;
              is_texttable            = &apos;X&apos;
         TABLES
              sellist                 = tgd_sellist
              wheretab                = vim_wheretab
              x_namtab                = x_namtab
         EXCEPTIONS
              no_conditions_for_table = 01.
    IF sy-subrc = 1. sellist_l = 0. ENDIF.
  ELSE.
    REFRESH vim_wheretab.
  ENDIF.

* VIM_WHERETAB um Bedingungen für ausgew. Sprachen ergänzen
  DESCRIBE TABLE langus LINES l.
  IF l &gt; 1.
    and_or_str = &apos;OR&apos;.
    IF sellist_l &gt; 0.
      left_par = &apos;(&apos;.
    ENDIF.
  ENDIF.
  tbx = 1.
  spras_value = &apos;&apos;&apos; &apos;&apos;&apos;.
  LOOP AT langus.
    spras_value+1(1) = langus-spras.
    IF tbx = l.      &quot; letzte Zeile für Sprachselektion
      IF l &gt; 1 AND sellist_l &gt; 0.
        and_or_str = &apos; ) AND&apos;.
      ELSEIF l = 1 AND sellist_l &gt; 0.
        and_or_str = &apos; AND&apos;.
      ELSE.
        CLEAR and_or_str.
      ENDIF.
    ENDIF.
   CONCATENATE left_par x_header-sprasfield &apos;EQ&apos; spras_value and_or_str
                            INTO wheretab_line SEPARATED BY space.
    INSERT wheretab_line INTO vim_wheretab INDEX tbx.
    CLEAR left_par.
    tbx = tbx + 1.
  ENDLOOP.

  SELECT * FROM (x_header-texttab) INTO TABLE &lt;tmp_texttab&gt;
                                      WHERE (vim_wheretab).

* Texttabellen-Einträge sortiert in Texttabelle einfügen
  IF x_header-delmdtflag &lt;&gt; space AND  &quot;zeitabh. &amp; part. Fremdschl.
     x_header-ptfrkyexst  = &apos;X&apos;.       &quot;      -&gt; zeitunabh. Texttab.
    keylen = x_header-after_keyc
              - vim_datum_length * cl_abap_char_utilities=&gt;charsize.
  ELSE.
    keylen = x_header-after_keyc.
  ENDIF.
  ASSIGN: view_wa(keylen) TO &lt;view_key&gt;,
          texttab_wa TO &lt;h_texttab_wa&gt; CASTING,
          &lt;h_texttab_wa&gt;(keylen) TO &lt;viewkey_in_texttab&gt;,
          &lt;h_texttab_wa&gt;+keylen(x_header-texttablen) TO &lt;h_texttab&gt;,
          &lt;h_texttab&gt; TO &lt;texttab_struc&gt;
           CASTING TYPE (x_header-texttab),
          COMPONENT x_header-sprasfield OF STRUCTURE &lt;texttab_struc&gt;
           TO &lt;next_spras&gt;,
          COMPONENT x_header-sprasfield OF STRUCTURE &lt;tmp_texttab_wa&gt;
           TO &lt;curr_spras&gt;.
  LOOP AT &lt;tmp_texttab&gt; INTO &lt;tmp_texttab_wa&gt;.
    PERFORM map_texttabkey_to_viewkey TABLES x_namtab
                                      USING x_header
                                            &lt;tmp_texttab_wax&gt;
                                            x_header-textkeylen
                                            x_header-genertxtrp
                                      CHANGING &lt;view_key&gt;
                                               map_error.
    CHECK map_error = space.
*    PERFORM vim_fill_view_key USING tmp_texttab
*                           CHANGING &lt;view_key&gt; curr_spras.
    CLEAR texttab_wa.
    READ TABLE texttab WITH KEY &lt;view_key&gt; INTO texttab_wa
                                                        BINARY SEARCH.
    texttab_tabix = sy-tabix.
    IF sy-subrc = 0 AND
      &lt;viewkey_in_texttab&gt; = &lt;view_key&gt; AND  &quot;Text ex. in weiteren Spr
      &lt;next_spras&gt; &lt; &lt;curr_spras&gt;. &quot;#EC PORTABLE
      LOOP AT texttab FROM texttab_tabix INTO texttab_wa.
        IF &lt;viewkey_in_texttab&gt; &lt;&gt; &lt;view_key&gt; OR
           &lt;next_spras&gt; &gt;= &lt;curr_spras&gt;. &quot;#EC PORTABLE
          texttab_tabix = sy-tabix.
          EXIT.
        ELSEIF &lt;next_spras&gt; &lt; &lt;curr_spras&gt;. &quot;#EC PORTABLE
          texttab_tabix = sy-tabix + 1.
        ENDIF.
      ENDLOOP.
    ENDIF.   &quot; &lt;next_spras&gt; &gt;= &lt;curr_spras&gt; oder ex. nicht
    IF &lt;next_spras&gt; &lt;&gt; &lt;curr_spras&gt; OR
       &lt;viewkey_in_texttab&gt; &lt;&gt; &lt;view_key&gt;.  &quot;Text ex. nicht in Sprache
      CLEAR texttab_wa.
      &lt;viewkey_in_texttab&gt; = &lt;view_key&gt;.
      &lt;texttab_struc&gt; = &lt;tmp_texttab_wa&gt;.
      INSERT texttab_wa INTO texttab INDEX texttab_tabix.
    ELSE.
      &lt;texttab_struc&gt; = &lt;tmp_texttab_wa&gt;.
      MODIFY texttab FROM texttab_wa INDEX texttab_tabix.
    ENDIF.

  ENDLOOP.                             &quot; tmp_texttab
ENDFORM.                               &quot;VIM_GET_TEXTTAB_DATA

*---------------------------------------------------------------------*
*       FORM VIM_READ_TEXTTAB_ENTRY                                   *
*---------------------------------------------------------------------*
* einzelnen Texttabellen-Eintrag für alle bisher bearbeiteten         *
* Sprachen nachlesen
* Aktueller Eintrag steht in Kopfzeile von EXTRACT
*---------------------------------------------------------------------*
FORM vim_read_texttab_entry.
  DATA: texttab_wa TYPE vim_line_ul,
        texttab_tabix LIKE sy-tabix,
        keylen TYPE i,
        offset TYPE i,
        modify_texttab(1) TYPE c,
        tmp_texttab TYPE ref to data,
        w_tmp_texttab type ref to data.
  FIELD-SYMBOLS: &lt;h_texttab_wa&gt; type x,
                 &lt;viewkey_in_texttab&gt; type x,                &quot;#EC *
                 &lt;texttab_key&gt; type x,
                 &lt;texttab_fields&gt;, &lt;texttab_action&gt; type c,
                 &lt;extract_key&gt; type x,
                 &lt;tmp_texttab&gt; type standard table,
                 &lt;w_tmp_texttab&gt; type any,
                 &lt;w_tmp_texttab_x&gt; type x.

  IF x_header-delmdtflag &lt;&gt; space AND  &quot;zeitabh. &amp; part. Fremdschl.
     x_header-ptfrkyexst  = &apos;X&apos;.       &quot;      -&gt; zeitunabh. Texttab.
    ASSIGN &lt;vim_ext_mkey_beforex&gt; TO &lt;extract_key&gt;.
*    ASSIGN &lt;vim_ext_mkey_before&gt; TO &lt;extract_key&gt;.
    keylen = x_header-keylen
              - vim_datum_length * cl_abap_char_utilities=&gt;charsize.
  ELSE.
    ASSIGN &lt;vim_xextract_key&gt; TO &lt;extract_key&gt;.
     keylen = x_header-after_keyc.
*    keylen = x_header-keylen.
  ENDIF.

  READ TABLE &lt;vim_texttab&gt; WITH KEY &lt;extract_key&gt;
                           BINARY SEARCH TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    texttab_tabix = sy-tabix.
  ELSE.
    EXIT.     &quot;keine Texte zum Key in anderen Sprachen erfaßt
  ENDIF.

  ASSIGN: texttab_wa TO &lt;h_texttab_wa&gt; casting,
          &lt;h_texttab_wa&gt;+keylen(x_header-textkeylen) TO &lt;texttab_key&gt;,
          &lt;h_texttab_wa&gt;+keylen(x_header-texttablen)
           TO &lt;texttab_fields&gt;.
*  ASSIGN texttab_wa(keylen) TO &lt;viewkey_in_texttab&gt;.
*  ASSIGN texttab_wa+keylen(x_header-textkeylen) TO &lt;texttab_key&gt;.
*  ASSIGN texttab_wa+keylen(x_header-texttablen) TO &lt;texttab_fields&gt;.
  offset = ( keylen + x_header-texttablen )
           / cl_abap_char_utilities=&gt;charsize.
*  offset = keylen + x_header-texttablen.
  ASSIGN texttab_wa+offset(1) TO &lt;texttab_action&gt;.

  create data tmp_texttab type standard table of (x_header-texttab).
  create data w_tmp_texttab type (x_header-texttab).
  assign: tmp_texttab-&gt;* to &lt;tmp_texttab&gt;,
          w_tmp_texttab-&gt;* to &lt;w_tmp_texttab&gt;,
          &lt;w_tmp_texttab&gt; to &lt;w_tmp_texttab_x&gt; casting.
  LOOP AT &lt;vim_texttab&gt; FROM texttab_tabix INTO texttab_wa.
    IF &lt;viewkey_in_texttab&gt; &lt;&gt; &lt;extract_key&gt;. EXIT. ENDIF.
    IF &lt;texttab_action&gt; = neuer_eintrag.
      DELETE &lt;vim_texttab&gt;.
      modify_texttab = &apos;X&apos;.
    ELSEIF &lt;texttab_action&gt; &lt;&gt; original.
      refresh &lt;tmp_texttab&gt;.
*      REFRESH tmp_texttab.
      CALL FUNCTION &apos;DB_SELECT_GENERIC_TABLE&apos;
           EXPORTING
                genkey      = &lt;texttab_key&gt;
                genkey_ln   = x_header-textkeylen
                tablename   = x_header-texttab
           TABLES
                inttab      = &lt;tmp_texttab&gt;
*                inttab      = tmp_texttab
           EXCEPTIONS
                db_error    = 12
                not_found   = 04
                wrong_param = 08.
      IF sy-subrc &gt; 4. RAISE get_table_error. ENDIF.

      READ TABLE &lt;tmp_texttab&gt; into &lt;w_tmp_texttab&gt; INDEX 1.
*      READ TABLE tmp_texttab INDEX 1.
      IF sy-subrc = 0.
        &lt;texttab_fields&gt; = &lt;w_tmp_texttab_x&gt;(x_header-texttablen).
*        &lt;texttab_fields&gt; = tmp_texttab(x_header-texttablen).
        &lt;texttab_action&gt; = original.
        MODIFY &lt;vim_texttab&gt; FROM texttab_wa.
        modify_texttab = &apos;X&apos;.
      ELSE.                            &quot;NOT_FOUND
        DELETE &lt;vim_texttab&gt;.
        modify_texttab = &apos;X&apos;.
      ENDIF.
    ENDIF.
  ENDLOOP.
  IF modify_texttab = &apos;X&apos;.
    MODIFY vim_texttab_container INDEX vim_texttab_container_index.
    CLEAR sy-subrc.
  ELSE.
    sy-subrc = 4.
  ENDIF.
ENDFORM.                               &quot;VIM_READ_TEXTTAB_ENTRY

*---------------------------------------------------------------------*
*       FORM VIM_TEXTTAB_DB_UPD                                       *
*---------------------------------------------------------------------*
* Datenbank-Änderungen für Texttabelle (für spras &lt;&gt; SY-LANGU)        *
* Action_Flag in &lt;VIM_TEXTTAB&gt; für modif. Einträge zurücksetzen
* gelöschte Einträge aus interner Text-Tabelle löschen
*---------------------------------------------------------------------*
FORM vim_texttab_db_update.
  DATA: modified_entries TYPE i,
        texttab_modified(1) TYPE c,
        keylen TYPE i,
        offset TYPE i,
        align type f, texttab_wa TYPE vim_line_ul, &quot;HCG never separate
        tmp_texttab TYPE REF TO data,
        w_tmp_texttab TYPE REF TO data.
*        tmp_texttab TYPE vim_tab_ul WITH HEADER LINE.
  FIELD-SYMBOLS: &lt;tmp_texttab&gt; TYPE STANDARD TABLE,
                 &lt;w_tmp_texttab&gt; TYPE ANY,
                 &lt;h_texttab_wa&gt; TYPE x, &lt;h_texttab_fields&gt; TYPE x,
                 &lt;texttab_fields&gt; TYPE ANY, &lt;texttab_action&gt;.

  CLEAR texttab_modified.
  CHECK x_header-texttbexst &lt;&gt; space.
  IF x_header-delmdtflag &lt;&gt; space AND  &quot;zeitabh. &amp; part. Fremdschl.
     x_header-ptfrkyexst  = &apos;X&apos;.       &quot;      -&gt; zeitunabh. Texttab.
    keylen = x_header-after_keyc
             - vim_datum_length * cl_abap_char_utilities=&gt;charsize.
  ELSE.
    keylen = x_header-after_keyc.
  ENDIF.

  CREATE DATA: tmp_texttab TYPE STANDARD TABLE OF (x_header-texttab),
               w_tmp_texttab TYPE (x_header-texttab).
  ASSIGN: tmp_texttab-&gt;* TO &lt;tmp_texttab&gt;,
          w_tmp_texttab-&gt;* TO &lt;w_tmp_texttab&gt;,
          texttab_wa TO &lt;h_texttab_wa&gt; CASTING,
          &lt;h_texttab_wa&gt;+keylen(x_header-texttablen)
           TO &lt;h_texttab_fields&gt;,
          &lt;h_texttab_fields&gt; TO &lt;texttab_fields&gt;
           CASTING TYPE (x_header-texttab).
  offset = ( keylen + x_header-aft_txttbc )
           / cl_abap_char_utilities=&gt;charsize.
  ASSIGN texttab_wa+offset(1) TO &lt;texttab_action&gt;.

* DELETE: nur in interner Texttabelle, in DB schon bisher für alle Spr.
  LOOP AT &lt;vim_texttab&gt; INTO texttab_wa.
    CHECK &lt;texttab_action&gt; EQ geloescht OR
          &lt;texttab_action&gt; EQ neuer_geloescht OR
          &lt;texttab_action&gt; EQ update_geloescht.
    DELETE &lt;vim_texttab&gt;.
    texttab_modified = &apos;X&apos;.
  ENDLOOP.                             &quot;&lt;VIM_TEXTTAB&gt;

* UPDATE
  CLEAR modified_entries. REFRESH &lt;tmp_texttab&gt;.
  LOOP AT &lt;vim_texttab&gt; INTO texttab_wa.
    CHECK &lt;texttab_action&gt; EQ aendern.
    APPEND &lt;texttab_fields&gt; TO &lt;tmp_texttab&gt;.
*    tmp_texttab  = &lt;texttab_fields&gt;.
*    APPEND tmp_texttab.
    modified_entries = modified_entries + 1.
    &lt;texttab_action&gt; = original.
    MODIFY &lt;vim_texttab&gt; FROM texttab_wa.
  ENDLOOP.                             &quot;&lt;VIM_TEXTTAB&gt;
  IF modified_entries &gt; 0.
    UPDATE (x_header-texttab) FROM TABLE &lt;tmp_texttab&gt;.
    texttab_modified = &apos;X&apos;.
  ENDIF.

* INSERT
  CLEAR modified_entries. REFRESH &lt;tmp_texttab&gt;.
  LOOP AT &lt;vim_texttab&gt; INTO texttab_wa.
    CHECK &lt;texttab_action&gt; EQ neuer_eintrag.
    APPEND &lt;texttab_fields&gt; TO &lt;tmp_texttab&gt;.
*    tmp_texttab = &lt;texttab_fields&gt;.
*    APPEND tmp_texttab.
    modified_entries = modified_entries + 1.
    &lt;texttab_action&gt; = original.
    MODIFY &lt;vim_texttab&gt; FROM texttab_wa.
  ENDLOOP.                             &quot;&lt;VIM_TEXTTAB&gt;
  IF modified_entries &gt; 0.
    INSERT (x_header-texttab) FROM TABLE &lt;tmp_texttab&gt;
           ACCEPTING DUPLICATE KEYS. &quot;um RABAX bei unzulässigem
    &quot;Texttab-Aufbau zu vermeiden
    texttab_modified = &apos;X&apos;.
  ENDIF.

  IF texttab_modified = &apos;X&apos;.
    MODIFY vim_texttab_container INDEX vim_texttab_container_index.
  ENDIF.
ENDFORM.                               &quot;VIM_TEXTTAB_DB_UPDATE

* Import für Texte in anderen Sprachen                      &quot;Textimp ...
*---------------------------------------------------------------------*
*       FORM VIM_READ_TEXTTAB_ALL_LANGUS                              *
*---------------------------------------------------------------------*
* Texteinträge von der DB für alle Sprachen einlesen.                 *
*---------------------------------------------------------------------*
FORM vim_read_texttab_all_langus.
  DATA: langus_selected(1) TYPE c,
        curr_sptxt LIKE t002t-sptxt,
        sel_langus LIKE h_t002 OCCURS 0 WITH HEADER LINE.

  CALL FUNCTION &apos;VIEW_GET_LANGUAGES&apos;
       EXPORTING
            all_without_selection = &apos;X&apos;
       IMPORTING
            languages_selected    = langus_selected
            curr_sptxt            = curr_sptxt
       TABLES
            languages             = sel_langus.
  IF x_header-frm_tl_get NE space.
    PERFORM (x_header-frm_tl_get) IN PROGRAM (x_header-fpoolname)
                                  TABLES sel_langus.
  ELSE.
    PERFORM vim_read_texttab_for_langus TABLES sel_langus USING &apos; &apos;.
  ENDIF.
ENDFORM.                               &quot;VIM_READ_TEXTTAB_ALL_LANGUS

************************************************************************
* SW Langtext
*    Absprung in Langtextpflege über Userexit vom Übersetzungsscreen aus
*    ermöglichen
*---------------------------------------------------------------------*
*       FORM VIM_CALL_LTEXT_EXIT                                      *
*---------------------------------------------------------------------*
* -&gt;  MAINT_MODE      &apos;U&apos;/&apos;R&apos; (Update/Read)
* -&gt;  EXITFORM        Name der Userexit-Routine für Langtextpflege
* &lt;-&gt; TEXTTABLE_ENTRY Zeile, für die Langtextpflege aufgerufen wurde
* &lt;-  MODIFIED        &apos;X&apos; -&gt; Zeile wurde modifiziert
*---------------------------------------------------------------------*
* Aufruf des Userexits für Langtextpflege                             *
*---------------------------------------------------------------------*
FORM vim_call_ltext_exit
             USING    maint_mode TYPE c
                      exitform TYPE vimfrmname
             CHANGING texttable_entry TYPE vimty_textmaint_record
                      modified TYPE c.
  DATA: text_wa TYPE vim_line_ul,
        textmaint_field TYPE vimty_textfield,
        pgm_name LIKE sy-repid,
        offset LIKE sy-fdpos.

  FIELD-SYMBOLS: &lt;text_wa&gt; TYPE x, &lt;text_wa_struc&gt; TYPE ANY,
                 &lt;texttabkey&gt; TYPE x, &lt;txtfld&gt; TYPE ANY.

  CLEAR modified.
  IF vim_internal_ltext_call = space.
    PERFORM (exitform) IN PROGRAM (sy-repid).
  ELSE.
    READ TABLE x_header INDEX 1.
    ASSIGN: text_wa TO &lt;text_wa&gt; CASTING,
            &lt;text_wa&gt; TO &lt;text_wa_struc&gt;
             CASTING TYPE (x_header-texttab),
            texttable_entry-keys TO &lt;texttabkey&gt; CASTING.

    PERFORM map_viewkey_to_texttabkey TABLES x_namtab
                                USING x_header
                                      texttable_entry-spras
                                      &lt;texttabkey&gt;
                             CHANGING &lt;text_wa&gt;.
*    PERFORM VIM_FILL_TEXTTAB_KEY USING TEXTTABLE_ENTRY-KEYS
*                                       TEXTTABLE_ENTRY-SPRAS
*                                       X_HEADER-SPRASFDPOS
*                              CHANGING TEXT_WA.
    LOOP AT texttable_entry-texttab INTO textmaint_field.
      READ TABLE x_namtab INDEX textmaint_field-namtab_idx.
*      offset = x_namtab-texttabpos.
      IF x_namtab-lowercase = space.
        TRANSLATE textmaint_field-text TO UPPER CASE.
      ENDIF.
      IF x_namtab-txttabfldn = space.
* tab + texttab
        ASSIGN COMPONENT x_namtab-bastabfld
         OF STRUCTURE &lt;text_wa_struc&gt; TO &lt;txtfld&gt;.
      ELSE.
* view
        ASSIGN COMPONENT x_namtab-txttabfldn
         OF STRUCTURE &lt;text_wa_struc&gt; TO &lt;txtfld&gt;.
      ENDIF.
      &lt;txtfld&gt; = textmaint_field-text.
*      text_wa+offset(x_namtab-flength) =
*         textmaint_field-text(x_namtab-flength).
    ENDLOOP.
    PERFORM (exitform) IN PROGRAM (x_header-fpoolname)
                          USING maint_mode
                          CHANGING text_wa modified.
    IF modified = &apos;X&apos;.
      IF maint_mode = &apos;U&apos;.
        LOOP AT texttable_entry-texttab INTO textmaint_field.
          READ TABLE x_namtab INDEX textmaint_field-namtab_idx.
          ASSIGN COMPONENT x_namtab-txttabfldn
           OF STRUCTURE &lt;text_wa_struc&gt; TO &lt;txtfld&gt;.
          textmaint_field-text = &lt;txtfld&gt;.
*          offset = x_namtab-texttabpos.
*          textmaint_field-text(x_namtab-flength) =
*            text_wa+offset(x_namtab-flength).
          MODIFY texttable_entry-texttab FROM textmaint_field.
        ENDLOOP.
        texttable_entry-action = &apos;X&apos;.
      ELSE.
        CLEAR modified.
      ENDIF.
    ENDIF.
  ENDIF.
ENDFORM.                               &quot; VIM_CALL_LTEXT_EXIT</include_source>
   </include>
   <include NAME="LSVIMFTX" VARCL="X" SUBC="I" APPL="S" CNAM="SAP" CDAT="19950113" UNAM="SAP" UDAT="20080721" VERN="000025" LEVL="30A" RMAND="000" RLOAD="D" SDATE="20080721" STIME="122442" IDATE="20080721" ITIME="122442">
    <include_source>*-------------------------------------------------------------------
***INCLUDE LSVIMFTX .
*-------------------------------------------------------------------
*&amp;--------------------------------------------------------------------*
*&amp;      Form  TABLE_CALL_FUNCTION                                     *
*---------------------------------------------------------------------*
* call function TABLEPROC with proper parameters
*---------------------------------------------------------------------*
* TCF_FCODE    ---&gt; current function code                             *
* TCF_TABTYPE  ---&gt; type of int. table: SHORT, MIDDLE, LONG, VERY_LONG*
* TCF_UPD_fLAG &lt;--- flag: update required                             *
*---------------------------------------------------------------------*
FORM table_call_function TABLES dba_sellist dpl_sellist
                                x_header STRUCTURE vimdesc
                                x_namtab excl_cua_funct
                         USING value(tcf_fcode) value(tcf_tabtype)
                               tcf_upd_flag.

  DATA: function_name LIKE tfdir-funcname VALUE &apos;TABLEPROC_&apos;,
        prefix_len TYPE i VALUE &apos;10&apos;.

  READ TABLE x_header INDEX 1.
  MOVE x_header-area TO function_name+prefix_len.
  IF function_name CA forbidden_func_name_chars.
    PERFORM replace_forbidden_chars USING forbidden_func_name_chars
                                          function_name.
  ENDIF.
  CASE tcf_tabtype.
    WHEN &apos;ULTRA_SHORT&apos;.
      CALL FUNCTION function_name
        EXPORTING
          fcode                    = tcf_fcode
          view_action              = maint_mode
          view_name                = x_header-viewname
          corr_number              = corr_nbr
        IMPORTING
          ucomm                    = function
          update_required          = tcf_upd_flag
        TABLES
          dba_sellist              = dba_sellist
          dpl_sellist              = dpl_sellist
          excl_cua_funct           = excl_cua_funct
          x_header                 = x_header
          x_namtab                 = x_namtab
          corr_keytab              = e071k_tab
          extract                  = extract_us
          total                    = total_us
        EXCEPTIONS
          missing_corr_number      = 01
          saving_correction_failed = 03.
    WHEN &apos;VERY_SHORT&apos;.
      CALL FUNCTION function_name
        EXPORTING
          fcode                    = tcf_fcode
          view_action              = maint_mode
          view_name                = x_header-viewname
          corr_number              = corr_nbr
        IMPORTING
          ucomm                    = function
          update_required          = tcf_upd_flag
        TABLES
          dba_sellist              = dba_sellist
          dpl_sellist              = dpl_sellist
          excl_cua_funct           = excl_cua_funct
          x_header                 = x_header
          x_namtab                 = x_namtab
          corr_keytab              = e071k_tab
          extract                  = extract_vs
          total                    = total_vs
        EXCEPTIONS
          missing_corr_number      = 01
          saving_correction_failed = 03.
    WHEN &apos;SHORT&apos;.
      CALL FUNCTION function_name
        EXPORTING
          fcode                    = tcf_fcode
          view_action              = maint_mode
          view_name                = x_header-viewname
          corr_number              = corr_nbr
        IMPORTING
          ucomm                    = function
          update_required          = tcf_upd_flag
        TABLES
          dba_sellist              = dba_sellist
          dpl_sellist              = dpl_sellist
          excl_cua_funct           = excl_cua_funct
          x_header                 = x_header
          x_namtab                 = x_namtab
          corr_keytab              = e071k_tab
          extract                  = extract_s
          total                    = total_s
        EXCEPTIONS
          missing_corr_number      = 01
          saving_correction_failed = 03.
    WHEN &apos;MIDDLE&apos;.
      CALL FUNCTION function_name
        EXPORTING
          fcode                    = tcf_fcode
          view_action              = maint_mode
          view_name                = x_header-viewname
          corr_number              = corr_nbr
        IMPORTING
          ucomm                    = function
          update_required          = tcf_upd_flag
        TABLES
          dba_sellist              = dba_sellist
          dpl_sellist              = dpl_sellist
          excl_cua_funct           = excl_cua_funct
          x_header                 = x_header
          x_namtab                 = x_namtab
          corr_keytab              = e071k_tab
          extract                  = extract_m
          total                    = total_m
        EXCEPTIONS
          missing_corr_number      = 01
          saving_correction_failed = 03.
    WHEN &apos;LONG&apos;.
      CALL FUNCTION function_name
        EXPORTING
          fcode                    = tcf_fcode
          view_action              = maint_mode
          view_name                = x_header-viewname
          corr_number              = corr_nbr
        IMPORTING
          ucomm                    = function
          update_required          = tcf_upd_flag
        TABLES
          dba_sellist              = dba_sellist
          dpl_sellist              = dpl_sellist
          excl_cua_funct           = excl_cua_funct
          x_header                 = x_header
          x_namtab                 = x_namtab
          corr_keytab              = e071k_tab
          extract                  = extract_l
          total                    = total_l
        EXCEPTIONS
          missing_corr_number      = 01
          saving_correction_failed = 03.
    WHEN &apos;VERY_LONG&apos;.
      CALL FUNCTION function_name
        EXPORTING
          fcode                    = tcf_fcode
          view_action              = maint_mode
          view_name                = x_header-viewname
          corr_number              = corr_nbr
        IMPORTING
          ucomm                    = function
          update_required          = tcf_upd_flag
        TABLES
          dba_sellist              = dba_sellist
          dpl_sellist              = dpl_sellist
          excl_cua_funct           = excl_cua_funct
          x_header                 = x_header
          x_namtab                 = x_namtab
          corr_keytab              = e071k_tab
          extract                  = extract_vl
          total                    = total_vl
        EXCEPTIONS
          missing_corr_number      = 01
          saving_correction_failed = 03.
    WHEN &apos;ULTRA_LONG&apos;.
      CALL FUNCTION function_name
        EXPORTING
          fcode                    = tcf_fcode
          view_action              = maint_mode
          view_name                = x_header-viewname
          corr_number              = corr_nbr
        IMPORTING
          ucomm                    = function
          update_required          = tcf_upd_flag
        TABLES
          dba_sellist              = dba_sellist
          dpl_sellist              = dpl_sellist
          excl_cua_funct           = excl_cua_funct
          x_header                 = x_header
          x_namtab                 = x_namtab
          corr_keytab              = e071k_tab
          extract                  = extract_ul
          total                    = total_ul
        EXCEPTIONS
          missing_corr_number      = 01
          saving_correction_failed = 03.
  ENDCASE.
ENDFORM.                               &quot; TABLE_CALL_FUNCTION

*&amp;--------------------------------------------------------------------*
*&amp;      Form  TABLE_GET_DATA                                          *
*---------------------------------------------------------------------*
* get data from database
*---------------------------------------------------------------------*
FORM table_get_data.
  CONSTANTS maxsellines TYPE i VALUE 500.
  DATA: tgd_sellist LIKE vimsellist OCCURS 10, tgd_sel LIKE vimsellist,
        tgd_sellangu LIKE vimsellist,
        short_sellist LIKE vimsellist OCCURS 10,
        short_sel LIKE vimsellist,
        tgd_ind TYPE i, tgd_field LIKE vimnamtab-viewfield,
        selnumber TYPE i, selindex TYPE i, selcut TYPE i,
        selpieces TYPE i.
  FIELD-SYMBOLS: &lt;text_key&gt;.                                &quot;#EC *
  DATA: primtab TYPE REF TO data, texttab TYPE REF TO data,
        w_texttab_save TYPE REF TO data, w_texttab TYPE REF TO data,
        text_keyflds TYPE vim_flds_tab_type.
  DATA: append_flag(1) TYPE c.

  FIELD-SYMBOLS: &lt;primtab&gt; TYPE STANDARD TABLE,
                 &lt;texttab&gt; TYPE SORTED TABLE, &lt;w_texttab&gt; TYPE ANY,
                 &lt;w_texttab_save&gt; TYPE ANY, &lt;textline_x&gt; TYPE x.

  REFRESH total. CLEAR total.
  IF x_header-selection NE space.
    DESCRIBE TABLE dba_sellist LINES selnumber.
    IF selnumber &gt; maxsellines.  &quot;fragmentation of too large sellists
      CLEAR selpieces.
      CLEAR selindex.
      CREATE DATA primtab TYPE STANDARD TABLE OF (x_header-maintview).
      ASSIGN primtab-&gt;* TO &lt;primtab&gt;.
      WHILE selindex &lt; selnumber.
        selpieces = selpieces + maxsellines.
        REFRESH short_sellist.
        CLEAR selcut.
        WHILE selcut EQ 0 AND selindex &lt; selnumber.
          selindex = selindex + 1.
          READ TABLE dba_sellist INTO short_sel INDEX selindex.
          APPEND short_sel TO short_sellist.
          IF selindex &gt; selpieces AND short_sel-and_or NE &apos;AND&apos;.
            selcut = 1.
          ENDIF.
        ENDWHILE.
        CLEAR short_sel-and_or.      &quot;last line without logic operation
        MODIFY short_sellist FROM short_sel INDEX selindex.
        CALL FUNCTION &apos;VIEW_FILL_WHERETAB&apos;
           EXPORTING
                tablename               = x_header-maintview
*             ONLY_CNDS_FOR_KEYFLDS   = &apos;X&apos; &quot;use default SPACE
           TABLES
                sellist                 = short_sellist
                wheretab                = vim_wheretab
                x_namtab                = x_namtab
           EXCEPTIONS
                no_conditions_for_table = 01.
*       read data from database with morer wheretabs...................*
        SELECT * FROM (x_header-maintview) APPENDING TABLE &lt;primtab&gt;
                                          WHERE (vim_wheretab).
        CLEAR selcut.
      ENDWHILE.
    ELSE.                                  &quot;selnumber &gt; maxsellines
      CALL FUNCTION &apos;VIEW_FILL_WHERETAB&apos;
           EXPORTING
                tablename               = x_header-maintview
*             ONLY_CNDS_FOR_KEYFLDS   = &apos;X&apos; &quot;use default SPACE
           TABLES
                sellist                 = dba_sellist
                wheretab                = vim_wheretab
                x_namtab                = x_namtab
           EXCEPTIONS
                no_conditions_for_table = 01.
*   read data from database with one wheretab..........................*
      CREATE DATA primtab TYPE STANDARD TABLE OF (x_header-maintview).&quot;UCb
      ASSIGN primtab-&gt;* TO &lt;primtab&gt;.
      SELECT * FROM (x_header-maintview) INTO TABLE &lt;primtab&gt;
                                          WHERE (vim_wheretab).
    ENDIF.                                   &quot;if selnumber &gt; maxsellines
  ELSE.                                  &quot;if x_header-selection NE space
    REFRESH vim_wheretab.
*   read data from database without wheretab...........................*
    CREATE DATA primtab TYPE STANDARD TABLE OF (x_header-maintview).&quot;UCb
    ASSIGN primtab-&gt;* TO &lt;primtab&gt;.
    SELECT * FROM (x_header-maintview) INTO TABLE &lt;primtab&gt;.
  ENDIF.                                &quot;if x_header-selection NE space
  IF x_header-texttbexst EQ space.
* no texttable
    LOOP AT &lt;primtab&gt; INTO &lt;vim_total_struc&gt;.
      APPEND total.
    ENDLOOP.                                                &quot;UCe
    SORT total BY &lt;vim_xtotal_key&gt;. &lt;status&gt;-alr_sorted = &apos;R&apos;.
    IF x_header-selection EQ space AND x_header-delmdtflag NE space.
* time dependence
      PERFORM build_mainkey_tab_0.
    ENDIF.
    LOOP AT total.
      CLEAR: &lt;action&gt;, &lt;mark&gt;.
      MODIFY total.
      IF x_header-selection EQ space AND x_header-delmdtflag NE space.
        PERFORM build_mainkey_tab_1.
      ENDIF.
    ENDLOOP.
    IF x_header-selection EQ space AND x_header-delmdtflag NE space.
      PERFORM build_mainkey_tab_2.
    ENDIF.
  ELSE.
* texttable exists
    PERFORM vim_get_text_keyflds USING x_header-texttab
                                 CHANGING text_keyflds.
    CREATE DATA texttab TYPE SORTED TABLE OF (x_header-texttab)
     WITH UNIQUE KEY (text_keyflds).                        &quot;UCb
    ASSIGN texttab-&gt;* TO &lt;texttab&gt;.
    IF x_header-selection NE space.
* get selection for texttable
*      READ TABLE dba_sellist INTO dpl_sellist INDEX 1.
      DESCRIBE TABLE dba_sellist LINES selnumber.
      selindex = 0.
      WHILE selindex &lt; selnumber.
        selindex = selindex + 1.
        READ TABLE dba_sellist INTO tgd_sel INDEX selindex.
        READ TABLE x_namtab WITH KEY
          viewfield = tgd_sel-viewfield texttabfld = space. &quot;#EC *
        CHECK x_namtab-keyflag = &apos;X&apos;.        &quot; key fields for texttab only
        tgd_sel-viewfield = x_namtab-txttabfldn.
        READ TABLE x_namtab WITH KEY
          viewfield = tgd_sel-viewfield texttabfld = &apos;X&apos;.
        tgd_sel-tabix = sy-tabix.
        CLEAR append_flag.
        IF sy-subrc EQ 0.&quot;Otherwise keyfld in tab not in txttab HW696310
          append_flag = &apos;X&apos;.
        ENDIF.
        IF tgd_sel-and_or NE &apos;AND&apos; OR selindex = 1.       &quot;Langufield
          READ TABLE x_namtab WITH KEY primtabkey = 0 keyflag = &apos;X&apos;.
          tgd_sellangu-viewfield = x_namtab-viewfield.
          tgd_sellangu-tabix     = sy-tabix.
          tgd_sellangu-operator = &apos;EQ&apos;.
          tgd_sellangu-value = sy-langu.
          tgd_sellangu-and_or = &apos;AND&apos;.
          IF tgd_sellangu-value EQ space.
            tgd_sellangu-initial = &apos;X&apos;.
          ENDIF.
          tgd_sellangu-cond_kind = dpl_sellist-cond_kind.
          CLEAR tgd_sellangu-converted.
          APPEND tgd_sellangu TO tgd_sellist.
        ENDIF.
        IF append_flag EQ &apos;X&apos;.
          APPEND tgd_sel TO tgd_sellist.
        ENDIF.
*      Did not work for sellist to describe more than one dataset in
*      transport request                                          &quot;HCG
*      LOOP AT x_namtab WHERE keyflag NE space    &quot;fill sellist for
*                         AND texttabfld NE space. &quot;texttab
*        tgd_field = x_namtab-viewfield.
*        tgd_ind   = sy-tabix.
*        IF x_namtab-primtabkey EQ 0.   &quot;langufield
*          tgd_sel-viewfield = tgd_field.
*          tgd_sel-tabix     = tgd_ind.
*          tgd_sel-operator = &apos;EQ&apos;.
*          tgd_sel-value = sy-langu.
*          tgd_sel-and_or = &apos;AND&apos;.
*          IF tgd_sel-value EQ space.
*            tgd_sel-initial = &apos;X&apos;.
*          ENDIF.
*          tgd_sel-cond_kind = dpl_sellist-cond_kind.
*          clear tgd_sel-converted.
*          APPEND tgd_sel TO tgd_sellist.
*        ELSE.
*          READ TABLE x_namtab INDEX x_namtab-primtabkey.
*          LOOP AT dba_sellist WHERE viewfield EQ x_namtab-viewfield.
*            tgd_sel = dba_sellist.
*            tgd_sel-viewfield = tgd_field.
*            tgd_sel-tabix     = tgd_ind.
*            IF tgd_sel-and_or EQ space.
*              tgd_sel-and_or = &apos;AND&apos;.
*            ENDIF.
*            APPEND tgd_sel TO tgd_sellist.
*          ENDLOOP.
*        ENDIF.
*      ENDLOOP.
      ENDWHILE.
      DESCRIBE TABLE tgd_sellist.
      READ TABLE tgd_sellist INDEX sy-tfill INTO tgd_sel.
      IF tgd_sel-and_or NE space.
        CLEAR tgd_sel-and_or.
        MODIFY tgd_sellist INDEX sy-tfill FROM tgd_sel.
      ENDIF.
    ELSE.
* no selection for primary table: fill selection with langu-field only
      LOOP AT x_namtab WHERE keyflag NE space    &quot;fill sellist with
                         AND texttabfld NE space  &quot;language condition
                         AND primtabkey EQ 0.
        tgd_sel-viewfield = x_namtab-viewfield.
        tgd_sel-tabix     = sy-tabix.
        tgd_sel-operator = &apos;EQ&apos;.
        tgd_sel-value = sy-langu.
        tgd_sel-and_or = space.
        IF tgd_sel-value EQ space.
          tgd_sel-initial = &apos;X&apos;.
        ENDIF.
        APPEND tgd_sel TO tgd_sellist.
        EXIT.
      ENDLOOP.
    ENDIF.
*    CALL FUNCTION &apos;VIEW_FILL_WHERETAB&apos;
*      EXPORTING
*        tablename               = x_header-texttab
*        only_cnds_for_keyflds   = &apos;X&apos;
*      TABLES
*        sellist                 = tgd_sellist
*        wheretab                = vim_wheretab
*        x_namtab                = x_namtab
*      EXCEPTIONS
*        no_conditions_for_table = 01.
** read texttable from database
*    SELECT * FROM (x_header-texttab) INTO TABLE &lt;texttab&gt;
*                                      WHERE (vim_wheretab).
    DESCRIBE TABLE tgd_sellist LINES selnumber.
    IF selnumber &gt; maxsellines.  &quot;fragmentation of too large sellists
      CLEAR selpieces.
      CLEAR selindex.
      WHILE selindex &lt; selnumber.
        selpieces = selpieces + maxsellines.
        REFRESH short_sellist.
        CLEAR selcut.
        WHILE selcut EQ 0 AND selindex &lt; selnumber.
          selindex = selindex + 1.
          READ TABLE tgd_sellist INTO short_sel INDEX selindex.
          APPEND short_sel TO short_sellist.
          IF selindex &gt; selpieces AND short_sel-and_or NE &apos;AND&apos;.
            selcut = 1.
          ENDIF.
        ENDWHILE.
        CLEAR short_sel-and_or.      &quot;last line without logic operation
        MODIFY short_sellist FROM short_sel INDEX selindex.
        CALL FUNCTION &apos;VIEW_FILL_WHERETAB&apos;
          EXPORTING
            tablename               = x_header-texttab
            only_cnds_for_keyflds   = &apos;X&apos;
          TABLES
            sellist                 = short_sellist
            wheretab                = vim_wheretab
            x_namtab                = x_namtab
          EXCEPTIONS
            no_conditions_for_table = 01.
*       read data from database with morer wheretabs...................*
        SELECT * FROM (x_header-texttab) APPENDING TABLE &lt;texttab&gt;
                                          WHERE (vim_wheretab).
        CLEAR selcut.
      ENDWHILE.
    ELSE.                                  &quot;selnumber &gt; maxsellines
      CALL FUNCTION &apos;VIEW_FILL_WHERETAB&apos;
        EXPORTING
          tablename               = x_header-texttab
          only_cnds_for_keyflds   = &apos;X&apos;
        TABLES
          sellist                 = tgd_sellist
          wheretab                = vim_wheretab
          x_namtab                = x_namtab
        EXCEPTIONS
          no_conditions_for_table = 01.
*   read data from database with one wheretab..........................*
      SELECT * FROM (x_header-texttab) INTO TABLE &lt;texttab&gt;
                                        WHERE (vim_wheretab).
    ENDIF.                                   &quot;if selnumber &gt; maxsellines
    IF x_header-selection EQ space AND x_header-delmdtflag NE space.
      PERFORM build_mainkey_tab_0.
    ENDIF.
    CREATE DATA w_texttab_save TYPE (x_header-texttab).
    CREATE DATA w_texttab TYPE (x_header-texttab).
    ASSIGN: w_texttab-&gt;* TO &lt;w_texttab&gt;,
            w_texttab_save-&gt;* TO &lt;w_texttab_save&gt;,
            &lt;w_texttab_save&gt; TO &lt;textline_x&gt; CASTING.
    LOOP AT &lt;primtab&gt; INTO &lt;vim_total_struc&gt;.
*       hier aufbauen schlüssel texttabelle in feld text_key
      CLEAR &lt;w_texttab&gt;.
      PERFORM fill_texttab_key_uc USING &lt;vim_total_struc&gt;
                                  CHANGING &lt;w_texttab&gt;.
      IF &lt;w_texttab&gt; NE &lt;w_texttab_save&gt;.
        READ TABLE &lt;texttab&gt; INTO &lt;w_texttab_save&gt;
         FROM &lt;w_texttab&gt;.
        IF sy-subrc = 0.
*          MOVE &lt;w_texttab_save&gt; TO &lt;w_textline&gt;.
*          MOVE textline(x_header-texttablen) TO &lt;total_text&gt;.
        ELSE.
          MOVE &lt;text_initial&gt; TO &lt;w_texttab_save&gt;.
        ENDIF.
*      ELSE.
*        MOVE &lt;w_texttab_save&gt; TO &lt;w_textline&gt;.
*        MOVE textline(x_header-texttablen) TO &lt;total_text&gt;.
      ENDIF.
      MOVE &lt;textline_x&gt; TO &lt;vim_xtotal_text&gt;.
      CLEAR: &lt;action&gt;, &lt;mark&gt;, &lt;action_text&gt;.
      APPEND total.
      IF x_header-selection EQ space AND x_header-delmdtflag NE space.
        PERFORM build_mainkey_tab_1.
      ENDIF.
    ENDLOOP.
    SORT total BY &lt;vim_xtotal_key&gt;. &lt;status&gt;-alr_sorted = &apos;R&apos;.
    IF x_header-selection EQ space AND x_header-delmdtflag NE space.
      PERFORM build_mainkey_tab_2.
    ENDIF.
  ENDIF.
*.check dynamic selectoptions (not in DDIC)...........................*
  IF x_header-selection NE space.
    PERFORM check_dynamic_select_options.
  ENDIF.
ENDFORM.                               &quot; TABLE_GET_DATA

*&amp;--------------------------------------------------------------------*
*&amp;      Form  TABLE_DB_UPD                                            *
*---------------------------------------------------------------------*
* process data base updates/inserts/deletes
*---------------------------------------------------------------------*
FORM table_db_upd.
  DATA: modified_entries TYPE i, prt_frky_entries TYPE i, rc TYPE i,
        h_ix TYPE i,
        primtab_mod TYPE REF TO data,
        primtab_mod_wa TYPE REF TO data,
        texttab_mod TYPE REF TO data,
        w_texttab_mod TYPE REF TO data,
        e071_loctab TYPE vim_ko200_tab_type.
  FIELD-SYMBOLS: &lt;mod_elem_tab&gt; TYPE STANDARD TABLE,
                 &lt;h_keyx&gt; TYPE x,                           &quot;#EC *
                 &lt;mod_elem_wa&gt; TYPE ANY,
                 &lt;texttab&gt; TYPE STANDARD TABLE, &lt;w_texttab&gt; TYPE ANY,
                 &lt;textline_x&gt; TYPE x.

* first of all: delete requests
  CREATE DATA primtab_mod TYPE TABLE OF (x_header-maintview).
  CREATE DATA primtab_mod_wa TYPE (x_header-maintview).
  ASSIGN: primtab_mod-&gt;* TO &lt;mod_elem_tab&gt;,
          primtab_mod_wa-&gt;* TO &lt;mod_elem_wa&gt;.
  LOOP AT total.
    CHECK ( &lt;action&gt; EQ geloescht OR &lt;action&gt; EQ update_geloescht OR
            &lt;action&gt; EQ neuer_geloescht ).
    IF &lt;action&gt; EQ neuer_geloescht.
      IF status-delete EQ geloescht.
        READ TABLE extract WITH KEY &lt;vim_xtotal_key&gt;.
        IF sy-subrc EQ 0.
          DELETE extract INDEX sy-tabix.
        ENDIF.
      ENDIF.
      DELETE total.
    ELSE.
      APPEND &lt;vim_total_struc&gt; TO &lt;mod_elem_tab&gt;.
      ADD 1 TO modified_entries.
      IF x_header-texttbexst EQ space. &quot;no texttab
        IF status-delete EQ geloescht.
          READ TABLE extract WITH KEY &lt;vim_xtotal_key&gt;.
          IF sy-subrc EQ 0.
            DELETE extract INDEX sy-tabix.
          ENDIF.
        ENDIF.
        DELETE total.
      ENDIF.
    ENDIF.
  ENDLOOP.
  IF modified_entries NE 0.
    DELETE (x_header-maintview) FROM TABLE &lt;mod_elem_tab&gt;.
  ENDIF.
  IF x_header-texttbexst NE space.
    CLEAR modified_entries.
    CREATE DATA texttab_mod TYPE STANDARD TABLE OF (x_header-texttab).
    CREATE DATA w_texttab_mod TYPE (x_header-texttab).
    ASSIGN: texttab_mod-&gt;* TO &lt;texttab&gt;,
            w_texttab_mod-&gt;* TO &lt;w_texttab&gt;,
            &lt;w_texttab&gt; TO &lt;textline_x&gt; CASTING.
* delete texts for all deleted entities
    LOOP AT &lt;mod_elem_tab&gt; INTO &lt;table1_wa&gt;.
      READ TABLE total WITH KEY &lt;f1_wax&gt; BINARY SEARCH.
      h_ix = sy-tabix.
      IF x_header-ptfrkyexst NE space.
* partial foreign key relation:
* Are there still any primary table entries?
        PERFORM create_wheretab_new USING x_namtab[]
                                          &lt;vim_total_struc&gt;
                                          &lt;vim_tot_txt_struc&gt;
                                          x_header-maintview
                                          &apos;X&apos; rc.
        IF rc NE 0.                    &quot;something seems to be wrong
          prt_frky_entries = 1.        &quot;don&apos;t delete
        ELSE.
          SELECT COUNT(*) FROM (x_header-maintview) UP TO 1 ROWS
                          WHERE (vim_wheretab).
          prt_frky_entries = sy-dbcnt.
        ENDIF.
      ELSE.
        CLEAR prt_frky_entries.
      ENDIF.
      IF prt_frky_entries EQ 0.
* No, there aren&apos;t.
*        MODIFY mod_elem_tab FROM &lt;total_text&gt;.
        MOVE &lt;vim_xtotal_text&gt; TO &lt;textline_x&gt;.
        APPEND &lt;w_texttab&gt; TO &lt;texttab&gt;.
        ADD 1 TO modified_entries.
      ENDIF.
      IF status-delete EQ geloescht.
        READ TABLE extract WITH KEY &lt;vim_xtotal_key&gt;
         TRANSPORTING NO FIELDS.
        IF sy-subrc EQ 0.
          DELETE extract INDEX sy-tabix.
        ENDIF.
      ENDIF.
      DELETE total INDEX h_ix.
    ENDLOOP.
    IF modified_entries NE 0.
* delete text entries in all languages
      DO modified_entries TIMES.
*        READ TABLE mod_elem_tab INDEX 1.
*        DELETE mod_elem_tab INDEX 1.
*        READ TABLE &lt;texttab&gt; INTO &lt;w_texttab&gt; INDEX 1.
        READ TABLE &lt;texttab&gt; INTO &lt;vim_tot_txt_struc&gt; INDEX 1.&quot;IG 862951
        DELETE &lt;texttab&gt; INDEX 1.                           &quot;IG 862951
*        PERFORM create_wheretab TABLES x_namtab
*                                USING mod_elem_tab
*                                      x_header-texttab space rc.

        PERFORM create_wheretab_new USING x_namtab[]
                                          &lt;vim_total_struc&gt;
                                          &lt;vim_tot_txt_struc&gt;
                                          x_header-texttab
                                          space
                                          rc.
        SELECT * FROM (x_header-texttab) APPENDING TABLE &lt;texttab&gt;
                                         WHERE (vim_wheretab).
      ENDDO.
*      DELETE (x_header-texttab) FROM TABLE mod_elem_tab.
      DELETE (x_header-texttab) FROM TABLE &lt;texttab&gt;.
    ENDIF.
  ENDIF.
* now update requests
  REFRESH: &lt;mod_elem_tab&gt;.
  CLEAR modified_entries.
  LOOP AT total.
    CHECK &lt;action&gt; EQ aendern.
*    MOVE: total TO &lt;table1&gt;,
*          &lt;table1&gt; TO mod_elem_tab.
*    APPEND mod_elem_tab.
    APPEND &lt;vim_total_struc&gt; TO &lt;mod_elem_tab&gt;.
    ADD 1 TO modified_entries.
    IF x_header-texttbexst EQ space OR
       &lt;action_text&gt; EQ original.
      READ TABLE extract WITH KEY &lt;vim_xtotal_key&gt;.
      &lt;action&gt; = original.
      IF sy-subrc = 0.
        &lt;xact&gt; = original.
        MODIFY extract INDEX sy-tabix.
      ENDIF.
      MODIFY total.
    ENDIF.
  ENDLOOP.
  IF modified_entries NE 0.
    UPDATE (x_header-maintview) FROM TABLE &lt;mod_elem_tab&gt;.
  ENDIF.
  IF x_header-texttbexst NE space.
    REFRESH &lt;texttab&gt;.
    CLEAR modified_entries.
    LOOP AT total.
      CHECK &lt;action_text&gt; EQ aendern.
*      MOVE: &lt;total_text&gt; TO mod_elem_tab.
*      APPEND mod_elem_tab.
      MOVE &lt;vim_xtotal_text&gt; TO &lt;textline_x&gt;.
      APPEND &lt;w_texttab&gt; TO &lt;texttab&gt;.
      ADD 1 TO modified_entries.
      READ TABLE extract WITH KEY &lt;vim_xtotal_key&gt;.
      IF &lt;action&gt; EQ aendern.
        &lt;action&gt; = original. &lt;xact&gt; = original.
      ENDIF.
      &lt;action_text&gt; = original. &lt;xact_text&gt; = original.
      IF sy-subrc = 0.
        MODIFY extract INDEX sy-tabix.
      ENDIF.
      MODIFY total.
    ENDLOOP.
    IF modified_entries NE 0.
*      UPDATE (x_header-texttab) FROM TABLE mod_elem_tab.
      UPDATE (x_header-texttab) FROM TABLE &lt;texttab&gt;.
    ENDIF.
  ENDIF.
* last not least: insert requests
  REFRESH: &lt;mod_elem_tab&gt;. CLEAR modified_entries.
  LOOP AT total.
    CHECK &lt;action&gt; EQ neuer_eintrag.
*    MOVE: total TO &lt;table1&gt;,
*          &lt;table1&gt; TO mod_elem_tab.
*    APPEND mod_elem_tab.
    APPEND &lt;vim_total_struc&gt; TO &lt;mod_elem_tab&gt;.
    ADD 1 TO modified_entries.
    IF x_header-texttbexst EQ space OR
       &lt;action_text&gt; EQ original.
      READ TABLE extract WITH KEY &lt;vim_xtotal_key&gt;.
      &lt;action&gt; = original.
      IF sy-subrc = 0.
        &lt;xact&gt; = original.
        MODIFY extract INDEX sy-tabix.
      ENDIF.
      MODIFY total.
    ENDIF.
  ENDLOOP.
  IF modified_entries NE 0.
    INSERT (x_header-maintview) FROM TABLE &lt;mod_elem_tab&gt;.
  ENDIF.
  IF x_header-texttbexst NE space.
    REFRESH &lt;texttab&gt;.
    CLEAR modified_entries.
    LOOP AT total.
      CHECK &lt;action_text&gt; EQ neuer_eintrag.
*      MOVE: &lt;total_text&gt; TO mod_elem_tab.
*      APPEND mod_elem_tab.
      MOVE &lt;vim_xtotal_text&gt; TO &lt;textline_x&gt;.
      APPEND &lt;w_texttab&gt; TO &lt;texttab&gt;.
      ADD 1 TO modified_entries.
      READ TABLE extract WITH KEY &lt;vim_xtotal_key&gt;.
      IF &lt;action&gt; EQ neuer_eintrag.
        &lt;action&gt; = original. &lt;xact&gt; = original.
      ENDIF.
      &lt;action_text&gt; = original. &lt;xact_text&gt; = original.
      IF sy-subrc = 0.
        MODIFY extract INDEX sy-tabix.
      ENDIF.
      MODIFY total.
    ENDLOOP.
    IF modified_entries NE 0.
*      INSERT (x_header-texttab) FROM TABLE mod_elem_tab
*                                ACCEPTING DUPLICATE KEYS.
      INSERT (x_header-texttab) FROM TABLE &lt;texttab&gt;
                                ACCEPTING DUPLICATE KEYS.
      IF sy-subrc NE 0. &quot;duplicate keys -&gt; process additional update
*        UPDATE (x_header-texttab) FROM TABLE mod_elem_tab.
        UPDATE (x_header-texttab) FROM TABLE &lt;texttab&gt;.
      ENDIF.
    ENDIF.
  ENDIF.
*    Call synchronizer
*  REFRESH e071_loctab.
*  APPEND e071 TO e071_loctab.
*  PERFORM vim_synchronizer_call
*                USING e071_loctab[]
*                      corr_keytab[]
*                      &apos;X&apos;.

  CLEAR: &lt;status&gt;-upd_flag,
         &lt;status&gt;-upd_checkd.
  MESSAGE s018(sv).
ENDFORM.                               &quot; TABLE_DB_UPD

*&amp;--------------------------------------------------------------------*
*&amp;      Form  TABLE_READ_SINGLE_ENTRY                                 *
*---------------------------------------------------------------------*
* read single entry from data base
*---------------------------------------------------------------------*
FORM table_read_single_entry.
  DATA: tab TYPE REF TO data, texttab TYPE REF TO data,
        textline TYPE REF TO data.

  FIELD-SYMBOLS: &lt;tab&gt; TYPE STANDARD TABLE,
                 &lt;texttab&gt; TYPE STANDARD TABLE,
                 &lt;textline&gt; TYPE ANY, &lt;textline_x&gt; TYPE x.

  CREATE DATA tab TYPE STANDARD TABLE OF (x_header-maintview).
  ASSIGN tab-&gt;* TO &lt;tab&gt;.
*  REFRESH mod_elem_tab.
*  MOVE &lt;f1&gt; TO gen_key.
  CALL FUNCTION &apos;DB_SELECT_GENERIC_TABLE&apos;
       EXPORTING
            tablename   = x_header-maintview
*            genkey      = gen_key
            genkey      = &lt;f1_x&gt;
            genkey_ln   = x_header-keylen
       TABLES
*            inttab      = mod_elem_tab
            inttab      = &lt;tab&gt;
       EXCEPTIONS
            db_error    = 12
            not_found   = 04
            wrong_param = 08.
  IF sy-subrc &gt; 4. RAISE get_table_error. ENDIF.
*  READ TABLE mod_elem_tab INDEX 1.
  READ TABLE &lt;tab&gt; INTO &lt;table1&gt; INDEX 1.
  IF sy-subrc &lt;&gt; 0.
    MOVE &lt;initial&gt; TO &lt;table1&gt;.
*  ELSE.
*    &lt;table1&gt; = mod_elem_tab.
  ENDIF.
  IF x_header-texttbexst NE space.
* read text table
    CREATE DATA texttab TYPE STANDARD TABLE OF (x_header-texttab).
    CREATE DATA textline TYPE (x_header-texttab).
    ASSIGN: texttab-&gt;* TO &lt;texttab&gt;,
            textline-&gt;* TO &lt;textline&gt;,
            &lt;textline&gt; TO &lt;textline_x&gt; CASTING.
*    REFRESH mod_elem_tab.
*    CLEAR gen_key.
*    WRITE &lt;table1_text&gt; TO gen_key(x_header-textkeylen).
    CALL FUNCTION &apos;DB_SELECT_GENERIC_TABLE&apos;
         EXPORTING
              tablename   = x_header-texttab
*              genkey      = gen_key
              genkey      = &lt;textkey_x&gt;
              genkey_ln   = x_header-textkeylen
         TABLES
*              inttab      = mod_elem_tab
              inttab      = &lt;texttab&gt;
         EXCEPTIONS
              db_error    = 12
              not_found   = 04
              wrong_param = 08.
    IF sy-subrc &gt; 4. RAISE get_table_error. ENDIF.
*    READ TABLE mod_elem_tab INDEX 1.
    READ TABLE &lt;texttab&gt; INTO &lt;table1_text&gt; INDEX 1.
    IF sy-subrc &lt;&gt; 0.
      MOVE &lt;text_initial&gt; TO &lt;table1_text&gt;.
      CLEAR sy-subrc.
*    ELSE.
*      &lt;table1_text&gt; = mod_elem_tab.
    ENDIF.
  ENDIF.
ENDFORM.                               &quot; TABLE_READ_SINGLE_ENTRY

*&amp;--------------------------------------------------------------------*
*&amp;      Form  SET_TXT_UPDATE_FLAG                                     *
*---------------------------------------------------------------------*
* note, if texttab entry was modified on screen
*---------------------------------------------------------------------*
FORM set_txt_update_flag.

  DATA: lb_als TYPE REF TO IF_EX_VIM_ALS_BADI.

  IF &lt;textkey_x&gt; EQ &lt;initial_textkey_x&gt; OR &quot;textkey not filled yet OR
     status-action EQ kopieren OR      &quot;copy mode              OR
     neuer EQ &apos;J&apos; OR &lt;xact&gt; EQ leer OR &quot;real new entry         OR
     ( temporal_delimitation_happened EQ &apos;X&apos; AND &quot;temporal delimitation
        x_header-delmdtflag EQ &apos;B&apos; ).
    PERFORM fill_texttab_key_uc USING &lt;table1&gt; &lt;table1_text&gt;.&quot;#EC ..
  ENDIF.
  IF status-action EQ hinzufuegen.
    &lt;status&gt;-upd_flag = &apos;X&apos;.           &quot;always both tables must be added
  ELSE.
    TRANSLATE &lt;status&gt;-upd_flag USING &apos; TEX&apos;.
  ENDIF.

  CALL METHOD cl_exithandler=&gt;get_instance
    EXPORTING
      null_instance_accepted        = seex_false
      exit_name                     = &apos;VIM_ALS_BADI&apos;
    CHANGING
      instance                      = lb_als
    EXCEPTIONS
      no_reference                  = 1
      no_interface_reference        = 2
      no_exit_interface             = 3
      class_not_implement_interface = 4
      single_exit_multiply_active   = 5
      cast_error                    = 6
      exit_not_existing             = 7
      data_incons_in_exit_managem   = 8
      OTHERS                        = 9.
  IF sy-subrc NE 0.
    EXIT.
  ELSE.
    CALL METHOD lb_als-&gt;enable_als
      EXPORTING
        view_name   = x_header-viewname
      IMPORTING
        als_enabled = als_enabled.

    IF als_enabled = &apos;X&apos; AND
       ( &lt;status&gt;-upd_flag EQ &apos;T&apos; OR  &lt;status&gt;-upd_flag EQ &apos;X&apos; ).
      PERFORM VIM_MULTI_LANGU_TEXT_ALS.
    ENDIF.
  ENDIF.

ENDFORM.                               &quot; SET_TXT_UPDATE_FLAG

*&amp;--------------------------------------------------------------------*
*&amp;      Form  FILL_TEXTTAB_KEY                                        *
*&amp;--------------------------------------------------------------------*
*       Kept for downward compatibility only. Never use in unicode-
*       system. Use FILL_TEXTTAB_KEY instead                          *
*&amp;--------------------------------------------------------------------*
FORM fill_texttab_key USING enti_wa text_wa.
  FIELD-SYMBOLS: &lt;enti&gt;, &lt;text&gt;.
  DATA: index TYPE i.
  LOOP AT x_namtab WHERE texttabfld NE space
                     AND keyflag NE space.   &quot;all keyfields of text table
    index = x_namtab-position - x_header-tablen.
    ASSIGN text_wa+index(x_namtab-flength) TO &lt;text&gt;.
    IF x_namtab-primtabkey EQ space.   &quot;language key
      MOVE sy-langu TO &lt;text&gt;.
    ELSE.
      index = x_namtab-primtabkey.
      READ TABLE x_namtab INDEX index.   &quot;corresponding field of entity tb
      IF sy-subrc EQ 0.
        ASSIGN enti_wa+x_namtab-position(x_namtab-flength) TO &lt;enti&gt;.
        MOVE &lt;enti&gt; TO &lt;text&gt;.
      ENDIF.
    ENDIF.
  ENDLOOP.
ENDFORM.                               &quot;FILL_TEXTTAB_KEY

*&amp;--------------------------------------------------------------------*
*&amp;      Form  FILL_TEXTTAB_KEY_UC                                     *
*&amp;--------------------------------------------------------------------*
* ENTI_WA ---&gt; WA of entity table                                     *
* TEXT_WA &lt;--- WA of text table                                       *
*&amp;--------------------------------------------------------------------*
FORM fill_texttab_key_uc USING enti_wa
                         CHANGING text_wa.
  FIELD-SYMBOLS: &lt;namtab&gt; TYPE vimnamtab, &lt;namtab2&gt; TYPE vimnamtab,
                 &lt;enti&gt; TYPE ANY, &lt;text&gt; TYPE ANY.
  DATA: index TYPE i.
  LOOP AT x_namtab ASSIGNING &lt;namtab&gt; WHERE texttabfld NE space
                     AND keyflag NE space.
* keyfield of text table
    ASSIGN COMPONENT &lt;namtab&gt;-viewfield OF STRUCTURE text_wa
     TO &lt;text&gt;.
    IF &lt;namtab&gt;-primtabkey EQ space.   &quot;language key
      MOVE sy-langu TO &lt;text&gt;.
    ELSE.
      index = &lt;namtab&gt;-primtabkey.
      READ TABLE x_namtab ASSIGNING &lt;namtab2&gt; INDEX index.
* corresponding field of entity tb
      IF sy-subrc EQ 0.
        ASSIGN COMPONENT &lt;namtab2&gt;-viewfield OF STRUCTURE enti_wa
         TO &lt;enti&gt;.
        MOVE &lt;enti&gt; TO &lt;text&gt;.
      ENDIF.
    ENDIF.
  ENDLOOP.
ENDFORM.                               &quot;FILL_TEXTTAB_KEY_UC

*&amp;--------------------------------------------------------------------*
*&amp;      Form CREATE_WHERETAB_NEW                                      *
*&amp;--------------------------------------------------------------------*
* create where-tab for dynamic select                                 *
*&amp;--------------------------------------------------------------------*
*        --&gt; CW_TOTAL        table line
*            CW_TABLE        table the wheretab has to be filled for
*            CW_ENTI_KEY
*            CW_RC
*&amp;--------------------------------------------------------------------*
FORM create_wheretab_new USING cw_namtab LIKE x_namtab[]
                               total_struc TYPE any
                               total_txt_struc TYPE any
                               value(cw_table) LIKE vimdesc-viewname
                               value(cw_enti_key) TYPE xfeld
                               cw_rc TYPE i.

  DATA: cw_sellist LIKE vimsellist OCCURS 10,
        cw_sel LIKE vimsellist,
        first(1) TYPE c VALUE &apos;X&apos;, w_namtab TYPE vimnamtab,
        flength_in_char TYPE i.
  FIELD-SYMBOLS: &lt;cw_value&gt; TYPE ANY,
                 &lt;w_namtab2&gt; TYPE vimnamtab.

  LOOP AT cw_namtab INTO w_namtab
                    WHERE keyflag NE space    &quot;all textkeyfields
                      AND texttabfld NE space &quot;with relations to
                      AND primtabkey NE 0.    &quot;entity key fields
    CHECK w_namtab-datatype NE &apos;CLNT&apos; OR first EQ space.
    TRANSLATE first USING &apos;X &apos;.
*    IF cw_enti_key EQ space.
*      SUBTRACT x_header-tablen FROM w_namtab-position.
*    ENDIF.
*    ASSIGN cw_total+w_namtab-position(w_namtab-flength) &quot;value of
*              TO &lt;cw_value&gt;.           &quot;textkey
    IF cw_enti_key NE space.
      READ TABLE cw_namtab INDEX w_namtab-primtabkey
       ASSIGNING &lt;w_namtab2&gt;.           &quot;corresp. enti key
      ASSIGN COMPONENT &lt;w_namtab2&gt;-viewfield OF
       STRUCTURE total_struc TO &lt;cw_value&gt;.
      cw_sel-viewfield = &lt;w_namtab2&gt;-viewfield.
    ELSE.
      ASSIGN COMPONENT w_namtab-viewfield OF
       STRUCTURE total_txt_struc TO &lt;cw_value&gt;.
      cw_sel-viewfield = w_namtab-viewfield.
    ENDIF.
    cw_sel-tabix     = sy-tabix.
    cw_sel-operator = &apos;EQ&apos;.
    cw_sel-and_or = &apos;AND&apos;.
    CALL FUNCTION &apos;VIEW_CONVERSION_OUTPUT&apos;
         EXPORTING
              tabname      = cw_table
              fieldname    = cw_sel-viewfield
              value_intern = &lt;cw_value&gt;
*              inttype      = w_namtab-inttype
*              datatype     = w_namtab-datatype
*              decimals     = w_namtab-decimals
*              convexit     = w_namtab-convexit
*              sign         = w_namtab-sign
              outputlen    = w_namtab-outputlen
              intlen       = w_namtab-flength
         IMPORTING
              value_extern = cw_sel-value.
    IF cw_sel-value EQ space.
      cw_sel-initial = &apos;X&apos;.
    ENDIF.
    flength_in_char =
                  w_namtab-flength / cl_abap_char_utilities=&gt;charsize.
    CASE w_namtab-inttype.
      WHEN &apos;F&apos;. cw_sel-fltp_value = &lt;cw_value&gt;.
      WHEN &apos;D&apos;. cw_sel-date_value = &lt;cw_value&gt;.
      WHEN &apos;T&apos;. cw_sel-time_value = &lt;cw_value&gt;.
*      WHEN &apos;P&apos;. cw_sel-pckd_value(w_namtab-flength) = &lt;cw_value&gt;.
      WHEN &apos;P&apos;. cw_sel-raw_value(w_namtab-flength) = &lt;cw_value&gt;.
      WHEN &apos;N&apos;. cw_sel-numc_value(flength_in_char) = &lt;cw_value&gt;.
      WHEN &apos;C&apos;. cw_sel-invd_value(flength_in_char) = &lt;cw_value&gt;.
      WHEN &apos;I&apos;. cw_sel-int4_value = &lt;cw_value&gt;.
      WHEN &apos;X&apos;.
        CASE w_namtab-datatype.
          WHEN &apos;INT1&apos;. cw_sel-int1_value = &lt;cw_value&gt;.
          WHEN &apos;INT2&apos;. cw_sel-int2_value = &lt;cw_value&gt;.
          WHEN &apos;INT4&apos;. cw_sel-int4_value = &lt;cw_value&gt;.
          WHEN &apos;RAW&apos;. cw_sel-raw_value(w_namtab-flength) = &lt;cw_value&gt;.
        ENDCASE.
    ENDCASE.
    cw_sel-converted = &apos;X&apos;.
    APPEND cw_sel TO cw_sellist.
    CLEAR cw_sel.
  ENDLOOP.
  DESCRIBE TABLE cw_sellist.
  READ TABLE cw_sellist INTO cw_sel INDEX sy-tfill.
  IF cw_sel-and_or NE space.
    CLEAR cw_sel-and_or. MODIFY cw_sellist INDEX sy-tfill FROM cw_sel.
  ENDIF.
  CALL FUNCTION &apos;VIEW_FILL_WHERETAB&apos;
    EXPORTING
      tablename               = cw_table
      only_cnds_for_keyflds   = &apos;X&apos;
    TABLES
      sellist                 = cw_sellist
      wheretab                = vim_wheretab
      x_namtab                = cw_namtab
    EXCEPTIONS
      no_conditions_for_table = 01.
  cw_rc = sy-subrc.
ENDFORM.                               &quot;create_wheretab_new
*&amp;--------------------------------------------------------------------*
*&amp;      Form CREATE_WHERETAB                                          *
*&amp;--------------------------------------------------------------------*
*       Kept for downward compatibility only. Never use in unicode-
*       system. Use CREATE_WHERETAB_NEW instead.
*&amp;--------------------------------------------------------------------*
*        --&gt; CW_TOTAL        table line
*            CW_TABLE        table name
*            CW_ENTI_KEY
*            CW_RC
*&amp;--------------------------------------------------------------------*
FORM create_wheretab TABLES cw_namtab STRUCTURE vimnamtab
                     USING value(cw_total)
                           value(cw_table) LIKE vimdesc-viewname
                           value(cw_enti_key) TYPE c
                           cw_rc TYPE i.
  DATA: cw_sellist LIKE vimsellist OCCURS 10, cw_sel LIKE vimsellist,
        first(1) TYPE c VALUE &apos;X&apos;.
  FIELD-SYMBOLS: &lt;cw_value&gt;.

  LOOP AT cw_namtab WHERE keyflag NE space    &quot;all textkeyfields
                      AND texttabfld NE space &quot;with relations to
                      AND primtabkey NE 0.      &quot;entity key fields
    CHECK cw_namtab-datatype NE &apos;CLNT&apos; OR first EQ space.
    TRANSLATE first USING &apos;X &apos;.
    IF cw_enti_key EQ space.
      SUBTRACT x_header-tablen FROM cw_namtab-position.
    ENDIF.
    ASSIGN cw_total+cw_namtab-position(cw_namtab-flength) &quot;value of
              TO &lt;cw_value&gt;.           &quot;textkey
    IF cw_enti_key NE space.
      READ TABLE cw_namtab INDEX cw_namtab-primtabkey.   &quot;corresp. enti key
    ENDIF.
    cw_sel-viewfield = cw_namtab-viewfield.
    cw_sel-tabix     = sy-tabix.
    cw_sel-operator = &apos;EQ&apos;.
    cw_sel-and_or = &apos;AND&apos;.
    CALL FUNCTION &apos;VIEW_CONVERSION_OUTPUT&apos;
      EXPORTING
        value_intern = &lt;cw_value&gt;
        inttype      = cw_namtab-inttype
        datatype     = cw_namtab-datatype
        decimals     = cw_namtab-decimals
        convexit     = cw_namtab-convexit
        sign         = cw_namtab-sign
        outputlen    = cw_namtab-outputlen
        intlen       = cw_namtab-flength
      IMPORTING
        value_extern = cw_sel-value.
    IF cw_sel-value EQ space.
      cw_sel-initial = &apos;X&apos;.
    ENDIF.
* SW 5.8.98 ..
* folgende MOVE&apos;s führen zu unerwünschten impliziten Konvertierungen
* und damit zu Laufzeitfehler
    CLEAR cw_sel-converted.
*   case cw_namtab-inttype.
*     when &apos;F&apos;. cw_sel-fltp_value = &lt;cw_value&gt;.
*     when &apos;D&apos;. cw_sel-date_value = &lt;cw_value&gt;.
*     when &apos;T&apos;. cw_sel-time_value = &lt;cw_value&gt;.
*     when &apos;P&apos;. cw_sel-pckd_value(cw_namtab-flength) = &lt;cw_value&gt;.
*     when &apos;N&apos;. cw_sel-numc_value(cw_namtab-flength) = &lt;cw_value&gt;.
*     when &apos;C&apos;. cw_sel-invd_value(cw_namtab-flength) = &lt;cw_value&gt;.
*     when &apos;I&apos;. cw_sel-int4_value = &lt;cw_value&gt;.
*     when &apos;X&apos;.
*       case cw_namtab-datatype.
*         when &apos;INT1&apos;. cw_sel-int1_value = &lt;cw_value&gt;.
*         when &apos;INT2&apos;. cw_sel-int2_value = &lt;cw_value&gt;.
*         when &apos;INT4&apos;. cw_sel-int4_value = &lt;cw_value&gt;.
*         when &apos;RAW&apos;. cw_sel-raw_value(cw_namtab-flength) = &lt;cw_value&gt;.
*       endcase.
*   endcase.
*   cw_sel-converted = &apos;X&apos;.                                &quot;.. SW 5.8.98
    APPEND cw_sel TO cw_sellist.
  ENDLOOP.
  DESCRIBE TABLE cw_sellist.
  READ TABLE cw_sellist INTO cw_sel INDEX sy-tfill.
  IF cw_sel-and_or NE space.
    CLEAR cw_sel-and_or. MODIFY cw_sellist INDEX sy-tfill FROM cw_sel.
  ENDIF.
  CALL FUNCTION &apos;VIEW_FILL_WHERETAB&apos;
    EXPORTING
      tablename               = cw_table
      only_cnds_for_keyflds   = &apos;X&apos;
    TABLES
      sellist                 = cw_sellist
      wheretab                = vim_wheretab
      x_namtab                = cw_namtab
    EXCEPTIONS
      no_conditions_for_table = 01.
  cw_rc = sy-subrc.
ENDFORM.                               &quot;create_wheretab

*&amp;--------------------------------------------------------------------*
*&amp;      Form  TABLEFRAME                                              *
*&amp;--------------------------------------------------------------------*
* program for function TABLEFRAME_&lt;area&gt;                              *
*&amp;--------------------------------------------------------------------*
FORM  tableframe TABLES header STRUCTURE vimdesc
                        namtab STRUCTURE vimnamtab
                        dbasellist STRUCTURE vimsellist
                        dplsellist STRUCTURE vimsellist
                        exclcuafunct STRUCTURE vimexclfun
                 USING  corrnumber
                        viewaction
                        viewname.

  DATA: enqueue_processed TYPE c, &quot;flag: view enqueued by VIEWFRAME_..
        table_type(11) TYPE c,         &quot;type of table to use
        table_length TYPE i.           &quot;length of current table

*-&lt;&lt;&lt;--------------------------------------------------------------&gt;&gt;&gt;&gt;*
* first of all: determine well-sized internal tables etc.              *
*-&lt;&lt;&lt;--------------------------------------------------------------&gt;&gt;&gt;&gt;*
  READ TABLE header INDEX 1.
  table_length = header-tablen / cl_abap_char_utilities=&gt;charsize + 2.
*  tab lg. + action + mark
  IF header-texttbexst NE space.
    table_length = table_length
     + header-texttablen / cl_abap_char_utilities=&gt;charsize + 1.
* txtb+txtact
  ENDIF.
  IF table_length LE ultra_short_tab.
    MOVE &apos;ULTRA_SHORT&apos;     TO table_type.
    FREE: extract_vs, total_vs,
          extract_s, total_s,
          extract_m, total_m,
          extract_l, total_l,
          extract_vl, total_vl,
          extract_ul, total_ul.
  ELSEIF table_length LE very_short_tab.
    MOVE &apos;VERY_SHORT&apos;     TO table_type.
    FREE: extract_us, total_us,
          extract_s, total_s,
          extract_m, total_m,
          extract_l, total_l,
          extract_vl, total_vl,
          extract_ul, total_ul.
  ELSEIF table_length LE short_tab.
    MOVE &apos;SHORT&apos;     TO table_type.
    FREE: extract_us, total_us,
          extract_vs, total_vs,
          extract_m, total_m,
          extract_l, total_l,
          extract_vl, total_vl,
          extract_ul, total_ul.
  ELSEIF table_length LE middle_tab.
    MOVE &apos;MIDDLE&apos;    TO table_type.
    FREE: extract_us, total_us,
          extract_vs, total_vs,
          extract_s, total_s,
          extract_l, total_l,
          extract_vl, total_vl,
          extract_ul, total_ul.
  ELSEIF table_length LE long_tab.
    MOVE &apos;LONG&apos;    TO table_type.
    FREE: extract_us, total_us,
          extract_vs, total_vs,
          extract_s, total_s,
          extract_m, total_m,
          extract_vl, total_vl,
          extract_ul, total_ul.
  ELSEIF table_length LE very_long_tab.
    MOVE &apos;VERY_LONG&apos;    TO table_type.
    FREE: extract_us, total_us,
          extract_vs, total_vs,
          extract_s, total_s,
          extract_m, total_m,
          extract_l, total_l,
          extract_ul, total_ul.
  ELSEIF table_length LE ultra_long_tab.
    MOVE &apos;ULTRA_LONG&apos;    TO table_type.
    FREE: extract_us, total_us,
          extract_vs, total_vs,
          extract_s, total_s,
          extract_m, total_m,
          extract_l, total_l,
          extract_vl, total_vl.
  ENDIF.
  maint_mode = viewaction.
  corr_nbr = corrnumber.
*-&lt;&lt;&lt;--------------------------------------------------------------&gt;&gt;&gt;&gt;*
* Entrypoint after changing maintenance mode (show &lt;--&gt; update)        *
*-&lt;&lt;&lt;--------------------------------------------------------------&gt;&gt;&gt;&gt;*
  DO.
*----------------------------------------------------------------------*
* Select data from database                                            *
*----------------------------------------------------------------------*
    PERFORM table_call_function TABLES dbasellist dplsellist
                                header namtab exclcuafunct
                                USING read table_type update_flag.
    CASE sy-subrc.
      WHEN 1.
        RAISE missing_corr_number.
    ENDCASE.
*-&lt;&lt;&lt;--------------------------------------------------------------&gt;&gt;&gt;&gt;*
* Entrypoint after saving data into database                           *
* Entrypoint after refreshing selected entries from database           *
*-&lt;&lt;&lt;--------------------------------------------------------------&gt;&gt;&gt;&gt;*
    DO.
*----------------------------------------------------------------------*
* Edit data                                                            *
*----------------------------------------------------------------------*
      DO.
        PERFORM table_call_function
                             TABLES dbasellist dplsellist
                                    header namtab exclcuafunct
                             USING edit table_type &lt;status&gt;-upd_flag.
        CASE sy-subrc.
          WHEN 1.
            IF maint_mode EQ transportieren AND viewaction EQ aendern.
              MOVE viewaction TO maint_mode.
            ELSE.
              RAISE missing_corr_number.
            ENDIF.
          WHEN OTHERS.
            EXIT.
        ENDCASE.
      ENDDO.
*----------------------------------------------------------------------*
*  Handle usercommands...                                              *
*  ...at first handle commands which could cause loss of data          *
*----------------------------------------------------------------------*
      IF function EQ back.
        function = end.
      ENDIF.
      IF ( function EQ switch_to_show_mode OR
           function EQ get_another_view    OR
           function EQ switch_transp_to_upd_mode OR
           function EQ end ) AND
         &lt;status&gt;-upd_flag NE space.
        PERFORM beenden.
        CASE sy-subrc.
          WHEN 0.
            PERFORM table_call_function
                         TABLES dbasellist dplsellist
                                header namtab exclcuafunct
                         USING save table_type &lt;status&gt;-upd_flag.
            CASE sy-subrc.
              WHEN 0.
                IF &lt;status&gt;-upd_flag EQ space. EXIT. ENDIF.
              WHEN 1.
                RAISE missing_corr_number.
              WHEN 3.
            ENDCASE.
          WHEN 8.
            EXIT.
          WHEN 12.
        ENDCASE.
*----------------------------------------------------------------------*
*  ...2nd: transport request                                           *
*----------------------------------------------------------------------*
      ELSEIF function EQ transport.
        IF &lt;status&gt;-upd_flag NE space.
          PERFORM transportieren.
          CASE sy-subrc.
            WHEN 0.
              PERFORM table_call_function
                              TABLES dbasellist dplsellist
                                     header namtab exclcuafunct
                              USING save table_type &lt;status&gt;-upd_flag.
              CASE sy-subrc.
                WHEN 0.
                  maint_mode = transportieren.
                WHEN 1.
                  RAISE missing_corr_number.
                WHEN 3.
              ENDCASE.
            WHEN 8.
              EXIT.
            WHEN 12.
          ENDCASE.
        ELSE.
          maint_mode = transportieren.
        ENDIF.
*----------------------------------------------------------------------*
*  ...now reset or save requests                                       *
*----------------------------------------------------------------------*
      ELSEIF function EQ reset_list  OR
             function EQ reset_entry OR
             function EQ save.
*----------------------------------------------------------------------*
*  Refresh selected entries from database or save data into database   *
*----------------------------------------------------------------------*
        PERFORM table_call_function
                          TABLES dbasellist dplsellist
                                 header namtab exclcuafunct
                          USING function table_type &lt;status&gt;-upd_flag.
        CASE sy-subrc.
          WHEN 1.
            RAISE missing_corr_number.
          WHEN 3.
        ENDCASE.
      ELSE.
        EXIT.
      ENDIF.
    ENDDO.
*----------------------------------------------------------------------*
*  ...now other commands...                                            *
*----------------------------------------------------------------------*
    CASE function.
      WHEN switch_to_show_mode.
*   change maintenance mode from update to show
        PERFORM enqueue USING &apos;D&apos; header-frm_af_enq. &quot;dequeue view
        CLEAR enqueue_processed.
        maint_mode = anzeigen.
      WHEN switch_to_update_mode.
*     change maintenance mode from show to update
        PERFORM enqueue USING &apos;E&apos; header-frm_af_enq.  &quot;enqueue view
        IF sy-subrc EQ 0.
          MOVE &apos;X&apos; TO enqueue_processed.
          maint_mode = aendern.
        ENDIF.
      WHEN switch_transp_to_upd_mode.
*     change maintenance mode from transport to update
        maint_mode = aendern.
      WHEN transport.
*     change maintenance mode from update to transport
        maint_mode = transportieren.
      WHEN OTHERS.
        IF enqueue_processed NE space.
          PERFORM enqueue USING &apos;D&apos; header-frm_af_enq.&quot;dequeue view
        ENDIF.
        PERFORM before_leaving_frame_function
                                      USING header-frm_bf_end.
        EXIT.
    ENDCASE.
  ENDDO.
ENDFORM.                                                    &quot;

*&amp;--------------------------------------------------------------------*
*&amp;      Form TABLEPROC                                                *
*&amp;--------------------------------------------------------------------*
* program for function TABLEPROC_&lt;area&gt;                               *
*&amp;--------------------------------------------------------------------*
FORM  tableproc.
*----------------------------------------------------------------------*
* Initialization: set field-symbols etc.                               *
*----------------------------------------------------------------------*
  IF last_view_info NE view_name.
    PERFORM initialisieren.
  ENDIF.
  PERFORM justify_action_mode.
  MOVE: view_action TO maint_mode,
        corr_number TO corr_nbr.

*----------------------------------------------------------------------*
* Get data from database                                               *
*----------------------------------------------------------------------*
  IF fcode EQ read OR fcode EQ read_and_edit.
    PERFORM prepare_read_request.
    IF x_header-frm_rp_get NE space.
      PERFORM (x_header-frm_rp_get) IN PROGRAM (sy-repid).
    ELSE.
      PERFORM table_get_data.
    ENDIF.
    IF fcode EQ read_and_edit. fcode = edit. ENDIF.
  ENDIF.

  CASE fcode.
    WHEN  edit.                        &quot; Edit read data
      PERFORM call_dynpro.
      PERFORM check_upd.
*....................................................................*

    WHEN save.                         &quot; Write data into database
      PERFORM prepare_saving.
      IF &lt;status&gt;-upd_flag NE space.
        IF x_header-frm_rp_upd NE space.
          PERFORM (x_header-frm_rp_upd) IN PROGRAM.
        ELSE.
          IF sy-subrc EQ 0.
            PERFORM table_db_upd.
          ENDIF.
        ENDIF.
        PERFORM after_saving.
      ENDIF.
*....................................................................*

    WHEN reset_list.     &quot; Refresh all marked entries of EXTRACT from db
      PERFORM reset_entries USING list_bild.
*....................................................................*

    WHEN reset_entry.               &quot; Refresh single entry from database
      PERFORM reset_entries USING detail_bild.
*.......................................................................
  ENDCASE.
  MOVE: &lt;status&gt;-upd_flag TO update_required,
        function TO ucomm.
ENDFORM.                               &quot;tableproc

*&amp;--------------------------------------------------------------------*
*&amp;      FORM  REPLACE_FORBIDDEN_CHARS                                 *
*&amp;--------------------------------------------------------------------*
* replace forbidden characters with internal code into NAME           *
*---------------------------------------------------------------------*
* ---&gt; NAME - name to correct                                         *
* ---&gt; FORBIDDEN_CHARS - chars which must be replaced                 *
* &lt;--- NAME - corrected name                                          *
*&amp;--------------------------------------------------------------------*
FORM  replace_forbidden_chars USING value(forbidden_chars) name.
  FIELD-SYMBOLS: &lt;code&gt;.
  DATA: suspect_char(1) TYPE c, code(2) TYPE c.

  DO.
    IF name CA forbidden_chars.
      ASSIGN name+sy-fdpos(1)  TO &lt;code&gt;.
      MOVE &lt;code&gt; TO suspect_char.
      ASSIGN &lt;code&gt; TO &lt;code&gt; TYPE &apos;X&apos;.
      MOVE &lt;code&gt; TO code.
      REPLACE suspect_char WITH code INTO name.
    ELSE.
      EXIT.
    ENDIF.
  ENDDO.
ENDFORM.                               &quot;replace_forbidden_chars
*&amp;---------------------------------------------------------------------*
*&amp;      Form  vim_get_text_keyflds
*&amp;---------------------------------------------------------------------*
*       inserts all key field names of a texttable into a table
*----------------------------------------------------------------------*
*      --&gt;P_TEXTTABNAME   text table name
*      &lt;--P_TEXT_KEYFLDS  table of keyfields
*----------------------------------------------------------------------*
FORM vim_get_text_keyflds USING p_texttabname TYPE tabname
                         CHANGING p_text_keyflds TYPE vim_flds_tab_type.

  STATICS: texttabname_save TYPE tabname,
           text_keyflds_save TYPE vim_flds_tab_type.

  FIELD-SYMBOLS: &lt;namtab&gt; TYPE vimnamtab.

  REFRESH p_text_keyflds.
  IF texttabname_save = p_texttabname.
    APPEND LINES OF text_keyflds_save TO p_text_keyflds.
  ELSE.
    texttabname_save = p_texttabname.
    REFRESH text_keyflds_save.
    LOOP AT x_namtab ASSIGNING &lt;namtab&gt; WHERE texttabfld NE space
                       AND keyflag NE space.
      APPEND &lt;namtab&gt;-viewfield TO p_text_keyflds.
    ENDLOOP.
    APPEND LINES OF p_text_keyflds TO text_keyflds_save.
  ENDIF.
ENDFORM.                               &quot; vim_get_text_keyflds</include_source>
   </include>
   <include NAME="LSVIMFX2" VARCL="X" SUBC="I" APPL="S" CNAM="SAP" CDAT="19980824" UNAM="SAP" UDAT="20080721" VERN="000033" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122442" IDATE="20080721" ITIME="122442">
    <include_source>*----------------------------------------------------------------------*
*   INCLUDE LSVIMFX2                                                   *
*----------------------------------------------------------------------*
*---------------------------------------------------------------------*
*       FORM DETAILBILD                                               *
*---------------------------------------------------------------------*
*       .........                                                     *
*---------------------------------------------------------------------*
FORM detailbild.
  IF status-mode NE list_bild OR status-type NE zweistufig.
    MESSAGE i001(sv).
    EXIT.
  ENDIF.
  nextline = firstline + l - 1.
  IF l EQ 0 OR nextline GT maxlines.
    MESSAGE s032(sv).
    MOVE firstline TO nextline.
    EXIT.
  ENDIF.
  IF mark_extract &gt; 0.                 &quot;ufdetailb
    PERFORM set_mark_only USING nextline.
  ENDIF.                               &quot;ufdetaile
  IF x_header-delmdtflag NE space.
    TRANSLATE vim_no_mainkey_exists USING vim_no_mkey_not_procsd_patt.
  ENDIF.
  PERFORM process_detail_screen USING &apos;S&apos;.
ENDFORM.                    &quot;detailbild
*---------------------------------------------------------------------*
*       FORM DETAIL_ABBRECHEN
**---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM detail_abbrechen.
  IF replace_mode EQ space AND
     ( sy-datar NE space OR
       ( x_header-bastab EQ space OR x_header-texttbexst EQ space )
       AND &lt;table1_x&gt; NE &lt;table2_x&gt;
       OR  x_header-bastab NE space AND x_header-texttbexst NE space
       AND ( &lt;table1_x&gt; NE &lt;vim_xextract_enti&gt;
             OR &lt;table1_xtext&gt; NE &lt;vim_xextract_text&gt; ) ).
    CALL FUNCTION &apos;POPUP_TO_CONFIRM_STEP&apos;
      EXPORTING
        titel          = svim_text_007
        textline1      = svim_text_009
        textline2      = svim_text_006
        defaultoption  = &apos;N&apos;
        cancel_display = &apos; &apos;
      IMPORTING
        answer         = answer.                            &quot;#EC *
    IF answer NE &apos;J&apos;.
      EXIT.
    ENDIF.
  ENDIF.
  IF status-action EQ kopieren.
    SET SCREEN 0.
    LEAVE SCREEN.
  ENDIF.
  IF maxlines LE 1.
*   IF STATUS-ACTION EQ HINZUFUEGEN OR STATUS-ACTION EQ KOPIEREN.
    IF status-action EQ hinzufuegen.
      status-action = aendern.
      title-action  = aendern.
      CLEAR &lt;status&gt;-selected.
    ENDIF.
    PERFORM fill_extract.
    nextline = 1.
  ENDIF.
  neuer = &apos;N&apos;.
  IF vim_single_entry_function EQ space.
    &lt;status&gt;-upd_flag = space.
    IF replace_mode EQ space AND vim_special_mode NE vim_delete.
      l = nextline - &lt;status&gt;-firstline + 1.
      IF l LE 0 OR l GT looplines.
        l = 1.
      ENDIF.
      nextline = &lt;status&gt;-firstline.
      SET SCREEN liste.
    ELSE.
      SET SCREEN 0. CLEAR vim_act_dynp_view.
    ENDIF.
  ELSE.                                &quot;single_entry_function
    function = end. SET SCREEN 0. CLEAR vim_act_dynp_view.
    PERFORM update_status.
  ENDIF.
  LEAVE SCREEN.
ENDFORM.                    &quot;detail_abbrechen
*---------------------------------------------------------------------*
*       FORM DETAIL_BACK                                              *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM detail_back.

  DATA:count TYPE i.

  CASE status-action.
    WHEN aendern.
      PERFORM update_tab.
    WHEN hinzufuegen.
*      WRITE &lt;f1&gt; TO entry(x_header-keylen).
      MOVE &lt;f1_x&gt; TO &lt;f1_wax&gt;.
      PERFORM update_tab.
      neuer = &apos;N&apos;.
*      SORT extract BY &lt;vim_extract_key&gt;.
      SORT extract BY &lt;vim_xextract_key&gt;.                   &quot;#EC *
*      MOVE entry TO &lt;table1&gt;.
*      READ TABLE extract WITH KEY &lt;f1&gt; BINARY SEARCH.
      READ TABLE extract WITH KEY &lt;f1_x&gt;.                   &quot;#EC *
      firstline = 1.
      IF sy-tabix GT looplines AND looplines GT 0.
        count = ( sy-tabix - firstline ) DIV looplines + 1.
        DO count TIMES.
          firstline = firstline + looplines - 1.
        ENDDO.
        MOVE firstline TO &lt;status&gt;-firstline.
      ENDIF.
      l = sy-tabix - firstline + 1.
      MOVE l TO &lt;status&gt;-cur_line.
      MOVE &lt;initial&gt; TO &lt;table1&gt;.
      IF x_header-bastab NE space AND x_header-texttbexst NE space.
        MOVE &lt;text_initial_x&gt; TO &lt;table1_xtext&gt;.
*        MOVE &lt;text_initial&gt; TO &lt;table1_text&gt;.
      ENDIF.
  ENDCASE.
  IF status-data EQ auswahldaten AND maxlines LE 1.
    &lt;table1_wax&gt; = &lt;vim_xextract&gt;.
    IF status-delete = geloescht.
      status-delete = nicht_geloescht.
      title-action  = aendern.
      PERFORM markiere_alle USING nicht_markiert.
    ENDIF.
    IF status-action EQ hinzufuegen.
      status-action = aendern.
      title-action  = aendern.
      CLEAR &lt;status&gt;-selected.
    ENDIF.
    IF x_header-delmdtflag NE space.
      &lt;vim_h_mkey&gt;(x_header-keylen) = &lt;f1_x&gt;.
      LOOP AT vim_collapsed_mainkeys.&quot;#EC * &quot;WHERE mkey_bf EQ &lt;vim_f1_before&gt;.
        IF vim_collapsed_mainkeys-mkey_bf EQ space. &quot;SW: wie liste_back
* change XB 11.06.02 BCEK060520/BCEK060521 ----------begin--------------
* if &lt;vim_collapsed_mkey_bfx&gt; should be changed, only when it isn&apos;t
* constant 4B00, that means data isn&apos;t at position 0.
          IF &lt;vim_collapsed_mkey_bfx&gt; NE &lt;vim_mkey_beforex&gt;.
            &lt;vim_collapsed_mkey_bfx&gt; = &lt;vim_collapsed_logkeyx&gt;.
*          vim_collapsed_mainkeys-mkey_bf =
*                                       vim_collapsed_mainkeys-log_key.
          ENDIF.
* change XB 11.06.02 BCEK060520/BCEK060521 ------------end--------------
          CLEAR vim_collapsed_mainkeys-log_key.
        ENDIF.                                              &quot;SW
        &lt;f1_x&gt; = &lt;vim_h_coll_mkey&gt;.
*        &lt;f1&gt; = vim_collapsed_mainkeys-mainkey.
        &lt;vim_enddate_mask&gt; = space.
        &lt;vim_h_coll_mkey&gt; = &lt;f1_x&gt;.
*        vim_collapsed_mainkeys-mainkey = &lt;f1&gt;.
        MODIFY vim_collapsed_mainkeys.                      &quot;#EC *
      ENDLOOP.
      IF vim_delim_expa_excluded NE space.
        DELETE excl_cua_funct WHERE function EQ &apos;EXPA&apos;.
        CLEAR vim_delim_expa_excluded.
      ENDIF.
      IF status-action = aendern AND title-action = hinzufuegen.
        title-action  = aendern.
      ENDIF.
    ENDIF.
    PERFORM fill_extract.
*    &lt;table1&gt; = entry(x_header-keylen).
*    READ TABLE extract WITH KEY &lt;f1&gt;.
    READ TABLE extract WITH KEY &lt;f1_wax&gt;.
    IF sy-subrc EQ 0.
      nextline = sy-tabix.
    ELSE.
      nextline = 1.
    ENDIF.
  ELSE.
    MOVE firstline TO nextline.
  ENDIF.
  vim_next_screen = liste. vim_leave_screen = &apos;X&apos;.
ENDFORM.                    &quot;detail_back
*&amp;--------------------------------------------------------------------*
*&amp;      Form  DETAIL_EXIT_COMMAND                                     *
*&amp;--------------------------------------------------------------------*
* handle exit commands on detail screen                               *
*&amp;--------------------------------------------------------------------*
FORM detail_exit_command.
  DATA: answer.
  function = ok_code.
  CLEAR vim_old_viewkey.
  TRANSLATE vim_no_mainkey_exists USING vim_no_mkey_not_procsd_patt.
  CASE ok_code.
    WHEN &apos;ABR &apos;.
      CLEAR ok_code.
      PERFORM detail_abbrechen.
    WHEN &apos;IGN &apos;.
      PERFORM ignorieren.
    WHEN &apos;UPRF&apos;.                       &quot;UFprofileB
      CHECK vim_pr_activating = space.
*      IF SY-DATAR &lt;&gt; SPACE.
*        CALL FUNCTION &apos;POPUP_TO_CONFIRM_STEP&apos;
*             EXPORTING
*                  TEXTLINE1      = SVIM_TEXT_PRF
*                  TEXTLINE2      = SVIM_TEXT_PRG
*                  TITEL          = SVIM_TEXT_PRE
*                  CANCEL_DISPLAY = &apos; &apos;
*             IMPORTING
*                  ANSWER         = ANSWER.
*        IF ANSWER &lt;&gt; &apos;J&apos;.
*          CLEAR: FUNCTION, OK_CODE.
*        ENDIF.
*      ENDIF.
      IF NOT function IS INITIAL.
        PERFORM vim_pr_mand_fields.
      ENDIF.
    WHEN &apos;GPRF&apos;.
      CHECK vim_pr_activating = space.
      PERFORM vim_pr_mand_fields         .         &quot;UFprofileE
  ENDCASE.
ENDFORM.                               &quot;detail_exit_command
*---------------------------------------------------------------------*
*       FORM DETAIL_INIT                                              *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM detail_init.
  CONSTANTS: forward VALUE &apos;X&apos;.
  IF function NE space.
    status-mode = detail_bild.
    title-mode  = detail_bild.
    IF &lt;xmark&gt; EQ markiert.
      status-mark = markiert.
    ELSE.
      status-mark = nicht_markiert.
    ENDIF.
    IF status-action NE kopieren AND neuer NE &apos;J&apos;.
      IF &lt;status&gt;-selected = by_field_contents AND nextline &gt; maxlines.
        nextline = 1.                  &quot;377434/1999 UF011299
      ENDIF.
      IF x_header-subsetflag NE space AND replace_mode EQ space.
        PERFORM fill_subsetfields.
      ENDIF.
* ========== XB int225314/03 H601454 begin ==========
* maxlines must GT nextline in EXTRACT, otherweise the
* empty entry in EXTRACT will be readed.
      IF nextline &gt; maxlines.
        PERFORM read_table USING maxlines.
      ELSE.
        PERFORM read_table USING nextline.
      ENDIF.
* ========== XB int225314/03 H601454 end   ==========
      IF x_header-subsetflag NE space.
        PERFORM complete_subsetfields.
      ENDIF.
    ENDIF.
    IF vim_special_mode EQ vim_delimit.
      MOVE vim_sval_tab-value TO &lt;vim_new_begdate&gt;.
    ENDIF.
  ENDIF.
  CLEAR: vim_key_alr_checked, vim_keyrange_alr_checked.
  vim_act_dynp_view = x_header-viewname.
  PERFORM set_title USING title &lt;name&gt;.
  CASE replace_mode.
    WHEN space.
*     SET PF-STATUS STATUS EXCLUDING EXCL_CUA_FUNCT.
      IF neuer NE &apos;X&apos;. &quot;error in CHECK_KEY for timedep. objects
        IF vim_special_mode NE vim_delete.
          PERFORM set_pf_status USING status.
        ELSE.
          PERFORM set_pf_status USING &apos;REPLACE&apos;.
        ENDIF.
      ENDIF.
    WHEN OTHERS.
*     SUPPRESS DIALOG.
*     SET PF-STATUS &apos;REPLACE&apos;.
      PERFORM set_pf_status USING &apos;REPLACE&apos;.
*     IF X_HEADER-BASTAB NE SPACE AND X_HEADER-TEXTTBEXST NE SPACE.
*     IF VIM_SPECIAL_MODE NE VIM_UPGRADE AND
*        X_HEADER-BASTAB NE SPACE AND X_HEADER-TEXTTBEXST NE SPACE.
*       IF REPLACE_TEXTTABLE_FIELD NE SPACE.
*         MOVE &apos;T&apos; TO &lt;STATUS&gt;-UPD_FLAG.
*       ELSE.
*         MOVE &apos;E&apos; TO &lt;STATUS&gt;-UPD_FLAG.
*       ENDIF.
*     ELSE.
*       MOVE &apos;X&apos; TO &lt;STATUS&gt;-UPD_FLAG.
*     ENDIF.
*     EXIT.
  ENDCASE.
ENDFORM.                    &quot;detail_init
*---------------------------------------------------------------------*
*       FORM DETAIL_LOESCHE                                           *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM detail_loesche.
  DATA: tot_ix LIKE sy-tabix, rec LIKE sy-subrc,
        delete_fix_value(1) TYPE c,
        entry_contains_fix_val(1) TYPE c,
        w_field TYPE vimty_fields_type,
        bc_fix_del_info_sent(1) TYPE c VALUE &apos; &apos;.

*   -------Authority check before deleting fix values from BC-Sets------
  delete_fix_value = vim_bc_chng_allowed.
  IF vim_bc_chng_allowed = space.  &quot;fix field changeability forced
    READ TABLE vim_bc_entry_list INTO vim_bc_entry_list_wa
    WITH TABLE KEY viewname = x_header-viewname
    keys = &lt;vim_xextract_key&gt;.
    IF sy-subrc = 0.
      CLEAR entry_contains_fix_val.
      LOOP AT vim_bc_entry_list_wa-fields INTO w_field.
        IF w_field-flag = vim_profile_fix.
          entry_contains_fix_val = &apos;X&apos;.
        ENDIF.
      ENDLOOP.
      IF entry_contains_fix_val = &apos;X&apos;.
        IF bc_fix_del_info_sent EQ space AND
           &lt;status&gt;-bcfixdelinfosent NE &apos;Y&apos;.&quot;HCG: del dependent VCL
          bc_fix_del_info_sent = &apos;X&apos;.
          &lt;status&gt;-bcfixdelinfosent = &apos;X&apos;.
          MESSAGE i177(sv).
        ENDIF.
      ELSE.
        delete_fix_value = &apos;X&apos;.
      ENDIF.
    ELSE.
      delete_fix_value = &apos;X&apos;.
    ENDIF.
  ENDIF.
  CHECK delete_fix_value EQ &apos;X&apos;.
*   -------------------------------------------------------------&quot;HCG---
  IF &lt;xmark&gt; NE uebergehen.
    READ TABLE total WITH KEY &lt;vim_xextract_key&gt; BINARY SEARCH.&quot;#EC *
    MOVE sy-tabix TO tot_ix.
    IF x_header-existency EQ &apos;M&apos;.      &quot;no mainkey delete allowed
      PERFORM check_if_entry_can_be_deleted.
      IF sy-subrc NE 0.
        &lt;xmark&gt; = uebergehen. ignored_entries_exist = &apos;X&apos;.
        MODIFY extract INDEX nextline.                      &quot;#EC *
        &lt;mark&gt; = uebergehen.
        MODIFY total INDEX tot_ix.                          &quot;#EC *
        EXIT.
      ENDIF.
    ENDIF.
    PERFORM logical_delete_from_total USING tot_ix.
    IF &lt;xmark&gt; EQ markiert.
      mark_total  = mark_total - 1.
      mark_extract = mark_extract - 1.
    ENDIF.
    IF x_header-delmdtflag NE space.
      IF vim_special_mode NE vim_upgrade.
        PERFORM check_if_entry_is_to_display USING &apos;L&apos; &lt;vim_xtotal_key&gt;
                                                   space &lt;vim_begdate&gt;.
      ELSE.
        CLEAR sy-subrc.
      ENDIF.
    ENDIF.
    IF x_header-delmdtflag EQ space OR sy-subrc LT 8.
      rec = sy-subrc.
      DELETE extract INDEX nextline.
*MN 421570 2005
      DESCRIBE TABLE extract LINES maxlines.
      IF rec EQ 4.
        LOOP AT total.                                      &quot;#EC *
          PERFORM select USING &lt;status&gt;-selected.
          CHECK sy-subrc EQ 0.
          CHECK &lt;vim_tot_mkey_beforex&gt; EQ &lt;vim_old_mkey_beforex&gt; AND
                ( vim_mkey_after_exists EQ space OR
                  &lt;vim_tot_mkey_afterx&gt; EQ &lt;vim_old_mkey_afterx&gt; ).
*          CHECK &lt;vim_tot_mkey_before&gt; EQ &lt;vim_old_mkey_before&gt; AND
*                ( vim_mkey_after_exists EQ space OR
*                  &lt;vim_tot_mkey_after&gt; EQ &lt;vim_old_mkey_after&gt; ).
          vim_mainkey = vim_old_viewkey.
          extract = total.
          PERFORM mod_extract_and_mainkey_tab USING &apos;I&apos; nextline.
          EXIT.
        ENDLOOP.
      ENDIF.
    ENDIF.
    IF vim_special_mode EQ vim_upgrade.
      counter = 1.
      EXIT.
    ENDIF.
    IF ignored_entries_exist EQ space AND maxlines GT 1.
      MESSAGE s013(sv).
    ELSE.
      MESSAGE i013(sv).
    ENDIF.
  ENDIF.
  IF &lt;status&gt;-mark_only &lt;&gt; space.      &quot;ufdetailb
    DESCRIBE TABLE extract LINES maxlines.
    IF mark_extract = 0.
* last marked entry deleted
      nextline = 1.
      vim_next_screen = liste. vim_leave_screen = &apos;X&apos;.
    ELSE.
* search next marked entry
      nextline = nextline - 1.
      PERFORM get_marked_entry USING &apos;X&apos;
                  CHANGING nextline
                           rec.
      IF rec &lt;&gt; 0.
* search previous marked entry
        nextline = nextline + 1.
        PERFORM get_marked_entry USING space
                    CHANGING nextline
                             rec.
      ENDIF.
      IF rec &lt;&gt; 0.
        nextline = 1. vim_next_screen = liste. vim_leave_screen = &apos;X&apos;.
      ELSE.
        PERFORM get_page_and_position USING nextline
                                            looplines
                                      CHANGING firstline
                                               l.
      ENDIF.
    ENDIF.

  ELSE.                                &quot;ufdetaile
    DESCRIBE TABLE extract LINES maxlines.
    IF maxlines EQ 0.
      nextline = 1.
      IF status-action EQ hinzufuegen.
        status-action = aendern.
        title-action = aendern.
      ENDIF.
      PERFORM fill_extract.
      vim_next_screen = liste. vim_leave_screen = &apos;X&apos;.
    ENDIF.
    IF nextline GT maxlines.
      nextline = maxlines.
    ENDIF.
  ENDIF.                               &quot;ufdetail
  READ TABLE total INDEX tot_ix.                            &quot;#EC *
  CLEAR vim_old_viewkey.
  TRANSLATE vim_no_mainkey_exists USING vim_no_mkey_not_procsd_patt.
ENDFORM.                    &quot;detail_loesche
*---------------------------------------------------------------------*
*       FORM DETAIL_MARKIERE                                          *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM detail_markiere.
  IF neuer EQ &apos;J&apos;.
    EXIT.
  ENDIF.
  PERFORM update_tab.
* PERFORM MARKIERE USING FIRSTLINE.
  PERFORM markiere USING nextline.
  CLEAR function.
ENDFORM.                    &quot;detail_markiere


*---------------------------------------------------------------------*
*       FORM DETAIL_MARKIERTE                                         *
*---------------------------------------------------------------------*
*       UF300798 Detail-screen only with marked entries except line-
*                selection on list-screen
*---------------------------------------------------------------------*
FORM detail_markierte.

  DATA: rc LIKE sy-subrc.

  IF status-mode NE list_bild OR status-type NE zweistufig.
    MESSAGE i001(sv).
    EXIT.
  ENDIF.
  IF mark_extract = 0.
* no entries marked
    PERFORM detailbild.
    EXIT.
  ENDIF.
  &lt;status&gt;-mark_only = &apos;X&apos;.
** current entry marked?
*  nextline = firstline + l - 1.
*  PERFORM check_marked USING nextline
*                       CHANGING rc.
*  IF rc &lt;&gt; 0.
* search first marked entry
  nextline = 0.
  PERFORM get_marked_entry USING &apos;X&apos;
                           CHANGING nextline
                                    rc.
  IF rc &lt;&gt; 0. PERFORM detailbild. EXIT. ENDIF.
*  ENDIF.
  IF x_header-delmdtflag NE space.
    TRANSLATE vim_no_mainkey_exists USING vim_no_mkey_not_procsd_patt.
  ENDIF.
  PERFORM process_detail_screen USING &apos;S&apos;.
ENDFORM.                    &quot;detail_markierte

*---------------------------------------------------------------------*
*       FORM DETAIL_PAI                                               *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
* &lt;--- NEXT_SCREEN - next screen to process                           *
* &lt;--- LEAVE_SCREEN - flag: X - leave screen necessary                *
*---------------------------------------------------------------------*
FORM detail_pai.
  CLEAR: vim_next_screen, vim_leave_screen.
  MOVE: status-data TO &lt;status&gt;-st_data,
        status-mode TO &lt;status&gt;-st_mode,
        status-delete TO &lt;status&gt;-st_delete,
        status-action TO &lt;status&gt;-st_action,
        title         TO &lt;status&gt;-title,
        maxlines      TO &lt;status&gt;-maxlines,
        mark_extract  TO &lt;status&gt;-mk_xt,
        mark_total    TO &lt;status&gt;-mk_to,
        function      TO &lt;status&gt;-fcode.
  IF x_header-ptfrkyexst NE space.
    PERFORM consistency_prt_frky_fields USING &apos;X&apos;.
  ENDIF.
* IF TEMPORAL_DELIMITATION_HAPPENED NE SPACE AND
*    STATUS-ACTION NE KOPIEREN.
  IF &lt;status&gt;-prof_found &lt;&gt; space.
    CLEAR vim_pr_fields_wa.            &quot;UFprofiles
  ENDIF.
  IF vim_special_mode NE vim_upgrade AND
     temporal_delimitation_happened NE space AND
     status-action NE kopieren.
    PERFORM update_tab.
    PERFORM after_temporal_delimitation.
    CLEAR temporal_delimitation_happened.
    PERFORM check_if_entry_is_to_display USING &apos;L&apos; &lt;f1_x&gt; space
                                               &lt;vim_begdate&gt;.
    IF status-action EQ hinzufuegen.
      IF function NE &apos;NEXT&apos;.
        CASE sy-subrc.
          WHEN 0.                      &quot;expanded mode or new entry
            PERFORM read_table USING nextline.
          WHEN 4.                      &quot;collapsed mode and actual entry
            READ TABLE extract WITH KEY &lt;f1_x&gt;.             &quot;#EC *
            nextline = sy-tabix.
            extract = total.
            CLEAR function.
          WHEN OTHERS.                 &quot;collapsed mode and other entry
            LOOP AT extract.                                &quot;#EC *
              CHECK &lt;vim_ext_mkey_beforex&gt; EQ &lt;vim_f1_beforex&gt; AND
                    ( vim_mkey_after_exists EQ space OR
                    &lt;vim_ext_mkey_afterx&gt; EQ &lt;vim_f1_afterx&gt; ).
              nextline = sy-tabix.
              EXIT.
            ENDLOOP.
            extract = total.
            CLEAR function.
        ENDCASE.
      ENDIF.
    ELSE.
      IF sy-subrc EQ 0.
        ADD 1 TO exind.
        nextline = exind.
      ENDIF.
    ENDIF.
  ENDIF.
* FUNCTION = OK_CODE.
  CLEAR ok_code.
  IF replace_mode NE space AND
     ( vim_special_mode NE vim_upgrade OR
       NOT function IN exted_functions ).
    PERFORM update_tab.
*   SET SCREEN 0.
    vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
    EXIT.
  ELSEIF vim_special_mode EQ vim_delete.
    vim_next_screen = 0. vim_leave_screen = &apos;X&apos;. EXIT.
  ENDIF.
  IF vim_single_entry_function NE space AND function NE space.
    IF vim_single_entry_ins_key_input EQ space.
      TRANSLATE status-action USING &apos;AU&apos;. status-data = gesamtdaten.
    ENDIF.
    IF function EQ &apos;UEBE&apos;.
      function = &apos;ENDE&apos;.
    ENDIF.
  ENDIF.
  CASE function.
    WHEN &apos;ADDR&apos;.
      PERFORM address_maintain.
    WHEN &apos;AEND&apos;.
      PERFORM anzg_to_aend.
    WHEN &apos;ALCO&apos;.
      PERFORM selektiere USING transportieren.
    WHEN &apos;ALMK&apos;.
      PERFORM selektiere USING markiert.
    WHEN &apos;ALNC&apos;.
      PERFORM selektiere USING space.
    WHEN &apos;ALOE&apos;.
      PERFORM selektiere USING geloescht.
    WHEN &apos;ALNW&apos;.
      PERFORM selektiere USING neuer_eintrag.
    WHEN &apos;ANZG&apos;.
      PERFORM update_tab.
      IF l EQ 0. MOVE: 1 TO l, 1 TO &lt;status&gt;-cur_line. ENDIF.
*        SET SCREEN 0. LEAVE SCREEN.
      vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
    WHEN &apos;ATAB&apos;.
      PERFORM update_tab.
      IF l EQ 0. MOVE: 1 TO l, 1 TO &lt;status&gt;-cur_line. ENDIF.
*     SET SCREEN 0. LEAVE SCREEN.
      vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
    WHEN &apos;BCCH&apos;.                       &quot;change fix bc-set fields
      PERFORM vim_chng_fix_flds.
    WHEN &apos;BCSH&apos;.                        &quot; show fix bc-set fields
      PERFORM vim_bc_show_fix_flds.
    WHEN &apos;DELE&apos;.
*     PERFORM DETAIL_LOESCHE.
      PERFORM loeschen.
      IF replace_mode NE space.
        &lt;status&gt;-mk_to = mark_total.
        &lt;status&gt;-mk_xt = mark_extract.
        vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
        EXIT.
      ENDIF.
    WHEN &apos;DELM&apos;.
      PERFORM delimitation.
    WHEN &apos;ENDE&apos;.
      PERFORM update_tab.
      IF l EQ 0. MOVE: 1 TO l, 1 TO &lt;status&gt;-cur_line. ENDIF.
*     SET SCREEN 0. LEAVE SCREEN.
      vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
    WHEN &apos;EXPA&apos;.
*     perform ........
    WHEN &apos;FDOC&apos;.                       &quot;HW Functiondocu
      PERFORM show_function_docu.
      CLEAR function.
*    WHEN &apos;GPRF&apos;.                       &quot;UF Profile
* choose profile
*      CLEAR: &lt;status&gt;-prof_found, vim_pr_records.
*      PERFORM get_profiles USING &lt;status&gt;-prof_found.
    WHEN &apos;KOPE&apos;.
      counter = 0.
      PERFORM kopiere.
    WHEN &apos;KOPF&apos;.
*       IF X_HEADER-ADRNBRFLAG NE SPACE.
*         PERFORM ADDRESS_MAINTAIN.
*       ENDIF.
      PERFORM kopiere_eintrag USING &lt;orig_key&gt;.
    WHEN &apos;LANG&apos;.                       &quot;SW Texttransl
      PERFORM vim_set_languages.
      CLEAR function.
    WHEN &apos;MKEZ&apos;.
      PERFORM detail_markiere.
    WHEN &apos;NEWL&apos;.
      PERFORM update_tab.
      CLEAR &lt;status&gt;-mark_only.        &quot;UFdetail
      PERFORM hinzufuegen.
    WHEN &apos;NEXT&apos;.
      PERFORM naechster.
    WHEN &apos;ORDR&apos;.
      PERFORM order_administration.
    WHEN &apos;ORGI&apos;.
      PERFORM original_holen.
    WHEN &apos;POSI&apos;.
      PERFORM popup_positionieren.
    WHEN &apos;PREV&apos;.
      PERFORM voriger.
    WHEN &apos;PRMO&apos;.
* 4.6A: obsolete, left only for individual status
      PERFORM update_tab.
      PERFORM list_alv.
    WHEN &apos;PROT&apos;.
      PERFORM logs_analyse.
    WHEN &apos;PRST&apos;.
      PERFORM update_tab.
      PERFORM list_alv.
    WHEN &apos;SAVE&apos;.
      PERFORM update_tab.
      IF status-action EQ hinzufuegen.
        SORT extract BY &lt;vim_xextract_key&gt;.                 &quot;#EC *
*        READ TABLE extract WITH KEY extract BINARY SEARCH.
        READ TABLE extract WITH KEY &lt;vim_xextract_key&gt;.     &quot;#EC *
        &lt;status&gt;-cur_line = l = sy-tabix - firstline + 1.
      ENDIF.
*     SET SCREEN 0. LEAVE SCREEN.
      vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
    WHEN &apos;SCRF&apos;.
      PERFORM update_tab.
      PERFORM vim_sapscript_form_maint.
    WHEN &apos;SEAR&apos;.
      PERFORM update_tab.
      PERFORM suchen.
    WHEN &apos;SELU&apos;.
      PERFORM selektiere USING aendern.
    WHEN &apos;TEXT&apos;.
      PERFORM update_tab.
      PERFORM vim_multi_langu_text_maint.
    WHEN &apos;TREX&apos;.
      MOVE geloescht TO corr_action.
      PERFORM update_corr.
      IF replace_mode NE space.
        &lt;status&gt;-mk_to = mark_total.
        &lt;status&gt;-mk_xt = mark_extract.
        vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
        EXIT.
      ENDIF.
    WHEN &apos;TRIN&apos;.
      MOVE hinzufuegen TO corr_action.
      PERFORM update_corr.
      IF replace_mode NE space.
        &lt;status&gt;-mk_to = mark_total.
        &lt;status&gt;-mk_xt = mark_extract.
        vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
        EXIT.
      ENDIF.
    WHEN &apos;TRSP&apos;.
*     SET SCREEN 0. LEAVE SCREEN.
      IF x_header-cursetting NE space AND
         x_header-flag EQ vim_transport_denied.
        x_header-flag = x_header-cursetting.
        TRANSLATE x_header-flag USING &apos;X YX&apos;.
        MODIFY x_header INDEX 1.                            &quot;#EC *
      ENDIF.
      vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
    WHEN &apos;UEBE&apos;.
      PERFORM detail_back.
    WHEN &apos;UPRF&apos;.
* activate chosen profile
*      PERFORM activate_profile CHANGING &lt;status&gt;-prof_found.
      MESSAGE s175(sv).
    WHEN &apos;UNDO&apos;.
*     PERFORM DETAIL_ZURUECKHOLEN.
      PERFORM zurueckholen.
      IF replace_mode NE space.
        &lt;status&gt;-mk_to = mark_total.
        &lt;status&gt;-mk_xt = mark_extract.
        vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
        EXIT.
      ENDIF.
    WHEN &apos;    &apos;.
      IF vim_prt_fky_flds_updated NE space.
        CLEAR vim_prt_fky_flds_updated.
        PERFORM update_tab.
      ELSE.
        IF x_header-frm_h_flds NE space.
          PERFORM (x_header-frm_h_flds) IN PROGRAM.         &quot;#EC *
        ENDIF.
        IF neuer EQ &apos;J&apos; AND vim_key_alr_checked EQ space.
*          IF x_header-guidflag &lt;&gt; space.
*            PERFORM vim_make_guid.
*          ENDIF.
          IF x_header-frm_on_new NE space.
            PERFORM (x_header-frm_on_new) IN PROGRAM.       &quot;#EC *
          ENDIF.
        ENDIF.
        PERFORM check_key.
      ENDIF.
    WHEN OTHERS.
      IF vim_called_by_cluster NE space.                    &quot;SW Crtl ..
        CALL FUNCTION &apos;VIEWCLUSTER_NEXT_ACTION&apos;
          EXPORTING
            detail       = &apos;X&apos;
          IMPORTING
            leave_screen = vim_leave_screen
          CHANGING
            fcode        = function.
        IF vim_leave_screen NE space.
          PERFORM update_tab.
          vim_next_screen = 0.
        ENDIF.
      ENDIF.                           &quot;.. SW Ctrl
  ENDCASE.
ENDFORM.                    &quot;detail_pai

*---------------------------------------------------------------------*
*       FORM DETAIL_ZURUECKHOLEN                                       *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM detail_zurueckholen.
  DATA: tot_ix LIKE sy-tabix, msg_type(1) TYPE c, msg_no LIKE sy-msgno,
        rc LIKE sy-subrc.
  IF x_header-delmdtflag NE space.
    counter = 1.
    PERFORM temporal_delimitation.
  ENDIF.
  IF &lt;xmark&gt; EQ markiert.
    mark_total  = mark_total - 1.
    mark_extract = mark_extract - 1.
  ENDIF.
  READ TABLE total WITH KEY &lt;vim_xextract_key&gt; BINARY SEARCH.&quot;#EC *
  MOVE sy-tabix TO tot_ix.
  PERFORM logical_undelete_total USING sy-tabix.
  IF temporal_delimitation_happened NE space.
    CLEAR vim_delim_entries.
    PERFORM check_if_entry_is_to_display USING &apos;L&apos; &lt;vim_xtotal_key&gt;
                                               space &lt;vim_begdate&gt;.
    IF sy-subrc LT 8.
      vim_delim_entries-index3 = nextline.
      IF sy-subrc EQ 4.
        LOOP AT total.                                      &quot;#EC *
          CHECK &lt;action&gt; EQ geloescht OR &lt;action&gt; EQ neuer_geloescht OR
                &lt;action&gt; EQ update_geloescht.
          CHECK &lt;vim_tot_mkey_beforex&gt; EQ &lt;vim_old_mkey_beforex&gt; AND
                ( vim_mkey_after_exists EQ space OR
                  &lt;vim_tot_mkey_afterx&gt; EQ &lt;vim_old_mkey_afterx&gt; ).
*          CHECK &lt;vim_tot_mkey_before&gt; EQ &lt;vim_old_mkey_before&gt; AND
*                ( vim_mkey_after_exists EQ space OR
*                  &lt;vim_tot_mkey_after&gt; EQ &lt;vim_old_mkey_after&gt; ).
          vim_delim_entries-index1 = sy-tabix.
          vim_delim_entries-index2 = vim_delim_entries-index3.
          EXIT.
        ENDLOOP.
      ENDIF.
      APPEND vim_delim_entries.                             &quot;#EC *
    ENDIF.
    PERFORM after_temporal_delimitation.
    CLEAR temporal_delimitation_happened.
  ELSE.
    IF replace_mode NE space AND vim_external_mode EQ space.
      extract = total.
      MODIFY extract INDEX nextline.&quot;#EC * &quot;no deletion in upgrade mode
    ELSE.
      DELETE extract INDEX nextline.                        &quot;#EC *
      SUBTRACT 1 FROM maxlines.
    ENDIF.
  ENDIF.
  IF replace_mode EQ space.
    IF counter GT 1. msg_no = &apos;002&apos;. ELSE. msg_no = &apos;003&apos;. ENDIF.
    IF ignored_entries_exist EQ space.
      msg_type = &apos;S&apos;.
    ELSE.
      msg_type = &apos;W&apos;.
    ENDIF.
    MESSAGE ID &apos;SV&apos; TYPE msg_type NUMBER msg_no WITH counter.
    IF nextline NE 1 AND nextline GT maxlines.
      nextline = maxlines.
    ENDIF.
    IF maxlines EQ 0.
      title-action = aendern.
      status-delete = nicht_geloescht.
      vim_next_screen = liste. vim_leave_screen = &apos;X&apos;.
    ELSEIF &lt;status&gt;-mark_only &lt;&gt; space.
      IF mark_extract = 0.
* last marked entry deleted
        nextline = 1.
        vim_next_screen = liste. vim_leave_screen = &apos;X&apos;.
      ELSE.
* search next marked entry
        nextline = nextline - 1.
        PERFORM get_marked_entry USING &apos;X&apos;
                    CHANGING nextline
                             rc.
        IF rc &lt;&gt; 0.
* search previous marked entry
          nextline = nextline + 1.
          PERFORM get_marked_entry USING space
                      CHANGING nextline
                               rc.
        ENDIF.
        IF rc &lt;&gt; 0.
          nextline = 1. vim_next_screen = liste. vim_leave_screen = &apos;X&apos;.
        ELSE.
          PERFORM get_page_and_position USING nextline
                                              looplines
                                        CHANGING firstline
                                                 l.
        ENDIF.
      ENDIF.
    ENDIF.
    READ TABLE total INDEX tot_ix.                          &quot;#EC *
  ELSE.
    counter = 1.
  ENDIF.
  CLEAR vim_old_viewkey.
  TRANSLATE vim_no_mainkey_exists USING vim_no_mkey_not_procsd_patt.
ENDFORM.                    &quot;detail_zurueckholen

*&amp;---------------------------------------------------------------------*
*&amp;      Form  GET_MARKED_ENTRY
*&amp;---------------------------------------------------------------------*
*       Search marked entries in EXTRACT beginning at index p_index
*----------------------------------------------------------------------*
*      --&gt;P_FORWARD  &apos;X&apos;: search forward
*                    &apos; &apos;: search backward
*      &lt;--P_index    in: start from here (including)
*                    out: index of first marked entry found
*      &lt;--P_RC       0: further marked entry found
*                    4: no further marked entry found
*----------------------------------------------------------------------*
FORM get_marked_entry USING    p_forward TYPE sychar01
                      CHANGING p_index LIKE sy-tabix
                               p_rc LIKE sy-subrc.
  DATA: bw_index LIKE sy-tabix.

  p_rc = 4.
  IF p_forward IS INITIAL.
* search backward
    bw_index = p_index - 1.
    WHILE bw_index &gt; 0.
      READ TABLE extract INDEX bw_index.                    &quot;#EC *
      IF &lt;xmark&gt; = markiert.
        p_index = bw_index.
        old_nl = p_index.                                   &quot;GKPR - 0001009660
        CLEAR p_rc.
        EXIT.
      ENDIF.
      bw_index = bw_index - 1.
    ENDWHILE.
  ELSE.
* search forward.
    p_index = p_index + 1.
    LOOP AT extract FROM p_index.                           &quot;#EC *
      CHECK &lt;xmark&gt; = markiert.
      p_index = sy-tabix.
      old_nl = p_index.                                     &quot;GKPR - 0001009660
      CLEAR p_rc.
      EXIT.
    ENDLOOP.
    IF p_rc &gt; 0.
      p_index = p_index - 1.
    ENDIF.
  ENDIF.
ENDFORM.                               &quot; GET_MARKED_ENTRY
*---------------------------------------------------------------------*
*       FORM NAECHSTER                                                *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM naechster.
  DATA: last_list_pos LIKE sy-tabix, rc LIKE sy-subrc.
  IF status-action NE anzeigen AND status-action NE transportieren
  AND status-mode NE list_bild.
    PERFORM update_tab.
  ENDIF.
  IF &lt;status&gt;-mark_only = space.       &quot;ufdetail
* jump to next entry
    nextline = nextline + 1.
    IF nextline GT maxlines.
      IF status-action NE hinzufuegen.
        nextline = maxlines.
        MESSAGE s008(sv).
        EXIT.
      ELSE.
        IF status-type EQ zweistufig AND
           status-mode EQ detail_bild.
          neuer = &apos;J&apos;.
          MOVE &lt;initial&gt; TO &lt;table1&gt;.
          MOVE &lt;table1&gt; TO &lt;vim_extract_struc&gt;.
          IF x_header-bastab NE space AND x_header-texttbexst NE space.
            MOVE: &lt;text_initial_x&gt; TO &lt;table1_xtext&gt;,
                 &lt;table1_xtext&gt; TO &lt;vim_xextract_text&gt;.
*            MOVE: &lt;text_initial_x&gt; TO &lt;table1_text&gt;,
*                  &lt;table1_text&gt; TO &lt;extract_text&gt;.
          ENDIF.
          nextline = maxlines + 1.
        ELSE.
          nextline = nextline - 1.
          MESSAGE s008(sv).
        ENDIF.
      ENDIF.
    ENDIF.
  ELSE.                                &quot;ufdetailb
* jump to next marked entry
    PERFORM get_marked_entry USING &apos;X&apos;
                             CHANGING nextline
                                      rc.
    IF rc &lt;&gt; 0.
      MESSAGE s830(sv).
*   Letzter markierter Eintrag bereits erreicht.
      EXIT.
    ENDIF.
  ENDIF.                               &quot;ufdetaile
  IF looplines = 0.
* coming from lower viewcluster-node
    l = nextline - firstline + 1.
    MOVE l TO &lt;status&gt;-cur_line.
  ELSEIF looplines = 1.
    firstline = l = 1.
    MOVE: firstline TO &lt;status&gt;-firstline,
          l         TO &lt;status&gt;-cur_line.
  ELSEIF looplines &gt; 1.
    IF status-mode EQ detail_bild.
      last_list_pos = firstline + looplines - 1.
      IF nextline GT last_list_pos.
        IF &lt;status&gt;-mark_only = space. &quot;ufdetail
          firstline = firstline + looplines - 1.
          l = 2.
        ELSE.                          &quot;ufdetailb
          PERFORM get_page_and_position USING nextline
                                              looplines
                                        CHANGING firstline
                                                 l.
        ENDIF.                         &quot;ufdetaile
        MOVE: firstline TO &lt;status&gt;-firstline,
              l         TO &lt;status&gt;-cur_line.
      ELSE.
        IF status-mode NE list_bild.
          l = nextline - firstline + 1.
          MOVE l TO &lt;status&gt;-cur_line.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.
ENDFORM.                    &quot;naechster
*&amp;---------------------------------------------------------------------*
*&amp;      Form  SET_MARK_ONLY
*&amp;---------------------------------------------------------------------*
*       Sets status flag if entry with index p_index is marked.
*----------------------------------------------------------------------*
*      --&gt;P_index  EXTRACT-index
*----------------------------------------------------------------------*
FORM set_mark_only USING    p_index LIKE sy-tabix.
  DATA: rc LIKE sy-subrc.
  PERFORM check_marked USING p_index
                       CHANGING rc.
  IF rc = 0.
    &lt;status&gt;-mark_only = &apos;X&apos;.
  ENDIF.
ENDFORM.                               &quot; SET_MARK_ONLY
*---------------------------------------------------------------------*
*       FORM PROCESS_DETAIL_SCREEN                                    *
*---------------------------------------------------------------------*
* process detail screen call                                          *
*---------------------------------------------------------------------*
* ---&gt; MODE - C -&gt; call mode (CALL SCREEN), S -&gt; set mode (SET SCREEN)*
*---------------------------------------------------------------------*
FORM process_detail_screen USING value(mode) TYPE c.
  DATA: modulpool LIKE trdir-name,                          &quot;#EC *
        no_input_happened(1) TYPE c,
        state_action(1) TYPE c.
  IF detail NE &apos;0000&apos;.
    IF mode EQ &apos;S&apos;.
      SET SCREEN detail.
      LEAVE SCREEN.
    ELSE.
      PERFORM vim_imp_call_screen USING detail.
    ENDIF.
  ELSE.
    RAISE detail_scr_nbr_missing.
  ENDIF.
ENDFORM.                    &quot;process_detail_screen
*---------------------------------------------------------------------*
*       FORM VORIGER                                                  *
*---------------------------------------------------------------------*
*       NEXTLINE:   Index of current entry in table EXTRACT
*       FIRSTLINE:  EXTRACT-index of first line shown on list screen
*       L:          Line number of list screen, where entry was chosen
*                   via F2
*       LOOPLINES:  Number of step loop lines in list screen
*---------------------------------------------------------------------*
FORM voriger.
  DATA: rc LIKE sy-subrc, n TYPE i.

  IF status-action NE anzeigen AND status-action NE transportieren
  AND status-mode NE list_bild.
    PERFORM update_tab.
  ENDIF.
  IF &lt;status&gt;-mark_only = space.       &quot;ufdetail
* jump to previous entry
    nextline = nextline - 1.
    IF nextline LE 0.
      nextline = 1.
      MESSAGE s007(sv).
    ELSEIF nextline LT firstline.
* scroll upwards
      IF looplines &gt; firstline.
* bumping into top of EXTRACT
        firstline = 1.
        l = nextline.
      ELSE.
        firstline = firstline - looplines + 1.
        l = looplines - 1.
      ENDIF.
      MOVE: firstline TO &lt;status&gt;-firstline,
           l         TO &lt;status&gt;-cur_line.
    ELSE.
      l = nextline - firstline + 1.
      MOVE l TO &lt;status&gt;-cur_line.
    ENDIF.
  ELSE.                                &quot;ufdetailb
* jump to previous marked entry
    n = nextline DIV ( looplines - 1 ).
    PERFORM get_marked_entry USING space
                             CHANGING nextline rc.
    IF rc &gt; 0.
      MESSAGE s831(sv).
*   Erster markierter Eintrag bereits erreicht.
    ELSE.
      IF nextline LT firstline.
        PERFORM get_page_and_position USING nextline
                                            looplines
                                      CHANGING firstline
                                               l.
        MOVE: firstline TO &lt;status&gt;-firstline,
              l         TO &lt;status&gt;-cur_line.
      ELSE.
        l = nextline - firstline + 1.
        MOVE l TO &lt;status&gt;-cur_line.
      ENDIF.
    ENDIF.
  ENDIF.                               &quot;ufdetaile
ENDFORM.                    &quot;voriger
*&amp;---------------------------------------------------------------------*
*&amp;      Form  CHECK_MARKED
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_P_INDEX  text
*      &lt;--P_RC  text
*----------------------------------------------------------------------*
FORM check_marked USING    p_index LIKE sy-tabix
                  CHANGING p_rc LIKE sy-subrc.

  p_rc = 4.
  READ TABLE extract INDEX p_index.                         &quot;#EC *
  IF sy-subrc = 0 AND &lt;xmark&gt; = markiert. CLEAR p_rc. ENDIF.
ENDFORM.                               &quot; CHECK_MARKED
*&amp;---------------------------------------------------------------------*
*&amp;      Form  GET_PAGE_AND_POSITION
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_LINE      line in EXTRACT
*      --&gt;P_LOOPLINES # lines in list screen
*      &lt;--P_FIRST     number of first line in list screen
*      &lt;--P_PAGELINE  number of line no. P_LINE in list screen
*----------------------------------------------------------------------*
FORM get_page_and_position USING    p_line LIKE sy-tabix
                                    p_looplines LIKE sy-tabix
                           CHANGING p_first LIKE sy-tabix
                                    p_pageline LIKE sy-tabix.
  DATA: m TYPE i.
  m = p_line DIV ( p_looplines - 1 ).
  p_first = m * ( p_looplines - 1 ) + 1.
  p_pageline = p_line MOD ( p_looplines - 1 ).
ENDFORM.                               &quot; GET_PAGE_AND_POSITION

*---------------------------------------------------------------------*
*       FORM  VIM_MODIFY_DETAIL_SCREEN                                *
*---------------------------------------------------------------------*
* Modifizieren der Screen-Attribute für das Detailbild                *
*---------------------------------------------------------------------*
FORM vim_modify_detail_screen.

  DATA: dummyflag TYPE xfeld.


* dataset locked by key-specific synchronizer lock?
  IF vim_sync_keyspec_check NE space.
    PERFORM check_sync_key_lock USING &apos; &apos;
                                CHANGING vim_sync_key_lock.
  ENDIF.
  CLEAR vim_set_from_bc_pbo.
* dataset from BC-set? --&gt; get field parameters
  IF replace_mode = space AND status-action = aendern
   AND vim_bc_chng_allowed = space.    &quot;force changeability
    READ TABLE vim_bc_entry_list INTO vim_bc_entry_list_wa
     WITH TABLE KEY viewname = x_header-viewname
     keys = &lt;vim_xextract_key&gt;.
    IF sy-subrc = 0.
      vim_set_from_bc_pbo = &apos;X&apos;.
    ENDIF.
  ENDIF.
  LOOP AT SCREEN.
    SPLIT screen-name AT &apos;-&apos; INTO vim_object vim_objfield. &quot;Subviews ..
    IF status-action EQ anzeigen OR status-action EQ transportieren OR
       status-delete EQ geloescht.
      screen-input = &apos;0&apos;.
    ELSE.
      IF screen-group1 EQ &apos;KEY&apos; AND screen-required NE 0 AND
         screen-input NE &apos;0&apos;.
        screen-input = &apos;0&apos;.
      ENDIF.
      IF status-action EQ hinzufuegen OR
         status-action EQ kopieren.
        IF neuer CO &apos;XJ&apos; .
          IF screen-group1 EQ &apos;KEY&apos;.
            IF ( vim_single_entry_function NE &apos;INS&apos; OR
                 vim_single_entry_ins_key_input NE space ) AND
               ( x_header-existency NE &apos;M&apos; OR
                 screen-name EQ vim_enddate_name ).
              screen-input = &apos;1&apos;.
            ENDIF.
            IF vim_single_entry_function EQ &apos;INS&apos;.
              screen-request = &apos;1&apos;. sy-subrc = 8.
            ENDIF.
          ENDIF.
          IF vim_special_mode EQ vim_upgrade AND function NE &apos;DELE&apos;.
            IF &lt;status&gt;-prof_found = vim_pr_into_view &quot;UFprofiles begin
             AND screen-group1 = &apos;KEY&apos;.
              PERFORM set_profile_key_attributes USING vim_objfield
                                                 CHANGING screen-input
                                                     vim_modify_screen.
              CLEAR vim_modify_screen.
            ENDIF.                     &quot;UFprofiles end
            screen-request = &apos;1&apos;. sy-subrc = 8.
          ENDIF.
        ENDIF.
        IF vim_pr_activating &lt;&gt; space.
          IF screen-required = &apos;1&apos;.
* obligatory fields shall not stop profile import
            screen-required = &apos;0&apos;.     &quot;UFprofile
          ENDIF.
        ENDIF.
      ELSE.
        IF replace_mode NE space.
          CASE vim_special_mode.
            WHEN vim_replace.
              IF screen-name EQ sel_field_for_replace_l.
                screen-request = &apos;1&apos;. sy-subrc = 8.
                IF screen-invisible = &apos;1&apos;.
                  screen-input = &apos;1&apos;.
                ENDIF.
              ENDIF.
            WHEN vim_upgrade.
              IF NOT function IN exted_functions.
                screen-request = &apos;1&apos;. sy-subrc = 8.
              ENDIF.
*             screen-input = &apos;1&apos;.
          ENDCASE.
        ELSE.
          IF vim_special_mode EQ vim_delete.
            screen-input = &apos;0&apos;.
          ENDIF.
          IF x_header-delmdtflag NE space AND
             x_header-existency EQ &apos;U&apos; AND
             screen-name EQ vim_begdate_name.
            screen-input = &apos;0&apos;.
          ENDIF.
        ENDIF.
        IF status-action = aendern AND neuer &lt;&gt; &apos;J&apos;.
* Dataset locked by key-specific synchronizer lock?
          IF vim_sync_key_lock NE space AND screen-group1 &lt;&gt; &apos;KEY&apos; AND
                                            screen-name NE &apos;VIM_MARKED&apos;.
            screen-input = 0.
            vim_modify_screen  = &apos;X&apos;.
          ENDIF.
          IF vim_set_from_bc_pbo &lt;&gt; space.
* Dataset comes from BC-set -&gt; check field parameter
            PERFORM vim_bc_logs_use USING    vim_objfield
                                             vim_bc_entry_list_wa
                                    CHANGING screen
                                             dummyflag.
          ENDIF.
        ENDIF.
      ENDIF. &quot;status-action EQ hinzufuegen OR status-action EQ kopieren.
    ENDIF.
    IF &lt;xmark&gt; EQ markiert AND &lt;status&gt;-mark_only = space. &quot;ufdetail
      screen-intensified = &apos;1&apos;.
    ENDIF.
    IF vim_objfield &lt;&gt; space AND vim_object = x_header-maintview.
      LOOP AT x_namtab WHERE viewfield = vim_objfield AND
                             ( texttabfld = space OR keyflag = space ).&quot;#EC *
        IF x_namtab-readonly = vim_hidden.
          screen-active = &apos;0&apos;.
        ELSEIF x_namtab-readonly = rdonly.
          screen-input = &apos;0&apos;.
        ENDIF.
        EXIT.
      ENDLOOP.
    ENDIF.                                   &quot;.. Subviews
    MODIFY SCREEN.
  ENDLOOP.
ENDFORM.                               &quot;vim_modify_detail_screen</include_source>
   </include>
   <include NAME="LSVIMFX3" VARCL="X" SUBC="I" APPL="S" CNAM="SAP" CDAT="19981026" UNAM="SAP" UDAT="20080721" VERN="000020" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122442" IDATE="20080721" ITIME="122442">
    <include_source>*----------------------------------------------------------------------*
*   INCLUDE LSVIMFX3                                                   *
*----------------------------------------------------------------------*
*&amp;--------------------------------------------------------------------*
*&amp;      Form LIST_ALV                                               *
*&amp;--------------------------------------------------------------------*
* D_VIA_SELECTION_SCREEN --&gt; X - mit Selektion, &apos; &apos; - Standardliste   *
*&amp;--------------------------------------------------------------------*
FORM list_alv.

*  STATICS: vim_alv_fcat TYPE slis_t_fieldcat_alv,  --&gt; global
*           alv_events TYPE slis_t_event,
*           alv_layout TYPE slis_layout_alv.
  STATICS: texttab_begin LIKE sy-tabix,
           textlen TYPE intlen, unittab TYPE tabname,
           unitname TYPE fieldname, cukytab TYPE tabname,
           cukyname TYPE fieldname,
           glob_unitvalue(3) TYPE c,    &quot;vim_unit,UF296573/2000
           glob_cukyvalue TYPE vim_cuky.
  DATA: textfld_no, textoffset TYPE intlen, rc LIKE sy-subrc,
        progname LIKE sy-repid, value_len TYPE intlen,
        w_alv_value_tab TYPE tabl8000.
  FIELD-SYMBOLS: &lt;alv_fcat&gt; LIKE LINE OF vim_alv_fcat,
                 &lt;textfields&gt;.                            &quot;#EC *

  IF x_header-frm_bf_prn &lt;&gt; space.
* old user exit for printing still used
    PERFORM drucken_ztp_alt.
    EXIT.
  ENDIF.
  IF NOT vim_alv_fcat[] IS INITIAL.
    READ TABLE vim_alv_fcat ASSIGNING &lt;alv_fcat&gt; INDEX 1.
    IF &lt;alv_fcat&gt;-ref_tabname &lt;&gt; view_name.
      UNASSIGN &lt;alv_fcat&gt;. FREE vim_alv_fcat.
    ENDIF.
  ENDIF.
  IF vim_alv_fcat[] IS INITIAL.
* build up field catalogue from X_NAMTAB
    PERFORM fill_alv_fieldcat CHANGING vim_alv_fcat
                                       texttab_begin
                                       vim_alv_value_length
                                       unittab
                                       unitname
                                       glob_unitvalue
                                       cukytab
                                       cukyname
                                       glob_cukyvalue.
    PERFORM define_alv_callbacks CHANGING vim_alv_events.
    PERFORM make_list_commentary USING unittab
                                       unitname
                                       glob_unitvalue
                                       cukytab
                                       cukyname
                                       glob_cukyvalue
                                 CHANGING vim_list_header.
    PERFORM make_alv_layout CHANGING vim_alv_layout
                                     vim_alv_print.
    PERFORM init_alv_variant CHANGING vim_var_save
                                      vim_var_default
                                      vim_alv_variant.
    vim_alv_called_by = &apos;VIM_CALL_ALV&apos;.
*    REFRESH: vim_alv_excluding, vim_alv_special_groups,
*             vim_alv_sort, vim_alv_event_exit.
*    CLEAR:   vim_alv_print, vim_alv_sel_hide.
  ENDIF.                               &quot;new structure table
  REFRESH alv_value_tab.
  IF status-mode = list_bild.
* Build ALV_VALUE_TAB
    LOOP AT extract.
      w_alv_value_tab = &lt;vim_xextract&gt;.
*    LOOP AT extract ASSIGNING &lt;extract_line&gt;.
*      alv_value_tab = &lt;extract_line&gt;.
      APPEND w_alv_value_tab TO alv_value_tab.
    ENDLOOP.
  ELSE.
* Build VALUE_TAB with single line
    w_alv_value_tab = &lt;vim_xextract&gt;.
*    alv_value_tab = extract.
    APPEND w_alv_value_tab TO alv_value_tab.
  ENDIF.
  IF x_header-bastab &lt;&gt; space AND x_header-texttbexst &lt;&gt; space.
* table and texttable
    textlen = x_header-aft_txttbc - x_header-aft_txtkc.
*  IF x_header-bastab = space OR x_header-texttbexst = space
*   OR x_header-maintview NE x_header-viewname.
* no table &amp; texttable
*    CLEAR textlen.
*  ENDIF.
*  IF textlen &lt;&gt; 0.
* Shift fields
    PERFORM maintain_alv_value_tab_text USING    textlen.
  ELSE.
    vim_alv_value_length = x_header-tablen.
  ENDIF.
  IF x_header-frm_bf_alv &lt;&gt; space.
    PERFORM (x_header-frm_bf_alv) IN PROGRAM (sy-repid).
* Release 6.10(Unicode): alv_value_tab has got type RAW!
* useful parameters:
*   vim_alv_value_length     int. length of dataset in alv_value_tab
*   vim_alv_called_by        form routine calling FM ALV_LIST_DISPLAY
*                            preset value: &apos;VIM_CALL_ALV&apos;
*   alv_value_tab[]          internal table containing values
*   vim_alv_fcat[]     \
*   vim_alv_events[]    |
*   vim_list_header[]   &gt;    preset by view-maintenance
*   vim_alv_variant     |
*   vim_alv_layout     /
    CHECK NOT alv_value_tab[] IS INITIAL. &quot;suppress list
  ENDIF.
  PERFORM check_list_before_alv CHANGING rc.
  CHECK rc = 0.
  progname = sy-repid.
  CALL FUNCTION &apos;REUSE_ALV_TABLE_CREATE&apos;
    EXPORTING
      it_fieldcat        = vim_alv_fcat
      i_callback_program = progname
      i_formname         = vim_alv_called_by.
  FREE alv_value_tab.
ENDFORM.                               &quot; LIST_ALV

*&amp;--------------------------------------------------------------------*
*&amp;      Form DRUCKEN_ZTP_ALT                                          *
*&amp;--------------------------------------------------------------------*
* Keeps compatibility of view maintenance dialogs using old user exit
* &quot;before printing&quot;
* D_VIA_SELECTION_SCREEN --&gt; X - mit Selektion, &apos; &apos; - Standardliste   *
*&amp;--------------------------------------------------------------------*
FORM drucken_ztp_alt.
  DATA: rc_safe LIKE sy-subrc, texttab_begin LIKE sy-tabix, x TYPE i,
        entifct_begin LIKE sy-tabix, len TYPE i,
        after_text_assigned TYPE c, hname LIKE d021s-fnam.
  DATA: fcat_entry TYPE slis_fieldcat_alv, i TYPE i,
        cukytab TYPE tabname, unittab TYPE tabname, rc LIKE sy-subrc,
        cukyname TYPE fieldname, unitname TYPE fieldname,
        cukyvalue TYPE vim_cuky, unitvalue TYPE vim_unit,
        length TYPE doffset, cukylength TYPE doffset,
        fcat_entry2 TYPE slis_fieldcat_alv, progname LIKE sy-repid,
        alv_called_by TYPE char30 VALUE &apos;VIM_CALL_ALV&apos;.
  FIELD-SYMBOLS: &lt;before_text&gt;, &lt;text&gt;, &lt;after_text&gt;,     &quot;#EC *
                 &lt;cuky&gt;, &lt;unit&gt;,
                 &lt;value&gt; TYPE tabl8000, &lt;w_value_tab_x&gt; TYPE x.

  CLEAR structure_table.
  DESCRIBE TABLE structure_table.
  IF sy-tfill NE 0. READ TABLE structure_table INDEX 1. ENDIF.
  IF structure_table-tabname NE view_name.
    CALL FUNCTION &apos;VIEW_GET_FIELDTAB&apos;
      EXPORTING
        view_name = view_name
      TABLES
        fieldtab  = structure_table.
    IF x_header-bastab NE space AND x_header-texttbexst NE space
       AND x_header-maintview = x_header-viewname.           &quot;Subviews
* einfügen text-felder in structure_table hinter entity-key
      LOOP AT x_namtab WHERE texttabfld NE space
                         AND keyflag NE space.
        texttab_begin = sy-tabix.
        EXIT.
      ENDLOOP.
      LOOP AT x_namtab WHERE texttabfld EQ space
                         AND keyflag EQ space.
        entifct_begin = sy-tabix.
        EXIT.
      ENDLOOP.
      IF sy-subrc NE 0.  &quot;no entifct fields -&gt; delete text key fields
        LOOP AT structure_table FROM texttab_begin
                                WHERE keyflag NE space.
          DELETE structure_table.
        ENDLOOP.
      ELSE.
        WHILE sy-subrc EQ 0.
          LOOP AT structure_table FROM texttab_begin.
            DELETE structure_table.
            IF structure_table-keyflag EQ space.
              EXIT.
            ENDIF.
          ENDLOOP.
          IF sy-subrc EQ 0.
            INSERT structure_table INDEX entifct_begin.
            ADD: 1 TO entifct_begin, 1 TO texttab_begin.
          ENDIF.
        ENDWHILE.
      ENDIF.
* aktualisieren von offset und position in structure_table
      len = 0.
      LOOP AT structure_table.
        structure_table-offset = len.
        structure_table-position = sy-tabix.
* Alignment
        IF &apos;CNDT&apos; CS structure_table-inttype.
* Character-like datatypes
          x = ( structure_table-offset
                + cl_abap_char_utilities=&gt;charsize )
                MOD cl_abap_char_utilities=&gt;charsize.
          IF x NE 0.
            structure_table-offset = structure_table-offset
                               + cl_abap_char_utilities=&gt;charsize - x.
          ENDIF.
        ELSE.
          CASE structure_table-datatype.
            WHEN &apos;INT2&apos; OR &apos;PREC&apos;.
              x = ( structure_table-offset + 2 ) MOD 2.
              IF x NE 0.
                structure_table-offset = structure_table-offset + 2 - x.
              ENDIF.
            WHEN &apos;INT4&apos;.
              x = ( structure_table-offset + 4 ) MOD 4.
              IF x NE 0.
                structure_table-offset = structure_table-offset + 4 - x.
              ENDIF.
            WHEN &apos;FLTP&apos;.
              x = ( structure_table-offset + 8 ) MOD 8.
              IF x NE 0.
                structure_table-offset = structure_table-offset + 8 - x.
              ENDIF.
          ENDCASE.
        ENDIF.
        MODIFY structure_table.
        len = structure_table-offset + structure_table-intlen.
      ENDLOOP.
    ENDIF.                             &quot;table with texttable
    IF x_header-hiddenflag NE space.   &quot;hidden fields exist
* ignore hidden fields
      LOOP AT x_namtab WHERE readonly EQ vim_hidden OR
       domname IN vim_guid_domain.
        LOOP AT structure_table WHERE fieldname EQ x_namtab-viewfield.
          DELETE structure_table.
          EXIT.
        ENDLOOP.
      ENDLOOP.
* aktualisieren von offset und position in structure_table
      len = 0.
      LOOP AT structure_table.
        structure_table-offset = len.
        structure_table-position = sy-tabix.
        IF &apos;CNDT&apos; CS structure_table-inttype.
* Character-like datatypes
          x = ( structure_table-offset
                + cl_abap_char_utilities=&gt;charsize )
                MOD cl_abap_char_utilities=&gt;charsize.
          IF x NE 0.
            structure_table-offset = structure_table-offset
                               + cl_abap_char_utilities=&gt;charsize - x.
          ENDIF.
        ELSE.
          CASE structure_table-datatype.
            WHEN &apos;INT2&apos; OR &apos;PREC&apos;.
              x = ( structure_table-offset + 2 ) MOD 2.
              IF x NE 0.
                structure_table-offset = structure_table-offset + 2 - x.
              ENDIF.
            WHEN &apos;INT4&apos;.
              x = ( structure_table-offset + 4 ) MOD 4.
              IF x NE 0.
                structure_table-offset = structure_table-offset + 4 - x.
              ENDIF.
            WHEN &apos;FLTP&apos;.
              x = ( structure_table-offset + 8 ) MOD 8.
              IF x NE 0.
                structure_table-offset = structure_table-offset + 8 - x.
              ENDIF.
          ENDCASE.
        ENDIF.
        MODIFY structure_table.
        len = structure_table-offset + structure_table-intlen.
      ENDLOOP.
    ENDIF.                             &quot;hidden fields exist
  ENDIF.                               &quot;new structure table
* Aufbau der Value_tab
  ASSIGN value_tab TO &lt;w_value_tab_x&gt; CASTING.
  IF x_header-bastab NE space AND x_header-texttbexst NE space
                                       &quot;base table with text table
     AND x_header-maintview = x_header-viewname.
    CLEAR value_tab.
    IF status-mode EQ list_bild.
      LOOP AT extract.
        PERFORM build_valtab_hfields.
      ENDLOOP.
    ELSE.
      PERFORM build_valtab_hfields.
    ENDIF.
*    ENDIF.
  ELSE.
* view or base table without text table and user exits exists or hidden
* fields exist
    CLEAR value_tab.
    IF x_header-hiddenflag EQ space AND&quot;no hidden fields
       x_header-fieldorder EQ space.   &quot;Subviews /untersch. Feldreihenf.
      IF status-mode EQ list_bild.
        LOOP AT extract.
          MOVE &lt;vim_xextract&gt; TO &lt;w_value_tab_x&gt;(x_header-tablen).
*          MOVE extract TO value_tab(tablen).
          APPEND value_tab.
        ENDLOOP.
      ELSE.
        MOVE &lt;vim_xextract&gt; TO &lt;w_value_tab_x&gt;(x_header-tablen).
*        MOVE extract TO value_tab(tablen).
        APPEND value_tab.
      ENDIF.
    ELSE. &quot;hidden fields exist -&gt; move field by field
      IF status-mode EQ list_bild.
        LOOP AT extract.
          PERFORM build_valtab_hfields.
        ENDLOOP.
      ELSE.
        PERFORM build_valtab_hfields.
      ENDIF.
    ENDIF.
  ENDIF.                               &quot;base table with text_table.
  IF x_header-frm_bf_prn NE space.     &quot;user exit exists
* perform user exit
    PERFORM (x_header-frm_bf_prn) IN PROGRAM (sy-repid).
  ENDIF.
  CHECK NOT value_tab[] IS INITIAL.    &quot;suppress list
************************************************************************
* Build up ALV fieldcatalogue from STRUCTURE
  REFRESH vim_alv_fcat.
  LOOP AT structure_table.
    CLEAR fcat_entry.
    PERFORM conv_dfies_fcat USING structure_table
                                  sy-tabix
                            CHANGING fcat_entry.
    APPEND fcat_entry TO vim_alv_fcat.
  ENDLOOP.
  length = structure_table-offset + structure_table-intlen.
* consider CUKY or UNIT fields.......
  DESCRIBE TABLE vim_alv_fcat LINES i.
  LOOP AT vim_alv_fcat INTO fcat_entry WHERE datatype = &apos;CURR&apos;
   OR datatype = &apos;QUAN&apos;.
    CASE fcat_entry-datatype.
      WHEN &apos;CURR&apos;.
        READ TABLE x_namtab WITH KEY viewfield = fcat_entry-cfieldname
            TRANSPORTING NO FIELDS.
        IF sy-subrc &lt;&gt; 0.
* try to get global currency field
          READ TABLE x_namtab WITH KEY viewfield = fcat_entry-fieldname.
          cukytab = x_namtab-reftable.
          cukyname = x_namtab-reffield.
          CONCATENATE x_namtab-reftable &apos;-&apos; x_namtab-reffield
                  INTO hname.
          ASSIGN (hname) TO &lt;cuky&gt;.
          IF sy-subrc = 0.
* global currency key exists to be inserted in value table
            fcat_entry-currency = cukyvalue = &lt;cuky&gt;.
          ENDIF.
        ENDIF.
      WHEN &apos;QUAN&apos;.
        READ TABLE x_namtab WITH KEY viewfield = fcat_entry-qfieldname
            TRANSPORTING NO FIELDS.
        IF sy-subrc &lt;&gt; 0.
* try to get global quantity field
          READ TABLE x_namtab WITH KEY viewfield = fcat_entry-fieldname.
          unittab = x_namtab-reftable.
          unitname = x_namtab-reffield.
          CONCATENATE x_namtab-reftable &apos;-&apos; x_namtab-reffield
                  INTO hname.
          ASSIGN (hname) TO &lt;unit&gt;.
          IF sy-subrc = 0.
* global unit key exists to be inserted in value table
            fcat_entry-quantity = unitvalue = &lt;unit&gt;.
          ENDIF.
        ENDIF.
    ENDCASE.
    MODIFY vim_alv_fcat FROM fcat_entry.
  ENDLOOP.
  REFRESH alv_value_tab.
  LOOP AT value_tab.
    APPEND &lt;w_value_tab_x&gt; TO alv_value_tab.
  ENDLOOP.
*  APPEND LINES OF value_tab TO alv_value_tab.
  FREE value_tab.
  IF NOT cukyname IS INITIAL.
* Append global currency to value_tab
    LOOP AT alv_value_tab ASSIGNING &lt;value&gt;.
      &lt;value&gt;+length = cukyvalue.
    ENDLOOP.
    length = length + cukylength.
  ENDIF.
  IF NOT unitname IS INITIAL.
* Append global unit to value_tab
    LOOP AT alv_value_tab ASSIGNING &lt;value&gt;.
      &lt;value&gt;+length = unitvalue.
    ENDLOOP.
  ENDIF.
  PERFORM define_alv_callbacks CHANGING vim_alv_events.
  PERFORM make_list_commentary USING unittab
                                     unitname
                                     unitvalue
                                     cukytab
                                     cukyname
                                     cukyvalue
                               CHANGING vim_list_header.
  PERFORM make_alv_layout CHANGING vim_alv_layout
                                   vim_alv_print.
  PERFORM init_alv_variant CHANGING vim_var_save
                                    vim_var_default
                                    vim_alv_variant.
  progname = sy-repid.
  PERFORM check_list_before_alv CHANGING rc.
  CHECK rc = 0.
  CALL FUNCTION &apos;REUSE_ALV_TABLE_CREATE&apos;
    EXPORTING
      it_fieldcat        = vim_alv_fcat
      i_callback_program = progname
      i_formname         = alv_called_by.
  FREE alv_value_tab.
*  if sy-subrc ne 0. raise print_error. endif.
ENDFORM.                               &quot; DRUCKEN_ZTP_ALT

*&amp;---------------------------------------------------------------------*
*&amp;      Form  MAKE_LIST_COMMENTARY
*&amp;---------------------------------------------------------------------*
*       Build up list header
*----------------------------------------------------------------------*
*      &lt;--P_LIST_COMMENTARY  text
*----------------------------------------------------------------------*
FORM make_list_commentary USING p_unittab TYPE tabname
                                p_unitname TYPE fieldname
                                p_unitvalue TYPE any
                                                &quot;vim_unitUF296573/2000
                                p_cukytab TYPE tabname
                                p_cukyname TYPE fieldname
                                p_cukyvalue TYPE vim_cuky
                       CHANGING p_list_header TYPE slis_t_listheader.
  DATA: h_header TYPE slis_listheader,
        text(40), w_dfies TYPE dfies.

  REFRESH p_list_header.
  h_header-typ = &apos;H&apos;.
  h_header-info = x_header-ddtext.
  APPEND h_header TO p_list_header.
  h_header-typ = &apos;S&apos;.
  IF x_header-bastab NE space AND x_header-texttbexst NE space
   AND x_header-maintview = x_header-viewname.
    h_header-key = svim_text_p01.
  ELSE.
    h_header-key = svim_text_p02.
  ENDIF.
  h_header-info = x_header-viewname.
  APPEND h_header TO p_list_header.
  IF x_header-clidep &lt;&gt; space.
    h_header-key = svim_text_p03.
    h_header-info = sy-mandt.
    APPEND h_header TO p_list_header.
  ENDIF.
  IF p_unitname &lt;&gt; space.
    CLEAR h_header.
    h_header-typ = &apos;S&apos;.
    PERFORM vim_get_reffield_alv USING p_unitname
                                       p_unittab
                                  CHANGING w_dfies.
    IF w_dfies &lt;&gt; space.
      IF w_dfies-scrtext_m &lt;&gt; space.
        h_header-key = w_dfies-scrtext_m(20).
      ELSE.
        IF w_dfies-scrtext_l &lt;&gt; space.
          h_header-key = w_dfies-scrtext_l(20).
        ELSE.
          IF w_dfies-scrtext_s &lt;&gt; space.
            h_header-key = w_dfies-scrtext_s(10).
          ELSE.
            IF w_dfies-reptext &lt;&gt; space.
              h_header-key = w_dfies-reptext(20).
            ELSE.
              h_header-key = w_dfies-fieldname.
            ENDIF.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.
    h_header-info = p_unitvalue.
    APPEND h_header TO p_list_header.
  ENDIF.
  IF p_cukyname &lt;&gt; space.
    CLEAR h_header.
    h_header-typ = &apos;S&apos;.
    PERFORM vim_get_reffield_alv USING p_cukyname
                                       p_cukytab
                                  CHANGING w_dfies.
    IF w_dfies &lt;&gt; space.
      IF w_dfies-scrtext_m &lt;&gt; space.
        h_header-key = w_dfies-scrtext_m(20).
      ELSE.
        IF w_dfies-scrtext_l &lt;&gt; space.
          h_header-key = w_dfies-scrtext_l(20).
        ELSE.
          IF w_dfies-scrtext_s &lt;&gt; space.
            h_header-key = w_dfies-scrtext_s(10).
          ELSE.
            IF w_dfies-reptext &lt;&gt; space.
              h_header-key = w_dfies-reptext(20).
            ELSE.
              h_header-key = w_dfies-fieldname.
            ENDIF.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.
    h_header-info = p_cukyvalue.
    APPEND h_header TO p_list_header.
  ENDIF.
ENDFORM.                               &quot; MAKE_LIST_COMMENTARY
*&amp;---------------------------------------------------------------------*
*&amp;      Form  DEFINE_ALV_CALLBACKS
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      &lt;--P_ALV_EVENTS  text
*----------------------------------------------------------------------*
FORM define_alv_callbacks CHANGING p_alv_events TYPE slis_t_event.
  DATA: h_event TYPE slis_alv_event.
  CONSTANTS: formname_top_of_list TYPE slis_formname
             VALUE &apos;ALV_TOP_OF_LIST&apos;,
             formname_top_of_page TYPE slis_formname
             VALUE &apos;ALV_TOP_OF_PAGE&apos;,
             formname_end_of_page TYPE slis_formname
             VALUE &apos;ALV_END_OF_PAGE&apos;,
             formname_end_of_list TYPE slis_formname
             VALUE &apos;ALV_END_OF_LIST&apos;.
  REFRESH p_alv_events.
  CALL FUNCTION &apos;REUSE_ALV_EVENTS_GET&apos;
    EXPORTING
      i_list_type = 0
    IMPORTING
      et_events   = p_alv_events.
* define TOP_OF_LIST event
  READ TABLE p_alv_events WITH KEY name = slis_ev_top_of_list
                           INTO h_event.
  IF sy-subrc = 0.
    h_event-form = formname_top_of_list.
    APPEND h_event TO p_alv_events.
  ENDIF.
* define TOP_OF_PAGE event
  READ TABLE p_alv_events WITH KEY name = slis_ev_top_of_page
                           INTO h_event.
  IF sy-subrc = 0.
    h_event-form = formname_top_of_page.
    APPEND h_event TO p_alv_events.
  ENDIF.
* define END_OF_PAGE event
  READ TABLE p_alv_events WITH KEY name = slis_ev_end_of_page
                           INTO h_event.
  IF sy-subrc = 0.
    h_event-form = formname_end_of_page.
    APPEND h_event TO p_alv_events.
  ENDIF.
* define END_OF_LIST event
  READ TABLE p_alv_events WITH KEY name = slis_ev_end_of_list
                           INTO h_event.
  IF sy-subrc = 0.
    h_event-form = formname_end_of_list.
    APPEND h_event TO p_alv_events.
  ENDIF.
ENDFORM.                    &quot;define_alv_callbacks

*&amp;---------------------------------------------------------------------*
*&amp;      Form  ALV_TOP_OF_LIST
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
FORM alv_top_of_list.
  CALL FUNCTION &apos;REUSE_ALV_COMMENTARY_WRITE&apos;
    EXPORTING
      it_list_commentary = vim_list_header.

ENDFORM.                               &quot; ALV_TOP_OF_LIST
*&amp;---------------------------------------------------------------------*
*&amp;      Form  ALV_TOP_OF_PAGE
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
FORM alv_top_of_page.
  WRITE AT (sy-linsz) sy-datum RIGHT-JUSTIFIED.
ENDFORM.                               &quot; ALV_TOP_OF_PAGE
*&amp;---------------------------------------------------------------------*
*&amp;      Form  ALV_END_OF_PAGE
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
FORM alv_end_of_page.
  WRITE AT (sy-linsz) sy-pagno CENTERED.
ENDFORM.                               &quot; ALV_END_OF_PAGE

*&amp;---------------------------------------------------------------------*
*&amp;      Form  MAKE_ALV_LAYOUT
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      &lt;--P_ALV_LAYOUT  text
*----------------------------------------------------------------------*
FORM make_alv_layout CHANGING p_alv_layout TYPE slis_layout_alv
                              p_alv_print  TYPE slis_print_alv.
* screen layout
  CLEAR p_alv_layout.
  p_alv_layout-colwidth_optimize = &apos;X&apos;.
  p_alv_layout-f2code = &apos;&amp;ETA&apos;.
  p_alv_layout-detail_popup = &apos;X&apos;.
* print layout
  p_alv_print-reserve_lines = 2.                            &quot;GKPR/1014972
  p_alv_print-no_print_listinfos = &apos;X&apos;.
ENDFORM.                               &quot; MAKE_ALV_LAYOUT
*&amp;---------------------------------------------------------------------*
*&amp;      Form  FILL_ALV_FIELDCAT
*&amp;---------------------------------------------------------------------*
*       Builds up ALV-fieldcatalogue from X_NAMTAB
*----------------------------------------------------------------------*
*      &lt;--P_VIM_ALV_FCAT  ALV-fieldctalogue
*----------------------------------------------------------------------*
FORM fill_alv_fieldcat CHANGING p_vim_alv_fcat TYPE slis_t_fieldcat_alv
                                texttab_begin LIKE sy-tabix
                                p_value_length TYPE intlen
*                                p_textlen TYPE intlen
                                p_unittab TYPE tabname
                                p_unitname TYPE fieldname
                                p_unitvalue TYPE any &quot;vim_unit
                                       &quot;UF296573/2000
                                p_cukytab TYPE tabname
                                p_cukyname TYPE fieldname
                                p_cukyvalue TYPE vim_cuky.

  DATA: fcat_header TYPE slis_fieldcat_alv, textfld_no TYPE i,
        fcat_reffield TYPE slis_fieldcat_alv, rc LIKE sy-subrc,
        first TYPE xfeld VALUE &apos;X&apos;, list_width TYPE outputlen,
        i TYPE i, first_func_field TYPE i, text_outp_len TYPE outputlen,
        fldno(2) TYPE n, strln TYPE i,
        hname TYPE fnam_____4, maintview, global_unit_set,
        global_cuky_set.

  CONSTANTS: max_list_width TYPE i VALUE 250.

  FIELD-SYMBOLS: &lt;alv_fcat&gt; LIKE LINE OF p_vim_alv_fcat,
                 &lt;alv_fcat2&gt; LIKE LINE OF p_vim_alv_fcat, &quot;UF412290/2001
                 &lt;x_namt&gt; LIKE LINE OF x_namtab, &lt;cuky&gt; TYPE vim_cuky,
                 &lt;unit&gt; TYPE ANY.      &quot;vim_unit. UF296573/2000

  REFRESH p_vim_alv_fcat.
  CLEAR:  p_unitname, p_cukyname, p_unitvalue, p_cukyvalue,
          p_value_length.
  IF x_header-bastab EQ space OR x_header-texttbexst EQ space
   OR x_header-maintview NE x_header-viewname.
    maintview = &apos;X&apos;.                   &quot;It&apos;s a maintenance view!
  ENDIF.
* Build up field catalogue
  LOOP AT x_namtab ASSIGNING &lt;x_namt&gt; WHERE texttabfld = space
   OR keyflag = space.
    i = i + 1.
    fcat_header-col_pos = i.
    fcat_header-fieldname = &lt;x_namt&gt;-viewfield.
    IF maintview = space.
      fcat_header-ref_tabname = &lt;x_namt&gt;-bastabname.
    ELSE.
      fcat_header-ref_tabname = x_header-maintview.
    ENDIF.
    fcat_header-key = &lt;x_namt&gt;-keyflag.
    fcat_header-seltext_l = &lt;x_namt&gt;-scrtext_l.
    fcat_header-seltext_m = &lt;x_namt&gt;-scrtext_m.
    fcat_header-seltext_s = &lt;x_namt&gt;-scrtext_s.
    fcat_header-reptext_ddic = &lt;x_namt&gt;-reptext.
    fcat_header-datatype = &lt;x_namt&gt;-datatype.
    fcat_header-inttype = &lt;x_namt&gt;-inttype.
    fcat_header-ddic_outputlen = &lt;x_namt&gt;-outputlen.
    fcat_header-intlen = &lt;x_namt&gt;-flength.
    fcat_header-lowercase = &lt;x_namt&gt;-lowercase.
    CASE &lt;x_namt&gt;-datatype.
      WHEN &apos;CLNT&apos;.
        IF x_header-clidep &lt;&gt; space.
          fcat_header-tech = &apos;X&apos;.
        ENDIF.
      WHEN &apos;CURR&apos;.
        READ TABLE x_namtab WITH KEY viewfield = &lt;x_namt&gt;-reffield
            TRANSPORTING NO FIELDS.
        IF sy-subrc = 0 AND &lt;x_namt&gt;-reftable = x_header-maintview.
          &quot;UF163276/2001
* currency field in structure
          fcat_header-cfieldname = &lt;x_namt&gt;-reffield.
        ELSE.
          IF p_cukyvalue IS INITIAL.
* try to get global currency field
            p_cukytab = &lt;x_namt&gt;-reftable.
            p_cukyname = &lt;x_namt&gt;-reffield.
            CONCATENATE &lt;x_namt&gt;-reftable &apos;-&apos; &lt;x_namt&gt;-reffield
                    INTO hname.
            ASSIGN (hname) TO &lt;cuky&gt;.
            IF sy-subrc = 0.
* global currency key exists to be inserted in value table
              fcat_header-currency = p_cukyvalue = &lt;cuky&gt;.
            ENDIF.
          ELSE.
            fcat_header-currency = p_cukyvalue.
          ENDIF.
        ENDIF.
      WHEN &apos;QUAN&apos;.
        READ TABLE x_namtab WITH KEY viewfield = &lt;x_namt&gt;-reffield
            TRANSPORTING NO FIELDS.
        IF sy-subrc = 0 AND &lt;x_namt&gt;-reftable = x_header-maintview.
          &quot;UF163276/2001.
* quantity field in structure
          fcat_header-qfieldname = &lt;x_namt&gt;-reffield.
        ELSE.
* try to get global quantity field
          IF p_unitvalue IS INITIAL.
            p_unittab = &lt;x_namt&gt;-reftable.
            p_unitname = &lt;x_namt&gt;-reffield.
            CONCATENATE &lt;x_namt&gt;-reftable &apos;-&apos; &lt;x_namt&gt;-reffield
                    INTO hname.
            ASSIGN (hname) TO &lt;unit&gt;.
            IF sy-subrc = 0.
* global unit key exists to be inserted in value table
              fcat_header-quantity = p_unitvalue = &lt;unit&gt;.
            ENDIF.
          ELSE.
            fcat_header-quantity = p_unitvalue.
          ENDIF.
        ENDIF.
    ENDCASE.
    IF &lt;x_namt&gt;-readonly = vim_hidden
* hide hidden fields
     OR &lt;x_namt&gt;-domname IN vim_guid_domain.
* no GUID-values
      fcat_header-tech = &apos;X&apos;.
    ELSE.
      list_width = list_width + &lt;x_namt&gt;-outputlen + 1.
    ENDIF.
    p_value_length = p_value_length + fcat_header-intlen.
    APPEND fcat_header TO p_vim_alv_fcat.
    CLEAR fcat_header.
    CHECK &lt;x_namt&gt;-texttabfld &lt;&gt; space.
    textfld_no = textfld_no + 1.       &quot;get no. of text fields
*    p_textlen = p_textlen + &lt;x_namt&gt;-flength. &quot;int. length of text flds
    CHECK &lt;x_namt&gt;-readonly &lt;&gt; vim_hidden.
    IF first &lt;&gt; space.
      texttab_begin = i.               &quot;position of 1st text fld
      CLEAR first.
    ENDIF.
    text_outp_len = text_outp_len + &lt;x_namt&gt;-outputlen.
  ENDLOOP.
  first = &apos;X&apos;.
  CLEAR i.
  IF x_header-bastab NE space AND x_header-texttbexst NE space
   AND x_header-maintview = x_header-viewname.
* Place text fields behind key fields.
    LOOP AT p_vim_alv_fcat ASSIGNING &lt;alv_fcat&gt; WHERE key = space.
      IF first &lt;&gt; space.
        first_func_field = &lt;alv_fcat&gt;-col_pos.
        CLEAR first.
      ENDIF.
      IF sy-tabix &lt; texttab_begin.
        &lt;alv_fcat&gt;-col_pos = &lt;alv_fcat&gt;-col_pos + textfld_no.
      ELSE.
        i = i + 1.
        &lt;alv_fcat&gt;-col_pos = first_func_field + i - 1.
      ENDIF.
    ENDLOOP.
    first = &apos;X&apos;.
    SORT p_vim_alv_fcat BY col_pos.
  ENDIF.
  IF list_width &gt; max_list_width.
* line size to large for one line
    list_width = i = 1.
    LOOP AT p_vim_alv_fcat ASSIGNING &lt;alv_fcat&gt;.
      list_width = list_width + &lt;alv_fcat&gt;-ddic_outputlen + 1.
      IF list_width &gt; max_list_width.
        i = i + 1.
        list_width = &lt;alv_fcat&gt;-ddic_outputlen + 1.
      ENDIF.
      &lt;alv_fcat&gt;-row_pos = i.
    ENDLOOP.
  ENDIF.
  IF maintview = space.                  &quot;UF412290/2001b
*check field catalogue for doublettes and change their fieldname
    LOOP AT p_vim_alv_fcat ASSIGNING &lt;alv_fcat&gt;.
      i = sy-tabix.
      CLEAR fldno.
      LOOP AT p_vim_alv_fcat ASSIGNING &lt;alv_fcat2&gt;
       WHERE fieldname = &lt;alv_fcat&gt;-fieldname.
        CHECK sy-tabix &lt;&gt; i.
        &lt;alv_fcat2&gt;-ref_fieldname = &lt;alv_fcat2&gt;-fieldname.
        ADD 1 TO fldno.
        CONCATENATE &lt;alv_fcat2&gt;-fieldname fldno
         INTO &lt;alv_fcat2&gt;-fieldname.
        IF sy-subrc &lt;&gt; 0.
          strln = strlen( &lt;alv_fcat2&gt;-fieldname ) - 2.
          CONCATENATE &lt;alv_fcat2&gt;-fieldname(strln) fldno
          INTO &lt;alv_fcat2&gt;-fieldname.
        ENDIF.
      ENDLOOP.
    ENDLOOP.
  ENDIF.                                 &quot;UF412290/2001e
ENDFORM.                               &quot; FILL_ALV_FIELDCAT

*&amp;---------------------------------------------------------------------*
*&amp;      Form  VIM_CALL_ALV
*&amp;---------------------------------------------------------------------*
*       Calls ABAP List Viewer. Has to be called from Function Module
*       REUSE_ALV_TABLE_CREATE.
*----------------------------------------------------------------------*
*      --&gt;VALUE_TAB
*----------------------------------------------------------------------*
FORM vim_call_alv TABLES value_tab.

  DATA: progname LIKE sy-repid.
  FIELD-SYMBOLS: &lt;alv_value_tab_x&gt; TYPE tabl8000,
                 &lt;value_tab_x&gt; TYPE x.

  REFRESH value_tab.
  ASSIGN value_tab TO &lt;value_tab_x&gt; CASTING.
  LOOP AT alv_value_tab ASSIGNING &lt;alv_value_tab_x&gt;.
    &lt;value_tab_x&gt; = &lt;alv_value_tab_x&gt;.
    APPEND value_tab.
  ENDLOOP.
*  APPEND LINES OF alv_value_tab TO value_tab.
  progname = sy-repid.
  CALL FUNCTION &apos;REUSE_ALV_LIST_DISPLAY&apos;
      EXPORTING
           i_callback_program       = progname
           is_layout                = vim_alv_layout
           it_fieldcat              = vim_alv_fcat
*           it_excluding             = vim_alv_excluding
*           it_special_groups        = vim_alv_special_groups
*           it_sort                  = vim_alv_sort
*            IT_FILTER                =
*           is_sel_hide              = vim_alv_sel_hide
           i_default                = vim_var_default
           i_save                   = vim_var_save
           is_variant               = vim_alv_variant
           it_events                = vim_alv_events
*           it_event_exit            = vim_alv_event_exit
           is_print                 = vim_alv_print
*            IS_REPREP_ID             =
*            I_SCREEN_START_COLUMN    = 0
*            I_SCREEN_START_LINE      = 0
*            I_SCREEN_END_COLUMN      = 0
*            I_SCREEN_END_LINE        = 0
*       IMPORTING
*            E_EXIT_CAUSED_BY_CALLER  =
*            ES_EXIT_CAUSED_BY_USER   =
       TABLES
            t_outtab                 = value_tab[]
       EXCEPTIONS
            program_error            = 1
            OTHERS                   = 2.
  IF sy-subrc NE 0. RAISE print_error. ENDIF.
ENDFORM.                               &quot;vim_call_alv
*&amp;---------------------------------------------------------------------*
*&amp;      Form  MAINTAIN_ALV_VALUE_TAB_TEXT
*&amp;---------------------------------------------------------------------*
*       shift textfield directly behind key
*----------------------------------------------------------------------*
*      --&gt;P_TEXTLEN  text
*----------------------------------------------------------------------*
FORM maintain_alv_value_tab_text USING    p_textlen TYPE intlen.

  DATA: x TYPE i, record TYPE tabl8000, textoffset TYPE intlen,
        BEGIN OF new_offs,
          ref_tabname TYPE tabname,
          fieldname TYPE viewfield,
          ref_fieldname TYPE fieldname,
          offset TYPE tabfdpos,
        END OF new_offs.

  STATICS: t_fld_offs LIKE SORTED TABLE OF new_offs WITH UNIQUE KEY
                           ref_tabname fieldname ref_fieldname
                           INITIAL SIZE 1,
           viewname TYPE viewname.
  FIELD-SYMBOLS: &lt;x_namt&gt; LIKE LINE OF x_namtab,
                 &lt;alv_fcat&gt; TYPE slis_fieldcat_alv,
                 &lt;alv_val&gt;.

  IF viewname &lt;&gt; x_header-viewname.
    viewname = x_header-viewname.
    REFRESH t_fld_offs.
    new_offs-offset = x_header-after_keyc.
*    new_offs-offset = x_header-keylen.
* Offset aktualisieren
    LOOP AT vim_alv_fcat ASSIGNING &lt;alv_fcat&gt; WHERE key = space.
      new_offs-ref_tabname = &lt;alv_fcat&gt;-ref_tabname.
      new_offs-fieldname = &lt;alv_fcat&gt;-fieldname.
      new_offs-ref_fieldname = &lt;alv_fcat&gt;-ref_fieldname. &quot;UF412290/2001
* Alignment
      IF &apos;CNDT&apos; CS &lt;alv_fcat&gt;-inttype.
* Character-like datatypes
        x = ( new_offs-offset + cl_abap_char_utilities=&gt;charsize )
              MOD cl_abap_char_utilities=&gt;charsize.
        IF x NE 0.
          new_offs-offset = new_offs-offset
                             + cl_abap_char_utilities=&gt;charsize - x.
        ENDIF.
      ELSE.
        CASE &lt;alv_fcat&gt;-datatype.
          WHEN &apos;INT2&apos; OR &apos;PREC&apos;.
            x = ( new_offs-offset + 2 ) MOD 2.
            IF x NE 0.
              new_offs-offset = new_offs-offset + 2 - x.
            ENDIF.
          WHEN &apos;INT4&apos;.
            x = ( new_offs-offset + 4 ) MOD 4.
            IF x NE 0.
              new_offs-offset = new_offs-offset + 4 - x.
            ENDIF.
          WHEN &apos;FLTP&apos;.
            x = ( new_offs-offset + 8 ) MOD 8.
            IF x NE 0.
              new_offs-offset = new_offs-offset + 8 - x.
            ENDIF.
        ENDCASE.
      ENDIF.
      INSERT new_offs INTO TABLE t_fld_offs.
      new_offs-offset = new_offs-offset + &lt;alv_fcat&gt;-intlen.
    ENDLOOP.
  ENDIF.
  textoffset = x_header-after_tabc + x_header-aft_txtkc.
*  textoffset = x_header-tablen + x_header-textkeylen.
  LOOP AT alv_value_tab ASSIGNING &lt;alv_val&gt;.
    record(x_header-after_keyc) = &lt;alv_val&gt;(x_header-after_keyc).
*    record = &lt;alv_val&gt;(x_header-keylen).
    IF p_textlen &gt; 0.
      record+x_header-after_keyc(p_textlen) =
       &lt;alv_val&gt;+textoffset(p_textlen).
*      record+x_header-keylen(p_textlen) =
*       &lt;alv_val&gt;+textoffset(p_textlen).
    ENDIF.
    LOOP AT x_namtab ASSIGNING &lt;x_namt&gt; WHERE keyflag = space AND
                                              texttabfld = space.
      READ TABLE t_fld_offs INTO new_offs WITH TABLE KEY
                                    ref_tabname = &lt;x_namt&gt;-bastabname
                                    fieldname = &lt;x_namt&gt;-viewfield
                                    ref_fieldname = space.
      IF sy-subrc = 0.
        record+new_offs-offset(&lt;x_namt&gt;-flength) =
         &lt;alv_val&gt;+&lt;x_namt&gt;-position(&lt;x_namt&gt;-flength).
      ELSE.                                &quot;UF412290/2001b
* field had to be renamed because of doublettes
        READ TABLE t_fld_offs INTO new_offs WITH KEY
                                    ref_tabname = &lt;x_namt&gt;-bastabname
                                    ref_fieldname = &lt;x_namt&gt;-viewfield.
        IF sy-subrc = 0.
          record+new_offs-offset(&lt;x_namt&gt;-flength) =
           &lt;alv_val&gt;+&lt;x_namt&gt;-position(&lt;x_namt&gt;-flength).
        ENDIF.                             &quot;UF412290/2001e
      ENDIF.
    ENDLOOP.
    CLEAR &lt;alv_val&gt;.
    &lt;alv_val&gt; = record.
  ENDLOOP.
ENDFORM.                               &quot; MAINTAIN_ALV_VALUE_TAB_TEXT
*&amp;---------------------------------------------------------------------*
*&amp;      Form  VIM_GET_REFFIELD_ALV
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_REFFIELD  text
*      --&gt;P_REFTABLE  text
*      &lt;--P_DFIES Entry for ALV-Fieldcatalogue
*----------------------------------------------------------------------*
FORM vim_get_reffield_alv USING value(p_reffield) TYPE fieldname
                                value(p_reftable) TYPE tabname
                      CHANGING p_dfies TYPE dfies.

  DATA: dfies_tab TYPE TABLE OF dfies.

  CALL FUNCTION &apos;DDIF_FIELDINFO_GET&apos;
    EXPORTING
      tabname        = p_reftable
      fieldname      = p_reffield
      langu          = sy-langu
    TABLES
      dfies_tab      = dfies_tab
    EXCEPTIONS
      not_found      = 1
      internal_error = 2
      OTHERS         = 3.
  IF sy-subrc &lt;&gt; 0.
    EXIT.
  ELSE.
    READ TABLE dfies_tab INTO p_dfies INDEX 1.
  ENDIF.
ENDFORM.                               &quot; VIM_GET_REFFIELD_ALV

*&amp;---------------------------------------------------------------------*
*&amp;      Form  CONV_DFIES_FCAT
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_P_DFIES  text
*      &lt;--P_P_FCAT_REFFIELD  text
*----------------------------------------------------------------------*
FORM conv_dfies_fcat USING    p_dfies LIKE dfies
                              i TYPE i
                    CHANGING p_fcat_reffield TYPE slis_fieldcat_alv.

  p_fcat_reffield-col_pos = i.
  p_fcat_reffield-fieldname = p_dfies-fieldname.
  p_fcat_reffield-ref_tabname = p_dfies-tabname.
  p_fcat_reffield-key = p_dfies-keyflag.
  p_fcat_reffield-seltext_l = p_dfies-scrtext_l.
  p_fcat_reffield-seltext_m = p_dfies-scrtext_m.
  p_fcat_reffield-seltext_s = p_dfies-scrtext_s.
  p_fcat_reffield-reptext_ddic = p_dfies-reptext.
  p_fcat_reffield-datatype = p_dfies-datatype.
  p_fcat_reffield-inttype = p_dfies-inttype.
  p_fcat_reffield-ddic_outputlen = p_dfies-outputlen.
  p_fcat_reffield-intlen = p_dfies-intlen.
  p_fcat_reffield-lowercase = p_dfies-lowercase.
  CASE p_dfies-datatype.
    WHEN &apos;CLNT&apos;.
      CHECK x_header-clidep &lt;&gt; space AND p_fcat_reffield-key &lt;&gt; space.
      p_fcat_reffield-tech = &apos;X&apos;.
    WHEN &apos;CURR&apos;.
* currency field in structure
      p_fcat_reffield-cfieldname = p_dfies-reffield.
    WHEN &apos;QUAN&apos;.
* currency field in structure
      p_fcat_reffield-qfieldname = p_dfies-reffield.
  ENDCASE.
ENDFORM.                               &quot; CONV_DFIES_FCAT
*&amp;---------------------------------------------------------------------*
*&amp;      Form  INIT_ALV_VARIANT
*&amp;---------------------------------------------------------------------*
*       define path for list variant names
*----------------------------------------------------------------------*
*      &lt;--P_VARIANT  text
*      &lt;--P_SAVE     text
*----------------------------------------------------------------------*
FORM init_alv_variant CHANGING p_save
                               p_default
                               p_variant STRUCTURE disvariant.

  CONCATENATE x_header-viewname sy-repid INTO p_variant-report.
  p_save = &apos;A&apos;.
  p_default = &apos;X&apos;.
ENDFORM.                               &quot; INIT_ALV_VARIANT
*&amp;---------------------------------------------------------------------*
*&amp;      Form  ALV_END_OF_LIST
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
FORM alv_end_of_list.
  WRITE AT /(sy-linsz) sy-pagno CENTERED.
ENDFORM.                               &quot; ALV_END_OF_LIST</include_source>
   </include>
   <include NAME="LSVIMFXL" VARCL="X" SUBC="I" APPL="S" CNAM="SAP" CDAT="19960903" UNAM="SAP" UDAT="20080721" VERN="000041" LEVL="40A" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122442" IDATE="20080721" ITIME="122442">
    <include_source>***INCLUDE LSVIMFXL.
* SW 25.3.1997
*    Readonly-Felder in Texttabelle berücksichtigen

* SW 14.7.1998
*    Import für Texte in anderen Sprachen    &quot;Textimp

* SW 17.9.1998
*    beim Kopieren Texte in anderen Sprachen berücksichtigen   &quot;Textcopy
* UF 19.10.1998: DB-Zugriffe in Include LSVIMFL1 verlagert
INCLUDE lsvimfl1.
*---------------------------------------------------------------------*
*       FORM VIM_SET_LANGUAGES                                        *
*---------------------------------------------------------------------*
* Sprachauswahl expl. über Menue
*---------------------------------------------------------------------*
FORM vim_set_languages.
  DATA: dummy_langus LIKE h_t002 OCCURS 0.
  CALL FUNCTION &apos;VIEW_GET_LANGUAGES&apos;
    EXPORTING
      new_selection         = &apos;X&apos;
*      called_by_viewmaint   = &apos;X&apos;
    TABLES
      languages             = dummy_langus
    EXCEPTIONS
      no_languages_possible = 1.
  IF sy-subrc = 1.
    MESSAGE s160(sv).
  ENDIF.
ENDFORM.                    &quot;vim_set_languages

*---------------------------------------------------------------------*
*       FORM VIM_RESET_TEXTTAB                                        *
*---------------------------------------------------------------------*
* Rücksetzen der internen Texttabelle
*---------------------------------------------------------------------*
* --&gt; VIEWNAME   Rücksetzen der Texttab für Tab/View VIEWNAME
*---------------------------------------------------------------------*
FORM vim_reset_texttab USING viewname LIKE tvdir-tabname.

  READ TABLE vim_texttab_container WITH KEY viewname = viewname
                         BINARY SEARCH.
  IF sy-subrc = 0.
    FREE vim_texttab_container-tabdata-tab_us.
    FREE vim_texttab_container-tabdata-tab_vs.
    FREE vim_texttab_container-tabdata-tab_s.
    FREE vim_texttab_container-tabdata-tab_m.
    FREE vim_texttab_container-tabdata-tab_l.
    FREE vim_texttab_container-tabdata-tab_vl.
    FREE vim_texttab_container-tabdata-tab_ul.
    FREE vim_texttab_container-sel_langus.
    CLEAR vim_texttab_container-all_langus.
    MODIFY vim_texttab_container INDEX sy-tabix.
*     DELETE VIM_TEXTTAB_CONTAINER INDEX SY-TABIX.
  ENDIF.
ENDFORM.                               &quot;VIM_RESET_TEXTTAB

*---------------------------------------------------------------------*
*       FORM VIM_MULTI_LANGU_TEXT_MAINT                               *
*---------------------------------------------------------------------*
* Routine zur Behandlung der Funktion:                                *
*   &quot;Texterfassung in weiteren Sprachen&quot;                              *
*---------------------------------------------------------------------*
FORM vim_multi_langu_text_maint.
  DATA: langus_selected(1) TYPE c,
        curr_sptxt LIKE t002t-sptxt,
        sel_langus LIKE h_t002 OCCURS 0 WITH HEADER LINE,
        texttab_for_output TYPE vimty_multilangu_texttab,
        maint_mode(1) TYPE c,
        textmodif(1) TYPE c,
        f_called_by_viewmaint TYPE c.  &quot;XB H611377 BCEK070683


  CALL FUNCTION &apos;VIEW_GET_LANGUAGES&apos;
    IMPORTING
      languages_selected    = langus_selected
      curr_sptxt            = curr_sptxt
    TABLES
      languages             = sel_langus
    EXCEPTIONS
      no_languages_possible = 1.
  IF sy-subrc = 1.
    MESSAGE s160(sv).
    EXIT.
  ELSEIF langus_selected = &apos; &apos;.
    MESSAGE s153(sv).
    EXIT.
  ENDIF.
  IF x_header-frm_tl_get NE space.
    PERFORM (x_header-frm_tl_get) IN PROGRAM (x_header-fpoolname)
                                  TABLES sel_langus.
  ELSE.
    PERFORM vim_read_texttab_for_langus TABLES sel_langus USING &apos; &apos;.
  ENDIF.

* Falls mehr als 8 Textfelder (noch nicht realisiert)
*    -&gt; Popup zur Feldselektion und Dynproattribute aktualisieren
* PERFORM VIM_ACTUALIZE_D0100.

  REFRESH texttab_for_output.
  PERFORM vim_fill_texttab_for_maint TABLES sel_langus
                                     USING curr_sptxt
                                     CHANGING texttab_for_output.
  IF status-action EQ anzeigen OR status-action EQ transportieren.
    maint_mode = &apos;R&apos;.
  ELSE.
    maint_mode = &apos;U&apos;.
  ENDIF.
* XB H611377B BCEK070683
* check if it is called by view maintenance.
  IF x_namtab IS NOT INITIAL AND x_header IS NOT INITIAL.
    f_called_by_viewmaint = &apos;X&apos;.
  ENDIF.
  CALL FUNCTION &apos;VIEW_MULTI_LANGU_TEXT_MAINT&apos;
    EXPORTING
      mode                   = maint_mode
      ltext_exit_form        = x_header-frm_tltext
      called_by_viewmaint    = f_called_by_viewmaint
    IMPORTING
      vim_texttable_modified = textmodif
    TABLES
      vim_d0100_fielddescr   = vim_d0100_fdescr_ini
      vim_texttable          = texttab_for_output
      x_header               = x_header
      x_namtab               = x_namtab.
* XB H611377E BCE070683
  IF maint_mode = &apos;U&apos; AND textmodif = &apos;X&apos;.
    PERFORM vim_update_texttab USING texttab_for_output.
    MODIFY vim_texttab_container INDEX vim_texttab_container_index.
  ENDIF.

  IF status-mode = list_bild.          &quot;Entmarkieren
    LOOP AT extract.
      CHECK &lt;xmark&gt; = markiert.
      CLEAR &lt;xmark&gt;.
      MODIFY extract.
      mark_extract = mark_extract - 1.
      READ TABLE total WITH KEY &lt;vim_xextract_key&gt; BINARY SEARCH.
      IF sy-subrc = 0 AND &lt;mark&gt; = markiert.
        CLEAR &lt;mark&gt;.
        MODIFY total INDEX sy-tabix.
        mark_total = mark_total - 1.
      ENDIF.
    ENDLOOP.
  ENDIF.

ENDFORM.                               &quot; VIM_MULTI_LANGU_TEXT_MAINT

*---------------------------------------------------------------------*
*       FORM VIM_SELECT_TEXTFIELDS                                    *
*---------------------------------------------------------------------*
* Falls mehr als 8 Textfelder existieren -&gt; Benutzerauswahl
*---------------------------------------------------------------------*
FORM vim_select_textfields.
  DATA: nr_of_fields TYPE i.

  nr_of_fields = 0.
  LOOP AT x_namtab WHERE keyflag &lt;&gt; &apos;X&apos; AND
                         ( texttabfld = &apos;X&apos; OR txttabfldn &lt;&gt; space ) AND
                     ( readonly = space OR readonly = &apos;R&apos; ).&quot;SW 25.3.97
    &quot;   Textfeld in Tabelle or Textfeld in View
    x_namtab-textfldsel = &apos;X&apos;.
    nr_of_fields = nr_of_fields + 1.
    MODIFY x_namtab.
    IF nr_of_fields &gt;= vim_max_textfields.   &quot; Auswahl über Popup !!!
      EXIT.
    ENDIF.
  ENDLOOP.
ENDFORM.                               &quot;VIM_SELECT_TEXTFIELDS

*---------------------------------------------------------------------*
*       FORM VIM_INITIALIZE_D0100                                     *
*---------------------------------------------------------------------*
* Initialierung der Attribute für Dynprofelder des Texterfassungs-    *
* Dynpros D0100 (View-unabhängig)                                     *
*---------------------------------------------------------------------*
FORM vim_initialize_d0100.
  DATA: fdescr_wa TYPE vimty_screen_fdescr.

  REFRESH vim_d0100_fdescr_ini.
* Keys
  CLEAR fdescr_wa.
  fdescr_wa-active = &apos;X&apos;.
  fdescr_wa-name = &apos;VIM_D0100_WORKAREA-KEY1&apos;.
  APPEND fdescr_wa TO vim_d0100_fdescr_ini.
  CLEAR fdescr_wa-active.
  fdescr_wa-name = &apos;VIM_D0100_WORKAREA-KEY2&apos;.
  APPEND fdescr_wa TO vim_d0100_fdescr_ini.
  fdescr_wa-name = &apos;VIM_D0100_WORKAREA-KEY3&apos;.
  APPEND fdescr_wa TO vim_d0100_fdescr_ini.
  fdescr_wa-name = &apos;VIM_D0100_WORKAREA-KEY4&apos;.
  APPEND fdescr_wa TO vim_d0100_fdescr_ini.
  fdescr_wa-name = &apos;VIM_D0100_WORKAREA-KEY5&apos;.
  APPEND fdescr_wa TO vim_d0100_fdescr_ini.
  fdescr_wa-name = &apos;VIM_D0100_WORKAREA-KEY6&apos;.
  APPEND fdescr_wa TO vim_d0100_fdescr_ini.
  fdescr_wa-name = &apos;VIM_D0100_WORKAREA-KEY7&apos;.
  APPEND fdescr_wa TO vim_d0100_fdescr_ini.
  fdescr_wa-name = &apos;VIM_D0100_WORKAREA-KEY8&apos;.
  APPEND fdescr_wa TO vim_d0100_fdescr_ini.
  fdescr_wa-name = &apos;VIM_D0100_WORKAREA-KEY9&apos;.
  APPEND fdescr_wa TO vim_d0100_fdescr_ini.
  fdescr_wa-name = &apos;VIM_D0100_WORKAREA-KEY10&apos;.
  APPEND fdescr_wa TO vim_d0100_fdescr_ini.
* Sprache
  fdescr_wa-vislength = 10.
  fdescr_wa-active = &apos;X&apos;.
  fdescr_wa-name = &apos;VIM_D0100_WORKAREA-SPTXT&apos;.
  APPEND fdescr_wa TO vim_d0100_fdescr_ini.
* Texte
  fdescr_wa-name = &apos;VIM_D0100_WORKAREA-TEXT1&apos;.
  fdescr_wa-textfld = &apos;X&apos;.
  APPEND fdescr_wa TO vim_d0100_fdescr_ini.
  CLEAR fdescr_wa-active.
  fdescr_wa-textfld = &apos;X&apos;.
  fdescr_wa-name = &apos;VIM_D0100_WORKAREA-TEXT2&apos;.
  APPEND fdescr_wa TO vim_d0100_fdescr_ini.
  fdescr_wa-name = &apos;VIM_D0100_WORKAREA-TEXT3&apos;.
  APPEND fdescr_wa TO vim_d0100_fdescr_ini.
  fdescr_wa-name = &apos;VIM_D0100_WORKAREA-TEXT4&apos;.
  APPEND fdescr_wa TO vim_d0100_fdescr_ini.
  fdescr_wa-name = &apos;VIM_D0100_WORKAREA-TEXT5&apos;.
  APPEND fdescr_wa TO vim_d0100_fdescr_ini.
  fdescr_wa-name = &apos;VIM_D0100_WORKAREA-TEXT6&apos;.
  APPEND fdescr_wa TO vim_d0100_fdescr_ini.
  fdescr_wa-name = &apos;VIM_D0100_WORKAREA-TEXT7&apos;.
  APPEND fdescr_wa TO vim_d0100_fdescr_ini.
  fdescr_wa-name = &apos;VIM_D0100_WORKAREA-TEXT8&apos;.
  APPEND fdescr_wa TO vim_d0100_fdescr_ini.
ENDFORM.                               &quot; VIM_INITIALIZE_D0100

*---------------------------------------------------------------------*
*       FORM VIM_ACTUALIZE_D0100                                      *
*---------------------------------------------------------------------*
* Attribute für Dynprofelder für aktuellen View aktualisieren         *
* (bzw. der ausgewählten Textfelder, falls mehr als 8 ex.             *
*          !!! noch nicht unterstützt  !!!                )           *
*---------------------------------------------------------------------*
FORM vim_actualize_d0100.
  DATA: fdescr_wa TYPE vimty_screen_fdescr,
        next_tabix LIKE sy-tabix,
        nr_of_field TYPE i,
        tot_keylen TYPE i,
        vislen_0(1) TYPE c,
        max_textlen TYPE i,
        tmp_len TYPE i,
        nr_of_text TYPE i.
  FIELD-SYMBOLS: &lt;title&gt; LIKE vimnamtab-scrtext.            &quot;#EC *

  PERFORM vim_select_textfields.
  CLEAR: max_textlen, nr_of_text.
  LOOP AT x_namtab WHERE textfldsel = &apos;X&apos;.
    nr_of_text = nr_of_text + 1.
    IF max_textlen &lt; x_namtab-outputlen.
      max_textlen = x_namtab-outputlen.
    ENDIF.
  ENDLOOP.
  IF max_textlen &gt; 30. max_textlen = 30. ENDIF.

  CLEAR: tot_keylen, nr_of_field, vislen_0.
  LOOP AT x_namtab WHERE keyflag = &apos;X&apos; AND texttabfld &lt;&gt; &apos;X&apos;.
    CHECK x_namtab-datatype &lt;&gt; &apos;CLNT&apos; OR x_namtab-position &gt; 0.
    CHECK x_namtab-readonly &lt;&gt; &apos;S&apos; AND x_namtab-readonly &lt;&gt; &apos;H&apos;.
    CHECK x_header-delmdtflag = space OR x_header-ptfrkyexst = space OR
          x_namtab-domname &lt;&gt; vim_delim_date_domain OR
          ( x_namtab-rollname NOT IN vim_begda_types AND
            x_namtab-rollname NOT IN vim_endda_types ).
    nr_of_field = nr_of_field + 1.
    tot_keylen = tot_keylen + x_namtab-outputlen.
    IF nr_of_field &lt;= vim_max_keyfields.
      READ TABLE vim_d0100_fdescr_ini INDEX nr_of_field INTO fdescr_wa.
      fdescr_wa-title = x_namtab-scrtext.
      fdescr_wa-active = &apos;X&apos;.
      fdescr_wa-fixlength = x_namtab-outputlen.
      tmp_len = tot_keylen + max_textlen.
      IF vislen_0 = &apos;X&apos;.
        fdescr_wa-vislength = 0.
      ELSEIF tmp_len  &gt; 70.            &quot;???
        fdescr_wa-vislength = 70 - max_textlen -
                                 ( tot_keylen - x_namtab-outputlen ).
        vislen_0 = &apos;X&apos;.
        IF fdescr_wa-vislength &lt; 0.
          fdescr_wa-vislength = 0.
        ENDIF.
      ELSE.
        fdescr_wa-vislength = fdescr_wa-fixlength.
      ENDIF.
      IF nr_of_field &lt; vim_max_keyfields.
        MODIFY vim_d0100_fdescr_ini FROM fdescr_wa INDEX nr_of_field.
      ENDIF.
    ELSE.
      fdescr_wa-fixlength = fdescr_wa-fixlength + x_namtab-outputlen + 1.
    ENDIF.
  ENDLOOP.
  IF nr_of_field &gt;= vim_max_keyfields.
    fdescr_wa-title = &apos;...&apos;.
    fdescr_wa-active = &apos;X&apos;.
    fdescr_wa-vislength = 0.
    MODIFY vim_d0100_fdescr_ini FROM fdescr_wa INDEX vim_max_keyfields.
  ELSE.
    next_tabix = nr_of_field + 1.
    LOOP AT vim_d0100_fdescr_ini INTO fdescr_wa
            FROM next_tabix TO vim_max_keyfields.
      CLEAR fdescr_wa-active.
      fdescr_wa-fixlength = 0.
      fdescr_wa-vislength = 0.
      CLEAR fdescr_wa-title.
      MODIFY vim_d0100_fdescr_ini FROM fdescr_wa.
    ENDLOOP.
  ENDIF.
  next_tabix = vim_max_keyfields + 1.                       &quot;Sprachfeld

  LOOP AT x_namtab WHERE textfldsel = &apos;X&apos;.
    IF x_namtab-readonly = space OR x_namtab-readonly = &apos;R&apos;.&quot;SW 25.3.97
      next_tabix = next_tabix + 1.
      READ TABLE vim_d0100_fdescr_ini INDEX next_tabix INTO fdescr_wa.
      IF x_namtab-readonly = space.    &quot;SW 25.3.1997
        fdescr_wa-active = &apos;X&apos;.
      ELSEIF x_namtab-readonly = &apos;R&apos;.  &quot;SW 25.3.1997 ..
        fdescr_wa-active = &apos;R&apos;.
      ENDIF.                           &quot;.. SW 25.3.1997
      fdescr_wa-title = x_namtab-scrtext.
      fdescr_wa-fixlength = x_namtab-outputlen.
      fdescr_wa-vislength = x_namtab-outputlen.
      MODIFY vim_d0100_fdescr_ini FROM fdescr_wa INDEX next_tabix.
    ENDIF.
  ENDLOOP.

  next_tabix = next_tabix + 1.
  LOOP AT vim_d0100_fdescr_ini INTO fdescr_wa FROM next_tabix.
    CLEAR fdescr_wa-active.
    fdescr_wa-fixlength = 0.
    fdescr_wa-vislength = 0.
    CLEAR fdescr_wa-title.
    MODIFY vim_d0100_fdescr_ini FROM fdescr_wa.
  ENDLOOP.
ENDFORM.                               &quot;VIM_ACTUALIZE_D0100

*---------------------------------------------------------------------*
*       FORM VIM_READ_TEXTTAB_FOR_LANGUS                              *
*---------------------------------------------------------------------*
* Texteinträge von der DB nachlesen für alle Sprachen, für die noch   *
* nicht eingelesen wurde                                              *
*---------------------------------------------------------------------*
* --&gt; SEL_LANGUS         ausgewählte Sprachen
* --&gt; ALL_LANGUS         &apos;X&apos; alle Sprachen wurden ausgewählt
*---------------------------------------------------------------------*
FORM vim_read_texttab_for_langus TABLES sel_langus STRUCTURE h_t002
                                 USING all_langus TYPE c.
  DATA: diff_langus_exist(1) TYPE c,
        diff_langus LIKE h_t002 OCCURS 0 WITH HEADER LINE.

  IF vim_texttab_container-all_langus = &apos;X&apos;. EXIT. ENDIF. &quot;alles eingel.

  vim_texttab_container-all_langus = all_langus.
  REFRESH diff_langus. CLEAR diff_langus_exist.
  LOOP AT sel_langus.
    READ TABLE &lt;vim_read_langus&gt; WITH KEY sel_langus-spras
                            TRANSPORTING NO FIELDS BINARY SEARCH.
    IF sy-subrc &lt;&gt; 0.
      INSERT sel_langus-spras INTO &lt;vim_read_langus&gt; INDEX sy-tabix.
      diff_langus = sel_langus-spras.
      APPEND diff_langus.
      diff_langus_exist = &apos;X&apos;.
    ENDIF.
  ENDLOOP.

  IF diff_langus_exist = &apos;X&apos; OR all_langus = &apos;X&apos;.
    IF diff_langus_exist = &apos;X&apos;.
      PERFORM vim_get_texttab_data TABLES diff_langus
                                 CHANGING &lt;vim_texttab&gt;.
    ENDIF.
    MODIFY vim_texttab_container INDEX vim_texttab_container_index.
*                        wegen &lt;vim_read_langus&gt; und &lt;vim_texttab&gt;
  ENDIF.
ENDFORM.                               &quot; VIM_READ_TEXTTAB_FOR_LANGUS

*---------------------------------------------------------------------*
*       FORM VIM_FILL_TEXTTAB_FOR_MAINT                               *
*---------------------------------------------------------------------*
* Die zur Texterfassung in anderen Sprachen ausgewählten Texte werden *
* (anhand der markierten Einträge sowie der ausgewählten Sprachen)    *
* in die Tabelle zur Verarbeitung auf dem Dynpro übernommen.          *
*---------------------------------------------------------------------*
* --&gt; SEL_LANGUS         ausgewählte Sprachen
* --&gt; CURR_SPTXT         SPTXT von Sy-Langu
* &lt;-- TEXTTAB_FOR_MAINT  Verarbeitungstabelle der ausgewählten Texte
*                        auf dem Dynpro
*---------------------------------------------------------------------*
FORM vim_fill_texttab_for_maint TABLES sel_langus STRUCTURE h_t002
               USING curr_sptxt LIKE t002t-sptxt
               CHANGING texttab_for_maint TYPE vimty_multilangu_texttab.

  DATA: textmaint_record TYPE vimty_textmaint_record,
        textmaint_field TYPE vimty_textfield,
        align1 TYPE f,
        texttab_wa TYPE vim_line_ul,
        align2 TYPE f,
        tmp_wa TYPE tabl8000,
        condense(1) TYPE c,
        texttab_tabix LIKE sy-tabix,
        extract_index LIKE sy-tabix,
        keylen TYPE i,
        rc LIKE sy-subrc,                                   &quot;875536
        keys_identical TYPE xfeld.
  DATA: primkeylen TYPE i.
  FIELD-SYMBOLS: &lt;extract_key&gt; TYPE x,
                 &lt;next_spras&gt; TYPE spras,
                 &lt;text_rec_key&gt; TYPE x, &lt;h_texttab_wa&gt; TYPE x,
                 &lt;viewkey_in_texttab&gt; TYPE x, &lt;txtfld&gt; TYPE ANY,
                 &lt;h_tmp&gt; TYPE x, &lt;tmp_struc&gt; TYPE ANY,
                 &lt;h_texttab&gt; TYPE x, &lt;texttab_struc&gt; TYPE ANY.
  FIELD-SYMBOLS: &lt;extract_primkey&gt; TYPE x.

  IF x_header-delmdtflag &lt;&gt; space AND  &quot;zeitabh. &amp; part. Fremdschl.
     x_header-ptfrkyexst  = &apos;X&apos;.       &quot;      -&gt; zeitunabh. Texttab.
    condense = &apos;X&apos;.
    ASSIGN &lt;vim_ext_mkey_beforex&gt; TO &lt;extract_key&gt;.
*    ASSIGN &lt;vim_ext_mkey_before&gt; TO &lt;extract_key&gt;.
    keylen = x_header-after_keyc
     - vim_datum_length * cl_abap_char_utilities=&gt;charsize.
*    keylen = x_header-keylen - vim_datum_length.
    CLEAR &lt;vim_old_mkey_beforex&gt;.
  ELSE.
    ASSIGN &lt;vim_xextract_key&gt; TO &lt;extract_key&gt;.
    keylen = x_header-after_keyc.
*    keylen = x_header-keylen.
    CLEAR condense.
  ENDIF.
* In case of viewkey &gt; primtabkey -&gt; additional key fields are filled
* in &lt;extract_key&gt; but not existent in &lt;vim_texttab&gt; &quot;HCG 09/02/2005
*  primkeylen = x_header-textkeylen - cl_abap_char_utilities=&gt;charsize.
  IF x_header-bastab EQ space.                              &quot;875536
    CLEAR keys_identical.
    PERFORM vim_comp_roottabkey USING x_header
                                      x_namtab[]
                             CHANGING keys_identical
                                      rc.
    IF keys_identical EQ space.
      primkeylen = keylen.
    ELSE.
      clear primkeylen.
      LOOP AT x_namtab WHERE keyflag = &apos;X&apos; AND
                           bastabname = x_header-roottab.
        IF x_namtab-DATATYPE NE &apos;DATS&apos;.
          primkeylen = primkeylen + x_namtab-FLENGTH.
        ENDIF.
      ENDLOOP.
    ENDIF.
  ELSE.
    primkeylen = x_header-keylen.
  ENDIF.                                                    &quot;875536
  ASSIGN: texttab_wa TO &lt;h_texttab_wa&gt; CASTING.
  IF keylen &lt; primkeylen.
    ASSIGN &lt;h_texttab_wa&gt;(keylen) TO &lt;viewkey_in_texttab&gt;.
  ELSE.
    ASSIGN &lt;h_texttab_wa&gt;(primkeylen) TO &lt;viewkey_in_texttab&gt;.
  ENDIF.
*          texttab_wa+keylen(x_header-textkeylen) TO &lt;texttab_key&gt;,
  ASSIGN: &lt;h_texttab_wa&gt;+keylen(x_header-texttablen) TO &lt;h_texttab&gt;,
          tmp_wa+keylen(x_header-texttablen)
           TO &lt;h_tmp&gt;,
          &lt;h_texttab&gt; TO &lt;texttab_struc&gt;
           CASTING TYPE (x_header-texttab),
          &lt;h_tmp&gt; TO &lt;tmp_struc&gt; CASTING TYPE (x_header-texttab),
          COMPONENT x_header-sprasfield OF STRUCTURE &lt;texttab_struc&gt;
           TO &lt;next_spras&gt;,
           textmaint_record-keys TO &lt;text_rec_key&gt; CASTING.
*  ASSIGN texttab_wa+offset(vim_spras_length) TO &lt;next_spras&gt;.
  IF status-mode = list_bild.
    extract_index = 1.
  ELSE.
    extract_index = nextline.
  ENDIF.

  LOOP AT extract FROM extract_index.  &quot;Loop für Detail nicht nötig
    CHECK status-mode = detail_bild OR &lt;xmark&gt; = markiert.
    CHECK condense = &apos; &apos; OR
          &lt;vim_old_mkey_beforex&gt; &lt;&gt; &lt;vim_ext_mkey_beforex&gt;.
    IF condense = &apos;X&apos;.
      &lt;vim_old_mkey_beforex&gt; = &lt;vim_ext_mkey_beforex&gt;.
    ENDIF.
*   Texte in Sy-Langu
    CLEAR textmaint_record.
    &lt;text_rec_key&gt; = &lt;extract_key&gt;.
*    textmaint_record-keys = &lt;extract_key&gt;.
    PERFORM vim_external_repr_for_key TABLES textmaint_record-keytab
                                      USING &lt;vim_xextract_key&gt;.
    textmaint_record-spras = sy-langu.
    textmaint_record-sptxt = curr_sptxt.
    IF x_header-bastab = space.
* view
      LOOP AT x_namtab WHERE textfldsel = &apos;X&apos;.
        textmaint_field-namtab_idx = sy-tabix.
        textmaint_field-outplen = x_namtab-flength.
        ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE
         &lt;vim_extract_struc&gt; TO &lt;txtfld&gt;.
        textmaint_field-text = &lt;txtfld&gt;.
*      textmaint_field-text(x_namtab-flength) =
*                          extract+x_namtab-position(x_namtab-flength).
        APPEND textmaint_field TO textmaint_record-texttab.
      ENDLOOP.
    ELSE.
* tab + texttab
      LOOP AT x_namtab WHERE textfldsel = &apos;X&apos;.
        textmaint_field-namtab_idx = sy-tabix.
        textmaint_field-outplen = x_namtab-flength.
        ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE
         &lt;vim_ext_txt_struc&gt; TO &lt;txtfld&gt;.
        textmaint_field-text = &lt;txtfld&gt;.
*      textmaint_field-text(x_namtab-flength) =
*                          extract+x_namtab-position(x_namtab-flength).
        APPEND textmaint_field TO textmaint_record-texttab.
      ENDLOOP.
    ENDIF.
    APPEND textmaint_record TO texttab_for_maint.

*   Texte in ausgewählten Sprachen
************************************************************************
    CLEAR: &lt;viewkey_in_texttab&gt;, &lt;texttab_struc&gt;.
*    CLEAR texttab_wa.
*   In case of viewkey &gt; primtabkey -&gt; additional key fields are filled
*   in &lt;extract_key&gt; but not existent in &lt;vim_texttab&gt;  &quot;HCG 09/02/2005
    IF keylen &lt; primkeylen.
      ASSIGN &lt;extract_key&gt;(keylen) TO &lt;extract_primkey&gt;.
    ELSE.
      ASSIGN &lt;extract_key&gt;(primkeylen) TO &lt;extract_primkey&gt;.
    ENDIF.
*    READ TABLE &lt;vim_texttab&gt; WITH KEY &lt;extract_key&gt;
*                               INTO texttab_wa. &quot; BINARY SEARCH.
    READ TABLE &lt;vim_texttab&gt; WITH KEY &lt;extract_primkey&gt;
                               INTO texttab_wa. &quot; BINARY SEARCH.
    texttab_tabix = sy-tabix.
    LOOP AT sel_langus.
      CLEAR textmaint_record.
      &lt;text_rec_key&gt; = &lt;extract_key&gt;.
*      textmaint_record-keys = &lt;extract_key&gt;.             &quot;SW Langtext
      textmaint_record-spras = sel_langus-spras.
      textmaint_record-sptxt = sel_langus-sptxt.

*      IF &lt;viewkey_in_texttab&gt; = &lt;extract_key&gt; AND             &quot;817790
      IF &lt;viewkey_in_texttab&gt; = &lt;extract_primkey&gt; AND       &quot;817790
         &lt;next_spras&gt; &lt; sel_langus-spras.                 &quot;#EC PORTABLE
        LOOP AT &lt;vim_texttab&gt; FROM texttab_tabix INTO texttab_wa.
*          IF &lt;viewkey_in_texttab&gt; &lt;&gt; &lt;extract_key&gt; OR         &quot;817790
          IF &lt;viewkey_in_texttab&gt; &lt;&gt; &lt;extract_primkey&gt; OR   &quot;817790
             &lt;next_spras&gt; &gt;= sel_langus-spras.            &quot;#EC PORTABLE
            texttab_tabix = sy-tabix.
            EXIT.
          ENDIF.
        ENDLOOP.
      ENDIF.   &quot; &lt;next_spras&gt; &gt;= sel_langus-spras oder ex. nicht
      IF &lt;next_spras&gt; &lt;&gt; sel_langus-spras OR
*         &lt;viewkey_in_texttab&gt; &lt;&gt; &lt;extract_key&gt;.    &quot;HCG 09/02/2005
          &lt;viewkey_in_texttab&gt; &lt;&gt; &lt;extract_primkey&gt;.&quot;langu:text not ex
        CLEAR &lt;tmp_struc&gt;.
*        CLEAR tmp_wa.
      ELSE.
        tmp_wa = &lt;h_texttab_wa&gt;.
      ENDIF.
      LOOP AT x_namtab WHERE textfldsel = &apos;X&apos;.
        textmaint_field-namtab_idx = sy-tabix.
        textmaint_field-outplen = x_namtab-flength.
*        ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE
        ASSIGN COMPONENT x_namtab-bastabfld OF STRUCTURE     &quot;HCG wrong
         &lt;tmp_struc&gt; TO &lt;txtfld&gt;.   &quot;HCG for txtfldname in view differs
        textmaint_field-text = &lt;txtfld&gt;.
*        offset = keylen + x_namtab-texttabpos.
*        textmaint_field-text(x_namtab-flength) =
*                   tmp_wa+offset(x_namtab-flength).
        APPEND textmaint_field TO textmaint_record-texttab.
      ENDLOOP.
      APPEND textmaint_record TO texttab_for_maint.
    ENDLOOP.                           &quot; SEL_LANGUS

    IF status-mode = detail_bild. EXIT. ENDIF.
  ENDLOOP.                                                  &quot; EXTRACT
ENDFORM.                               &quot; VIM_FILL_TEXTTAB_FOR_MAINT

*&amp;--------------------------------------------------------------------*
*&amp;      Form  VIM_EXTERNAL_REPR_FOR_KEY                               *
*&amp;--------------------------------------------------------------------*
* --&gt; INT_KEY    Interne Darstellung der Schlüsselfelder
* &lt;-- KEYTAB     Tabelle, externe      &quot;
*&amp;--------------------------------------------------------------------*
FORM vim_external_repr_for_key TABLES keytab &quot;TYPE VIMTY_TEXTFIELD
                               USING int_key TYPE x.
  DATA: keynr TYPE i,
        keyfield TYPE vimty_textfield,
        namtab_idx LIKE sy-tabix.
  FIELD-SYMBOLS: &lt;i_value&gt; TYPE ANY, &lt;e_value&gt; TYPE c.

  CLEAR: keynr, keyfield. REFRESH keytab.
  MOVE int_key TO &lt;table1_wax&gt;.
  LOOP AT x_namtab WHERE keyflag = &apos;X&apos; AND texttabfld &lt;&gt; &apos;X&apos;.
    namtab_idx = sy-tabix.
*   Mandant nicht anzeigen
    CHECK x_namtab-datatype &lt;&gt; &apos;CLNT&apos; OR x_header-clidep = space.
*   Subset- und Readonly-Felder nicht anzeigen
    CHECK x_namtab-readonly &lt;&gt; &apos;S&apos; AND x_namtab-readonly &lt;&gt; &apos;H&apos;.
*   Datum bei zeitunabh. Texttabelle nicht anzeigen
    CHECK x_header-delmdtflag = space OR x_header-ptfrkyexst = space OR
          x_namtab-domname &lt;&gt; vim_delim_date_domain OR
          ( x_namtab-rollname NOT IN vim_begda_types AND
            x_namtab-rollname NOT IN vim_endda_types ).
    keynr = keynr + 1.
    IF keynr &gt; vim_max_keyfields.
      keyfield-text+keyfield-outplen(1) = &apos;|&apos;.
      keyfield-outplen = keyfield-outplen + 1.
    ENDIF.
    ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE &lt;table1_wa&gt;
     TO &lt;i_value&gt;.
*    ASSIGN int_key+x_namtab-position(x_namtab-flength) TO &lt;i_value&gt;.
    ASSIGN keyfield-text+keyfield-outplen(x_namtab-outputlen)
                                                       TO &lt;e_value&gt;.
    CALL FUNCTION &apos;VIEW_CONVERSION_OUTPUT&apos;
      EXPORTING
        value_intern = &lt;i_value&gt;
        tabname      = x_header-maintview
        fieldname    = x_namtab-viewfield
        outputlen    = x_namtab-outputlen
        intlen       = x_namtab-flength
      IMPORTING
        value_extern = &lt;e_value&gt;.

    IF keynr &lt; vim_max_keyfields.
      keyfield-namtab_idx = namtab_idx.
      keyfield-outplen = x_namtab-outputlen.
      APPEND keyfield TO keytab.
      CLEAR keyfield.
    ELSE.
      keyfield-outplen = keyfield-outplen + x_namtab-outputlen.
    ENDIF.
  ENDLOOP.

  IF keynr &gt;= vim_max_keyfields.
    APPEND keyfield TO keytab.
  ENDIF.
ENDFORM.                               &quot;VIM_EXTERNAL_REPR_FOR_KEY

*&amp;--------------------------------------------------------------------*
*&amp;      Form  VIM_FILL_TEXTTAB_KEY                                    *
*&amp;--------------------------------------------------------------------*
* UF210800: Not unicode-compatible: Please use form
* MAP_VIEWKEY_TO_TEXTTABKEY instead
*
*&amp;--------------------------------------------------------------------*
* --&gt; VIEW_WA  WA of view                                             *
* --&gt; SPRAS    Sprachschlüssel                                        *
* --&gt; SPRAS_POS Position des Sprachschlüssel in VIEW_WA
* &lt;-- TEXT_WA  Key of text table                                      *
*&amp;--------------------------------------------------------------------*
*FORM vim_fill_texttab_key USING view_wa
*                                spras LIKE t002-spras
*                                spras_pos LIKE vimdesc-sprasfdpos
*                       CHANGING text_wa.
*
** Sprachschlüssel
** TEXT_WA+X_HEADER-SPRASFDPOS(VIM_SPRAS_LENGTH) = SPRAS.
*  text_wa+spras_pos(vim_spras_length) = spras.
** Schlüsselfelder der Text-Tabelle
*  LOOP AT x_namtab WHERE txttabfldn &lt;&gt; space AND keyflag &lt;&gt; space.
*    text_wa+x_namtab-texttabpos(x_namtab-flength) =
*         view_wa+x_namtab-position(x_namtab-flength).
*  ENDLOOP.
*ENDFORM.                               &quot;VIM_FILL_TEXTTAB_KEY
*
*&amp;--------------------------------------------------------------------*
*&amp;      Form  VIM_FILL_VIEW_KEY                                       *
*&amp;--------------------------------------------------------------------*
* Not usable in unicode-systems!!!!
* Please use form MAP_TEXTTABKEY_TO_VIEWKEY instead!
*&amp;--------------------------------------------------------------------*
* --&gt; TEXTTAB_WA  WA of text table                                    *
* &lt;-- VIEW_KEY    KEY of view / table                                 *
* &lt;-- SPRAS                                                           *
*&amp;--------------------------------------------------------------------*
FORM vim_fill_view_key USING texttab_wa TYPE vim_line_ul
                   CHANGING view_key
                            spras LIKE t002-spras.

  LOOP AT x_namtab WHERE txttabfldn &lt;&gt; space AND keyflag &lt;&gt; space.
*   alle Schlüsselfelder, zu denen es Felder in der Texttabelle gibt
    view_key+x_namtab-position(x_namtab-flength) =
         texttab_wa+x_namtab-texttabpos(x_namtab-flength).
  ENDLOOP.
  spras = texttab_wa+x_header-sprasfdpos(vim_spras_length).
ENDFORM.                               &quot;VIM_FILL_VIEW_KEY

*---------------------------------------------------------------------*
*       FORM VIM_UPDATE_TEXTTAB                                       *
*---------------------------------------------------------------------*
* Die vom Benutzer erfaßten/geänderten Texte  werden in die interne   *
* Texttabelle &lt;VIM_TEXTTAB&gt; übernommen                                *
*---------------------------------------------------------------------*
FORM vim_update_texttab
                USING texttab_for_maint TYPE vimty_multilangu_texttab.
  DATA: textmaint_record TYPE vimty_textmaint_record,
        textmaint_field TYPE vimty_textfield,
        align TYPE f,
        texttab_wa TYPE vim_line_ul,
        search_key TYPE tabl8000,
        offset LIKE sy-fdpos,
        keylen LIKE sy-fdpos,
        extract_index LIKE sy-tabix,
        total_index   LIKE sy-tabix,
        texttab_tabix LIKE sy-tabix,
        new_entry(1)  TYPE c,
        keylen_char TYPE i,
        primkeylen type i,                                  &quot;817790
        rc LIKE sy-subrc,                                   &quot;875536
        keys_identical TYPE xfeld.
  FIELD-SYMBOLS:
        &lt;search_key&gt; TYPE x, &lt;rec_key&gt; TYPE x, &lt;curr_spras&gt; TYPE ANY,
        &lt;h_texttab_wa&gt; TYPE x,
        &lt;viewkey_in_texttab&gt; TYPE x, &quot;Key aus View/Tab in Texttab
        &lt;texttab_key&gt; TYPE x, &lt;texttab_struc&gt; TYPE ANY,
        &lt;h_texttab&gt; TYPE x, &lt;tot_fld&gt; TYPE ANY, &lt;ext_fld&gt; TYPE ANY,
        &lt;texttab_action&gt; TYPE c,
        &lt;t_action&gt;, &lt;e_action&gt;,
        &lt;search_txtkey&gt; type x.                             &quot;817790

  IF x_header-delmdtflag &lt;&gt; space AND     &quot;zeitabh. &amp; part. Fremdschl.
     x_header-ptfrkyexst  = &apos;X&apos;.          &quot;      -&gt; zeitunabh. Texttab.
    keylen = x_header-after_keyc
     - vim_datum_length * cl_abap_char_utilities=&gt;charsize.
  ELSE.
    keylen = x_header-after_keyc.
  ENDIF.
  keylen_char = keylen / cl_abap_char_utilities=&gt;charsize.
*  primkeylen = x_header-textkeylen - cl_abap_char_utilities=&gt;charsize.&quot;817790
  IF x_header-bastab EQ space.                              &quot;875536
    CLEAR keys_identical.
    PERFORM vim_comp_roottabkey USING x_header
                                      x_namtab[]
                             CHANGING keys_identical
                                      rc.
    IF keys_identical EQ space.
      primkeylen = keylen.
    ELSE.
      clear primkeylen.
      LOOP AT x_namtab WHERE keyflag = &apos;X&apos; AND
                           bastabname = x_header-roottab.
        IF x_namtab-DATATYPE NE &apos;DATS&apos;.
          primkeylen = primkeylen + x_namtab-FLENGTH.
        ENDIF.
      ENDLOOP.
    ENDIF.
  ELSE.
    primkeylen = x_header-keylen.
  ENDIF.                                                    &quot;875536

  ASSIGN: search_key(keylen) TO &lt;search_key&gt;,
          textmaint_record-keys(keylen_char) TO &lt;rec_key&gt; CASTING,
          texttab_wa TO &lt;h_texttab_wa&gt; CASTING,
          &lt;h_texttab_wa&gt;(keylen) TO &lt;viewkey_in_texttab&gt;,
          &lt;h_texttab_wa&gt;+keylen(x_header-textkeylen) TO &lt;texttab_key&gt;,
          &lt;h_texttab_wa&gt;+keylen(x_header-texttablen) TO &lt;h_texttab&gt;,
          &lt;h_texttab&gt; TO &lt;texttab_struc&gt;
           CASTING TYPE (x_header-texttab),
          COMPONENT x_header-sprasfield OF STRUCTURE &lt;texttab_struc&gt;
           TO &lt;curr_spras&gt;.
  IF keylen &lt; primkeylen.                                   &quot;875536
    ASSIGN search_key(keylen) TO &lt;search_txtkey&gt;.
  ELSE.
    ASSIGN search_key(primkeylen) TO &lt;search_txtkey&gt;.       &quot;817790
  ENDIF.

  offset = keylen + x_header-aft_txttbc.
  ASSIGN &lt;h_texttab_wa&gt;+offset(cl_abap_char_utilities=&gt;charsize)
   TO &lt;texttab_action&gt; CASTING.
  IF x_header-bastab = &apos;X&apos;.
* tab+texttab
    ASSIGN &lt;action_text&gt; TO &lt;t_action&gt;.
    ASSIGN &lt;xact_text&gt; TO &lt;e_action&gt;.
  ELSE.
    ASSIGN &lt;action&gt; TO &lt;t_action&gt;.
    ASSIGN &lt;xact&gt; TO &lt;e_action&gt;.
  ENDIF.

  LOOP AT texttab_for_maint INTO textmaint_record.
    IF textmaint_record-spras = sy-langu.
      &lt;search_key&gt; = &lt;rec_key&gt;.
      READ TABLE extract WITH KEY &lt;search_key&gt; BINARY SEARCH.
      extract_index = sy-tabix.
    ENDIF.
    CHECK textmaint_record-action = &apos;X&apos;.      &quot; Texte wurden modifiziert

    IF textmaint_record-spras = sy-langu.
*     Texte in Sy-Langu  =&gt; Update in Total und Extract
*      READ TABLE EXTRACT WITH KEY &lt;SEARCH_KEY&gt; BINARY SEARCH.
*      EXTRACT_INDEX = SY-TABIX.
      READ TABLE total WITH KEY &lt;search_key&gt; BINARY SEARCH.
      total_index = sy-tabix.
      IF x_header-bastab = &apos;X&apos;
       AND &lt;vim_xextract_text&gt; = &lt;text_initial_x&gt;.
        PERFORM map_viewkey_to_texttabkey TABLES x_namtab
                                          USING x_header
                                                sy-langu
                                                &lt;vim_xtotal&gt;
                                          CHANGING &lt;vim_xextract_text&gt;.
        PERFORM map_viewkey_to_texttabkey TABLES x_namtab
                                          USING x_header
                                                sy-langu
                                                &lt;vim_xtotal&gt;
                                          CHANGING &lt;vim_xtotal_text&gt;.
*        PERFORM vim_fill_texttab_key USING &lt;search_key&gt; sy-langu
*                                           x_header-sprasfdpos
*                                  CHANGING &lt;extract_text&gt;.
*        PERFORM vim_fill_texttab_key USING &lt;search_key&gt; sy-langu
*                                           x_header-sprasfdpos
*                                  CHANGING &lt;total_text&gt;.
        &lt;e_action&gt; = neuer_eintrag.
        &lt;t_action&gt; = neuer_eintrag.
      ELSEIF &lt;e_action&gt; = original.
        &lt;e_action&gt; = aendern.
        &lt;t_action&gt; = aendern.
*     Else.                     &quot; neuer_eintrag / aendern =&gt; ok
      ENDIF.
      LOOP AT textmaint_record-texttab INTO textmaint_field.
        READ TABLE x_namtab INDEX textmaint_field-namtab_idx.
        IF x_namtab-lowercase = space.
          TRANSLATE textmaint_field-text TO UPPER CASE.
        ENDIF.
        IF x_header-bastab = &apos;X&apos;.
* tab + texttab
          ASSIGN: COMPONENT x_namtab-viewfield OF STRUCTURE
                   &lt;vim_ext_txt_struc&gt; TO &lt;ext_fld&gt;,
                  COMPONENT x_namtab-viewfield OF STRUCTURE
                   &lt;vim_tot_txt_struc&gt; TO &lt;tot_fld&gt;.
        ELSE.
* view
          ASSIGN: COMPONENT x_namtab-viewfield OF STRUCTURE
                   &lt;vim_extract_struc&gt; TO &lt;ext_fld&gt;,
                  COMPONENT x_namtab-viewfield OF STRUCTURE
                   &lt;vim_total_struc&gt; TO &lt;tot_fld&gt;.
        ENDIF.
        &lt;tot_fld&gt; = textmaint_field-text.
        &lt;ext_fld&gt; = textmaint_field-text.
*        extract+x_namtab-position(x_namtab-flength) =
*           textmaint_field-text(x_namtab-flength).
*        total+x_namtab-position(x_namtab-flength) =
*           textmaint_field-text(x_namtab-flength).
      ENDLOOP.                         &quot;TEXTMAINT_RECORD-TEXTTAB
      MODIFY extract INDEX extract_index.
      MODIFY total INDEX total_index.

    ELSE.
* different language: Update in texttable
      CLEAR: &lt;h_texttab_wa&gt;, &lt;texttab_struc&gt;.
*      READ TABLE &lt;vim_texttab&gt; WITH KEY &lt;search_key&gt;            &quot;817790
*                               INTO texttab_wa BINARY SEARCH.   &quot;817790
      READ TABLE &lt;vim_texttab&gt; WITH KEY &lt;search_txtkey&gt;     &quot;817790
                               INTO texttab_wa BINARY SEARCH.&quot;817790

      texttab_tabix = sy-tabix.
*     IF &lt;viewkey_in_texttab&gt; = &lt;search_key&gt; AND   &quot;Text ex. in and. Spr &quot;817790
      IF keylen &lt; primkeylen.                               &quot;875536
        primkeylen = keylen.                                &quot;875536
      ENDIF.                                                &quot;875536
      IF &lt;viewkey_in_texttab&gt;(primkeylen) = &lt;search_txtkey&gt; AND&quot;817790
         &lt;curr_spras&gt; &lt; textmaint_record-spras.
        LOOP AT &lt;vim_texttab&gt; FROM texttab_tabix INTO texttab_wa.
*          IF &lt;viewkey_in_texttab&gt; &lt;&gt; &lt;search_key&gt; OR                         &quot;817790
          IF &lt;viewkey_in_texttab&gt;(primkeylen) &lt;&gt; &lt;search_txtkey&gt; OR&quot;817790
             &lt;curr_spras&gt; &gt;= textmaint_record-spras.
            texttab_tabix = sy-tabix.
            EXIT.
          ELSEIF &lt;curr_spras&gt; &lt; textmaint_record-spras.
            texttab_tabix = sy-tabix + 1.
          ENDIF.
        ENDLOOP.
      ENDIF.   &quot; &lt;next_spras&gt; &gt;= sel_langus-spras oder ex. nicht
*      IF &lt;viewkey_in_texttab&gt; &lt;&gt; &lt;search_key&gt; OR                            &quot;817790
      IF &lt;viewkey_in_texttab&gt;(primkeylen) &lt;&gt; &lt;search_txtkey&gt; OR&quot;817790
        &lt;curr_spras&gt; &lt;&gt; textmaint_record-spras.
        CLEAR: &lt;texttab_struc&gt;.
*        CLEAR texttab_wa.
        new_entry = &apos;X&apos;.
        &lt;viewkey_in_texttab&gt; = &lt;search_key&gt;.
*        texttab_wa = &lt;search_key&gt;.
        &lt;texttab_action&gt; = neuer_eintrag.
        PERFORM map_viewkey_to_texttabkey TABLES x_namtab
                                          USING x_header
                                                textmaint_record-spras
                                                &lt;viewkey_in_texttab&gt;
                                          CHANGING &lt;texttab_key&gt;.
**        PERFORM vim_fill_texttab_key
*                            USING &lt;search_key&gt; textmaint_record-spras
*                                  x_header-sprasfdpos
*                            CHANGING &lt;texttab_key&gt;.
      ELSE.
        CLEAR new_entry.
      ENDIF.
*     Text-Values übernehmen
      LOOP AT textmaint_record-texttab INTO textmaint_field.
        READ TABLE x_namtab INDEX textmaint_field-namtab_idx.
*        offset = keylen + x_namtab-texttabpos.
        IF x_namtab-lowercase = space.
          TRANSLATE textmaint_field-text TO UPPER CASE.
        ENDIF.
        IF x_header-bastab = &apos;X&apos;.&quot;HCG Custmessage 282684/02------------
* tab + texttab
          ASSIGN: COMPONENT x_namtab-viewfield OF STRUCTURE
*                   &lt;vim_ext_txt_struc&gt; TO &lt;ext_fld&gt;.
                   &lt;texttab_struc&gt; TO &lt;ext_fld&gt;. &quot;XB int.40684/02
        ELSE.
* view, basis table field name.
          ASSIGN: COMPONENT x_namtab-bastabfld OF STRUCTURE
*                   &lt;vim_extract_struc&gt; TO &lt;ext_fld&gt;.
                   &lt;texttab_struc&gt; TO &lt;ext_fld&gt;. &quot;XB int.. 40684
        ENDIF.
*        ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE
*---------      &lt;texttab_struc&gt; TO &lt;ext_fld&gt;.&quot;HCG Custmessage 282684/02
        &lt;ext_fld&gt; = textmaint_field-text.
*        texttab_wa+offset(x_namtab-flength) =
*           textmaint_field-text(x_namtab-flength).
      ENDLOOP.
      IF &lt;texttab_action&gt; = original.
        &lt;texttab_action&gt; = aendern.
      ENDIF.
      IF new_entry = &apos;X&apos;.
        INSERT texttab_wa INTO &lt;vim_texttab&gt; INDEX texttab_tabix.
      ELSE.
        MODIFY &lt;vim_texttab&gt; FROM texttab_wa INDEX texttab_tabix.
      ENDIF.

    ENDIF.                             &quot; Sy-Langu
  ENDLOOP.                             &quot; TEXTTAB_FOR_MAINT

ENDFORM.                               &quot; VIM_UPDATE_TEXTTAB

*---------------------------------------------------------------------*
*       FORM VIM_TEMP_DELIM_TEXTTAB                                   *
*---------------------------------------------------------------------*
* Abgrenzen für zeitabh. Texttabelle :                                *
*    neuen Eintrag für &lt;vim_xtotal_key&gt; für alle Sprachen in
*      Texttabelle erzeugen, bzw. -falls schon ex.- Texte darin ersetzen
*      Texte werden aus Originaleintrag ORIG_KEY übernommen
*    im Eintrag ENDDATE Texte löschen;
*      falls dieser neu ist -&gt; gesammten Eintrag löschen
*---------------------------------------------------------------------*
* &lt;vim_xtotal_key&gt; = aktuell bearb. Intervall, entstanden durch
*                    Abgrenzen
* --&gt; ENDDATE   Endedatum des neuen Intervalls
* --&gt; ORIG_KEY  altes Endedatum des aktuellen Intervalls vor Abgrenzen
*---------------------------------------------------------------------*
FORM vim_temp_delim_texttab USING value(enddate)
                                  value(orig_key) TYPE x.
  DATA: texttab_orig TYPE vim_line_ul,
        texttab_new  TYPE vim_line_ul,
        align        TYPE f,
        old_key      TYPE tabl8000,
        orig_tabix LIKE sy-tabix,
        new_tabix  LIKE sy-tabix,
        len TYPE i,
        offset TYPE i,
        langus_selected(1) TYPE c,
        curr_sptxt LIKE t002t-sptxt,
        sel_langus LIKE h_t002 OCCURS 0 WITH HEADER LINE.
  FIELD-SYMBOLS: &lt;texttab_orig_x&gt; TYPE x,
                 &lt;txttb_orig_struc&gt; TYPE ANY,
                 &lt;viewkey_in_orig&gt; TYPE x,    &quot;-&gt; texttab_orig
                 &lt;texttab_new_x&gt; TYPE x,
                 &lt;txttb_new_struc&gt; TYPE ANY,
                 &lt;viewkey_in_new&gt; TYPE x,     &quot;-&gt; texttab_new
                 &lt;spras_in_orig&gt; TYPE spras,
                 &lt;spras_in_new&gt; TYPE spras,
                 &lt;date_in_textkey_new&gt; LIKE sy-datum,
                 &lt;action_in_orig&gt;,
                 &lt;action_in_new&gt;,
                 &lt;textfields_in_new&gt; TYPE x,
                 &lt;textfields_in_orig&gt; TYPE x,
                 &lt;h_old_key&gt; TYPE x, &lt;old_key_enddate&gt; LIKE sy-datum,
                 &lt;old_keyx&gt; TYPE x, &lt;old_key_struc&gt; TYPE ANY.

  CALL FUNCTION &apos;VIEW_GET_LANGUAGES&apos;
    EXPORTING
      all_without_selection = &apos;X&apos;
    IMPORTING
      languages_selected    = langus_selected
      curr_sptxt            = curr_sptxt
    TABLES
      languages             = sel_langus.
  IF x_header-frm_tl_get NE space.
    PERFORM (x_header-frm_tl_get) IN PROGRAM (x_header-fpoolname)
                                  TABLES sel_langus.
  ELSE.
    PERFORM vim_read_texttab_for_langus TABLES sel_langus USING &apos;X&apos;.
  ENDIF.

  READ TABLE &lt;vim_texttab&gt; WITH KEY orig_key
                           BINARY SEARCH TRANSPORTING NO FIELDS.
  CHECK sy-subrc = 0.
  orig_tabix = sy-tabix.
  ASSIGN: texttab_orig TO &lt;texttab_orig_x&gt; CASTING,
          &lt;texttab_orig_x&gt;(x_header-keylen) TO &lt;viewkey_in_orig&gt;,
          &lt;texttab_orig_x&gt;+x_header-after_keyc
           TO &lt;txttb_orig_struc&gt; CASTING TYPE (x_header-texttab),
          COMPONENT x_header-sprasfield OF STRUCTURE &lt;txttb_orig_struc&gt;
           TO &lt;spras_in_orig&gt;.
  ASSIGN: texttab_new TO &lt;texttab_new_x&gt; CASTING,
          &lt;texttab_new_x&gt;(x_header-keylen) TO &lt;viewkey_in_new&gt;,
          &lt;texttab_new_x&gt;+x_header-after_keyc
           TO &lt;txttb_new_struc&gt; CASTING TYPE (x_header-texttab),
          COMPONENT x_header-sprasfield OF STRUCTURE &lt;txttb_new_struc&gt;
           TO &lt;spras_in_new&gt;.
  offset = x_header-after_keyc + x_header-textkeylen.
  len = x_header-aft_txttbc - x_header-textkeylen.
  ASSIGN: &lt;texttab_new_x&gt;+offset(len) TO &lt;textfields_in_new&gt;,
          &lt;texttab_orig_x&gt;+offset(len) TO &lt;textfields_in_orig&gt;.
  ASSIGN: old_key TO &lt;h_old_key&gt; CASTING,
          &lt;h_old_key&gt;(x_header-keylen) TO &lt;old_keyx&gt;,
          old_key TO &lt;old_key_struc&gt; CASTING TYPE (x_header-maintview).
*  ASSIGN texttab_orig(x_header-keylen) TO &lt;viewkey_in_orig&gt;.
*  ASSIGN texttab_new(x_header-keylen) TO &lt;viewkey_in_new&gt;.
*  offset = x_header-keylen + x_header-sprasfdpos.
*  ASSIGN texttab_orig+offset(vim_spras_length) TO &lt;spras_in_orig&gt;.
*  ASSIGN texttab_new+offset(vim_spras_length) TO &lt;spras_in_new&gt;.
  LOOP AT x_namtab WHERE keyflag = &apos;X&apos; AND
    ( texttabfld = &apos;X&apos; OR txttabfldn &lt;&gt; space ) AND
      domname EQ vim_delim_date_domain AND
    ( rollname IN vim_begda_types OR rollname IN vim_endda_types ).
*      offset = x_header-keylen + x_namtab-texttabpos.
*      len = x_namtab-flength.
    EXIT.
  ENDLOOP.
  ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE &lt;txttb_new_struc&gt;
   TO &lt;date_in_textkey_new&gt;.
*    ASSIGN texttab_new+offset(len) TO &lt;date_in_textkey_new&gt; TYPE &apos;D&apos;.
  offset = ( x_header-after_keyc + x_header-aft_txttbc )
           / cl_abap_char_utilities=&gt;charsize.
*  offset = x_header-keylen + x_header-texttablen.
  ASSIGN texttab_orig+offset(1) TO &lt;action_in_orig&gt;.
  ASSIGN texttab_new+offset(1) TO &lt;action_in_new&gt;.
*  ASSIGN texttab_new+offset(len) TO &lt;textfields_in_new&gt;.
*  ASSIGN texttab_orig+offset(len) TO &lt;textfields_in_orig&gt;.

  LOOP AT &lt;vim_texttab&gt; INTO texttab_orig FROM orig_tabix.
    IF &lt;viewkey_in_orig&gt; &lt;&gt; orig_key. EXIT. ENDIF.
    READ TABLE &lt;vim_texttab&gt; WITH KEY &lt;vim_xtotal_key&gt;
                     INTO texttab_new BINARY SEARCH.
    new_tabix = sy-tabix.
    IF &lt;viewkey_in_new&gt; = &lt;vim_xtotal_key&gt; AND
       &lt;spras_in_new&gt; &lt; &lt;spras_in_orig&gt;.                  &quot;#EC PORTABLE
      LOOP AT &lt;vim_texttab&gt; FROM new_tabix INTO texttab_new.
        IF &lt;viewkey_in_new&gt; &lt;&gt; &lt;vim_xtotal_key&gt; OR
           &lt;spras_in_new&gt; &gt;= &lt;spras_in_orig&gt;.             &quot;#EC PORTABLE
          new_tabix = sy-tabix.
          EXIT.
        ELSEIF &lt;spras_in_new&gt; &lt; &lt;spras_in_orig&gt;.          &quot;#EC PORTABLE
          new_tabix = sy-tabix + 1.
        ENDIF.
      ENDLOOP.
    ENDIF.
    IF &lt;viewkey_in_new&gt; &lt;&gt; &lt;vim_xtotal_key&gt; OR
       &lt;spras_in_new&gt; &lt;&gt; &lt;spras_in_orig&gt;.
*    es gibt noch keinen Eintrag mit neuem Schlüssel
      texttab_new = texttab_orig.
      &lt;viewkey_in_new&gt; = &lt;vim_xtotal_key&gt;.
      &lt;date_in_textkey_new&gt; = &lt;vim_enddate&gt;.
      &lt;action_in_new&gt; = neuer_eintrag.
      INSERT texttab_new INTO &lt;vim_texttab&gt; INDEX new_tabix.
    ELSE.
      IF &lt;action_in_new&gt; = original.
        &lt;action_in_new&gt; = aendern.
      ENDIF.
      &lt;textfields_in_new&gt; = &lt;textfields_in_orig&gt;.
      MODIFY &lt;vim_texttab&gt; FROM texttab_new INDEX new_tabix.
    ENDIF.
  ENDLOOP.

* Text in neuen Eintrag löschen
  &lt;old_keyx&gt; = &lt;vim_xtotal_key&gt;.
*  ASSIGN old_key(x_header-keylen) TO &lt;old_key&gt;.
  LOOP AT x_namtab WHERE keyflag = &apos;X&apos; AND
    ( texttabfld = &apos;X&apos; OR txttabfldn &lt;&gt; space ) AND
    domname EQ vim_delim_date_domain AND
    ( rollname IN vim_begda_types OR rollname IN vim_endda_types ).
    EXIT.
  ENDLOOP.
  ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE &lt;old_key_struc&gt;
   TO &lt;old_key_enddate&gt;.
  &lt;old_key_enddate&gt; = enddate.
*  old_key+x_namtab-position(x_namtab-flength) = enddate.
  READ TABLE &lt;vim_texttab&gt; WITH KEY &lt;old_keyx&gt;
                           BINARY SEARCH TRANSPORTING NO FIELDS.
*  READ TABLE &lt;vim_texttab&gt; WITH KEY &lt;old_key&gt;
*                           BINARY SEARCH TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    LOOP AT &lt;vim_texttab&gt; INTO texttab_orig FROM sy-tabix.
      IF &lt;viewkey_in_orig&gt; &lt;&gt; &lt;old_keyx&gt;. EXIT. ENDIF.
      IF &lt;action_in_orig&gt; = neuer_eintrag.
        DELETE &lt;vim_texttab&gt;.
      ELSE.
        CLEAR &lt;textfields_in_orig&gt;.
        IF &lt;action_in_orig&gt; = original.
          &lt;action_in_orig&gt; = aendern.
        ENDIF.
        MODIFY &lt;vim_texttab&gt; FROM texttab_orig.
      ENDIF.
    ENDLOOP.
  ENDIF.
  MODIFY vim_texttab_container INDEX vim_texttab_container_index.
ENDFORM.                               &quot; VIM_TEMP_DELIM_TEXTTAB

*---------------------------------------------------------------------*
*       FORM VIM_CHECK_UPD_TEXTTAB                                    *
*---------------------------------------------------------------------*
* Setzen von &lt;STATUS&gt;-UPD_FLAG, falls Änderungen in Texttabelle       *
*---------------------------------------------------------------------*
FORM vim_check_upd_texttab.
  DATA: texttab_wa TYPE vim_line_ul,
        offset TYPE i.
  FIELD-SYMBOLS: &lt;texttab_action&gt;.

  IF x_header-delmdtflag &lt;&gt; space AND  &quot;zeitabh. &amp; part. Fremdschl.
     x_header-ptfrkyexst  = &apos;X&apos;.       &quot;      -&gt; zeitunabh. Texttab.
    offset = x_header-after_keyc
     - vim_datum_length * cl_abap_char_utilities=&gt;charsize.
  ELSE.
    offset = x_header-after_keyc.
  ENDIF.
  offset = ( offset + x_header-aft_txttbc )
           / cl_abap_char_utilities=&gt;charsize.
  ASSIGN texttab_wa+offset(1) TO &lt;texttab_action&gt;.
  LOOP AT &lt;vim_texttab&gt; INTO texttab_wa.
    CHECK &lt;texttab_action&gt; &lt;&gt; original.
    MOVE &apos;X&apos; TO &lt;status&gt;-upd_flag.
    EXIT.
  ENDLOOP.

ENDFORM.                               &quot;VIM_CHECK_UPD_TEXTTAB

*---------------------------------------------------------------------*
*       FORM VIM_SET_TEXTTAB_ACTION_DELETE                            *
*---------------------------------------------------------------------*
* Für alle als &apos;GELOESCHT&apos; gekennzeichneten Einträge in TOTAL         *
* entsprechende Einträge in der Texttabelle als &apos;GELOESCHT&apos; kennz.    *
*---------------------------------------------------------------------*
FORM vim_set_texttab_action_delete.
  DATA: texttab_tabix LIKE sy-tabix,
        offset TYPE i,
        texttab_wa TYPE vim_line_ul.
  FIELD-SYMBOLS: &lt;h_texttab_wa&gt; TYPE x,
                 &lt;texttab_action&gt; TYPE char01,
                 &lt;viewkey_in_texttab&gt; TYPE x,
                 &lt;total_key&gt; TYPE x.

  IF x_header-delmdtflag &lt;&gt; space AND  &quot;zeitabh. &amp; part. Fremdschl.
     x_header-ptfrkyexst  = &apos;X&apos;.       &quot;      -&gt; zeitunabh. Texttab.
    offset = x_header-after_keyc
             - vim_datum_length * cl_abap_char_utilities=&gt;charsize.
    ASSIGN &lt;vim_tot_mkey_beforex&gt; TO &lt;total_key&gt;.
  ELSE.
    offset = x_header-after_keyc.
    ASSIGN &lt;vim_xtotal_key&gt; TO &lt;total_key&gt;.
  ENDIF.
  ASSIGN: texttab_wa TO &lt;h_texttab_wa&gt; CASTING,
          &lt;h_texttab_wa&gt;(offset) TO &lt;viewkey_in_texttab&gt;.
  offset = ( offset + x_header-aft_txttbc )
           / cl_abap_char_utilities=&gt;charsize.
  ASSIGN texttab_wa+offset(1) TO &lt;texttab_action&gt;.

* Text-Einträge werden nur in dieser Routine, also in PREPARE_SAVING,
* als gelöscht gekennzeichnet, und nach dem eigentlichen Sichern,
* in AFTER_SAVING, aus der internen Texttabelle gelöscht.
* Hier sollten daher keine Einträge als gelöscht gekennzeichnet sein,
* außer wenn im User_exit vor dem Sichern das Sichern abgebrochen wurde.
  LOOP AT &lt;vim_texttab&gt; INTO texttab_wa.
    CHECK &lt;texttab_action&gt; = geloescht OR
          &lt;texttab_action&gt; = update_geloescht OR
          &lt;texttab_action&gt; = neuer_geloescht.
    TRANSLATE &lt;texttab_action&gt; USING &apos;D XNYU&apos;.
    MODIFY &lt;vim_texttab&gt; FROM texttab_wa.
  ENDLOOP.

  LOOP AT total.
    CHECK &lt;action&gt; = update_geloescht OR
          &lt;action&gt; = geloescht OR
          &lt;action&gt; = neuer_geloescht.
    READ TABLE &lt;vim_texttab&gt; WITH KEY &lt;total_key&gt;
                               BINARY SEARCH TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      texttab_tabix = sy-tabix.
      LOOP AT &lt;vim_texttab&gt; FROM texttab_tabix INTO texttab_wa.
        IF &lt;viewkey_in_texttab&gt; &lt;&gt; &lt;total_key&gt;.
          EXIT.
        ENDIF.
        TRANSLATE &lt;texttab_action&gt; USING &apos; DNXUY&apos;.
        MODIFY &lt;vim_texttab&gt; FROM texttab_wa.
      ENDLOOP.
    ENDIF.
  ENDLOOP.
ENDFORM.                               &quot;VIM_SET_TEXTTAB_ACTION_DELETE

*---------------------------------------------------------------------*
*    VIM_TEXTTAB_MODIF_FOR_KEY
*---------------------------------------------------------------------*
* &lt;-- MODIF       &apos;X&apos; -&gt; es gibt mind. einen modifizierten Eintrag
*                        in anderer Sprache
*---------------------------------------------------------------------*
* aktueller Eintrag steht in Kopfzeile von EXTRACT
*---------------------------------------------------------------------*
FORM vim_texttab_modif_for_key CHANGING modif.
  DATA: texttab_wa TYPE vim_line_ul,
        texttab_tabix LIKE sy-tabix,
        keylen TYPE i,
        offset TYPE i.
  FIELD-SYMBOLS: &lt;h_texttab_wa&gt; TYPE x,
                 &lt;texttab_action&gt; TYPE xfeld,
                 &lt;viewkey_in_texttab&gt; TYPE x,
                 &lt;extract_key&gt; TYPE x.

  IF x_header-delmdtflag &lt;&gt; space AND  &quot;zeitabh. &amp; part. Fremdschl.
     x_header-ptfrkyexst  = &apos;X&apos;.       &quot;      -&gt; zeitunabh. Texttab.
    ASSIGN &lt;vim_ext_mkey_beforex&gt; TO &lt;extract_key&gt;.
    keylen = x_header-after_keyc
     - vim_datum_length * cl_abap_char_utilities=&gt;charsize.
  ELSE.
    ASSIGN &lt;vim_xextract_key&gt; TO &lt;extract_key&gt;.
    keylen = x_header-after_keyc.
  ENDIF.

  CLEAR modif.
  READ TABLE &lt;vim_texttab&gt; WITH KEY &lt;vim_xextract_key&gt;
                           BINARY SEARCH TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    texttab_tabix = sy-tabix.
  ELSE.
    EXIT.     &quot;keine Texte zum Key in anderen Sprachen erfaßt
  ENDIF.

  ASSIGN: texttab_wa TO &lt;h_texttab_wa&gt; CASTING,
          &lt;h_texttab_wa&gt;(keylen) TO &lt;viewkey_in_texttab&gt;.
  offset = ( keylen + x_header-aft_txttbc )
           / cl_abap_char_utilities=&gt;charsize.
  ASSIGN texttab_wa+offset(1) TO &lt;texttab_action&gt;.
  LOOP AT &lt;vim_texttab&gt; FROM texttab_tabix INTO texttab_wa.
    IF &lt;viewkey_in_texttab&gt; &lt;&gt; &lt;extract_key&gt;.
      EXIT.
    ELSEIF &lt;texttab_action&gt; &lt;&gt; original.
      modif = &apos;X&apos;.
      EXIT.
    ENDIF.
  ENDLOOP.
ENDFORM.                               &quot;VIM_TEXTTAB_MODIF_FOR_KEY

*---------------------------------------------------------------------*
*       FORM VIM_TEXT_KEYTAB_ENTRIES
*---------------------------------------------------------------------*
* Korrektureinträge für Texttabellenänderungen
* UF170200 Dump DATA_LENGTH_TOO_LARGE: Keylen not changed anymore in
* header line of X_HEADER but received in CORR_UPD and added to
* interface (P_KEYLEN).
*---------------------------------------------------------------------*
FORM vim_text_keytab_entries USING value(vake_action) TYPE c
                                   vake_rc TYPE i
                                   value(p_keylen) TYPE syfleng
                                   value(p_txtkeylen) TYPE syfleng.
  DATA: rc1 LIKE sy-subrc,
        offset TYPE i,
        texttab_wa TYPE vim_line_ul,
        max_trsp_keylength_in_byte TYPE i,
        text_keylen TYPE i.                                 &quot; MN 904720
  FIELD-SYMBOLS: &lt;h_texttab_wa&gt; TYPE x,
                 &lt;texttab_action&gt; TYPE c, &lt;texttab_key&gt; TYPE x,
                 &lt;x_header2&gt; TYPE vimdesc.                  &quot;#EC *

  text_keylen = x_header-keylen.                            &quot;MN 904720
  IF x_header-delmdtflag &lt;&gt; space AND  &quot;zeitabh. &amp; part. Fremdschl.
     x_header-ptfrkyexst  = &apos;X&apos;.       &quot;      -&gt; zeitunabh. Texttab.
    p_keylen = p_keylen
     - vim_datum_length * cl_abap_char_utilities=&gt;charsize. &quot;UF170200
    text_keylen = x_header-keylen
      - vim_datum_length * cl_abap_char_utilities=&gt;charsize.&quot;MN 904720
  ENDIF.
*  ASSIGN: texttab_wa TO &lt;h_texttab_wa&gt; CASTING,
*          &lt;h_texttab_wa&gt;+x_header-keylen(x_header-textkeylen) TO &lt;texttab_key&gt;.
  ASSIGN: texttab_wa TO &lt;h_texttab_wa&gt; CASTING,
          &lt;h_texttab_wa&gt;+text_keylen(x_header-textkeylen) TO &lt;texttab_key&gt;.&quot; MN 904720
  max_trsp_keylength_in_byte = vim_max_trsp_keylength
   * cl_abap_char_utilities=&gt;charsize.
  IF x_header-keylen GT max_trsp_keylength_in_byte.
*       &quot;HCG                  same as in corr_upd -&gt; p_keylen unchanged
  ELSE.                     &quot;HCG if keylen not an even number char must
    p_keylen = x_header-after_keyc.  &quot;begin on even memory adress in UC
  ENDIF.           &quot;e.g. int1 in key -&gt; keylen = 2n+1 aft_keyc = 2n+1+1
  offset = x_header-after_keyc + x_header-aft_txttbc.       &quot;IG 924398
  IF x_header-delmdtflag &lt;&gt; space AND  &quot;zeitabh. &amp; part. Fremdschl.
     x_header-ptfrkyexst  = &apos;X&apos;.       &quot;      -&gt; zeitunabh. Texttab.
    offset = offset
     - vim_datum_length * cl_abap_char_utilities=&gt;charsize. &quot;HCG774471
  ENDIF.
  ASSIGN &lt;h_texttab_wa&gt;+offset(cl_abap_char_utilities=&gt;charsize)
          TO &lt;texttab_action&gt; CASTING.

  corr_keytab =  e071k.
  corr_keytab-objname = x_header-texttab.

  vake_rc = 8.
  LOOP AT &lt;vim_texttab&gt; INTO texttab_wa.
    CHECK &lt;texttab_action&gt; &lt;&gt; original AND
          &lt;texttab_action&gt; &lt;&gt; neuer_geloescht.
    MOVE &lt;texttab_key&gt; TO &lt;vim_corr_keyx&gt;(p_txtkeylen).
*    MOVE &lt;texttab_key&gt; TO corr_keytab-tabkey(p_txtkeylen).
    PERFORM update_corr_keytab USING vake_action rc1.
    IF rc1 = 0.
      CLEAR vake_rc.
    ELSE.
      IF vake_action EQ pruefen. vake_rc = 8. EXIT. ENDIF.
    ENDIF.
  ENDLOOP.
ENDFORM.                               &quot;VIM_TEXT_KEYTAB_ENTRIES

*---------------------------------------------------------------------*
*       FORM VIM_TEXT_KEYTAB_ENTRY
*---------------------------------------------------------------------*
* Korrektureintrag für Entry in allen vorhandenen Sprachen
*---------------------------------------------------------------------*
FORM vim_text_keytab_entry USING value(viewkey) TYPE x
                                 value(vake_action) TYPE c
                                 vake_rc TYPE i.
  DATA: rc1 LIKE sy-subrc,
        sys_type(10) TYPE c,
        keylen TYPE i,
        offset TYPE i,
        tbx LIKE sy-tabix,
        align TYPE f,
        texttab_wa TYPE vim_line_ul,
        key_wa TYPE vim_line_ul,
        wheretab LIKE vimwheretb OCCURS 0 WITH HEADER LINE,
        tmp_sellist LIKE vimsellist OCCURS 0 WITH HEADER LINE,
        tmp_texttab TYPE REF TO data, w_tmp_texttab TYPE REF TO data.
  FIELD-SYMBOLS: &lt;tmp_texttab&gt; TYPE STANDARD TABLE,
                 &lt;texttab_wax&gt; TYPE x,
                 &lt;texttab_x&gt; TYPE x, &lt;texttab_struc&gt; TYPE ANY,
                 &lt;texttab_key&gt; TYPE x, &lt;texttab_action&gt; TYPE c,
                 &lt;keyvalue&gt; TYPE ANY, &lt;lang&gt; TYPE spras,
                 &lt;viewkey_in_texttab&gt;, &lt;viewkey&gt; TYPE x.

  vake_rc = 8.
  corr_keytab =  e071k.
  corr_keytab-objname = x_header-texttab.

  IF x_header-generictrp &lt;&gt; space OR x_header-genertxtrp &lt;&gt; space.
    keylen = x_header-maxtrkeyln.
  ELSE.
    keylen = x_header-keylen.
  ENDIF.
  CALL &apos;C_SAPGPARAM&apos; ID &apos;NAME&apos;  FIELD &apos;transport/systemtype&apos;
                     ID &apos;VALUE&apos; FIELD sys_type.

  ASSIGN: viewkey(keylen) TO &lt;viewkey&gt; CASTING.
  IF vim_texttab_container-all_langus = &apos;X&apos;.
* texts have already been read
    ASSIGN: texttab_wa TO &lt;texttab_wax&gt; CASTING,
            &lt;texttab_wax&gt;+keylen(x_header-texttablen) TO &lt;texttab_x&gt;,
            &lt;texttab_x&gt;(x_header-textkeylen) TO &lt;texttab_key&gt;,
            &lt;texttab_x&gt; TO &lt;texttab_struc&gt;
             CASTING TYPE (x_header-texttab),
            COMPONENT x_header-sprasfield OF STRUCTURE
             &lt;texttab_struc&gt; TO &lt;lang&gt;.
    IF x_header-delmdtflag &lt;&gt; space AND&quot;zeitabh. &amp; part. Fremdschl.
       x_header-ptfrkyexst  = &apos;X&apos;.     &quot;      -&gt; zeitunabh. Texttab.
      keylen = keylen
                - vim_datum_length * cl_abap_char_utilities=&gt;charsize.
    ENDIF.
    ASSIGN &lt;texttab_wax&gt;(keylen) TO &lt;viewkey_in_texttab&gt;.
    offset = keylen + x_header-aft_txttbc.
    ASSIGN &lt;texttab_wax&gt;+offset(cl_abap_char_utilities=&gt;charsize)
     TO &lt;texttab_action&gt; CASTING.

    READ TABLE &lt;vim_texttab&gt; WITH KEY &lt;viewkey&gt;
             BINARY SEARCH TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      LOOP AT &lt;vim_texttab&gt; INTO texttab_wa FROM sy-tabix.
        CHECK &lt;texttab_action&gt; &lt;&gt; neuer_eintrag.
        IF &lt;viewkey_in_texttab&gt; &lt;&gt; &lt;viewkey&gt;. EXIT. ENDIF.
        MOVE &lt;texttab_key&gt; TO &lt;vim_corr_keyx&gt;(x_header-textkeylen).
*        WRITE &lt;texttab_key&gt; TO corr_keytab-tabkey(x_header-textkeylen).
        PERFORM update_corr_keytab USING vake_action rc1.
        IF rc1 = 0.
          CLEAR vake_rc.
        ELSE.
          IF vake_action EQ pruefen. vake_rc = 8. EXIT. ENDIF.
        ENDIF.
      ENDLOOP.
    ELSE.
      CLEAR vake_rc.
    ENDIF.
  ELSE.
* Texte direkt von DB lesen
    REFRESH wheretab.
    tmp_sellist-operator = &apos;EQ&apos;.
    tmp_sellist-and_or = &apos;AND&apos;.
    MOVE &lt;viewkey&gt; TO &lt;f1_wax&gt;.
    LOOP AT x_namtab WHERE keyflag NE space    &quot;fill sellist for
                       AND txttabfldn &lt;&gt; space.             &quot;texttab
      tmp_sellist-tabix = sy-tabix.
*      ASSIGN viewkey+x_namtab-position(x_namtab-flength) TO &lt;keyvalue&gt;.
*      ASSIGN COMPONENT x_namtab-viewfield
*       OF STRUCTURE &lt;table1_wa&gt; TO &lt;keyvalue&gt;.
* XB 11062002, int2023251/03. choos the right key into texttabkey.
      ASSIGN COMPONENT x_namtab-viewfield
       OF STRUCTURE &lt;table1&gt; TO &lt;keyvalue&gt;.           &quot; XB H631231
      tmp_sellist-viewfield = x_namtab-txttabfldn.
      IF x_namtab-inttype = &apos;C&apos; AND x_namtab-convexit = space.
        tmp_sellist-value = &lt;keyvalue&gt;.
      ELSE.
        CALL FUNCTION &apos;VIEW_CONVERSION_OUTPUT&apos;
          EXPORTING
            value_intern = &lt;keyvalue&gt;
            tabname      = x_header-maintview
            fieldname    = x_namtab-viewfield
            inttype      = x_namtab-inttype
            datatype     = x_namtab-datatype
            decimals     = x_namtab-decimals
            convexit     = x_namtab-convexit
            sign         = x_namtab-sign
            outputlen    = x_namtab-outputlen
            intlen       = x_namtab-flength
          IMPORTING
            value_extern = tmp_sellist-value
          EXCEPTIONS
            OTHERS       = 1.
      ENDIF.
      APPEND tmp_sellist.
      tbx   = sy-tabix.
    ENDLOOP.
    IF tbx &gt; 0.
      CLEAR tmp_sellist-and_or.
      MODIFY tmp_sellist INDEX tbx.
      CALL FUNCTION &apos;VIEW_FILL_WHERETAB&apos;
        EXPORTING
          tablename               = x_header-texttab
          only_cnds_for_keyflds   = &apos;X&apos;
          is_texttable            = &apos;X&apos;
        TABLES
          sellist                 = tmp_sellist
          wheretab                = wheretab
          x_namtab                = x_namtab
        EXCEPTIONS
          no_conditions_for_table = 01.
      CREATE DATA tmp_texttab TYPE STANDARD TABLE OF (x_header-texttab).
      CREATE DATA w_tmp_texttab TYPE (x_header-texttab).
      ASSIGN: tmp_texttab-&gt;* TO &lt;tmp_texttab&gt;,
              w_tmp_texttab-&gt;* TO &lt;texttab_struc&gt;,
              &lt;texttab_struc&gt; TO &lt;texttab_wax&gt; CASTING,
              &lt;texttab_wax&gt;(x_header-textkeylen) TO &lt;texttab_key&gt;,
              COMPONENT x_header-sprasfield OF STRUCTURE
               &lt;texttab_struc&gt; TO &lt;lang&gt;.
      SELECT * FROM (x_header-texttab) INTO TABLE &lt;tmp_texttab&gt;
                                      WHERE (wheretab).
      IF sy-subrc = 0.
*        ASSIGN texttab_wa(x_header-textkeylen) TO &lt;texttab_key&gt;.
        LOOP AT &lt;tmp_texttab&gt; INTO &lt;texttab_struc&gt;.
*          MOVE &lt;texttab_key&gt; TO &lt;vim_corr_keyx&gt;(x_header-textkeylen).
* txttabkeyLen &gt; 120, use x_hader-maxtrtxkln.
* XB H631231B
          IF x_header-textkeylen &gt; x_header-maxtrtxkln
            AND x_header-maxtrtxkln &lt;&gt; 0.
            MOVE &lt;texttab_key&gt; TO &lt;vim_corr_keyx&gt;(x_header-maxtrtxkln).
          ELSE.
            MOVE &lt;texttab_key&gt; TO &lt;vim_corr_keyx&gt;(x_header-textkeylen).
          ENDIF.
* XB H631231E
          PERFORM update_corr_keytab USING vake_action rc1.
          IF rc1 = 0.
            CLEAR vake_rc.
          ELSE.
            IF vake_action EQ pruefen. vake_rc = 8. EXIT. ENDIF.
          ENDIF.
        ENDLOOP.
      ELSE.
        CLEAR vake_rc.
      ENDIF.
    ENDIF.
  ENDIF.

ENDFORM.                               &quot;VIM_TEXT_KEYTAB_ENTRY

* &quot;SW Textcopy
*---------------------------------------------------------------------*
*       FORM VIM_COPY_TEXTTAB_ENTRY                                   *
*---------------------------------------------------------------------*
* Kopieren für Texttabelle :                                          *
*    neuen Eintrag für NEW_KEY für alle Sprachen in Texttabelle erzeugen
*       ?? bzw. -falls schon ex.- Texte darin ersetzen ??
*    Texte werden aus Originaleintrag ORIG_KEY übernommen
*---------------------------------------------------------------------*
* --&gt; NEW_KEY   Schlüssel des neuen Eintrags
* --&gt; ORIG_KEY  Schlüssel des zu kopierenden Eintrags
*---------------------------------------------------------------------*
FORM vim_copy_texttab_entry USING value(new_key) TYPE x
                                  value(orig_key) TYPE x.
  DATA: texttab_orig TYPE vim_line_ul,
        texttab_new  TYPE vim_line_ul,
        orig_tabix LIKE sy-tabix,
        new_tabix  LIKE sy-tabix,
        len TYPE i,
        offset TYPE i,
        langus_selected(1) TYPE c,
        curr_sptxt LIKE t002t-sptxt,
        sel_langus LIKE h_t002 OCCURS 0 WITH HEADER LINE.
  FIELD-SYMBOLS: &lt;texttab_orig_x&gt; TYPE x,
                 &lt;h_texttab_orig_x&gt; TYPE x,
                 &lt;txttb_orig_struc&gt; TYPE ANY,
                 &lt;viewkey_in_orig&gt; TYPE x,    &quot;-&gt; texttab_orig
                 &lt;texttab_new_x&gt; TYPE x,
                 &lt;h_texttab_new_x&gt; TYPE x,
                 &lt;txttb_new_struc&gt; TYPE ANY,
                 &lt;viewkey_in_new&gt; TYPE x,     &quot;-&gt; texttab_new
                 &lt;spras_in_orig&gt; TYPE spras,
                 &lt;spras_in_new&gt; TYPE spras,
                 &lt;action_in_orig&gt;,
                 &lt;action_in_new&gt;,
                 &lt;textfields_in_new&gt; TYPE x,
                 &lt;textfields_in_orig&gt; TYPE x,
                 &lt;textkey_in_new&gt; TYPE x.

  CALL FUNCTION &apos;VIEW_GET_LANGUAGES&apos;
    EXPORTING
      all_without_selection = &apos;X&apos;
    IMPORTING
      languages_selected    = langus_selected
      curr_sptxt            = curr_sptxt
    TABLES
      languages             = sel_langus.
  IF x_header-frm_tl_get NE space.
    PERFORM (x_header-frm_tl_get) IN PROGRAM (x_header-fpoolname)
                                  TABLES sel_langus.
  ELSE.
    PERFORM vim_read_texttab_for_langus TABLES sel_langus USING &apos;X&apos;.
  ENDIF.

  READ TABLE &lt;vim_texttab&gt; WITH KEY orig_key
                           BINARY SEARCH TRANSPORTING NO FIELDS.
  CHECK sy-subrc = 0.
  orig_tabix = sy-tabix.
  ASSIGN: texttab_orig TO &lt;texttab_orig_x&gt; CASTING,
          &lt;texttab_orig_x&gt;(x_header-keylen) TO &lt;viewkey_in_orig&gt;,
          &lt;texttab_orig_x&gt;+x_header-after_keyc(x_header-texttablen)
           TO &lt;h_texttab_orig_x&gt;,
          &lt;h_texttab_orig_x&gt;
           TO &lt;txttb_orig_struc&gt; CASTING TYPE (x_header-texttab),
          COMPONENT x_header-sprasfield OF STRUCTURE &lt;txttb_orig_struc&gt;
           TO &lt;spras_in_orig&gt;.
  ASSIGN: texttab_new TO &lt;texttab_new_x&gt; CASTING,
          &lt;texttab_new_x&gt;(x_header-keylen) TO &lt;viewkey_in_new&gt;,
          &lt;texttab_new_x&gt;+x_header-after_keyc(x_header-textkeylen)
           TO &lt;textkey_in_new&gt;,
          &lt;texttab_new_x&gt;+x_header-after_keyc(x_header-texttablen)
           TO &lt;h_texttab_new_x&gt;,
          &lt;h_texttab_new_x&gt;
           TO &lt;txttb_new_struc&gt; CASTING TYPE (x_header-texttab),
          COMPONENT x_header-sprasfield OF STRUCTURE &lt;txttb_new_struc&gt;
           TO &lt;spras_in_new&gt;.
  offset = x_header-after_keyc + x_header-textkeylen.
  len = x_header-aft_txttbc - x_header-textkeylen.
  ASSIGN: &lt;texttab_new_x&gt;+offset(len) TO &lt;textfields_in_new&gt;,
          &lt;texttab_orig_x&gt;+offset(len) TO &lt;textfields_in_orig&gt;.
  offset = ( x_header-after_keyc + x_header-aft_txttbc )
           / cl_abap_char_utilities=&gt;charsize.
  ASSIGN texttab_orig+offset(1) TO &lt;action_in_orig&gt;.
  ASSIGN texttab_new+offset(1) TO &lt;action_in_new&gt;.
*  ASSIGN texttab_orig(x_header-keylen) TO &lt;viewkey_in_orig&gt;.
*  ASSIGN texttab_new(x_header-keylen) TO &lt;viewkey_in_new&gt;.
*  ASSIGN texttab_new+x_header-keylen(x_header-textkeylen)
*                                       TO &lt;textkey_in_new&gt;.
*  offset = x_header-keylen + x_header-sprasfdpos.
*  ASSIGN texttab_orig+offset(vim_spras_length) TO &lt;spras_in_orig&gt;.
*  ASSIGN texttab_new+offset(vim_spras_length) TO &lt;spras_in_new&gt;.
*  offset = x_header-keylen + x_header-texttablen.
*  ASSIGN texttab_new+offset(1) TO &lt;action_in_new&gt;.
*  offset = x_header-keylen + x_header-textkeylen.
*  len = x_header-texttablen - x_header-textkeylen.
*  ASSIGN texttab_new+offset(len) TO &lt;textfields_in_new&gt;.
*  ASSIGN texttab_orig+offset(len) TO &lt;textfields_in_orig&gt;.

  LOOP AT &lt;vim_texttab&gt; INTO texttab_orig FROM orig_tabix.
    IF &lt;viewkey_in_orig&gt; &lt;&gt; orig_key. EXIT. ENDIF.
    READ TABLE &lt;vim_texttab&gt; WITH KEY new_key
                     INTO texttab_new BINARY SEARCH.
    new_tabix = sy-tabix.
    IF &lt;viewkey_in_new&gt; = new_key AND
       &lt;spras_in_new&gt; &lt; &lt;spras_in_orig&gt;.                  &quot;#EC PORTABLE
      LOOP AT &lt;vim_texttab&gt; FROM new_tabix INTO texttab_new.
        IF &lt;viewkey_in_new&gt; &lt;&gt; new_key OR                 &quot;#EC PORTABLE
           &lt;spras_in_new&gt; &gt;= &lt;spras_in_orig&gt;.
          new_tabix = sy-tabix.
          EXIT.
        ELSEIF &lt;spras_in_new&gt; &lt; &lt;spras_in_orig&gt;.          &quot;#EC PORTABLE
          new_tabix = sy-tabix + 1.
        ENDIF.
      ENDLOOP.
    ENDIF.
    IF &lt;viewkey_in_new&gt; &lt;&gt; new_key OR
       &lt;spras_in_new&gt; &lt;&gt; &lt;spras_in_orig&gt;.
*    es gibt noch keinen Eintrag mit neuem Schlüssel
      texttab_new = texttab_orig.
      &lt;viewkey_in_new&gt; = new_key.
      PERFORM map_viewkey_to_texttabkey TABLES x_namtab
                                        USING x_header
                                              &lt;spras_in_orig&gt;
                                              new_key
                                        CHANGING &lt;textkey_in_new&gt;.
*      PERFORM vim_fill_texttab_key USING new_key
*                          &lt;spras_in_orig&gt; x_header-sprasfdpos
*                                   CHANGING &lt;textkey_in_new&gt;.
      &lt;action_in_new&gt; = neuer_eintrag.
      INSERT texttab_new INTO &lt;vim_texttab&gt; INDEX new_tabix.
    ELSE.
      IF &lt;action_in_new&gt; = original.
        &lt;action_in_new&gt; = aendern.
      ENDIF.
      &lt;textfields_in_new&gt; = &lt;textfields_in_orig&gt;.
      MODIFY &lt;vim_texttab&gt; FROM texttab_new INDEX new_tabix.
    ENDIF.
  ENDLOOP.
  MODIFY vim_texttab_container INDEX vim_texttab_container_index.
ENDFORM.                               &quot; VIM_COPY_TEXTTAB_ENTRY</include_source>
   </include>
   <include NAME="LSVIMFXP" VARCL="X" SUBC="I" APPL="S" CNAM="SAP" CDAT="19980603" UNAM="SAP" UDAT="20080721" VERN="000026" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122443" IDATE="20080721" ITIME="122443">
    <include_source>*----------------------------------------------------------------------*
*   INCLUDE LSVIMFXP  form routines to activate profiles               *
*----------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp;      Form  GET_PROFILES
*&amp;---------------------------------------------------------------------*
*  NOT IN USE ANYMOREW BUT STILL CALLED IN APPLICATION FUNCTION GROUPS
*       Get customizing profiles using Function
*       SCPR_SHOW_CUT_OF_VIEW
*----------------------------------------------------------------------*
*  &lt;--  p_selected  Flag X: Profil wurde bereits ausgewählt und
*                           importiert ==&gt; nur anzeigen
*----------------------------------------------------------------------*
FORM get_profiles USING p_selected TYPE c.

*  DATA: cobj_type VALUE &apos;V&apos;.           &quot;customizing-objecttype
*
*  IF x_header-bastab NE space.               &quot;HCG FuBa gelöscht zu 700
*    cobj_type = vim_tabl.
*  ENDIF.
*  CLEAR vim_pr_activating.
*  CALL FUNCTION &apos;SCPR_SHOW_OUT_OF_VIEW&apos;
*    EXPORTING
*      tabname            = x_header-viewname
*      tabtype            = cobj_type
*      preselection       = p_selected
*      cluster            = vim_called_by_cluster
*    TABLES
*      header             = x_header
*      namtab             = x_namtab
*      sellist            = &lt;vim_ck_sellist&gt;
*    EXCEPTIONS
*      user_abort         = 1
*      no_profile_found   = 2
*      profile_dont_exist = 3
*      no_data            = 4
*      OTHERS             = 5.
*  CASE sy-subrc.
*    WHEN 2.
*      MESSAGE s820(sv).
**   Kein Profil gefunden.
*    WHEN 3.
*      IF cobj_type = &apos;S&apos;.
*        MESSAGE s822(sv) WITH x_header-viewname.
**   Zur Tabelle &amp; existiert kein Profil.
*      ELSE.
*        MESSAGE s821(sv) WITH x_header-viewname.
**   Zur View &amp; existiert kein Profil.
*      ENDIF.
*  ENDCASE.
ENDFORM.                               &quot; GET_PROFILES
*&amp;---------------------------------------------------------------------*
*&amp;      Form  IMPORT_PROFILE
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*----------------------------------------------------------------------*
FORM import_profile USING actopts TYPE scpractopt.

  DATA:          ext_field(1000),
                 pr_field(1000),
                 next,
                 i TYPE i VALUE 1,
                 extr_lin TYPE i,
                 len_text TYPE i, profile_used,
                 imported_to_all VALUE &apos;X&apos;.
  FIELD-SYMBOLS: &lt;pr_field&gt;, &lt;bc_total_key&gt;,                &quot;#EC *
                 &lt;bc_total&gt;, &lt;bc_total_action&gt;, &lt;bc_total_mark&gt;,&quot;#EC *
                 &lt;w_record&gt; TYPE vim_pr_tab_type.

  len_text = x_header-texttablen - x_header-textkeylen.
  CASE status-action.
    WHEN aendern.
* import in update mode
      IF status-mode = list_bild.
* import in list screen
        LOOP AT vim_pr_tab ASSIGNING &lt;w_record&gt;.
          IF &lt;w_record&gt;-action = aendern.
* update existing entry
            LOOP AT extract.
              CHECK &lt;w_record&gt;-keys = &lt;vim_xextract_key&gt;.
              PERFORM bcset_force_into_entry USING    &lt;w_record&gt;
                                                      aendern actopts.
              MODIFY extract.
              EXIT.
            ENDLOOP.
          ELSE.
* new entry
            MOVE &lt;initial_x&gt; TO &lt;vim_xextract&gt;.
            &lt;vim_xextract_key&gt; = &lt;w_record&gt;-keys.
            PERFORM bcset_force_into_entry USING    &lt;w_record&gt;
                                                  neuer_eintrag actopts.
            APPEND extract.
            ADD 1 TO maxlines.
          ENDIF.
        ENDLOOP.
        SORT extract BY &lt;vim_xextract_key&gt;.
      ELSE.
* import in detail mode
        LOOP AT vim_pr_tab ASSIGNING &lt;w_record&gt; WHERE
         action = neuer_eintrag.
          MOVE &lt;initial_x&gt; TO &lt;vim_xextract&gt;.
          &lt;vim_xextract_key&gt; = &lt;w_record&gt;-keys.
          PERFORM bcset_force_into_entry USING    &lt;w_record&gt;
                                               neuer_eintrag actopts.
          APPEND extract.
          ADD 1 TO maxlines.
        ENDLOOP.
* update existing entries
        LOOP AT vim_pr_tab ASSIGNING &lt;w_record&gt; WHERE action = aendern.
          CLEAR profile_used.
          LOOP AT extract.
            CHECK &lt;w_record&gt;-keys = &lt;vim_xextract_key&gt;.
            PERFORM bcset_force_into_entry USING    &lt;w_record&gt;
                                                    aendern actopts.
            MODIFY extract.
            profile_used = &apos;X&apos;.
            EXIT.
          ENDLOOP.
          IF profile_used = space.
            LOOP AT total INTO extract.
              CHECK &lt;w_record&gt;-keys = &lt;vim_xextract_key&gt;.
              PERFORM bcset_force_into_entry USING    &lt;w_record&gt;
                                                      aendern actopts.
              APPEND extract.
              ADD 1 TO maxlines.
              EXIT.
            ENDLOOP.
          ENDIF.
        ENDLOOP.
        SORT extract BY &lt;vim_xextract_key&gt;.
      ENDIF.
    WHEN hinzufuegen.
* import from append status
      IF status-mode = list_bild.
* import in list mode
        DESCRIBE TABLE extract LINES extr_lin.
        LOOP AT vim_pr_tab ASSIGNING &lt;w_record&gt; WHERE
         action = neuer_eintrag.
          IF extr_lin LE i.
* add blank line to extract
            CLEAR extract. MOVE leer TO &lt;xact&gt;.
            APPEND extract.
          ENDIF.
* new entry
          LOOP AT extract FROM i.
            CHECK &lt;xact&gt; = leer.
            i = sy-tabix + 1.
            ADD 1 TO maxlines.
            &lt;vim_xextract_key&gt; = &lt;w_record&gt;-keys.
            PERFORM bcset_force_into_entry USING    &lt;w_record&gt;
                                                 neuer_eintrag actopts.
            MODIFY extract.
            EXIT.
          ENDLOOP.
        ENDLOOP.
      ELSE.
* import in detail mode
        MOVE &lt;initial_x&gt; TO &lt;vim_xextract&gt;.
        LOOP AT vim_pr_tab ASSIGNING &lt;w_record&gt; WHERE
         action = neuer_eintrag.
          &lt;vim_xextract_key&gt; = &lt;w_record&gt;-keys.
          PERFORM bcset_force_into_entry USING    &lt;w_record&gt;
                                               neuer_eintrag actopts.
          APPEND extract.
          ADD 1 TO maxlines.
        ENDLOOP.
      ENDIF.
* update existing entries
      LOOP AT vim_pr_tab ASSIGNING &lt;w_record&gt; WHERE action = aendern.
        LOOP AT total INTO extract.
          CHECK &lt;w_record&gt;-keys = &lt;vim_xextract_key&gt;.
          PERFORM bcset_force_into_entry USING    &lt;w_record&gt;
                                                  aendern actopts.
          APPEND extract.
          EXIT.
        ENDLOOP.
      ENDLOOP.
      SORT extract BY &lt;vim_xextract_key&gt;.
  ENDCASE.
ENDFORM.                               &quot; IMPORT_PROFILE
*&amp;---------------------------------------------------------------------*
*&amp;      Form  GET_PROFILE_STATUS
*&amp;---------------------------------------------------------------------*
*       Checks key fields of the profile whether they&apos;re fixed or not
*       and concatenates profile keys into the lines of vim_pr_tab
*       according to their nametab-position.
*       Table &amp; Texttable: Fills textfield value and initial text key
*       into VIM_PR_TAB.
*----------------------------------------------------------------------*
*  &lt;--  VIM_PR_TAB     contains for every record key status, key values
*                      and textfields
*  &lt;--  VIM_PR_FIELDS  Contains all profile fields filled with
*                      values. Used to set the request-flag in PBO.
*----------------------------------------------------------------------*
FORM get_profile_status CHANGING vim_pr_tab LIKE vim_pr_tab
                                 vim_pr_fields LIKE vim_pr_fields[].

  DATA:          w_profile TYPE scpr_vals,
                 w_vim_pr_tab TYPE vim_pr_tab_type,
                 w_vim_pr_fields TYPE vim_pr_fields_type,
                 recnumber LIKE scprvals-recnumber,
                 text(1000), value LIKE vimsellist-value,
                 gottext, first, rc LIKE sy-subrc,
                 fieldname TYPE fnam_____4.
  FIELD-SYMBOLS: &lt;pr_key&gt;,                                  &quot;#EC *
                 &lt;x_keys&gt; TYPE x, &lt;x_text&gt; TYPE x,
                 &lt;bc_val&gt; TYPE ANY, &lt;imp_val&gt; TYPE ANY,
                 &lt;keys_struc&gt; TYPE ANY, &lt;text_struc&gt; TYPE ANY.

  ASSIGN: w_vim_pr_tab-keys TO &lt;x_keys&gt; CASTING,
          &lt;x_keys&gt; TO &lt;keys_struc&gt; CASTING TYPE (x_header-maintview).
  IF x_header-bastab &lt;&gt; space AND x_header-texttbexst &lt;&gt; space.
    ASSIGN: w_vim_pr_tab-textrecord TO &lt;x_text&gt; CASTING,
            &lt;x_text&gt; TO &lt;text_struc&gt; CASTING TYPE (x_header-texttab).
  ENDIF.
  RANGES dont_use FOR scprvals-recnumber.
  dont_use-sign = &apos;E&apos;. dont_use-option = &apos;EQ&apos;.

  LOOP AT vim_pr_tab INTO w_vim_pr_tab.
    READ TABLE vim_pr_fields INTO w_vim_pr_fields WITH KEY
     recnumber = w_vim_pr_tab-recnumber.
    &lt;x_keys&gt; = &lt;initial_x&gt;(x_header-keylen).
*    w_vim_pr_tab-keys = &lt;initial&gt;(x_header-keylen).
    IF x_header-bastab &lt;&gt; space AND x_header-texttbexst &lt;&gt; space.
      &lt;x_text&gt; = &lt;initial_textkey_x&gt;.
*      w_vim_pr_tab-textrecord = &lt;initial_textkey&gt;.
    ENDIF.
* Fill key fields
    LOOP AT x_namtab WHERE keyflag = &apos;X&apos; AND texttabfld IS INITIAL.
      IF x_namtab-datatype = &apos;CLNT&apos; AND x_header-clidep &lt;&gt; space.
*        MOVE sy-mandt TO
*             w_vim_pr_tab-keys+x_namtab-position(x_namtab-flength).
        DELETE TABLE w_vim_pr_fields-fields WITH TABLE KEY
         fieldname = x_namtab-viewfield.
        MODIFY TABLE vim_pr_fields FROM w_vim_pr_fields.
*        IF x_header-bastab &lt;&gt; space AND x_header-texttbexst &lt;&gt; space.
*          MOVE sy-mandt TO
*         w_vim_pr_tab-textrecord+x_namtab-texttabpos(x_namtab-flength).
*        ENDIF.
      ELSE.
        CLEAR w_profile.
        READ TABLE vim_profile_values INTO w_profile WITH KEY
                   tablename = x_header-viewname
                   fieldname = x_namtab-viewfield
                   recnumber = w_vim_pr_tab-recnumber.
        IF w_profile-flag = vim_profile_fixkey.
          CASE w_vim_pr_tab-keys_fix.
            WHEN space.
              w_vim_pr_tab-keys_fix = vim_pr_all_fix.
            WHEN vim_pr_open.
              w_vim_pr_tab-keys_fix = vim_pr_some_fix.
          ENDCASE.
        ELSE.
          CASE w_vim_pr_tab-keys_fix.
            WHEN space.
              w_vim_pr_tab-keys_fix = vim_pr_open.
            WHEN vim_pr_all_fix.
              w_vim_pr_tab-keys_fix = vim_pr_some_fix.
          ENDCASE.
        ENDIF.
        IF x_namtab-readonly &lt;&gt; subset.&quot;subsetf. already in &lt;initial&gt;
* use profile keyfield
          CONCATENATE x_header-maintview x_namtab-viewfield
           INTO fieldname SEPARATED BY &apos;-&apos;.
          ASSIGN: w_profile-value TO &lt;bc_val&gt; CASTING TYPE (fieldname),
                      COMPONENT x_namtab-viewfield
                       OF STRUCTURE &lt;keys_struc&gt; TO &lt;imp_val&gt;.
          &lt;imp_val&gt; = &lt;bc_val&gt;.
*          MOVE w_profile-value(x_namtab-flength) TO
*          w_vim_pr_tab-keys+x_namtab-position(x_namtab-flength).
          IF x_header-bastab &lt;&gt; space AND x_header-texttbexst &lt;&gt; space.
* make text table key (for finding the suitable text value only)
            ASSIGN COMPONENT x_namtab-txttabfldn
                   OF STRUCTURE &lt;text_struc&gt; TO &lt;imp_val&gt;.
            &lt;imp_val&gt; = &lt;bc_val&gt;.
*            MOVE w_profile-value(x_namtab-flength) TO
*         w_vim_pr_tab-textrecord+x_namtab-texttabpos(x_namtab-flength).
          ENDIF.
        ENDIF.                         &quot;x_namtab-readonly &lt;&gt; subset
        w_vim_pr_fields-keys_fix = w_vim_pr_tab-keys_fix.
        MODIFY vim_pr_fields FROM w_vim_pr_fields TRANSPORTING keys_fix
                 WHERE recnumber = w_vim_pr_fields-recnumber.
      ENDIF.                           &quot;x_namtab-datatype = &apos;CLNT&apos;
    ENDLOOP.
    IF x_header-bastab &lt;&gt; space AND x_header-texttbexst &lt;&gt; space AND
       w_vim_pr_tab-keys_fix &lt;&gt; vim_pr_error.
* get record for text table
      CLEAR recnumber.
      IF vim_pr_records &gt; 1.
        WHILE gottext = space.
          gottext = &apos;X&apos;.
          first = &apos;X&apos;.
          LOOP AT vim_profile_values INTO w_profile WHERE
                          tablename = x_header-texttab
                          AND recnumber IN dont_use[].
            IF first = &apos;X&apos;.
              recnumber = w_profile-recnumber.
              CLEAR first.
            ELSE.
              IF recnumber &lt;&gt; w_profile-recnumber.
                IF gottext &lt;&gt; space. EXIT. ENDIF.
                recnumber = w_profile-recnumber.
              ENDIF.
            ENDIF.
            IF w_profile-flag+2 = &apos;Y&apos;. &quot;keY, ukY or fkY -&gt; Key fields!
* check key-value
              IF w_profile-fieldname = x_header-sprasfield.
                IF w_profile-value(1) &lt;&gt; sy-langu.
                  dont_use-low = recnumber.
                  APPEND dont_use.
                  CLEAR: text, gottext.
                  CONTINUE.
                ENDIF.
              ELSE.
                READ TABLE x_namtab WITH KEY
                                    viewfield = w_profile-fieldname
                                    keyflag = &apos;X&apos; texttabfld = &apos;X&apos;.
                CONCATENATE x_header-texttab x_namtab-txttabfldn
                         INTO fieldname SEPARATED BY &apos;-&apos;.
                ASSIGN: w_profile-value TO &lt;bc_val&gt;
                         CASTING TYPE (fieldname),
                        COMPONENT x_namtab-txttabfldn
                         OF STRUCTURE &lt;text_struc&gt; TO &lt;imp_val&gt;.
*                ASSIGN w_profile-value(x_namtab-flength) TO &lt;vgl1&gt;.
*   ASSIGN w_vim_pr_tab-textrecord+x_namtab-texttabpos(x_namtab-flength)
*                                                          TO &lt;vgl2&gt;.
*                IF &lt;vgl1&gt; &lt;&gt; &lt;vgl2&gt;.
                IF &lt;imp_val&gt; &lt;&gt; &lt;bc_val&gt;.
                  CLEAR gottext.
                  dont_use-low = recnumber.
                  APPEND dont_use.
*                    CLEAR text.
                  CONTINUE.
                ENDIF.
              ENDIF.
*              ELSE.
** store textfield.
*                text = w_profile-value.
*                APPEND w_profile-fieldname TO w_vim_pr_fields-fields.
            ENDIF.                                          &quot;key field
          ENDLOOP.
        ENDWHILE.
        IF gottext &lt;&gt; space.
          recnumber = w_profile-recnumber.
        ENDIF.
*          IF NOT text IS INITIAL.
*            READ TABLE x_namtab WITH KEY keyflag = space
*                                         texttabfld = &apos;X&apos;.
*            MOVE text TO
*         w_vim_pr_tab-textrecord+x_namtab-texttabpos(x_namtab-flength).
*            CLEAR: text, gottext.
*          ENDIF.
      ELSEIF vim_pr_records = 1.
* insert language into text table key
*           READ TABLE x_namtab WITH KEY viewfield = x_header-sprasfield
*                                        keyflag = &apos;X&apos; texttabfld = &apos;X&apos;.
        ASSIGN COMPONENT x_header-sprasfield
                      OF STRUCTURE &lt;text_struc&gt; TO &lt;imp_val&gt;.
        &lt;imp_val&gt; = sy-langu.
*            MOVE sy-langu TO
*         w_vim_pr_tab-textrecord+x_namtab-texttabpos(x_namtab-flength).
        READ TABLE vim_profile_values INTO w_profile WITH KEY
                   tablename = x_header-texttab
                   fieldname = x_header-sprasfield
                   value = sy-langu.
        IF sy-subrc = 0.
* textfield value found
          recnumber = w_profile-recnumber.
        ENDIF.
      ENDIF.                                                &quot;lines = 1
      IF NOT recnumber IS INITIAL.
*textvalue in bc-set found
        LOOP AT x_namtab WHERE keyflag = space AND
                                     texttabfld = &apos;X&apos;.
          CONCATENATE x_header-texttab x_namtab-viewfield
                   INTO fieldname SEPARATED BY &apos;-&apos;.
          READ TABLE vim_profile_values INTO w_profile WITH KEY
                           tablename = x_header-texttab
                           recnumber = recnumber
                           fieldname = x_namtab-viewfield.
          ASSIGN: w_profile-value TO &lt;bc_val&gt;
                   CASTING TYPE (fieldname),
                  COMPONENT x_namtab-viewfield
                   OF STRUCTURE &lt;text_struc&gt; TO &lt;imp_val&gt;.
          &lt;imp_val&gt; = &lt;bc_val&gt;.
*                MOVE w_profile-value
*      TO w_vim_pr_tab-textrecord+x_namtab-texttabpos(x_namtab-flength).
          APPEND w_profile-fieldname TO w_vim_pr_fields-fields.
        ENDLOOP.
      ELSE.
* no text value in bc-set
        MOVE &lt;text_initial_x&gt; TO &lt;x_text&gt;.
      ENDIF.
    ENDIF.                             &quot;text table exists
    MODIFY vim_pr_tab FROM w_vim_pr_tab.
    MODIFY TABLE vim_pr_fields FROM w_vim_pr_fields.
  ENDLOOP.
ENDFORM.                    &quot;get_profile_status
*&amp;---------------------------------------------------------------------*
*&amp;      Form  ACTIVATE_PROFILE
*&amp;---------------------------------------------------------------------*
*     No longer in use: For 6.20 the funcionality of BC set activation
*     via SM30 was abolished
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM activate_profile CHANGING p_selected
TYPE c.

  DATA: pr_rc TYPE i, pr_funcsafe(4), pr_counter TYPE i,
        pr_mark_entries VALUE &apos;X&apos;, hf1  TYPE i, hf  TYPE i,
        cobj_type VALUE &apos;V&apos;, pr_key_da, pr_recnumber TYPE scpr_recnr,
        bc_id TYPE scpr_id, bc_rec_found(1) TYPE c,
        actopts TYPE scpractopt.&quot;HCG always empty, only nec. 46C 610
  STATICS: viewname LIKE vimdesc-viewname.
  FIELD-SYMBOLS: &lt;pr_f1&gt; TYPE x, &lt;w_record&gt; TYPE vim_pr_tab_type,
                 &lt;bc_key&gt; TYPE x.

  CHECK status-action NE anzeigen AND  &quot;ignore wrong setted requestflags
        status-action NE transportieren. &quot;due to individual F4 modules
  CLEAR vim_pr_activating.
  IF p_selected IS INITIAL.
* read profile
    REFRESH: vim_profile_values, vim_pr_tab.
*    CALL FUNCTION &apos;SCPR_ACTIVATE&apos;     // Ast stillgelegt, der Baustein
*                                      // existiert nicht mehr
*        EXPORTING
*             tabname          = x_header-viewname
*             initial          = &lt;initial&gt;
*       IMPORTING
*            PROFID           =
*        TABLES
*             values           = vim_profile_values
*             sellist          = dpl_sellist
*        EXCEPTIONS
*             user_abort       = 1
*             no_profile_found = 2
*             OTHERS           = 3.
*    CASE sy-subrc.
*      WHEN 0.
*        p_selected = &apos;X&apos;. viewname = x_header-viewname.
*        SORT vim_profile_values BY id version tablename recnumber.
*        IF &apos;AU&apos; CA status-action.
* get records the profile contains
*          PERFORM get_pr_nbr_records USING vim_profile_values
*                                           x_header
*                                     CHANGING pr_rc
*                                              bc_id
*                                              vim_pr_records
*                                              vim_pr_tab
*                                              vim_pr_fields.
* check key-status
*          PERFORM get_profile_status CHANGING vim_pr_tab
*                                              vim_pr_fields.
*        ENDIF.
*      WHEN 1.
*        EXIT.
*      WHEN 2.
*        IF x_header-bastab NE space.
*          cobj_type = vim_tabl.
*        ENDIF.
*        IF cobj_type = &apos;S&apos;.
*          MESSAGE e822(sv) WITH x_header-viewname.
*   Zur Tabelle &amp; existiert kein Profil.
*        ELSE.
*          MESSAGE e821(sv) WITH x_header-viewname.
*   Zur View &amp; existiert kein Profil.
*        ENDIF.
*    ENDCASE.
  ELSE.
    IF vim_called_by_cluster &lt;&gt; space AND
     viewname &lt;&gt; x_header-viewname.
* update key values according to current view and selection
      viewname = x_header-viewname.
      IF &apos;AU&apos; CA status-action.
* get records the profile contains
        PERFORM get_pr_nbr_records USING vim_profile_values
                                         x_header
                                   CHANGING pr_rc
                                            bc_id
                                            vim_pr_records
                                            vim_pr_tab
                                            vim_pr_fields.
* check key-status
        PERFORM get_profile_status CHANGING vim_pr_tab
                                            vim_pr_fields.
      ENDIF.
    ENDIF.
  ENDIF.
* check, if bc-set-records refer to existing datasets
  PERFORM bcset_key_check_in_total.
  PERFORM markiere_alle USING nicht_markiert.
  PERFORM import_profile USING actopts.
* viewcluster: show list of views to work on
  IF vim_called_by_cluster &lt;&gt; space.
    CALL FUNCTION &apos;VIEWCLUSTER_PR_IMPORT_CTRL&apos;
      EXPORTING
        viewname        = x_header-viewname
        action          = &apos;M&apos;
      TABLES
        profile_values  = vim_profile_values
      EXCEPTIONS
        wrong_parameter = 1
        OTHERS          = 2.
  ENDIF.
  replace_mode = &apos;X&apos;.
  vim_special_mode = vim_upgrade.
* handle changed entries
  ASSIGN &lt;vim_xtotal&gt;(x_header-tablen) TO &lt;pr_f1&gt; CASTING.
  LOOP AT extract.
    CHECK &lt;xact&gt; = aendern OR &lt;xact&gt; = neuer_eintrag.
    CLEAR vim_bc_entry_list_wa.
    vim_bc_entry_list_wa-id = bc_id.
    vim_bc_entry_list_wa-viewname = x_header-viewname.
    hf = sy-tabix.
    READ TABLE total WITH KEY &lt;vim_xextract_key&gt; BINARY SEARCH.
    IF sy-subrc EQ 0.                  &quot;entry exists in current client
      hf1 = sy-tabix.
      IF &lt;xact&gt; EQ neuer_eintrag AND
      &lt;action&gt; EQ geloescht OR &lt;action&gt; EQ neuer_geloescht OR
      &lt;action&gt; EQ update_geloescht.
        status-delete = geloescht.
* entry deleted in cur clnt -&gt; first undelete it
        &lt;xact&gt; = &lt;action&gt;.
        MODIFY extract.
        pr_funcsafe = function.
        CLEAR pr_rc.
        PERFORM vim_mark_and_process USING hf &apos;UNDO&apos; hf1
                                           pr_rc.
        CLEAR status-delete. function = pr_funcsafe.
        CHECK pr_rc NE 4.
        IF pr_rc EQ 8.
          EXIT.
        ENDIF.
        READ TABLE extract INDEX hf.
        READ TABLE total WITH KEY &lt;vim_xextract_key&gt; BINARY SEARCH.
        hf1 = sy-tabix.
        &lt;xact&gt; = aendern. MODIFY extract.
      ENDIF.
      IF &lt;vim_xtotal_key&gt; = &lt;vim_xextract_key&gt;.
* record already exists: do not import but save
        &lt;action&gt; = aendern.
        MODIFY total INDEX hf1.
        IF x_header-bastab NE space AND x_header-texttbexst NE space.
          TRANSLATE &lt;status&gt;-upd_flag USING &apos; ETX&apos;.
        ELSE.
          &lt;status&gt;-upd_flag = &apos;X&apos;.
        ENDIF.
      ENDIF.
    ENDIF.                             &quot;sy-subrc eq 0.
    CLEAR vim_pr_fields_wa.
    CLEAR bc_rec_found.
    LOOP AT vim_pr_tab ASSIGNING &lt;w_record&gt;.
      ASSIGN &lt;w_record&gt;-keys(x_header-keylen) TO &lt;bc_key&gt;.
      CHECK &lt;bc_key&gt; = &lt;vim_xextract_key&gt;.
      bc_rec_found = &apos;X&apos;.
      READ TABLE vim_pr_fields INTO vim_pr_fields_wa WITH KEY
       recnumber = &lt;w_record&gt;-recnumber.
      vim_bc_entry_list_wa-id = bc_id.
      vim_bc_entry_list_wa-recnumber = &lt;w_record&gt;-recnumber.
      vim_bc_entry_list_wa-keys = &lt;bc_key&gt;.
*      if x_header-bastab &lt;&gt; space and x_header-texttbexst &lt;&gt; space.
** table with text table
*        vim_bc_entry_list_wa-keys + x_header-keylen =
*         &lt;w_record&gt;-textrecord(x_header-textkeylen).
*      endif.
      vim_bc_entry_list_wa-action = neuer_eintrag.
      INSERT LINES OF vim_pr_fields_wa-fields INTO TABLE
       vim_bc_entry_list_wa-fields.
      EXIT.
    ENDLOOP.
    CHECK NOT bc_rec_found IS INITIAL.
    IF &lt;xact&gt; &lt;&gt; aendern OR &lt;pr_f1&gt; &lt;&gt; &lt;table2_x&gt;.
* import bc-set record
      CHECK NOT vim_pr_fields_wa IS INITIAL.
      &lt;status&gt;-prof_found = vim_pr_into_view.
      PERFORM vim_modify_view_entry USING hf pr_rc.
      &lt;status&gt;-prof_found = vim_profile_found.
      CHECK pr_rc NE 4.
      IF pr_rc EQ 8.
        EXIT.
      ENDIF.
    ENDIF.
    READ TABLE total WITH KEY &lt;vim_xtotal_key&gt; BINARY SEARCH
                     TRANSPORTING NO FIELDS.
    IF &lt;mark&gt; EQ nicht_markiert.
      &lt;mark&gt; = markiert. ADD 1 TO mark_total.
      MODIFY total INDEX sy-tabix.
    ENDIF.
    extract = total.
    MODIFY extract.
    INSERT vim_bc_entry_list_wa INTO TABLE vim_bc_entry_list.
    IF sy-subrc = 4.
      MODIFY TABLE vim_bc_entry_list FROM vim_bc_entry_list_wa.
    ENDIF.
    ADD 1 TO pr_counter.
  ENDLOOP.
  IF pr_counter &lt; vim_pr_records.
    MESSAGE s818(sv) WITH pr_counter vim_pr_records.
*   Es wurden &amp;1 von &amp;2 Einträgen des Business-Configuration-Sets import
  ELSE.
    MESSAGE s819(sv).
*   Das Business-Configuration-Set wurde vollständig importiert.
  ENDIF.
  nextline = 1.
  CLEAR: vim_special_mode, replace_mode.
  PERFORM fill_extract.
  IF status-action EQ hinzufuegen.
    status-action = aendern.
    title-action  = aendern.
    CLEAR &lt;status&gt;-selected.
  ENDIF.
  IF status-mode = detail_bild.
* return to list screen
    vim_next_screen = liste. vim_leave_screen = &apos;X&apos;.
  ENDIF.
ENDFORM.                               &quot; ACTIVATE_PROFILE
*&amp;---------------------------------------------------------------------*
*&amp;      Form  SET_PROFILE_KEY_ATTRIBUTES
*&amp;---------------------------------------------------------------------*
*       sets screen input attribute according to profile attributes
*       of key field p_name
*----------------------------------------------------------------------*
*      &lt;--P_SCREEN_INPUT  text
*      &lt;--P_VIM_MODIFY_SCREEN  text
*----------------------------------------------------------------------*
FORM set_profile_key_attributes
                    USING p_name LIKE vim_objfield
                    CHANGING p_screen_input LIKE screen-input
                             p_modify_screen LIKE vim_modify_screen.

  DATA: w_field TYPE vimty_fields_type.

  p_screen_input = &apos;0&apos;.
  CASE vim_pr_fields_wa-keys_fix.
    WHEN vim_pr_open.
      p_screen_input = &apos;1&apos;. p_modify_screen = &apos;X&apos;.
    WHEN vim_pr_all_fix.
      p_screen_input = &apos;0&apos;.
    WHEN vim_pr_some_fix.
      READ TABLE vim_pr_fields_wa-fields INTO w_field
          WITH KEY fieldname = p_name.
      IF w_field-flag &lt;&gt; vim_profile_fixkey.
        p_screen_input = &apos;1&apos;. p_modify_screen = &apos;X&apos;.
      ENDIF.
  ENDCASE.
ENDFORM.                               &quot; SET_PROFILE_KEY_ATTRIBUTES
*&amp;---------------------------------------------------------------------*
*&amp;      Form  PROFILE_PUT_INTO_WA
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p_record  bc-set
*  --&gt;  p_subset  flag: put &quot;initial&quot; value into subsetfield
*  --&gt;  p_action  action-flag from EXTRACT
*  &lt;--  p_field   view-maintenance dataset
*----------------------------------------------------------------------*
FORM profile_put_into_wa USING p_bc_set LIKE vim_profile_values
                               p_record TYPE vim_pr_tab_type
                               p_header TYPE vimdesc
                               p_namtab LIKE x_namtab[]
                               p_subset TYPE xfeld
                               p_action TYPE char1
                               actopts TYPE scpractopt
                         CHANGING p_field.
  DATA:          w_profile TYPE scpr_vals,
                 fieldname TYPE fnam_____4,
                 old_guid TYPE REF TO data,
                 tabname_wa TYPE objs-tabname,
                 objecttype TYPE objs-objecttype VALUE &apos;S&apos;.
  STATICS:       loc_viewname TYPE objs-objectname,
                 piecelist TYPE TABLE OF objs-tabname.
  FIELD-SYMBOLS: &lt;namtab&gt; TYPE vimnamtab, &lt;field&gt; TYPE ANY,
                 &lt;old_guid&gt; TYPE ANY, &lt;work_area&gt; TYPE ANY,
                 &lt;bc_value&gt; TYPE ANY.

  CONSTANTS: no_standard(1) TYPE c VALUE &apos;F&apos;,
             stan(3) TYPE c VALUE &apos;USE&apos;,
             new_entry(1) TYPE c VALUE &apos;N&apos;.                 &quot;IG 1036876

  ASSIGN p_field TO &lt;work_area&gt; CASTING TYPE (p_header-maintview).
  LOOP AT p_namtab ASSIGNING &lt;namtab&gt; WHERE keyflag = space
   AND texttabfld = space.
    ASSIGN COMPONENT &lt;namtab&gt;-viewfield OF STRUCTURE &lt;work_area&gt;
     TO &lt;field&gt;.
    CONCATENATE p_header-maintview &lt;namtab&gt;-viewfield
     INTO fieldname SEPARATED BY &apos;-&apos;.
    IF &lt;namtab&gt;-domname IN vim_guid_domain.
* GUID field
      IF p_action = neuer.
*     Overtake GUID from BC-Set for new entries.
      ELSE.
        IF p_record-keys_fix = vim_pr_all_fix.
          IF p_header-frm_af_uid &lt;&gt; space.
* prepare event 27
            CREATE DATA old_guid TYPE (fieldname).
*          ASSIGN p_field+&lt;namtab&gt;-position(&lt;namtab&gt;-flength)
*           TO &lt;guid&gt; CASTING TYPE (fieldname).
            ASSIGN: old_guid-&gt;* TO &lt;old_guid&gt;.
            &lt;old_guid&gt; = &lt;field&gt;.
          ENDIF.
        ELSE.
          CONTINUE.
* Use GUID from BC-Set only if complete key is given fix
        ENDIF.
      ENDIF.
    ENDIF.
    CASE &lt;namtab&gt;-readonly.
      WHEN space.
        READ TABLE p_bc_set INTO w_profile WITH KEY
          tablename = p_header-viewname
          recnumber = p_record-recnumber
          fieldname = &lt;namtab&gt;-viewfield BINARY SEARCH
          TRANSPORTING flag value.
        CHECK sy-subrc = 0.
        ASSIGN w_profile-value TO &lt;bc_value&gt; CASTING TYPE (fieldname).
*       Do not overwrite field of existing dataset with BC-Set value
*       if standard field (flag = USE) and actopts-no_standard = Y.
        IF actopts-no_standrd NE no_standard OR w_profile-flag NE stan
           OR p_action EQ new_entry.                        &quot;IG 1036876
          &lt;field&gt; = &lt;bc_value&gt;.
        ENDIF.
*        MOVE w_profile-value(&lt;namtab&gt;-flength)
*             TO p_field+&lt;namtab&gt;-position(&lt;namtab&gt;-flength).
      WHEN rdonly OR vim_hidden.       &quot;HCG Check if table in piece list
        IF p_header-viewname NE loc_viewname.
          loc_viewname = p_header-viewname.
          REFRESH piecelist.
          IF p_header-bastab EQ space. objecttype = &apos;V&apos;. ENDIF.
          SELECT tabname FROM objs INTO tabname_wa   &quot;Get info from OBJS
                       WHERE objectname = p_header-viewname
                       AND   objecttype = objecttype.
            APPEND tabname_wa TO piecelist.
          ENDSELECT.
        ENDIF.
        READ TABLE p_bc_set INTO w_profile WITH KEY
          tablename = p_header-viewname
          recnumber = p_record-recnumber
          fieldname = &lt;namtab&gt;-viewfield BINARY SEARCH
          TRANSPORTING flag value.
        CHECK sy-subrc = 0.
        READ TABLE piecelist INTO tabname_wa WITH KEY
                                               &lt;namtab&gt;-bastabname.
        IF sy-subrc EQ 0. &quot;HCG If table is not in piecelist: skip field
          ASSIGN w_profile-value TO &lt;bc_value&gt; CASTING TYPE (fieldname).
*         Do not overwrite field of existing dataset with BC-Set value
*         if standard field (flag = USE) and actopts-no_standard = Y.
          IF actopts-no_standrd NE no_standard OR
             w_profile-flag NE stan OR p_action EQ new_entry.&quot;IG 1036876
            &lt;field&gt; = &lt;bc_value&gt;.
          ENDIF.
        ENDIF.
      WHEN subset.
        CHECK p_subset &lt;&gt; space.
        ASSIGN COMPONENT &lt;namtab&gt;-viewfield OF STRUCTURE &lt;initial&gt;
         TO &lt;bc_value&gt;.
*        MOVE &lt;initial&gt;+&lt;namtab&gt;-position(&lt;namtab&gt;-flength)
*         TO p_field+&lt;namtab&gt;-position(&lt;namtab&gt;-flength).
    ENDCASE.
    IF &lt;namtab&gt;-domname IN vim_guid_domain
     AND p_record-keys_fix = vim_pr_all_fix
     AND  p_header-frm_af_uid &lt;&gt; space.
* event 27 for GUID field
      PERFORM (p_header-frm_af_uid) IN PROGRAM (p_header-fpoolname)
                                    USING &lt;old_guid&gt;
                                    CHANGING &lt;field&gt;
                                             &lt;work_area&gt;.
    ENDIF.
  ENDLOOP.
ENDFORM.                               &quot; PROFILE_PUT_INTO_WA
*&amp;---------------------------------------------------------------------*
*&amp;      Form  GET_PR_NBR_RECORDS
*&amp;---------------------------------------------------------------------*
*       Get the number of records the chosen profile contains and get
*       the fields every record contains.
*----------------------------------------------------------------------*
*      --&gt;VIM_PROFILE_VALUES  contains bc-set
*      --&gt;X_HEADER
*      --&gt;P_RC                = 4: no record found
*      &lt;--VIM_PR_RECORDS      number of records in bc-set
*      &lt;--VIM_PR_TAB          table of bc-set-records, initialized
*      &lt;--VIM_PR_FIELDS       lists of matched fields for every record
*----------------------------------------------------------------------*
FORM get_pr_nbr_records USING vim_profile_values
                               LIKE vim_profile_values
                              x_header TYPE vimdesc
                        CHANGING p_rc LIKE sy-subrc
                                 p_bc_id TYPE scpr_id
                                 vim_pr_records TYPE i
                                 vim_pr_tab LIKE vim_pr_tab
                                 vim_pr_fields LIKE vim_pr_fields.

  DATA: w_vim_pr_tab TYPE vim_pr_tab_type, first VALUE &apos;X&apos;,
        w_vim_pr_fields TYPE vim_pr_fields_type,
        w_fields TYPE vimty_fields_type, recnumber TYPE scpr_recnr.
  FIELD-SYMBOLS: &lt;profile_value&gt; LIKE LINE OF vim_profile_values.

  REFRESH: vim_pr_tab, vim_pr_fields.
  CLEAR: vim_pr_records, p_rc.

  LOOP AT vim_profile_values ASSIGNING &lt;profile_value&gt;
       WHERE tablename = x_header-viewname.
    IF &lt;profile_value&gt;-recnumber &lt;&gt; recnumber.
      recnumber = &lt;profile_value&gt;-recnumber.
      IF first = space.
        APPEND w_vim_pr_tab TO vim_pr_tab.
        APPEND w_vim_pr_fields TO vim_pr_fields. CLEAR w_vim_pr_fields.
      ENDIF.
      CLEAR first.
      w_vim_pr_fields-recnumber = w_vim_pr_tab-recnumber
       = &lt;profile_value&gt;-recnumber.
      ADD 1 TO vim_pr_records.
    ENDIF.
    w_fields-fieldname = &lt;profile_value&gt;-fieldname.
    w_fields-flag = &lt;profile_value&gt;-flag.
    APPEND w_fields TO w_vim_pr_fields-fields.
  ENDLOOP.
  p_rc = sy-subrc.
  CHECK sy-subrc = 0.
  APPEND w_vim_pr_tab TO vim_pr_tab.
  APPEND w_vim_pr_fields TO vim_pr_fields.
  p_bc_id = &lt;profile_value&gt;-id.
*  IF w_vim_pr_tab-recnumber IS INITIAL.
*    w_vim_pr_tab-recnumber = 1. APPEND w_vim_pr_tab TO vim_pr_tab.
*    ADD 1 TO vim_pr_records.
*  ENDIF.
ENDFORM.                               &quot; GET_PR_NBR_RECORDS
*&amp;---------------------------------------------------------------------*
*&amp;      Form  GET_PR_FIELD_FROM_SEL
*&amp;---------------------------------------------------------------------*
*       extracts value for field P_PR_NAMTAB-VIEWFIELD from P_PR_SELLIST
*       into P_VIM_SEL_VALUE.
*----------------------------------------------------------------------*
*      &lt;--P_SEL_VALUE   extracted value, P_SEL_VALUE remain sunchanged
*      &lt;--P_RC          0: o.k.  1: no selection defined, P_SEL_VALUE
*                       remains unchanged  2: no unambiguous
*                       extraction possible, P_SEL_VALUE cleared
*      --&gt;P_PR_SELLIST  text
*      --&gt;P_PR_NAMTAB   text
*      --&gt;P_PR_CLUSTER  Flag: View maintenance called by cluster
*----------------------------------------------------------------------*
FORM get_pr_field_from_sel
       USING    p_pr_sellist TYPE vimsellist_type
                p_pr_namtab LIKE vimnamtab
       CHANGING p_sel_value LIKE dpl_sellist-value
                p_rc LIKE sy-subrc.

  DATA: w_sellist LIKE vimsellist, first.

  p_rc = 1. first = &apos;X&apos;.
  LOOP AT p_pr_sellist INTO w_sellist.
    CHECK w_sellist-viewfield = p_pr_namtab-viewfield.
    IF first = space OR w_sellist-operator &lt;&gt; &apos;EQ&apos;.
      CLEAR p_sel_value. p_rc = 2. EXIT.
    ELSE.
      MOVE w_sellist-value(p_pr_namtab-flength) TO
       p_sel_value(p_pr_namtab-flength).
      p_rc = 0.
    ENDIF.
    CLEAR first.
  ENDLOOP.
ENDFORM.                               &quot; GET_PR_FIELD_FROM_SEL
*&amp;---------------------------------------------------------------------*
*&amp;      Form  VIM_PR_mand_fields
*&amp;---------------------------------------------------------------------*
*       Appending profiles in detail mode: Leaves screen to reset
*       mandatory attribute and to process sreen in background if
*       at least one dynpro-field is mandatory.
*----------------------------------------------------------------------*
FORM vim_pr_mand_fields.
  LOOP AT SCREEN.
    CHECK screen-required &lt;&gt; &apos;0&apos;.
    vim_pr_activating = &apos;X&apos;.
    SET SCREEN detail. LEAVE SCREEN.
  ENDLOOP.
ENDFORM.                               &quot; VIM_PR_AT_EXIT_COM
*&amp;---------------------------------------------------------------------*
*&amp;      Form  bcset_key_check_in_total
*&amp;---------------------------------------------------------------------*
*       check, if bc-set-key already exists
*----------------------------------------------------------------------*
*----------------------------------------------------------------------*
FORM bcset_key_check_in_total.

  DATA: w_record TYPE vim_pr_tab_type.
  FIELD-SYMBOLS: &lt;bc_key&gt; TYPE x.

  ASSIGN w_record-keys(x_header-keylen) TO &lt;bc_key&gt;.
  LOOP AT vim_pr_tab INTO w_record.
    CLEAR w_record-action.
    READ TABLE total WITH KEY &lt;bc_key&gt; BINARY SEARCH
     TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      w_record-action = aendern.
    ELSE.
      w_record-action = neuer_eintrag.
    ENDIF.
    MODIFY vim_pr_tab FROM w_record.
  ENDLOOP.
ENDFORM.                               &quot; bcset_key_check_in_total
*&amp;---------------------------------------------------------------------*
*&amp;      Form  bcset_force_into_entry
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_&lt;W_RECORD&gt;  text
*      &lt;--P_AENDERN  text
*----------------------------------------------------------------------*
FORM bcset_force_into_entry USING    p_record TYPE vim_pr_tab_type
                                     p_action TYPE char1
                                     actopts TYPE scpractopt.

  FIELD-SYMBOLS: &lt;textrec_x&gt; TYPE x.

  IF &lt;xmark&gt; = nicht_markiert.
    &lt;xmark&gt; = markiert. ADD 1 TO mark_extract.
  ENDIF.
  &lt;xact&gt; = p_action.
  PERFORM profile_put_into_wa USING vim_profile_values
                                    p_record
                                    x_header
                                    x_namtab[]
                                    &apos;X&apos;
                                    p_action
                                    actopts
                              CHANGING &lt;vim_xextract&gt;.
*                              CHANGING &lt;table2&gt;.
  IF x_header-texttbexst &lt;&gt; space AND x_header-bastab &lt;&gt; space.
    ASSIGN p_record-textrecord(x_header-texttablen)
     TO &lt;textrec_x&gt; CASTING.
    MOVE &lt;textrec_x&gt; TO &lt;vim_xextract_text&gt;.
*    MOVE p_record-textrecord+x_header-textkeylen(len_text)
*             TO &lt;extract_text&gt;+x_header-textkeylen(len_text).
  ENDIF.
ENDFORM.                               &quot; bcset_force_into_entry</include_source>
   </include>
   <include NAME="LSVIMFXX" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="SAP" CDAT="19950113" UNAM="SAP" UDAT="20080721" VERN="000065" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122443" IDATE="20080721" ITIME="122443">
    <include_source>INCLUDE LSVIMFXL.     &quot; Pflege von Text-Feldern in mehreren Sprachen
INCLUDE LSVIMFXP.     &quot; Form routines to activate profiles
INCLUDE LSVIMFX2.                      &quot; continueing LSVIMFXX
INCLUDE LSVIMFX3.     &quot; Form Routines for printing data into lists

  INCLUDE LSVIMF45 .  &quot; INITIALISIEREN

  INCLUDE LSVIMF44 .  &quot; VIM_PROCESS_ASSIGNS

  INCLUDE LSVIMF43 .  &quot; VIM_ASSIGN_MKEY_AFTER_2

  INCLUDE LSVIMF42 .  &quot; VIM_ASSIGN_MAINKEY_AFTER

  INCLUDE LSVIMF41 .  &quot; SET_POSITION_INFO

  INCLUDE LSVIMF40 .  &quot; SET_NUMBERED_TEXTS

  INCLUDE LSVIMF3Z .  &quot; INIT_STATE_VECTOR

  INCLUDE LSVIMF3Y .  &quot; SET_STATUS_NOKEYSELCNDS

  INCLUDE LSVIMF3X .  &quot; EXCLUDE_CUA_FUNCTIONS

  INCLUDE LSVIMF3W .  &quot; SET_PF_STATUS

  INCLUDE LSVIMF3V .  &quot; SET_TITLE

  INCLUDE LSVIMF3U .  &quot; JUSTIFY_ACTION_MODE

  INCLUDE LSVIMF3T .  &quot; VIM_SET_ALE_EDIT_LOCK


  INCLUDE LSVIMF3S .  &quot; VIM_CHECK_ALE_EDIT_LOCK

  INCLUDE LSVIMF3R .  &quot; VIM_SAPSCRIPT_FORM_MAINT

  INCLUDE LSVIMF3Q .  &quot; AEND_TO_ANZG

  INCLUDE LSVIMF3P .  &quot; ANZG_TO_AEND

  INCLUDE LSVIMF3O .  &quot; BEENDEN

  INCLUDE LSVIMF3N .  &quot; LISTE_BACK

  INCLUDE LSVIMF3M .  &quot; LISTE_ABBRECHEN

  INCLUDE LSVIMF3L .  &quot; IGNORIEREN

  INCLUDE LSVIMF3K .  &quot; BLAETTERN

  INCLUDE LSVIMF3J .  &quot; CHECK_UPD

  INCLUDE LSVIMF3I .  &quot; POPUP_POSITIONIEREN

  INCLUDE LSVIMF3H .  &quot; F4_POSITIONIEREN

  INCLUDE LSVIMF3G .  &quot; LISTE_MARKIERE

  INCLUDE LSVIMF3F .  &quot; MARKIERE_BLOCK

  INCLUDE LSVIMF3E .  &quot; MARKIERE

  INCLUDE LSVIMF3D .  &quot; MARKIERE_ALLE

  INCLUDE LSVIMF3C .  &quot; LISTE_ZURUECKHOLEN

  INCLUDE LSVIMF3B .  &quot; LOGICAL_UNDELETE_TOTAL

  INCLUDE LSVIMF3A .  &quot; SELEKTIERE

  INCLUDE LSVIMF39 .  &quot; NORMAL_SELECT

  INCLUDE LSVIMF38 .  &quot; SELECT

  INCLUDE LSVIMF37 .  &quot; FILL_EXTRACT

  INCLUDE LSVIMF36 .  &quot; MOD_EXTRACT_AND_MAINKEY_TAB

  INCLUDE LSVIMF35 .  &quot; CHECK_AND_MODIFY_MAINKEY_TAB

*  INCLUDE LSVIMF34 .  &quot; CHECK_IF_ENTRY_IS_TO_BE_MERGED

  INCLUDE LSVIMF33 .  &quot; CHECK_IF_ENTRY_IS_TO_DISPLAY

  INCLUDE LSVIMF32 .  &quot; READ_TABLE

  INCLUDE LSVIMF31 .  &quot; UPDATE_TAB

  INCLUDE LSVIMF30 .  &quot; VORHANDEN

  INCLUDE LSVIMF2Z .  &quot; UPDATE_ENTRY

  INCLUDE LSVIMF2Y .  &quot; NICHT_VORHANDEN

  INCLUDE LSVIMF2X .  &quot; CHECK_NEW_MAINKEY

  INCLUDE LSVIMF2W .  &quot; HINZUFUEGEN

  INCLUDE LSVIMF2V .  &quot; CHECK_KEY

  INCLUDE LSVIMF2U .  &quot; VIM_CK_APPEND_WHERETAB

  INCLUDE LSVIMF2T .  &quot; LISTE_LOESCHE

  INCLUDE LSVIMF2S .  &quot; LOGICAL_DELETE_FROM_TOTAL

  INCLUDE LSVIMF2R .  &quot; CHECK_IF_ENTRY_CAN_BE_DELETED

  INCLUDE LSVIMF2Q .  &quot; SUCHEN

  INCLUDE LSVIMF2P .  &quot; CONSIDER_OLD_EXCLUDE_TAB

  INCLUDE LSVIMF2O .  &quot; REPLACE

  INCLUDE LSVIMF2N .  &quot; KOPIERE

  INCLUDE LSVIMF2M .  &quot; KOPIERE_EINTRAG

  INCLUDE LSVIMF2L .  &quot; CALL_DYNPRO

  INCLUDE LSVIMF2K .  &quot; VIM_STORE_STATE_INFO

  INCLUDE LSVIMF2J .  &quot; VIM_RESTORE_STATE_INFO

  INCLUDE LSVIMF2I .  &quot; VIM_EXTERNAL_EDIT

  INCLUDE LSVIMF2H .  &quot; VIM_MARK_AND_PROCESS

  INCLUDE LSVIMF2G .  &quot; CHECK_DYNAMIC_SELECT_OPTIONS

  INCLUDE LSVIMF2F .  &quot; MODIFY_TABLES

  INCLUDE LSVIMF2E .  &quot; INIT_SUBSET_KEYFIELDS

  INCLUDE LSVIMF2D .  &quot; INIT_SUBSET_FCTFIELDS

  INCLUDE LSVIMF2C .  &quot; FILL_SUBSETFIELDS

  INCLUDE LSVIMF2B .  &quot; COMPLETE_EXPROFIELDS

  INCLUDE LSVIMF2A .  &quot; COMPLETE_SUBSETFIELDS

  INCLUDE LSVIMF29 .  &quot; VIM_MULTI_LANGU_TEXT_ALS

  INCLUDE LSVIMF28 .  &quot; X_ENQUEUE

  INCLUDE LSVIMF27 .  &quot; ENQUEUE

  INCLUDE LSVIMF25 .  &quot; LISTE_ADDRESS_MAINTAIN

  INCLUDE LSVIMF24 .  &quot; ADDRESS_MAINTAIN

  INCLUDE LSVIMF23 .  &quot; ORIGINAL_HOLEN

  INCLUDE LSVIMF22 .  &quot; ORDER_ADMINISTRATION

  INCLUDE LSVIMF21 .  &quot; GET_TRANSP_INFO

  INCLUDE LSVIMF20 .  &quot; REQUEST_CORR_NUMBER

  INCLUDE LSVIMF1Z .  &quot; CHECK_LOCKABLE_OBJECT

  INCLUDE LSVIMF1Y .  &quot; CHECK_TRANSP_OBJS_FOR_MAINT

  INCLUDE LSVIMF1X .  &quot; PREPARE_CORR

  INCLUDE LSVIMF1W .  &quot; UPDATE_CORR

  INCLUDE LSVIMF1V .  &quot; VIM_ADDRESS_KEYTAB_ENTRIES

  INCLUDE LSVIMF1U .  &quot; VIM_ADDR_KEYTAB_ENTRIES_INTERN

  INCLUDE LSVIMF1T .  &quot; UPDATE_CORR_KEYTAB

  INCLUDE LSVIMF1S .  &quot; CORR_UPD

  INCLUDE LSVIMF1R .  &quot; TRANSPORTIEREN

  INCLUDE LSVIMF1Q .  &quot; GET_KEYTAB

  INCLUDE LSVIMF1P .  &quot; PREPARE_READ_REQUEST

  INCLUDE LSVIMF1O .  &quot; VIM_FILL_WHERETAB

  INCLUDE LSVIMF1N .  &quot; EDIT_VIEW_ENTRY

  INCLUDE LSVIMF1M .  &quot; ZURUECKHOLEN

  INCLUDE LSVIMF1L .  &quot; LOESCHEN

  INCLUDE LSVIMF1K .  &quot; DELETE_CHECK_KEYRANGE

  INCLUDE LSVIMF1J .  &quot; MARK_IGNORED_ENTRIES

  INCLUDE LSVIMF1H .  &quot; BUILD_VALTAB_HFIELDS

  INCLUDE LSVIMF1G .  &quot; CHECK_ALLOWED_KEYRANGES

  INCLUDE LSVIMF1F .  &quot; RESET_ENTRIES

  INCLUDE LSVIMF1E .  &quot; PROCESS_ENTRY_RESET

  INCLUDE LSVIMF1D .  &quot; PROCESS_AFTER_ENTRY_RESET

  INCLUDE LSVIMF1C .  &quot; UPGRADE

  INCLUDE LSVIMF1B .  &quot; VIM_RESTORE_SUBSET_CONDS

  INCLUDE LSVIMF1A .  &quot; VIM_PROCESS_VIEW_ENTRY

  INCLUDE LSVIMF19 .  &quot; VIM_MODIFY_VIEW_ENTRY

  INCLUDE LSVIMF18 .  &quot; VIM_SET_IMPRES_HEADER

  INCLUDE LSVIMF17 .  &quot; VIM_CONVERT_TABKEY

  INCLUDE LSVIMF16 .  &quot; VIM_IMP_CALL_SCREEN

  INCLUDE LSVIMF15 .  &quot; MOVE_EXTRACT_TO_VIEW_WA

  INCLUDE LSVIMF14 .  &quot; PREPARE_SAVING

  INCLUDE LSVIMF13 .  &quot; AFTER_SAVING

  INCLUDE LSVIMF12 .  &quot; BEFORE_LEAVING_EXT

  INCLUDE LSVIMF11 .  &quot; BEFORE_LEAVING_FRAME_FUNCTION

  INCLUDE LSVIMF10 .  &quot; LISTE_EXIT_COMMAND

  INCLUDE LSVIMF0Z .  &quot; VIM_GET_GLOBAL_TABLE

  INCLUDE LSVIMF0Y .  &quot; VIM_GET_GLOBAL_FIELD_VALUE

  INCLUDE LSVIMF0X .  &quot; VIM_SET_GLOBAL_FIELD_VALUE

  INCLUDE LSVIMF0W .  &quot; VIM_APPEND_GLOBAL_TABLE

  INCLUDE LSVIMF0V .  &quot; VIM_RESTORE_LOCAL_MEMORY

  INCLUDE LSVIMF0U .  &quot; X_CALL_VIEWMAINTENANCE

  INCLUDE LSVIMF0T .  &quot; X_CALL_SCREEN

  INCLUDE LSVIMF0S .  &quot; AFTER_TEMPORAL_DELIMITATION

  INCLUDE LSVIMF0R .  &quot; CHECK_DELIM_NEW_ENTRY

  INCLUDE LSVIMF0Q .  &quot; TEMP_DELIM_DEL_OVERLD_ENTRIES

  INCLUDE LSVIMF0P .  &quot; TEMP_DELIM_UNDELETE

  INCLUDE LSVIMF0O .  &quot; TEMPORAL_DELIMITATION

  INCLUDE LSVIMF0N .  &quot; TEMP_DELIM_DETERMINE_ACTION

  INCLUDE LSVIMF0M .  &quot; CONSISTENCY_PRT_FRKY_FIELDS

  INCLUDE LSVIMF0L .  &quot; DELIMITATION

  INCLUDE LSVIMF0K .  &quot; TIME_DEPENDENT_DISPLAY_MODIF

  INCLUDE LSVIMF0J .  &quot; COLLAPSE

  INCLUDE LSVIMF0I .  &quot; BUILD_MAINKEY_TAB

  INCLUDE LSVIMF0H .  &quot; BUILD_MAINKEY_TAB_0

  INCLUDE LSVIMF0G .  &quot; BUILD_MAINKEY_TAB_1

*  INCLUDE LSVIMF0E .  &quot; CHECK_IF_ENTRY_CAN_BE_MERGED

  INCLUDE LSVIMF0D .  &quot; BUILD_MAINKEY_TAB_2

  INCLUDE LSVIMF0C .  &quot; DELETE_FROM_MAINKEY_TAB

  INCLUDE LSVIMF0B .  &quot; CHECK_MODIFY_MERGED_ENTRIES

  INCLUDE LSVIMF0A .  &quot; X_REFRESH_TCTRL

  INCLUDE LSVIMF09 .  &quot; VIM_PROCESS_MESSAGE

  INCLUDE LSVIMF08 .  &quot; VIM_SET_IMP_RESULTS

  INCLUDE LSVIMF07 .  &quot; VIM_SINGLE_ENTRY_FILL_SELLIST

  INCLUDE LSVIMF06 .  &quot; UPDATE_STATUS

  INCLUDE LSVIMF05 .  &quot; SHOW_FUNCTION_DOCU

  INCLUDE LSVIMF04 .  &quot; LOGS_ANALYSE

  INCLUDE LSVIMF46.   &quot; VIM_ADDR_ADJUST  Abgleich für Adressen

  INCLUDE LSVIMF50.   &quot; Viewcluster: Navigation über Control

  INCLUDE LSVIMF51.   &quot; VIM_ADD_IMG_NOTICES  Editor-Control für Notizen
  INCLUDE LSVIMF5A.   &quot; Logging BC-set import
  INCLUDE LSVIMF5B.   &quot; Check before ALV
  include lsvimf5c.   &quot; VIM_SET_GLOBAL_OBJECTS
  include lsvimf5d.   &quot; VIM_MAINT_SELFLAG
  include lsvimf5e.   &quot; maintaining GUIDs
  INCLUDE LSVIMF5F.   &quot; vim_read_table
  include lsvimf60.   &quot; vim_maintain_single_set
  include lsvimf61.   &quot; map viewkey to texttabkey
  INCLUDE LSVIMF62.   &quot; vim_get_tabkeylen
  INCLUDE LSVIMF63.   &quot; VIM_COMP_ROOTTABKEY
  INCLUDE LSVIMF64.   &quot; VIM_Synchronizer_call
  INCLUDE LSVIMF65.   &quot; CHECK_NONKEY</include_source>
   </include>
   <include NAME="LSVIMITX" SUBC="I" CNAM="SAP" CDAT="19950113" UNAM="SAP" UDAT="20080721" VERN="     1" LEVL="21A" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122443" IDATE="20080721" ITIME="122443">
    <include_source>***INCLUDE LSVIMITX .
MODULE SET_TXT_UPDATE_FLAG.
  PERFORM SET_TXT_UPDATE_FLAG.
ENDMODULE.</include_source>
   </include>
   <include NAME="LSVIMIXX" SQLX="X" VARCL="X" SUBC="I" APPL="S" CNAM="SAP" CDAT="19950113" UNAM="SAP" UDAT="20080721" VERN="000048" LEVL="12A" RMAND="000" RLOAD="D" SDATE="20080721" STIME="122443" IDATE="20080721" ITIME="122443">
    <include_source>*---------------------------------------------------------------------*
*       MODULE SET_UPDATE_FLAG                                        *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
MODULE set_update_flag.

  DATA: lb_als TYPE REF TO IF_EX_VIM_ALS_BADI.

  CHECK status-action NE anzeigen AND  &quot;ignore wrong setted requestflags
        status-action NE transportieren. &quot;due to individual F4 modules
  IF x_header-delmdtflag NE space AND
     status-type EQ einstufig AND
     status-mode EQ list_bild.         &quot;only on list screen
* check if dates entered properly
    IF ( &lt;vim_new_begdate&gt; EQ vim_init_date OR
       &lt;vim_enddate_mask&gt; EQ vim_init_date ).
      MESSAGE e127(sv).&quot;Bitte den Gültigkeitsbereich eingrenzen
    ENDIF.
    CLEAR sy-subrc.
    IF status-action EQ kopieren AND vim_special_mode NE vim_delimit.
      READ TABLE vim_copied_indices WITH KEY level = vim_copy_call_level
                                                ex_ix = nextline.&quot;#EC *
    ENDIF.
    IF sy-subrc NE 0 OR       &quot;copy mode and entry not yet processed or
       ( status-action EQ hinzufuegen AND &lt;xact&gt; EQ leer ).  &quot;new entry
      neuer = &apos;J&apos;.
      IF x_header-guidflag &lt;&gt; space.
        PERFORM vim_make_guid using space.
      ENDIF.
      IF x_header-frm_on_new NE space.
        PERFORM (x_header-frm_on_new) IN PROGRAM.           &quot;#EC *
      ENDIF.
      PERFORM check_key.
      neuer = &apos;N&apos;.
    ENDIF.
  ENDIF.
  IF x_header-bastab NE space AND x_header-texttbexst NE space.
    TRANSLATE &lt;status&gt;-upd_flag USING &apos; ETX&apos;.
  ELSE.
    &lt;status&gt;-upd_flag = &apos;X&apos;.
  ENDIF.
* check in non key field entries violate selection conditions
  PERFORM check_nonkey.
* perform ALS if it is enabled
  CALL METHOD cl_exithandler=&gt;get_instance
    EXPORTING
      null_instance_accepted        = seex_false
      exit_name                     = &apos;VIM_ALS_BADI&apos;
    CHANGING
      instance                      = lb_als
    EXCEPTIONS
      no_reference                  = 1
      no_interface_reference        = 2
      no_exit_interface             = 3
      class_not_implement_interface = 4
      single_exit_multiply_active   = 5
      cast_error                    = 6
      exit_not_existing             = 7
      data_incons_in_exit_managem   = 8
      OTHERS                        = 9.
  IF sy-subrc NE 0.
    EXIT.
  ELSE.
    CALL METHOD lb_als-&gt;enable_als
      EXPORTING
        view_name   = x_header-viewname
      IMPORTING
        als_enabled = als_enabled.

    IF als_enabled = &apos;X&apos; AND x_header-bastab EQ space.
      PERFORM set_als_update_flag.
    ENDIF.
  ENDIF.

ENDMODULE.                    &quot;set_update_flag

*---------------------------------------------------------------------*
*       MODULE DETAIL_EXIT_COMMAND                                    *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
MODULE detail_exit_command.                                 &quot;#EC *
  PERFORM detail_exit_command.
ENDMODULE.                    &quot;detail_exit_command

*---------------------------------------------------------------------*
*       MODULE LISTE_EXIT_COMMAND                                     *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
MODULE liste_exit_command.
  PERFORM liste_exit_command.
ENDMODULE.                    &quot;liste_exit_command

*---------------------------------------------------------------------*
*       MODULE LISTE_AFTER_LOOP                                       *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
MODULE liste_after_loop.
** Table-control !!!
  IF vim_tabctrl_active NE space.
    IF nextline NE &lt;vim_tctrl&gt;-top_line.
      nextline = &lt;vim_tctrl&gt;-top_line.
    ENDIF.
  ENDIF.
** Table-control !!!
  IF destpage NE 0.
    nextline = destpage. CLEAR destpage.
  ENDIF.
* IF TEMPORAL_DELIMITATION_HAPPENED NE SPACE.
  IF vim_special_mode NE vim_upgrade AND
     vim_special_mode NE vim_delimit AND
     temporal_delimitation_happened NE space.
    PERFORM after_temporal_delimitation.
    CLEAR: temporal_delimitation_happened, vim_old_viewkey.
    TRANSLATE vim_no_mainkey_exists USING vim_no_mkey_not_procsd_patt.
  ENDIF.
  IF function IN mark_functions AND mark_extract EQ 0.
    MESSAGE s026(sv).                  &quot;Bitte vorher Einträge markieren
    LEAVE SCREEN.
  ENDIF.
  PERFORM update_status.
  IF vim_single_entry_function EQ &apos;INS&apos; AND
     vim_single_entry_ins_key_input NE space AND
     status-action EQ hinzufuegen.
    PERFORM vim_single_entry_fill_sellist.
  ENDIF.
  CLEAR: vim_next_screen, vim_leave_screen.
  CASE function.
    WHEN &apos;ADDR&apos;.
      PERFORM liste_address_maintain.
    WHEN &apos;AEND&apos;.
      PERFORM anzg_to_aend.
    WHEN &apos;ALCO&apos;.
      PERFORM selektiere USING transportieren.
    WHEN &apos;ALMK&apos;.
      PERFORM selektiere USING markiert.
    WHEN &apos;ALNC&apos;.
      PERFORM selektiere USING space.
    WHEN &apos;ALOE&apos;.
      PERFORM selektiere USING geloescht.
    WHEN &apos;ALNW&apos;.
      PERFORM selektiere USING neuer_eintrag.
    WHEN &apos;ANZG&apos;.
      PERFORM aend_to_anzg.
      vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
    WHEN &apos;ATAB&apos;.
      vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
    WHEN &apos;BACK&apos;.
      IF status-mode EQ list_bild AND status-data EQ gesamtdaten OR
        vim_single_entry_function NE space.
        vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
      ELSE.
        PERFORM liste_back.
      ENDIF.
    WHEN &apos;BCCH&apos;.                       &quot;change fix bc-set fields
      PERFORM vim_chng_fix_flds.
    WHEN &apos;BCSH&apos;.                        &quot; show fix bc-set fields
      PERFORM vim_bc_show_fix_flds.
    WHEN &apos;BCON&apos;.
      PERFORM selektiere USING bcset_only. &quot;show only data from bcset
    WHEN &apos;CMPO&apos;.
      PERFORM upgrade USING &apos;O&apos;.
    WHEN &apos;CMPR&apos;.
      PERFORM upgrade USING &apos;R&apos;.
    WHEN &apos;COMP&apos;.
      PERFORM upgrade USING space.
    WHEN &apos;DELE&apos;.
      PERFORM loeschen.
      IF replace_mode NE space.
        &lt;status&gt;-mk_to = mark_total.
        &lt;status&gt;-mk_xt = mark_extract.
        vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
      ENDIF.
    WHEN &apos;DELM&apos;.
      PERFORM delimitation.
    WHEN &apos;DETM&apos;.                       &quot;UFdetail
      PERFORM detail_markierte.
    WHEN &apos;DETA&apos;.
      PERFORM detailbild.
    WHEN &apos;ENDE&apos;.
      vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
    WHEN &apos;EXPA&apos;.
*     PERFORM TIME_DEPENDENT_DISPLAY_MODIF.
      IF x_header-delmdtflag EQ space.
        MESSAGE s001(sv). EXIT.
      ENDIF.
      PERFORM (vim_time_dep_dpl_modif_form) IN PROGRAM.     &quot;#EC *
    WHEN &apos;FDOC&apos;.                       &quot;HW Functiondocu
      PERFORM show_function_docu.
*    WHEN &apos;GPRF&apos;.                       &quot;UF Profile
* choose profile
*      CLEAR: &lt;status&gt;-prof_found, vim_pr_records.
*      PERFORM get_profiles USING &lt;status&gt;-prof_found.
    WHEN &apos;KOPE&apos;.
      counter = 0.
      PERFORM kopiere.
    WHEN &apos;KOPF&apos;.
      SET SCREEN 0. LEAVE SCREEN.
    WHEN &apos;LANG&apos;.                       &quot;SW Texttransl
      PERFORM vim_set_languages.
    WHEN &apos;MKAL&apos;.
      PERFORM markiere_alle USING markiert.
    WHEN &apos;MKBL&apos;.
      PERFORM markiere_block.
    WHEN &apos;MKEZ&apos;.
      PERFORM liste_markiere.
    WHEN &apos;MKLO&apos;.
      PERFORM markiere_alle USING nicht_markiert.
    WHEN &apos;NEWL&apos;.
      PERFORM hinzufuegen.
    WHEN &apos;NEXT&apos;.
      PERFORM naechster.
    WHEN &apos;ORDR&apos;.
      PERFORM order_administration.
    WHEN &apos;ORGI&apos;.
      PERFORM original_holen.
    WHEN &apos;POSI&apos;.
      PERFORM popup_positionieren.
    WHEN &apos;PREV&apos;.
      PERFORM voriger.
    WHEN &apos;PRMO&apos;.
* 4.6A: obsolete, left for individual status only
      PERFORM list_alv.
    WHEN &apos;PROT&apos;.
      PERFORM logs_analyse.
    WHEN &apos;PRST&apos;.
      PERFORM list_alv.
    WHEN &apos;P+  &apos;.
      PERFORM blaettern.
    WHEN &apos;P-  &apos;.
      PERFORM blaettern.
    WHEN &apos;P++ &apos;.
      PERFORM blaettern.
    WHEN &apos;P-- &apos;.
      PERFORM blaettern.
    WHEN &apos;REPL&apos;.
      PERFORM replace.
    WHEN &apos;SAVE&apos;.
      IF status-action EQ hinzufuegen.
*       SORT EXTRACT BY &lt;VIM_EXTRACT_KEY&gt;.  &quot;not nec. anymore
        &lt;status&gt;-firstline = firstline = &lt;status&gt;-cur_line = l = 1.
      ENDIF.
      vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
    WHEN &apos;SCRF&apos;.
      PERFORM vim_sapscript_form_maint.
    WHEN &apos;SEAR&apos;.
      PERFORM suchen.
    WHEN &apos;SELU&apos;.
      PERFORM selektiere USING aendern.
*    WHEN &apos;SPRF&apos;.                       &quot;UF Profile
* show chosen profile
*      PERFORM get_profiles USING &lt;status&gt;-prof_found.
    WHEN &apos;TEXT&apos;.                       &quot;SW Texttransl
      PERFORM vim_multi_langu_text_maint.
    WHEN &apos;TREX&apos;.
      MOVE geloescht TO corr_action.
      PERFORM update_corr.
      IF replace_mode NE space.
        &lt;status&gt;-mk_to = mark_total.
        &lt;status&gt;-mk_xt = mark_extract.
        vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
      ENDIF.
    WHEN &apos;TRIN&apos;.
      MOVE hinzufuegen TO corr_action.
      PERFORM update_corr.
      IF replace_mode NE space.
        &lt;status&gt;-mk_to = mark_total.
        &lt;status&gt;-mk_xt = mark_extract.
        vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
      ENDIF.
    WHEN &apos;TRSP&apos;.
      IF x_header-cursetting NE space AND
         x_header-flag EQ vim_transport_denied.
        x_header-flag = x_header-cursetting.
        TRANSLATE x_header-flag USING &apos;X YX&apos;.
        MODIFY x_header INDEX 1.                            &quot;#EC *
      ENDIF.
      vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
    WHEN &apos;UNDO&apos;.
*     PERFORM LISTE_ZURUECKHOLEN.
      PERFORM zurueckholen.
      IF replace_mode NE space.
        &lt;status&gt;-mk_to = mark_total.
        &lt;status&gt;-mk_xt = mark_extract.
        vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
      ENDIF.
    WHEN &apos;UPRF&apos;.                       &quot;UF Profile
* activate chosen profile
*      PERFORM activate_profile CHANGING &lt;status&gt;-prof_found.
      message s175(SV).
    WHEN &apos;    &apos;.
      IF vim_single_entry_function EQ &apos;INS&apos; AND
         status-action EQ hinzufuegen.
        PERFORM liste_back.
      ENDIF.
      IF replace_mode NE space.
        vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
      ENDIF.
    WHEN OTHERS.
      IF vim_called_by_cluster NE space.
        CALL FUNCTION &apos;VIEWCLUSTER_NEXT_ACTION&apos;
          IMPORTING
            leave_screen = vim_leave_screen
          CHANGING
            fcode        = function.
        IF vim_leave_screen NE space.
          vim_next_screen = 0.
        ENDIF.
      ENDIF.
  ENDCASE.
  IF vim_leave_screen NE space.
    CLEAR: vim_leave_screen, vim_act_dynp_view.
    SET SCREEN vim_next_screen. LEAVE SCREEN.
  ENDIF.
ENDMODULE.                    &quot;liste_after_loop

*---------------------------------------------------------------------*
*       MODULE LISTE_BEFORE_LOOP                                      *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
MODULE liste_before_loop.
  GET CURSOR FIELD f LINE l OFFSET o.
  function = ok_code.
  CLEAR: ok_code, &lt;status&gt;-upd_flag.
  IF vim_special_mode EQ vim_delete.
    SET SCREEN 0. LEAVE SCREEN.
  ENDIF.
* PERFORM READ_TABLE USING FIRSTLINE.
  IF replace_mode EQ space.
*   SET PF-STATUS &apos;ERRORLIS&apos;.
    PERFORM set_pf_status USING &apos;ERRORLIS&apos;.
*   CLEAR &lt;STATUS&gt;-UPD_FLAG.
    neuer = &apos;N&apos;.
    IF vim_called_by_cluster NE space.
      CALL FUNCTION &apos;VIEWCLUSTER_SET_OKCODE&apos;
        EXPORTING
          ok_code = function.
    ENDIF.
  ENDIF.
ENDMODULE.                    &quot;liste_before_loop

*---------------------------------------------------------------------*
*       MODULE DETAIL_PAI                                             *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
MODULE detail_pai.                                          &quot;#EC *
  CLEAR: vim_next_screen, vim_leave_screen.
  IF function EQ &apos;DETA&apos;.                                    &quot;GKPR - 0001009660
    CLEAR old_nl.                                           &quot;GKPR - 0001009660
  ENDIF.                                                    &quot;GKPR - 0001009660
  function = ok_code.
  PERFORM detail_pai.
  IF vim_leave_screen NE space.
    CLEAR: vim_leave_screen, vim_act_dynp_view.
    SET SCREEN vim_next_screen. LEAVE SCREEN.
  ENDIF.
ENDMODULE.                    &quot;detail_pai

*---------------------------------------------------------------------*
*       MODULE DETAIL_SET_PFSTATUS                                    *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
MODULE detail_set_pfstatus.                                 &quot;#EC *
  IF replace_mode EQ space.
*   SET PF-STATUS &apos;ERROR&apos;.
    PERFORM set_pf_status USING &apos;ERROR&apos;.
  ENDIF.
  IF x_header-delmdtflag NE space.
    EXPORT ok_code TO MEMORY ID vim_memory_id_2.            &quot;#EC *
  ENDIF.
ENDMODULE.                    &quot;detail_set_pfstatus

*---------------------------------------------------------------------*
*       MODULE LISTE_MARK_CHECKBOX                                    *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
MODULE liste_mark_checkbox.
  CHECK &lt;xact&gt; NE leer.
  CLEAR answer.
  IF vim_marked NE space AND &lt;xmark&gt; NE markiert.
    MOVE: markiert TO &lt;xmark&gt;, markiert TO answer.
    ADD: 1 TO mark_total, 1 TO mark_extract.
  ELSEIF vim_marked EQ space AND &lt;xmark&gt; NE nicht_markiert.
    MOVE: nicht_markiert TO &lt;xmark&gt;, markiert TO answer.
    IF mark_total GT 0.             &quot;HCG must not get negative HW785631
      SUBTRACT: 1 FROM mark_total.
    ENDIF.
    IF mark_extract GT 0.           &quot;HCG Must not get negative HW785631
      SUBTRACT: 1 FROM mark_extract.
    ENDIF.
  ENDIF.
  IF &lt;status&gt;-upd_flag EQ space AND answer NE space.  &quot;only mouse mark
    MOVE nextline TO index.
    READ TABLE total WITH KEY &lt;vim_xextract_key&gt; BINARY SEARCH.&quot;#EC *
    PERFORM vorhanden.
  ENDIF.
  CLEAR answer.
ENDMODULE.                    &quot;liste_mark_checkbox

*---------------------------------------------------------------------*
*       MODULE LISTE_INIT_WORKAREA                                    *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
MODULE liste_init_workarea.
  IF replace_mode NE space.
    IF vim_special_mode EQ vim_upgrade.
      &lt;table2_x&gt; = &lt;vim_xtotal&gt;.
    ELSEIF vim_special_mode EQ vim_replace.
      CLEAR &lt;replace_field&gt;.
    ENDIF.
  ENDIF.
  PERFORM move_extract_to_view_wa.
  MOVE nextline TO exind.
  CLEAR vim_pr_activating.
  IF &lt;xact&gt; = profil_hinzufuegen.      &quot;UFprofiles begin
* Set update flags
    &lt;table2_x&gt; = &lt;initial_x&gt;.
    &lt;xact&gt; = leer.
    vim_pr_activating = &apos;X&apos;.
    MODIFY extract INDEX sy-stepl.                          &quot;#EC *
    IF x_header-bastab NE space AND x_header-texttbexst NE space.
      &lt;status&gt;-upd_flag = &apos;E&apos;.
    ELSE.
      &lt;status&gt;-upd_flag = &apos;X&apos;.
    ENDIF.
  ENDIF.                               &quot;UFprofiles end
  CLEAR: vim_key_alr_checked, vim_keyrange_alr_checked.
ENDMODULE.                    &quot;liste_init_workarea

*---------------------------------------------------------------------*
*       MODULE LISTE_UPDATE_LISTE                                     *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
MODULE liste_update_liste.
  CHECK status-action NE anzeigen.
  CHECK status-action NE transportieren.
  CHECK status-delete NE geloescht.
  IF ok_code NE &apos;IGN &apos;.
    IF x_header-ptfrkyexst NE space.
      PERFORM consistency_prt_frky_fields
                                   USING vim_show_consistency_alert.
    ENDIF.
    CASE status-action.                &quot;UFprofile
      WHEN kopieren.                   &quot;UFprofile
        READ TABLE vim_copied_indices WITH KEY level = vim_copy_call_level
                                                     ex_ix = nextline.&quot;#EC *
        IF sy-subrc EQ 0.              &quot;entry alr. processed
          &lt;xact&gt; = neuer_eintrag.
          PERFORM update_tab.
        ELSE.
          PERFORM kopiere_eintrag USING &lt;orig_key&gt;.
        ENDIF.
      WHEN OTHERS.
        PERFORM update_tab.
    ENDCASE.
  ELSE.
    PERFORM set_pf_status USING &apos;ERRORLIS&apos;.
  ENDIF.
  IF replace_mode EQ space.
    CLEAR ok_code.
  ENDIF.
ENDMODULE.                    &quot;liste_update_liste

*---------------------------------------------------------------------*
*       MODULE TEMP_DELIMITATION                                      *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
MODULE temp_delimitation.                                   &quot;#EC *
  DATA: td_addr_safe LIKE adrc-addrnumber.                  &quot;#EC *
  CHECK x_header-delmdtflag NE space.
* set update flag (if begdate not in the set_update_flag-chain)
  CHECK status-action NE anzeigen AND  &quot;ignore wrong set requestflags
        status-action NE transportieren. &quot;due to individual F4 modules
  IF x_header-bastab NE space AND x_header-texttbexst NE space.
    &lt;status&gt;-upd_flag = &apos;E&apos;.
  ELSE.
    &lt;status&gt;-upd_flag = &apos;X&apos;.
  ENDIF.
* process delimitation
  vim_begdate_entered = &apos;X&apos;.
  PERFORM temporal_delimitation.
  IF temporal_delimitation_happened EQ &apos;X&apos; AND
     x_header-delmdtflag EQ &apos;B&apos;.
    IF x_header-adrnbrflag = space.
      MOVE: &lt;vim_xtotal_key&gt; TO &lt;f1_x&gt;,
            &lt;vim_begdate&gt; TO &lt;vim_new_begdate&gt;.
    ELSE.
      MOVE: &lt;address_number&gt; TO td_addr_safe,
            &lt;vim_xtotal_key&gt; TO &lt;f1_x&gt;,
            td_addr_safe TO &lt;address_number&gt;,
            &lt;vim_begdate&gt; TO &lt;vim_new_begdate&gt;.
    ENDIF.
  ENDIF.
ENDMODULE.                    &quot;temp_delimitation

*---------------------------------------------------------------------*
*       MODULE CONSISTENCY                                            *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
MODULE consistency.                                         &quot;#EC *
  EXIT.
* CHECK STATUS-MODE NE DETAIL_BILD.
* PERFORM CONSISTENCY_PRT_FRKY_FIELDS USING &apos;X&apos;.
ENDMODULE.                             &quot;consistency

*&amp;---------------------------------------------------------------------*
*&amp;      Module  VCL_HELP_VALUES  INPUT
*&amp;---------------------------------------------------------------------*
* Modul zum Ereignis &apos;Process On Value-Request&apos; innerhalb der          *
* Viewcluster-Pflege:
* Realisierung von F4 auf ein Feld, dessen Prüftabelle im selben
* Viewcluster gepflegt wird.
*----------------------------------------------------------------------*
MODULE vcl_help_values INPUT.                               &quot;#EC *
  DATA: vcl_event(3) .
  CLEAR: f, vim_object, vim_objfield.
* POV-Module, die an List-Boxen hängen, werden schon zum Zeitpunkt
* CONTROL OUT gerufen. Hier kann das betroffene Feld nicht über
* die Cursor-Position ermittelt werden.
  CALL &apos;DY_GET_DYNPRO_EVENT&apos; ID &apos;EVENT&apos; FIELD vcl_event.
  IF sy-subrc = 0 AND vcl_event = &apos;OUT&apos;.
*   Aufruf zum Zeitpunkt Control Output
    MESSAGE i538(sv) WITH vim_calling_cluster view_name.
    EXIT.
  ENDIF.

  IF status-mode = &apos;L&apos;.                &quot; Listbild
    GET CURSOR FIELD f LINE l.
  ELSE.                                &quot; Detailbild
    GET CURSOR FIELD f.
  ENDIF.
  SPLIT f AT &apos;-&apos; INTO vim_object vim_objfield.
  IF vim_objfield IS INITIAL.
    MESSAGE s084(sv).
  ELSE.
    CALL FUNCTION &apos;VIEWCLUSTER_HELP_VALUES_NEW&apos;
      EXPORTING
        object    = vim_object
        fieldname = vim_objfield
      EXCEPTIONS
        OTHERS    = 1.
    IF sy-subrc &lt;&gt; 0.
      MESSAGE s084(sv).
    ENDIF.
  ENDIF.
ENDMODULE.                             &quot; VCL_HELP_VALUES  INPUT</include_source>
   </include>
   <include NAME="LSVIMOXX" SQLX="X" VARCL="X" SUBC="I" APPL="S" CNAM="SAP" CDAT="19950113" UNAM="SAP" UDAT="20080721" VERN="000057" LEVL="12A" RMAND="000" RLOAD="D" SDATE="20080721" STIME="122443" IDATE="20080721" ITIME="122443">
    <include_source>*---------------------------------------------------------------------*
*       MODULE DETAIL_INIT           OUTPUT                           *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
MODULE detail_init OUTPUT.
  IF vim_called_by_cluster &lt;&gt; space.                        &quot;SW CTRL ..
    PERFORM vim_vcldocking_control.
  ENDIF.                               &quot;.. SW CTRL
  PERFORM vim_add_img_notices_pbo USING x_header-detail.
  PERFORM detail_init.
  IF ( replace_mode NE space AND
   neuer NE &apos;X&apos; )         &quot;no error in CHECK_KEY for timedep. objects
   OR vim_pr_activating &lt;&gt; space.                           &quot;UF profile
    SUPPRESS DIALOG.
  ENDIF.
  PERFORM vim_modify_detail_screen.
ENDMODULE.                    &quot;detail_init OUTPUT

*---------------------------------------------------------------------*
*       MODULE VIM_MODIF_DETAIL         OUTPUT                        *
*---------------------------------------------------------------------*
* Modifikation der Screen-Attribute für Tabstrip-Screens              *
*---------------------------------------------------------------------*
MODULE vim_modif_detail OUTPUT.
  PERFORM vim_modify_detail_screen.
ENDMODULE.                    &quot;vim_modif_detail OUTPUT

*---------------------------------------------------------------------*
*       MODULE LISTE_SHOW_LISTE OUTPUT                                *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
MODULE liste_show_liste OUTPUT.

** Table-control !!!   &quot;bis der Fehler behoben ist
  IF vim_tabctrl_active NE space.
    IF &lt;vim_tctrl&gt;-current_line GT maxlines AND  &quot;no more entries
       &lt;xact&gt; NE leer.                 &quot;in EXTRACT and no new entry
      EXIT FROM STEP-LOOP.
    ENDIF.
  ENDIF.
** Table-control !!!
  looplines = sy-loopc.
  IF l GT looplines.
    counter = ( l - firstline ) DIV looplines + 1.
    DO counter TIMES.
      firstline = firstline + looplines - 1.
    ENDDO.
    MOVE firstline TO &lt;status&gt;-firstline.
    &lt;status&gt;-cur_line = l = l - firstline + 1.
    SET CURSOR FIELD f LINE l OFFSET o.
  ENDIF.
  IF vim_special_mode NE vim_upgrade AND
     status-action EQ hinzufuegen AND maxlines EQ 0 AND sy-stepl EQ 1.
    DESCRIBE TABLE extract.
    IF sy-tfill GT looplines.
      sy-tfill = looplines + 1.
      LOOP AT extract FROM sy-tfill.
        DELETE extract.
      ENDLOOP.
      nbr_of_added_dummy_entries = looplines.
    ENDIF.
  ENDIF.
* dataset locked by key-specific synchronizer lock?
  IF vim_sync_keyspec_check NE space.
    perform check_sync_key_lock using &apos; &apos;
                                changing vim_sync_key_lock.
  ENDIF.
* dataset from BC-set? --&gt; get field parameters
  CLEAR vim_set_from_bc_pbo.
  IF replace_mode = space AND status-action = aendern
   AND vim_bc_chng_allowed = space.  &quot;fix field changeability forced
    READ TABLE vim_bc_entry_list INTO vim_bc_entry_list_wa
     WITH TABLE KEY viewname = x_header-maintview           &quot;HCG 9/04
     keys = &lt;vim_xextract_key&gt;.
    IF sy-subrc = 0.
      vim_set_from_bc_pbo = &apos;X&apos;.
    ENDIF.
  ENDIF.
  IF replace_mode NE space OR vim_special_mode EQ vim_delete.&quot;aro
    IF sy-stepl GT 1.
      EXIT FROM STEP-LOOP.
    ELSE.
      MOVE &lt;vim_xtotal&gt; TO &lt;table2_x&gt;.
    ENDIF.
  ENDIF.                                                    &quot;aro
  index = exind = nextline.
  IF status-action EQ kopieren AND status-type EQ einstufig.
    READ TABLE vim_copied_indices WITH KEY level = vim_copy_call_level
                                           ex_ix = nextline.
    IF sy-subrc EQ 0.                  &quot;entry already copied
      READ TABLE total INDEX vim_copied_indices-ix.
      extract = total. neuer = &apos;N&apos;.
    ELSE.
      neuer = &apos;J&apos;.
    ENDIF.
  ENDIF.
  PERFORM move_extract_to_view_wa.
  IF vim_special_mode EQ vim_delimit.
    MOVE vim_sval_tab-value TO &lt;vim_new_begdate&gt;.
  ENDIF.
  IF status-action EQ hinzufuegen AND status-type EQ einstufig AND
     neuer NE &apos;J&apos; AND &lt;xact&gt; EQ leer.
    neuer = &apos;J&apos;.
  ENDIF.
  IF &lt;xmark&gt; EQ markiert.
    MOVE &apos;X&apos; TO vim_marked.
  ENDIF.
  LOOP AT SCREEN.
    CLEAR vim_modify_screen.
    SPLIT screen-name AT &apos;-&apos; INTO vim_object vim_objfield.
    IF ( status-action EQ anzeigen OR status-action EQ transportieren OR
            status-delete EQ geloescht ) AND screen-name NE &apos;VIM_MARKED&apos;.
      screen-input = &apos;0&apos;. vim_modify_screen = &apos;X&apos;.
    ELSEIF status-action EQ kopieren AND screen-name NE &apos;VIM_MARKED&apos; AND
           screen-group1 NE &apos;KEY&apos; AND function NE &apos;DELM&apos;.   &quot;864431
      screen-request = 1. vim_modify_screen = &apos;X&apos;.
    ELSE.
      IF screen-group1 EQ &apos;KEY&apos;.
        IF vim_tabctrl_active NE space AND screen-input EQ &apos;0&apos;.
          READ TABLE &lt;vim_tctrl&gt;-cols INTO vim_tc_cols
                                       WITH KEY
                                            screen-name = screen-name
                                       TRANSPORTING screen-required.
          IF sy-subrc EQ 0 AND
             screen-required NE vim_tc_cols-screen-required.
            screen-required = vim_tc_cols-screen-required.
            vim_modify_screen = &apos;X&apos;.
          ENDIF.
        ENDIF.
        IF screen-required NE 0 AND screen-input NE &apos;0&apos;.
          screen-input = &apos;0&apos;. vim_modify_screen = &apos;X&apos;.
        ENDIF.
        IF vim_single_entry_function EQ &apos;INS&apos;.
          screen-request = 1. vim_modify_screen = &apos;X&apos;.
        ENDIF.
* int. mess. 1757218/1999: no foreign-key check with copy
        IF status-action = kopieren.
          screen-request = 1. vim_modify_screen = &apos;X&apos;.
        ENDIF.
* int. mess. 1757218/1999: no foreign-key check with copy: end
      ENDIF.
*     IF NEUER EQ &apos;J&apos; OR STATUS-ACTION EQ KOPIEREN.
      IF neuer EQ &apos;J&apos;.
        IF vim_special_mode NE vim_delimit AND
           screen-group1 EQ &apos;KEY&apos; AND
           ( vim_single_entry_function NE &apos;INS&apos; OR
               vim_single_entry_ins_key_input NE space ) AND
           ( x_header-existency NE &apos;M&apos; OR
             screen-name EQ vim_enddate_name ).
          ADD 1 TO pos.
          IF pos EQ 1.
            SET CURSOR FIELD screen-name LINE sy-stepl.
          ENDIF.
          screen-input = &apos;1&apos;. vim_modify_screen = &apos;X&apos;.
        ENDIF.
        IF screen-name EQ &apos;VIM_MARKED&apos;.
          screen-input = &apos;0&apos;. vim_modify_screen = &apos;X&apos;.
        ELSE.
          IF &lt;xact&gt; = profil_hinzufuegen.
            READ TABLE vim_pr_fields_wa-fields WITH TABLE KEY
             fieldname = vim_objfield TRANSPORTING NO FIELDS.
            IF sy-subrc = 0.
              screen-request = 1. vim_modify_screen = &apos;X&apos;.
            ENDIF.
          ENDIF.
          IF vim_special_mode EQ vim_upgrade AND function NE &apos;DELE&apos;.
            IF &lt;status&gt;-prof_found = vim_pr_into_view &quot;UFprofiles begin
             AND status-action = hinzufuegen AND screen-group1 = &apos;KEY&apos;.
              PERFORM set_profile_key_attributes USING vim_objfield
                                                 CHANGING screen-input
                                                      vim_modify_screen.
            ENDIF.                     &quot;UFprofiles end
            screen-request = 1. vim_modify_screen = &apos;X&apos;.
          ENDIF.
        ENDIF.
      ELSE.
        IF x_header-delmdtflag NE space AND
           x_header-existency EQ &apos;U&apos; AND
           screen-name EQ vim_begdate_name.
          screen-input = &apos;0&apos;. vim_modify_screen = &apos;X&apos;.
        ENDIF.
        IF f EQ space AND screen-name NE &apos;VIM_MARKED&apos; AND
           screen-input EQ &apos;1&apos;.
          SET CURSOR FIELD screen-name LINE l.
          f = screen-name.
        ENDIF.
        IF replace_mode NE space.
          CASE vim_special_mode.
            WHEN vim_replace.
              IF screen-name EQ sel_field_for_replace_l.
                screen-request = 1. vim_modify_screen = &apos;X&apos;.
              ENDIF.
            WHEN vim_upgrade.
              IF NOT function IN exted_functions AND
                 screen-name NE &apos;VIM_MARKED&apos;.
                screen-request = 1. vim_modify_screen = &apos;X&apos;.
              ENDIF.
              screen-input = &apos;1&apos;. vim_modify_screen = &apos;X&apos;.
          ENDCASE.
        ELSE.
          IF vim_special_mode EQ vim_delete.
            screen-input = &apos;0&apos;. vim_modify_screen = &apos;X&apos;.
          ENDIF.
* Dataset locked by key-specific synchronizer lock?
          IF vim_sync_key_lock NE space AND screen-group1 &lt;&gt; &apos;KEY&apos; AND
                                            screen-name NE &apos;VIM_MARKED&apos;.
            screen-input = 0.
            vim_modify_screen  = &apos;X&apos;.
          ENDIF.
          IF vim_set_from_bc_pbo &lt;&gt; space AND screen-group1 &lt;&gt; &apos;KEY&apos;.
* Dataset comes from BC-set -&gt; check field parameter
            PERFORM vim_bc_logs_use USING    vim_objfield
                                             vim_bc_entry_list_wa
                                    CHANGING screen
                                             vim_modify_screen.
          ENDIF.
        ENDIF.                         &quot;replace_mode &lt;&gt; space
      ENDIF.                           &quot;neuer = &apos;J&apos;
    ENDIF.                             &quot;update mode
    IF &lt;xmark&gt; EQ markiert AND screen-name NE &apos;VIM_MARKED&apos;.
      screen-intensified = 1. vim_modify_screen = &apos;X&apos;.
    ENDIF.
    IF vim_special_mode EQ vim_delimit AND
       screen-name EQ vim_begdate_name.
      screen-request = 1. vim_modify_screen = &apos;X&apos;.
    ENDIF.
*   IF X_HEADER-RDONLYFLAG = &apos;X&apos; AND                      &quot;Subviews ..
*      X_HEADER-MAINTVIEW &lt;&gt; X_HEADER-VIEWNAME.
    IF vim_objfield &lt;&gt; space AND vim_object = x_header-maintview.
      LOOP AT x_namtab WHERE viewfield = vim_objfield AND
                          ( texttabfld = space OR keyflag = space ).
        IF x_namtab-readonly = vim_hidden.
          screen-active = &apos;0&apos;. vim_modify_screen = &apos;X&apos;.
        ELSEIF x_namtab-readonly = rdonly.
          screen-input = &apos;0&apos;. vim_modify_screen = &apos;X&apos;.
        ENDIF.
        EXIT.
      ENDLOOP.
    ENDIF.
*   ENDIF.                                                  &quot;.. Subviews
    IF vim_modify_screen = &apos;X&apos;.
      MODIFY SCREEN.
    ENDIF.
  ENDLOOP.
  IF vim_special_mode EQ vim_delete.
    SET CURSOR FIELD f LINE 1 OFFSET o. &quot;Always just 1 line in TC
  ENDIF.
  IF status-action EQ kopieren.
    neuer = &apos;N&apos;.
  ENDIF.
ENDMODULE.                    &quot;liste_show_liste OUTPUT

*---------------------------------------------------------------------*
*       MODULE LISTE_INITIALISIEREN OUTPUT                            *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
MODULE liste_initialisieren OUTPUT.
  IF vim_called_by_cluster &lt;&gt; space.                        &quot;SW CTRL ..
    PERFORM vim_vcldocking_control.
  ENDIF.                               &quot;.. SW CTRL
  status-mode = list_bild.
  title-mode  = list_bild.
  firstline = nextline.
  aktuell = firstline.
  vim_act_dynp_view = x_header-viewname.
  PERFORM vim_add_img_notices_pbo USING x_header-liste.
  IF vim_special_mode EQ vim_direct_upgrade.
    SUPPRESS DIALOG.
    ok_code = function = &apos;CMPR&apos;.
    EXIT.
  ENDIF.
  CLEAR &lt;status&gt;-mark_only.                                 &quot;ufdetail
  IF replace_mode NE space OR vim_special_mode EQ vim_delete.
    PERFORM set_title USING title &lt;name&gt;.
    IF vim_special_mode NE vim_delete. SUPPRESS DIALOG. ENDIF.
    PERFORM set_pf_status USING &apos;REPLACE&apos;.
    MOVE &lt;table1&gt; TO &lt;vim_total_struc&gt;.
*    MOVE &lt;table1&gt; TO total.
    IF x_header-bastab NE space AND x_header-texttbexst NE space.
      MOVE &lt;table1_text&gt; TO &lt;vim_tot_txt_struc&gt;.
    ENDIF.
** Table-control !!!
    IF vim_tabctrl_active NE space.
      IF status-action EQ hinzufuegen.
        &lt;vim_tctrl&gt;-lines = maxlines + nbr_of_added_dummy_entries.
      ELSE.
        &lt;vim_tctrl&gt;-lines = maxlines.
      ENDIF.
      &lt;vim_tctrl&gt;-top_line = firstline.
      LOOP AT &lt;vim_tctrl&gt;-cols INTO vim_tc_cols
                               WHERE screen-active EQ 0.
        vim_tc_cols-vislength = 0.
        MODIFY &lt;vim_tctrl&gt;-cols FROM vim_tc_cols.
      ENDLOOP.
    ENDIF.
    EXIT.
  ENDIF.
  IF mark_extract GT 0.
    status-mark = markiert.
  ELSE.
    status-mark = nicht_markiert.
  ENDIF.
  IF maxlines EQ 0.
    IF status-action NE hinzufuegen
    OR status-type NE einstufig.
      PERFORM fill_extract.
    ELSE.                                                   &quot;aro
      title-data = auswahldaten.                            &quot;aro
    ENDIF.                                                  &quot;aro
    status-delete = nicht_geloescht.
    PERFORM vim_send_sv005_or_sv766 USING &apos;766&apos;
                                          &apos;RESET&apos;.
  ELSEIF maxlines = 1 AND function &lt;&gt; &apos;UEBE&apos;.
* Viewcluster: jump into single screen also if view is chosen for
* the 2nd time
    PERFORM vim_maintain_single_set.         &quot;UFint2329966/2000
* Notlösung Sortproblem Hinzufügen Anfang
  ELSE.
    PERFORM vim_send_sv005_or_sv766 USING &apos;766&apos;
                                          &apos;RESET&apos;.
    IF status-action EQ hinzufuegen.
      pos = 1.
      LOOP AT extract.
        CHECK &lt;xact&gt; NE leer.
        IF sy-tabix NE pos.
          DELETE extract.
          INSERT extract INDEX pos.
        ENDIF.
        ADD 1 TO pos.
      ENDLOOP.
    ENDIF.
* Notlösung Sortproblem Hinzufügen Ende
  ENDIF.
  maximal = maxlines.
** Table-control !!!
  IF vim_tabctrl_active NE space.
    IF status-action EQ hinzufuegen.
      &lt;vim_tctrl&gt;-lines = maxlines + nbr_of_added_dummy_entries.
    ELSE.
      &lt;vim_tctrl&gt;-lines = maxlines.
    ENDIF.
    &lt;vim_tctrl&gt;-top_line = firstline.
    LOOP AT &lt;vim_tctrl&gt;-cols INTO vim_tc_cols
*                            WHERE SCREEN-INVISIBLE EQ 1
*                              OR  SCREEN-ACTIVE EQ 0.
                             WHERE screen-active EQ 0.
      vim_tc_cols-vislength = 0.
      MODIFY &lt;vim_tctrl&gt;-cols FROM vim_tc_cols.
    ENDLOOP.
* Notlösung Markierbarkeit beim Hinzufügen bzw. Kopieren
*   IF STATUS-ACTION EQ HINZUFUEGEN OR STATUS-ACTION EQ KOPIEREN.
*     &lt;VIM_TCTRL&gt;-LINE_SEL_MODE = 0.
*   ELSE.
**    &lt;VIM_TCTRL&gt;-LINE_SEL_MODE = 2.
*     &lt;VIM_TCTRL&gt;-LINE_SEL_MODE = &lt;STATUS&gt;-L_SEL_MODE.
*   ENDIF.
  ELSE.                                &quot;Subviews ..
    LOOP AT SCREEN.
      SPLIT screen-name AT &apos;-&apos; INTO vim_object vim_objfield.
      IF vim_objfield &lt;&gt; space AND vim_object = x_header-maintview.
        LOOP AT x_namtab WHERE viewfield = vim_objfield AND
                            ( texttabfld = space OR keyflag = space ).
          IF x_namtab-readonly = vim_hidden.
            screen-active = &apos;0&apos;. MODIFY SCREEN.
          ELSEIF x_namtab-readonly = rdonly.
            screen-input = &apos;0&apos;. MODIFY SCREEN.
          ENDIF.
          EXIT.
        ENDLOOP.
      ENDIF.
    ENDLOOP.                           &quot;.. Subviews
  ENDIF.
** Table-control !!!
  PERFORM set_position_info USING firstline maxlines.
  pos = maxlines - firstline + 1.
  IF l GT pos.
    l = 1.
  ENDIF.
  pos = 0.                                                  &quot;aro
  IF f EQ space AND fcode EQ edit AND x_header-subsetflag EQ space.
    LOOP AT SCREEN.
      SPLIT screen-name AT &apos;-&apos; INTO vim_object vim_objfield.
      IF vim_object = x_header-viewname.
        f = screen-name.
        EXIT.
      ENDIF.
    ENDLOOP.
  ENDIF.
  SET CURSOR FIELD f LINE l OFFSET o.
  PERFORM set_pf_status USING status.
  PERFORM set_title USING title &lt;name&gt;.
* Notlösung Batch-Input Anfang
  IF maxlines EQ 0.
    LOOP AT SCREEN.
      CHECK screen-name EQ &apos;VIM_POSI_PUSH&apos;.
      screen-input = 0.
      MODIFY SCREEN.
      EXIT.
    ENDLOOP.
  ENDIF.
* Notlösung Batch-Input Ende
  IF status-action EQ kopieren OR vim_single_entry_function NE space.
    LOOP AT SCREEN.
      CHECK screen-name EQ &apos;VIM_POSI_PUSH&apos;.
      screen-active = 0.
      MODIFY SCREEN.
      EXIT.
    ENDLOOP.
  ENDIF.
* Fill cache in sync function for key-specific synchronizer locks?
  IF vim_sync_keyspec_check NE space.
    perform check_sync_key_lock using &apos;X&apos;
                                changing vim_sync_key_lock.
  ENDIF.
ENDMODULE.                    &quot;liste_initialisieren OUTPUT

*---------------------------------------------------------------------*
*       MODULE FILL_SUBSTFLDS OUTPUT                                  *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
MODULE fill_substflds OUTPUT.
  CHECK x_header-subsetflag NE space.
  PERFORM fill_subsetfields.
ENDMODULE.                    &quot;fill_substflds OUTPUT

*---------------------------------------------------------------------*
*       MODULE LISTE_DEACTIVATE OUTPUT                                *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
MODULE liste_deactivate OUTPUT.
  CHECK &lt;xact&gt; NE leer AND status-action NE kopieren.
  LOOP AT SCREEN.
    CHECK screen-group2 EQ &apos;EZN&apos; .
    IF x_header-ptfrkyexst EQ space.
      MOVE screen-name TO f.
      SHIFT f UP TO &apos;-&apos;. SHIFT f.
      LOOP AT x_namtab WHERE keyflag EQ space  &quot;ignore keyfields
                         AND viewfield EQ f.
        MOVE &apos;X&apos; TO x_namtab-prtfrkyfld.
        MOVE &apos;X&apos; TO x_header-ptfrkyexst.
        MODIFY x_namtab.
      ENDLOOP.
    ENDIF.
    CHECK sy-stepl NE 1 AND
    &lt;vim_f1_beforex&gt; EQ &lt;vim_mkey_beforex&gt; AND
    ( vim_mkey_after_exists EQ space OR
      &lt;vim_f1_afterx&gt; EQ &lt;vim_mkey_afterx&gt; ).
*    &lt;vim_f1_before&gt; eq &lt;vim_mkey_before&gt; and
*    ( vim_mkey_after_exists eq space or
*      &lt;vim_f1_after&gt; eq &lt;vim_mkey_after&gt; ).
    screen-active = 0.
    MODIFY SCREEN.
  ENDLOOP.
  MODIFY x_header INDEX 1.
  IF vim_no_mainkey_exists EQ vim_no_mkey_not_procsd OR
    &lt;vim_f1_beforex&gt; NE &lt;vim_mkey_beforex&gt; OR
    ( vim_mkey_after_exists NE space AND
      &lt;vim_f1_afterx&gt; NE &lt;vim_mkey_afterx&gt; ).
*     &lt;vim_f1_before&gt; ne &lt;vim_mkey_before&gt; or
*     ( vim_mkey_after_exists ne space and
*       &lt;vim_f1_after&gt; ne &lt;vim_mkey_after&gt; ).
    &lt;vim_h_mkey&gt;(x_header-keylen) = &lt;f1_x&gt;.
*    vim_mainkey = &lt;f1&gt;.
    TRANSLATE vim_no_mainkey_exists USING vim_no_mkey_procsd_patt.
  ENDIF.
ENDMODULE.                             &quot;liste_deactivate.

*---------------------------------------------------------------------*
*       MODULE VIM_SUPPRESS_LISTE OUTPUT                              *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
MODULE vim_suppress_liste OUTPUT.
  CHECK vim_special_mode &lt;&gt; vim_direct_upgrade AND
        function NE space AND function NE &apos;ANZG&apos; AND
        function NE &apos;AEND&apos; AND &quot;function NE &apos;ABR &apos; AND
        NOT ( vim_called_by_cluster NE space AND
             ( function CP &apos;DET*&apos; OR  function CP &apos;%_*&apos; ) ).
  SUPPRESS DIALOG.
  ok_code = back.
ENDMODULE.                             &quot;vim_suppres_liste</include_source>
   </include>
   <include NAME="LSVIMTDT" VARCL="X" SUBC="I" APPL="S" CNAM="SAP" CDAT="19950113" UNAM="SAP" UDAT="20080721" VERN="000007" LEVL="21A" RMAND="000" RLOAD="D" FIXPT="X" SDATE="20080721" STIME="122443" IDATE="20080721" ITIME="122443">
    <include_source>***INCLUDE LSVIMTDT .
DATA:
* Tabelle für die DB-Zeilen, Ultra Long
  BEGIN OF EXTRACT_UL OCCURS 0,
        LINE(4096),
      END OF EXTRACT_UL,
* Tabelle für die DB-Zeilen, Very Long
  BEGIN OF EXTRACT_VL OCCURS 0,
        LINE(512),
      END OF EXTRACT_VL,
* Tabelle für die DB-Zeilen, Long
  BEGIN OF EXTRACT_L OCCURS 0,
        LINE(256),
      END OF EXTRACT_L,
* Tabelle für die DB-Zeilen, Middle
  BEGIN OF EXTRACT_M OCCURS 0,
        LINE(128),
      END OF EXTRACT_M,
* Tabelle für die DB-Zeilen, Short
  BEGIN OF EXTRACT_S OCCURS 0,
        LINE(64),
      END OF EXTRACT_S,
* Tabelle für die DB-Zeilen, Very Short
  BEGIN OF EXTRACT_VS OCCURS 0,
        LINE(48),
      END OF EXTRACT_VS,
* Tabelle für die DB-Zeilen, Ultra Short
  BEGIN OF EXTRACT_US OCCURS 0,
        LINE(32),
      END OF EXTRACT_US.

* Table for all entries loaded from database
DATA:
* Tabelle für die DB-Zeilen, Ultra Long
  BEGIN OF TOTAL_UL OCCURS 0,
        LINE(4096),
      END OF TOTAL_UL,
* Tabelle für die DB-Zeilen, Very Long
  BEGIN OF TOTAL_VL OCCURS 0,
        LINE(512),
      END OF TOTAL_VL,
* Tabelle für die DB-Zeilen, Long
  BEGIN OF TOTAL_L OCCURS 0,
        LINE(256),
      END OF TOTAL_L,
* Tabelle für die DB-Zeilen, Middle
  BEGIN OF TOTAL_M OCCURS 0,
        LINE(128),
      END OF TOTAL_M,
* Tabelle für die DB-Zeilen, Short
  BEGIN OF TOTAL_S OCCURS 0,
        LINE(64),
      END OF TOTAL_S,
* Tabelle für die DB-Zeilen, Very Short
  BEGIN OF TOTAL_VS OCCURS 0,
        LINE(48),
      END OF TOTAL_VS,
* Tabelle für die DB-Zeilen, Ultra Short
  BEGIN OF TOTAL_US OCCURS 0,
        LINE(32),
      END OF TOTAL_US.

* Tabelle mit den modifizierten Elementen

DATA: BEGIN OF MOD_ELEM_TAB OCCURS 100,
        LINES(4096),
      END OF MOD_ELEM_TAB.

*ATA: FORBIDDEN_FUNC_NAME_CHARS(10) VALUE &apos;/\$!§%&amp;&apos;&apos;##&apos;,   &quot;#EC *
*     FORBIDDEN_AREA_NAME_CHARS(10) VALUE &apos;/\$!§%&amp;&apos;&apos;##&apos;.   &quot;#EC *
DATA: FORBIDDEN_FUNC_NAME_CHARS(9) VALUE &apos;\$!§%&amp;&apos;&apos;##&apos;,   &quot;#EC *
      FORBIDDEN_AREA_NAME_CHARS(9) VALUE &apos;\$!§%&amp;&apos;&apos;##&apos;.   &quot;#EC *</include_source>
   </include>
   <include NAME="LZLOGS_MAINTF00" SQLX="X" EDTX="X" SUBC="I" CNAM="GAOWW" CDAT="20160527" UNAM="SAP*" UDAT="20160527" VERN="000001" LEVL="701" RLOAD="E" SDATE="20160527" STIME="101128" IDATE="20160527" ITIME="101128">
    <include_source>*---------------------------------------------------------------------*
*    view related FORM routines
*   generation date: 27.05.2016 at 10:11:28 by user GAOWW
*   view maintenance generator version: #001407#
*---------------------------------------------------------------------*

* base table related FORM-routines.............
INCLUDE LSVIMFTX .</include_source>
   </include>
   <include NAME="LZLOGS_MAINTI00" SQLX="X" EDTX="X" SUBC="I" CNAM="GAOWW" CDAT="20160527" UNAM="SAP*" UDAT="20160527" VERN="000001" LEVL="701" RLOAD="E" SDATE="20160527" STIME="101128" IDATE="20160527" ITIME="101128">
    <include_source>*---------------------------------------------------------------------*
*    view related PAI modules
*   generation date: 27.05.2016 at 10:11:28 by user GAOWW
*   view maintenance generator version: #001407#
*---------------------------------------------------------------------*

INCLUDE LSVIMITX . &quot;base table related PAI modules</include_source>
   </include>
   <include NAME="LZLOGS_MAINTTOP" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" CNAM="GAOWW" CDAT="20160527" UNAM="GAOWW" UDAT="20160527" VERN="000003" RMAND="000" FIXPT="X" SDATE="20160527" STIME="101128" IDATE="20160527" ITIME="101128" LDBNAME="D$S" UCCHECK="X">
    <include_source>*---------------------------------------------------------------------*
*    generated viewmaintenance function pool top
*   generation date: 27.05.2016 at 10:11:28 by user GAOWW
*   view maintenance generator version: #001407#
*---------------------------------------------------------------------*
FUNCTION-POOL ZLOGS_MAINT                MESSAGE-ID SV.

  INCLUDE LSVIMDAT                                . &quot;general data decl.
  INCLUDE LZLOGS_MAINTT00                         . &quot;view rel. data dcl.</include_source>
   </include>
  </includeprograms>
  <functionmodules>
   <functionmodule NAME="TABLEFRAME_ZLOGS_MAINT" STEXT="Upper-level extended table maintenance">
    <importing PARAMETER="VIEW_ACTION" DEFAULT="&apos;S&apos;"/>
    <importing PARAMETER="VIEW_NAME" DBFIELD="DD02V-TABNAME"/>
    <importing PARAMETER="CORR_NUMBER" DBFIELD="E070-TRKORR" DEFAULT="&apos; &apos;"/>
    <tables PARAMETER="DBA_SELLIST" DBSTRUCT="VIMSELLIST"/>
    <tables PARAMETER="DPL_SELLIST" DBSTRUCT="VIMSELLIST"/>
    <tables PARAMETER="EXCL_CUA_FUNCT" DBSTRUCT="VIMEXCLFUN"/>
    <tables PARAMETER="X_HEADER" DBSTRUCT="VIMDESC"/>
    <tables PARAMETER="X_NAMTAB" DBSTRUCT="VIMNAMTAB"/>
    <exceptions EXCEPTION="MISSING_CORR_NUMBER"/>
    <documentation PARAMETER="VIEW_ACTION" KIND="P" STEXT="Aktion mit Tabelle: anz./änd./transp. (S/U/T)" INDEX=" 001"/>
    <documentation PARAMETER="VIEW_NAME" KIND="P" STEXT="Name der Tabelle" INDEX=" 002"/>
    <documentation PARAMETER="CORR_NUMBER" KIND="P" STEXT="Korrekturnummer für durchgeführte Änderungen" INDEX=" 003"/>
    <documentation PARAMETER="DBA_SELLIST" KIND="P" STEXT="Selektionsbedingungen für den DB-Zugriff" INDEX=" 004"/>
    <documentation PARAMETER="DPL_SELLIST" KIND="P" STEXT="Selektionsbedingungen für die Anzeige" INDEX=" 005"/>
    <documentation PARAMETER="EXCL_CUA_FUNCT" KIND="P" STEXT="Tabelle mit dynam. zu deaktivierenden CUA-Funkt." INDEX=" 006"/>
    <documentation PARAMETER="X_HEADER" KIND="P" STEXT="Kontrollblocktabelle für die Tabelle" INDEX=" 007"/>
    <documentation PARAMETER="X_NAMTAB" KIND="P" STEXT="Kontrollblocktabelle für die Tabellen-Felder" INDEX=" 008"/>
    <documentation PARAMETER="MISSING_CORR_NUMBER" KIND="X" STEXT="Korrekturnummer fehlt" INDEX=" 009"/>
    <fm_source>*---------------------------------------------------------------------*
*    program for:   TABLEFRAME_ZLOGS_MAINT
*   generation date: 27.05.2016 at 10:11:28 by user GAOWW
*   view maintenance generator version: #001407#
*---------------------------------------------------------------------*

  PERFORM TABLEFRAME TABLES X_HEADER X_NAMTAB DBA_SELLIST DPL_SELLIST
                            EXCL_CUA_FUNCT
                     USING  CORR_NUMBER VIEW_ACTION VIEW_NAME.</fm_source>
   </functionmodule>
   <functionmodule NAME="TABLEPROC_ZLOGS_MAINT" GLOBAL="X" STEXT="Lower-level extended table maintenance">
    <importing PARAMETER="FCODE" DEFAULT="&apos;RDED&apos;"/>
    <importing PARAMETER="VIEW_ACTION" DEFAULT="&apos;S&apos;"/>
    <importing PARAMETER="VIEW_NAME" DBFIELD="DD02V-TABNAME"/>
    <importing PARAMETER="CORR_NUMBER" DBFIELD="E070-TRKORR" DEFAULT="&apos; &apos;"/>
    <exporting PARAMETER="LAST_ACT_ENTRY"/>
    <exporting PARAMETER="UCOMM"/>
    <exporting PARAMETER="UPDATE_REQUIRED"/>
    <tables PARAMETER="CORR_KEYTAB" DBSTRUCT="E071K"/>
    <tables PARAMETER="DBA_SELLIST" DBSTRUCT="VIMSELLIST"/>
    <tables PARAMETER="DPL_SELLIST" DBSTRUCT="VIMSELLIST"/>
    <tables PARAMETER="EXCL_CUA_FUNCT" DBSTRUCT="VIMEXCLFUN"/>
    <tables PARAMETER="EXTRACT"/>
    <tables PARAMETER="TOTAL"/>
    <tables PARAMETER="X_HEADER" DBSTRUCT="VIMDESC"/>
    <tables PARAMETER="X_NAMTAB" DBSTRUCT="VIMNAMTAB"/>
    <exceptions EXCEPTION="MISSING_CORR_NUMBER"/>
    <exceptions EXCEPTION="SAVING_CORRECTION_FAILED"/>
    <documentation PARAMETER="FCODE" KIND="P" STEXT="gewünschte Funktion des Bausteins" INDEX=" 001"/>
    <documentation PARAMETER="VIEW_ACTION" KIND="P" STEXT="Aktion mit Tabelle: anz./änd./transp. (S/U/T)" INDEX=" 002"/>
    <documentation PARAMETER="VIEW_NAME" KIND="P" STEXT="Name der Tabelle" INDEX=" 003"/>
    <documentation PARAMETER="CORR_NUMBER" KIND="P" STEXT="Korrekturnummer für durchgeführte Änderungen" INDEX=" 004"/>
    <documentation PARAMETER="LAST_ACT_ENTRY" KIND="P" STEXT="Index der Cursorposition in der Anzeigetabelle" INDEX=" 005"/>
    <documentation PARAMETER="UCOMM" KIND="P" STEXT="letztes User-command innerhalb der Viewpflege" INDEX=" 006"/>
    <documentation PARAMETER="UPDATE_REQUIRED" KIND="P" STEXT="Flag: Einträge verändert, Sichern erforderlich" INDEX=" 007"/>
    <documentation PARAMETER="CORR_KEYTAB" KIND="P" STEXT="Tabelle mit den Keys der zu transport. Einträge" INDEX=" 008"/>
    <documentation PARAMETER="DBA_SELLIST" KIND="P" STEXT="Selektionsbedingungen für den DB-Zugriff" INDEX=" 009"/>
    <documentation PARAMETER="DPL_SELLIST" KIND="P" STEXT="Selektionsbedingungen für die Anzeige" INDEX=" 010"/>
    <documentation PARAMETER="EXCL_CUA_FUNCT" KIND="P" STEXT="Tab. der nicht zu aktivierenden CUA-Funktionen" INDEX=" 011"/>
    <documentation PARAMETER="EXTRACT" KIND="P" STEXT="Tab. der gerade sichtbaren Daten (Anzeigetabelle" INDEX=" 012"/>
    <documentation PARAMETER="TOTAL" KIND="P" STEXT="Tabelle, mit allen von der DB gelesenen Daten" INDEX=" 013"/>
    <documentation PARAMETER="X_HEADER" KIND="P" STEXT="Kontrollblocktabelle für die Tabelle" INDEX=" 014"/>
    <documentation PARAMETER="X_NAMTAB" KIND="P" STEXT="Kontrollblocktabelle für die Tabellen-Felder" INDEX=" 015"/>
    <documentation PARAMETER="MISSING_CORR_NUMBER" KIND="X" STEXT="Korrekturnummer fehlt" INDEX=" 016"/>
    <documentation PARAMETER="SAVING_CORRECTION_FAILED" KIND="X" STEXT="Fehler beim Sichern der Korrektureinträge" INDEX=" 017"/>
    <fm_source>*---------------------------------------------------------------------*
*    program for:   TABLEPROC_ZLOGS_MAINT
*   generation date: 27.05.2016 at 10:11:28 by user GAOWW
*   view maintenance generator version: #001407#
*---------------------------------------------------------------------*

  PERFORM TABLEPROC.</fm_source>
   </functionmodule>
  </functionmodules>
 </FUGR>
 <PROG NAME="ZBCLOGSINC" VARCL="X" SUBC="I" CNAM="GAOWW" CDAT="20160531" UNAM="GAOWW" UDAT="20160622" VERN="000014" LEVL="701" RSTAT="K" RMAND="000" RLOAD="E" SDATE="20160622" STIME="013109" IDATE="20160622" ITIME="013109" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Include LZLOGS_PROCF02" LENGTH="22 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; author : William.Gao
*&amp; ##### ABAP.GAOWEIWEI@GMAIL.COM
*&amp;---------------------------------------------------------------------*
  TYPE-POOLS: sydes.

  DATA : gt_logdatas  LIKE TABLE OF ztbclogs_rlgd
       , gt_paras	    LIKE TABLE OF	zsfuncparas
       , gs_logheader LIKE          ztbclogs_rlgk
       , gs_logdata   LIKE          zsfuncparas
       , gs_para      LIKE          zsfuncparas
       , g_funcname   TYPE          rs38l_fnam
       , g_id         TYPE          guid_32
       , g_serial     TYPE          sytabix   VALUE 1
       , g_fsname     TYPE          string
       , g_active
       .

  FIELD-SYMBOLS
       &lt;fs_data&gt; .

*&amp;---------------------------------------------------------------------*
*&amp;      Form  frm_build_detial
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;VALUE(P_DATA)  text
*      --&gt;REF            text
*      --&gt;TO             text
*      --&gt;DATA           text
*      --&gt;PT_DETIAL      text
*      --&gt;ENDFORM        text
*----------------------------------------------------------------------*
  FORM frm_build_detial USING value(p_id)
                              value(p_s_para) TYPE zsfuncparas
                              value(p_data)
                     CHANGING pt_detial TYPE ANY TABLE
                       .

    DATA
      : lr_typedescr  TYPE REF TO cl_abap_typedescr
      , lr_tabdescr   TYPE REF TO cl_abap_tabledescr
      , l_type        TYPE        rs38l_typ
      , l_index       TYPE        sytabix
      , ls_rlgd       TYPE        ztbclogs_rlgd
      .

*  FIELD-SYMBOLS
*    : &lt;fs_data&gt;
*    , &lt;fs_line&gt;
*    , &lt;fs_tab&gt;  TYPE STANDARD TABLE
*    .


    CHECK p_data IS NOT INITIAL.

    &quot;------------- get kind type -----------------

    PERFORM frm_get_typedescr USING p_data CHANGING lr_typedescr l_type.

    ls_rlgd-zlogsnum    = p_id                 .
    ls_rlgd-paramtype   = p_s_para-paramtype   .
    ls_rlgd-zparameter  = p_s_para-parameter   .
    ls_rlgd-zindex      = g_serial             .



    &quot;------------- process different type --------------
    CASE lr_typedescr-&gt;kind.
      WHEN cl_abap_typedescr=&gt;kind_elem. &quot;------------------

        PERFORM frm_set_elem USING    p_data
                                      cl_abap_typedescr=&gt;kind_elem
                                      p_s_para-structure  &quot;l_type
                                      g_serial
                                      &apos;&apos;  &quot; field name
                                      0
                             CHANGING ls_rlgd
                                      pt_detial.

      WHEN cl_abap_typedescr=&gt;kind_struct.&quot;------------------

        PERFORM frm_set_struc USING   p_data
                                      cl_abap_typedescr=&gt;kind_struct
                                      p_s_para-structure  &quot;l_type
                                      g_serial
                                      &apos;&apos;  &quot; field name
                                      0
                             CHANGING ls_rlgd
                                      pt_detial.



      WHEN cl_abap_typedescr=&gt;kind_table.&quot;------------------

        PERFORM frm_set_table     USING p_data
                                        cl_abap_typedescr=&gt;kind_table
                                        p_s_para-structure  &quot;l_type
                                        g_serial
                                        &apos;&apos;  &quot; field name
                                        0
                               CHANGING ls_rlgd
                                        pt_detial[].

      WHEN OTHERS.
    ENDCASE.


  ENDFORM.                    &quot;frm_build_detial


*&amp;---------------------------------------------------------------------*
*&amp;      Form  FRM_SET_ELEM
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_p_data  text
*      --&gt;P_LR_TYPEDESCR_&gt;KIND  text
*      --&gt;P_L_TYPE  text
*      --&gt;P_G_SERIAL  text
*      --&gt;P_0109   text
*      &lt;--P_LS_RLGD  text
*----------------------------------------------------------------------*
  FORM frm_set_elem  USING   p_data
                              p_kind
                              p_type
                              p_serial
                              p_fieldname
                              p_parent_ix
                     CHANGING p_s_rlgd   TYPE ztbclogs_rlgd
                              p_t_detial TYPE STANDARD TABLE.

    CHECK p_data IS NOT INITIAL.

    p_s_rlgd-para_kind  = p_kind.
    p_s_rlgd-zindex     = p_serial.
    p_s_rlgd-name_feld  = p_fieldname .
    p_s_rlgd-value      = p_data.
    p_s_rlgd-zparent_ix = p_parent_ix.
    p_s_rlgd-zreftype   = p_type.

    APPEND p_s_rlgd  TO p_t_detial.
    ADD    1         TO g_serial.

  ENDFORM.                    &quot; FRM_SET_ELEM


*&amp;---------------------------------------------------------------------*
*&amp;      Form  frm_set_struc
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_DATA       text
*      --&gt;P_KIND       text
*      --&gt;P_TYPE       text
*      --&gt;P_SERIAL     text
*      --&gt;P_FIELDNAME  text
*      --&gt;P_PARENT_IX  text
*      --&gt;P_S_RLGD     text
*      --&gt;P_T_DETIAL   text
*----------------------------------------------------------------------*
  FORM frm_set_struc   USING  p_data
                              p_kind
                              p_type
                              p_serial
                              p_fieldname
                              p_parent_ix
                     CHANGING p_s_rlgd   TYPE ztbclogs_rlgd
                              p_t_detial TYPE STANDARD TABLE .


    DATA
      : ls_compdescr  TYPE        abap_compdescr
      , l_index       TYPE        sy-tabix
      , lr_typedescr  TYPE REF TO cl_abap_typedescr
      , lr_strudescr  TYPE REF TO cl_abap_structdescr
      , l_type        TYPE        rs38l_typ
      .

    FIELD-SYMBOLS
      &lt;fs_data&gt;.
    &quot;---------- add STRUCT_BEGIN line -------------------

    l_index             = p_serial.
    p_s_rlgd-zparent_ix = p_parent_ix.

    PERFORM frm_set_elem USING    &apos;%STRUCT_BEGIN%&apos;
                                  p_kind
                                  p_type
                                  p_serial
                                  p_fieldname
                                  p_parent_ix
                         CHANGING p_s_rlgd
                                  p_t_detial.


    &quot;---------- add field iteim -----------------

    lr_strudescr ?= cl_abap_structdescr=&gt;describe_by_data( p_data ).
*
    LOOP AT lr_strudescr-&gt;components INTO  ls_compdescr .

      ASSIGN COMPONENT ls_compdescr-name OF STRUCTURE p_data TO &lt;fs_data&gt;.
      CHECK &lt;fs_data&gt; IS ASSIGNED.

      lr_typedescr ?= cl_abap_typedescr=&gt;describe_by_data( &lt;fs_data&gt; ).

      CHECK lr_typedescr IS NOT INITIAL.

      SEARCH lr_typedescr-&gt;absolute_name FOR &apos;\TYPE=&apos;.

      IF sy-subrc = 0.
        sy-fdpos = sy-fdpos + STRLEN( &apos;\TYPE=&apos; ) .
        l_type   = lr_typedescr-&gt;absolute_name+sy-fdpos.
      ENDIF.

      &quot;----------------------------------
      CASE lr_typedescr-&gt;kind.
        WHEN cl_abap_typedescr=&gt;kind_elem.

          PERFORM frm_set_elem USING    &lt;fs_data&gt;
                                        cl_abap_typedescr=&gt;kind_elem
                                        l_type
                                        g_serial
                                        ls_compdescr-name
                                        l_index
                               CHANGING p_s_rlgd
                                      p_t_detial.


        WHEN cl_abap_typedescr=&gt;kind_struct.

          PERFORM frm_set_struc USING   &lt;fs_data&gt;
                                        cl_abap_typedescr=&gt;kind_struct
                                        l_type
                                        g_serial
                                        ls_compdescr-name
                                        l_index
                               CHANGING p_s_rlgd
                                        p_t_detial[].

        WHEN cl_abap_typedescr=&gt;kind_table.

          PERFORM frm_set_table USING   &lt;fs_data&gt;
                                        cl_abap_typedescr=&gt;kind_table
                                        l_type
                                        g_serial
                                        ls_compdescr-name
                                        l_index
                               CHANGING p_s_rlgd
                                        p_t_detial[].



        WHEN OTHERS.
      ENDCASE.

      UNASSIGN &lt;fs_data&gt;.

    ENDLOOP.


    &quot;---------- add STRUCT_BEGIN line -------------------

    l_index             = p_serial.
    p_s_rlgd-zparent_ix = p_parent_ix.

    PERFORM frm_set_elem USING    &apos;%STRUCT_END%&apos;
                                  p_kind
                                  p_type
                                  p_serial
                                  p_fieldname
                                  p_parent_ix
                         CHANGING p_s_rlgd
                                  p_t_detial.


  ENDFORM.                    &quot;frm_set_struc


*&amp;---------------------------------------------------------------------*
*&amp;      Form  frm_set_table
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_DATA       text
*      --&gt;P_KIND       text
*      --&gt;P_TYPE       text
*      --&gt;P_SERIAL     text
*      --&gt;P_FIELDNAME  text
*      --&gt;P_PARENT_IX  text
*      --&gt;P_S_RLGD     text
*      --&gt;P_T_DETIAL   text
*----------------------------------------------------------------------*
  FORM frm_set_table  USING  p_data
                              p_kind
                              p_type
                              p_serial
                              p_fieldname
                              p_parent_ix
                     CHANGING p_s_rlgd   TYPE ztbclogs_rlgd
                              p_t_detial TYPE STANDARD TABLE .

    DATA
      : l_index        TYPE        sy-tabix
      , lr_typedescr   TYPE REF TO cl_abap_typedescr
      , lr_1stdescr    TYPE REF TO cl_abap_typedescr
      , ls_compdescr   TYPE        abap_compdescr
      , lr_structdescr TYPE REF TO cl_abap_structdescr
      , l_type         TYPE        rs38l_typ
      , BEGIN OF lt_comp OCCURS 0
      ,  name TYPE abap_compname
      ,  type TYPE rs38l_typ
      ,  kind TYPE abap_typecategory
      ,  END OF lt_comp
      .

    FIELD-SYMBOLS
        : &lt;fs_data&gt;
        , &lt;fs_line&gt;
        , &lt;fs_tab&gt;  TYPE STANDARD TABLE
        .

    CHECK  p_data  IS NOT INITIAL .
    ASSIGN p_data  TO &lt;fs_tab&gt;.


    &quot;---------- add table_begin line -------------------
    l_index             = p_serial.
    p_s_rlgd-zparent_ix = p_parent_ix.

    PERFORM frm_set_elem USING    &apos;%TABLE_BEGIN%&apos;
                                  p_kind
                                  p_type
                                  p_serial
                                  p_fieldname
                                  p_parent_ix
                         CHANGING p_s_rlgd
                                  p_t_detial.

    LOOP AT &lt;fs_tab&gt; ASSIGNING &lt;fs_line&gt;.

      PERFORM frm_get_typedescr USING &lt;fs_line&gt; CHANGING lr_typedescr l_type.

      &quot;----------------------------------
      CASE lr_typedescr-&gt;kind.
        WHEN cl_abap_typedescr=&gt;kind_elem.

          PERFORM frm_set_elem USING    &lt;fs_line&gt;
                                        cl_abap_typedescr=&gt;kind_elem
                                        l_type
                                        g_serial
                                        &apos;&apos;
                                        l_index
                               CHANGING p_s_rlgd
                                        p_t_detial.


        WHEN cl_abap_typedescr=&gt;kind_struct.

          PERFORM frm_set_struc USING   &lt;fs_line&gt;
                                        cl_abap_typedescr=&gt;kind_struct
                                        lt_comp-type
                                        g_serial
                                        lt_comp-name
                                        l_index
                               CHANGING p_s_rlgd
                                        p_t_detial[].


        WHEN cl_abap_typedescr=&gt;kind_table.

          PERFORM frm_set_table USING   &lt;fs_line&gt;
                                        lr_typedescr-&gt;kind
                                        l_type
                                        g_serial
                                        &apos;&apos; &quot;ls_compdescr-name
                                        l_index
                               CHANGING p_s_rlgd
                                        p_t_detial[].

        WHEN OTHERS.
      ENDCASE.

    ENDLOOP.

    &quot;---------- add table_begin line -------------------

    l_index             = p_serial.
    p_s_rlgd-zparent_ix = p_parent_ix.

    PERFORM frm_set_elem USING    &apos;%TABLE_END%&apos;
                                  p_kind
                                  p_type
                                  p_serial
                                  p_fieldname
                                  p_parent_ix
                         CHANGING p_s_rlgd
                                  p_t_detial.


  ENDFORM.                    &quot;frm_set_table


*&amp;---------------------------------------------------------------------*
*&amp;      Form  frm_get_typedescr
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;p_data       text
*      --&gt;LR_TYPEDESCR  text
*      --&gt;L_TYPE        text
*----------------------------------------------------------------------*
  FORM frm_get_typedescr USING p_data
                      CHANGING lr_typedescr TYPE REF TO cl_abap_typedescr
                               l_type.

    lr_typedescr ?= cl_abap_typedescr=&gt;describe_by_data( p_data ).

    CHECK lr_typedescr IS NOT INITIAL.

    SEARCH lr_typedescr-&gt;absolute_name FOR &apos;\TYPE=&apos;.

    IF sy-subrc = 0.
      sy-fdpos = sy-fdpos + STRLEN( &apos;\TYPE=&apos; ) .
      l_type   = lr_typedescr-&gt;absolute_name+sy-fdpos.
    ENDIF.


  ENDFORM.                    &quot;frm_get_typedescr

*&amp;---------------------------------------------------------------------*
*&amp;      Form  FRM_GET_FUNCNAME
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
  FORM frm_get_funcname CHANGING p_funcname.

    DATA: lt_callstack TYPE abap_callstack,
          ls_callstack TYPE abap_callstack_line,
          lv_fname TYPE rs38l_fnam.

    CALL FUNCTION &apos;SYSTEM_CALLSTACK&apos;
      EXPORTING
        max_level = 0
      IMPORTING
        callstack = lt_callstack.
*  delete     lt_callstack where mainprogram = sy-repid.
    READ TABLE lt_callstack INTO ls_callstack WITH KEY blocktype = &apos;FUNCTION&apos;.
    IF sy-subrc = 0.
      p_funcname = ls_callstack-blockname.
    ENDIF.

  ENDFORM.                    &quot; FRM_GET_FUNCNAME

*&amp;---------------------------------------------------------------------*
*&amp;      Form  frm_get_funcname
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_FUNCNAME text
*----------------------------------------------------------------------*
  FORM  frm_get_funcact CHANGING p_active.
    CLEAR p_active .

    SELECT SINGLE active
      INTO g_active
      FROM ztbclogs_act
     WHERE name = g_funcname.
  ENDFORM.                    &quot;frm_get_funcname
*&amp;---------------------------------------------------------------------*
*&amp;      Form  FRM_GET_FUNCPARA
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_I_FUNCNAME  text
*      &lt;--P_ET_PARAS[]  text
*----------------------------------------------------------------------*
  FORM frm_get_funcpara  USING    p_i_funcname
                         CHANGING p_et_paras TYPE STANDARD TABLE.

    REFRESH p_et_paras.

    SELECT parameter
           paramtype
           structure
      INTO TABLE p_et_paras
      FROM fupararef
     WHERE funcname = p_i_funcname
       AND r3state  = &apos;A&apos;
       .
  ENDFORM.                    &quot; FRM_GET_FUNCPARA



  &quot;----------------------------------------------------------------------------
  DEFINE save_para_data.


    refresh gt_logdatas.


    perform frm_get_funcname changing g_funcname .
    perform frm_get_funcact  changing g_active   .

    if g_active = &apos;X&apos;.
      perform frm_get_funcpara using    g_funcname changing gt_paras.

      delete gt_paras where paramtype = &apos;E&apos;.

      call function &apos;GUID_CREATE&apos;
        importing
          ev_guid_32 = g_id.


      loop at gt_paras into gs_para.

        case gs_para-paramtype. &quot; [I:import,E:export,C:changing,T:table]
          when &apos;I&apos; or &apos;C&apos;.      g_fsname = gs_para-parameter.
          when &apos;T&apos;.             concatenate gs_para-parameter  &apos;[]&apos; into g_fsname.
          when others.          continue.
        endcase.

        assign (g_fsname) to &lt;fs_data&gt;.
        perform frm_build_detial using g_id gs_para &lt;fs_data&gt; changing gt_logdatas   .
        unassign &lt;fs_data&gt;.
      endloop.

      gs_logheader-zlogsnum        = g_id.
      gs_logheader-plug_type       = &apos;0&apos;.           &quot;inbound
      gs_logheader-funcname        = g_funcname .
      gs_logheader-erdat           = sy-datum .
      gs_logheader-erzet           = sy-uzeit .
      gs_logheader-ernam           = sy-uname .
*    gs_logheader-final_stauts    =
*    gs_logheader-destination     = g_i
*    gs_logheader-externalid      = g_i
*    gs_logheader-out_url         = g_i

      modify ztbclogs_rlgk from       gs_logheader.
      modify ztbclogs_rlgd from table gt_logdatas .
      commit WORK AND WAIT.
    endif. &quot;-------- end if g_active = &apos;X&apos;. --------------

  END-OF-DEFINITION.</source>
 </PROG>
 <PROG NAME="ZBCLOGSREP" VARCL="X" SUBC="1" CNAM="GAOWW" CDAT="20160530" UNAM="GAOWW" UDAT="20160531" VERN="000206" RSTAT="K" RMAND="000" RLOAD="E" FIXPT="X" SDATE="20160602" STIME="133117" IDATE="20160531" ITIME="233936" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Program ZBCLOGSREP" LENGTH="18 "/>
    <textElement ID="S" KEY="S_DEST" ENTRY="D       ." LENGTH="23 "/>
    <textElement ID="S" KEY="S_ERDAT" ENTRY="D       ." LENGTH="18 "/>
    <textElement ID="S" KEY="S_ERNAM" ENTRY="D       ." LENGTH="18 "/>
    <textElement ID="S" KEY="S_ERZET" ENTRY="D       ." LENGTH="12 "/>
    <textElement ID="S" KEY="S_EXTERN" ENTRY="D       ." LENGTH="19 "/>
    <textElement ID="S" KEY="S_FUNCNM" ENTRY="D       ." LENGTH="23 "/>
    <textElement ID="S" KEY="S_OUTURL" ENTRY="D       ." LENGTH="11 "/>
    <textElement ID="S" KEY="S_PLUGTP" ENTRY="D       ." LENGTH="20 "/>
    <textElement ID="S" KEY="S_STAUTS" ENTRY="        Status" LENGTH="19 "/>
    <textElement ID="S" KEY="S_ZLOGNM" ENTRY="        Number" LENGTH="15 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Report  ZBCLOGSREP
*&amp;
*&amp;---------------------------------------------------------------------*
*&amp; author : William.Gao
*&amp; ##### ABAP.GAOWEIWEI@GMAIL.COM
*&amp;---------------------------------------------------------------------*

REPORT  zbclogsrep.
TYPE-POOLS:slis,icon.
TABLES ztbclogs_rlgk.




DATA
  : gt_rlgk   LIKE TABLE OF ztbclogs_rlgk
  , gt_rlgd   LIKE TABLE OF ztbclogs_rlgd
  , gt_fupa   LIKE TABLE OF fupararef
  , gt_para   LIKE TABLE OF zsfuncparas
  , gs_layout TYPE          slis_layout_alv
  , g_title   TYPE          lvc_title
  .

SELECT-OPTIONS
  : s_zlognm          FOR ztbclogs_rlgk-zlogsnum
  , s_plugtp          FOR ztbclogs_rlgk-plug_type
  , s_funcnm          FOR ztbclogs_rlgk-funcname
  , s_stauts          FOR ztbclogs_rlgk-final_stauts
  , s_dest            FOR ztbclogs_rlgk-destination
  , s_extern          FOR ztbclogs_rlgk-externalid
  , s_outurl          FOR ztbclogs_rlgk-out_url
  , s_erdat           FOR ztbclogs_rlgk-erdat
  , s_erzet           FOR ztbclogs_rlgk-erzet
  , s_ernam           FOR ztbclogs_rlgk-ernam
  .


START-OF-SELECTION.

  SELECT *
    INTO TABLE gt_rlgk
    FROM ztbclogs_rlgk
   WHERE zlogsnum       IN  s_zlognm
     AND plug_type      IN  s_plugtp
     AND funcname       IN  s_funcnm
     AND final_stauts   IN  s_stauts
     AND destination    IN  s_dest
     AND externalid     IN  s_extern
     AND out_url        IN  s_outurl
     AND erdat          IN  s_erdat
     AND erzet          IN  s_erzet
     AND ernam          IN  s_ernam
    .

END-OF-SELECTION.

  IF gt_rlgk IS INITIAL .
    MESSAGE s429(mo) DISPLAY LIKE &apos;E&apos;.
    RETURN.
  ELSE.
    PERFORM 1frm_loglist_alv.
  ENDIF.
*&amp;---------------------------------------------------------------------*
*&amp;      Form  FRM_ALV_SHOW
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM 1frm_loglist_alv.

  gs_layout-zebra             = &apos;X&apos;.
  gs_layout-colwidth_optimize = &apos;X&apos;.

  g_title = &apos;Logs List&apos;.

  CALL FUNCTION &apos;REUSE_ALV_GRID_DISPLAY&apos;
    EXPORTING
      i_callback_program      = &apos;ZBCLOGSREP&apos;
      is_layout               = gs_layout
      i_grid_title            = g_title
      i_structure_name        = &apos;ZTBCLOGS_RLGK&apos;
      i_callback_user_command = &apos;2FRM_LOGLIST_COMMAND&apos;
    TABLES
      t_outtab                = gt_rlgk
    EXCEPTIONS
      program_error           = 1
      OTHERS                  = 2.
  IF sy-subrc &lt;&gt; 0.
* MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*         WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

ENDFORM.                    &quot; FRM_ALV_SHOW


*&amp;---------------------------------------------------------------------*
*&amp;      Form  FRM_USER_COMMAND
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM 2frm_loglist_command  USING r_ucomm     LIKE sy-ucomm
                                 rs_selfield TYPE slis_selfield.

  DATA
    : lt_para     LIKE TABLE OF zsfuncparas
    , l_parameter LIKE          zsfuncparas-parameter
    .

  CASE r_ucomm.
    WHEN &apos;&amp;IC1&apos;.
      REFRESH gt_para.
      PERFORM 3frm_logdata_detial USING rs_selfield-tabindex
                               CHANGING gt_para.
      PERFORM 4frm_logdata_alv    USING gt_para.
    WHEN OTHERS.
  ENDCASE.



ENDFORM.                    &quot;FRM_USER_COMMAND


*&amp;---------------------------------------------------------------------*
*&amp;      Form  FRM_DETIAL_LOGDATA
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_TABIX    text
*----------------------------------------------------------------------*
FORM 3frm_logdata_detial USING p_tabix
                      CHANGING pt_para TYPE STANDARD TABLE.

  DATA
    : ls_rlgk  LIKE  ztbclogs_rlgk
    , ls_rlgd  LIKE  ztbclogs_rlgd
    , ls_para  LIKE  zsfuncparas
    , ls_fupa  LIKE  fupararef
    .


  g_title = &apos;Parameter Data&apos;.

  READ TABLE gt_rlgk INTO ls_rlgk INDEX p_tabix.

  CHECK sy-subrc = 0.

  SELECT *
    INTO TABLE gt_rlgd
    FROM ztbclogs_rlgd
   WHERE zlogsnum = ls_rlgk-zlogsnum
    .

  SORT gt_rlgd BY zlogsnum  zindex.

  SELECT *
    INTO TABLE gt_fupa
    FROM fupararef
   WHERE funcname = ls_rlgk-funcname
     AND r3state  = &apos;A&apos;
     .

  LOOP AT gt_fupa INTO ls_fupa.

    READ TABLE gt_rlgd INTO ls_rlgd WITH KEY zparameter = ls_fupa-parameter.

    CHECK sy-subrc = 0.

    ls_para-parameter = ls_fupa-parameter  .
    ls_para-paramtype = ls_fupa-paramtype  .

    CASE ls_rlgd-para_kind.
      WHEN cl_abap_typedescr=&gt;kind_elem.
        ls_para-structure = ls_rlgd-value.
      WHEN cl_abap_typedescr=&gt;kind_struct OR
           cl_abap_typedescr=&gt;kind_table   .
        ls_para-structure = icon_icon_list .
      WHEN OTHERS.
    ENDCASE.

    APPEND ls_para TO pt_para.
    CLEAR  ls_para .
  ENDLOOP.



ENDFORM.                    &quot;frm_detial_show
*&amp;---------------------------------------------------------------------*
*&amp;      Form  FRM_DETIAL_SHOW
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_LT_PARA  text
*----------------------------------------------------------------------*
FORM 4frm_logdata_alv  USING   pt_para TYPE STANDARD TABLE.


  CALL FUNCTION &apos;REUSE_ALV_GRID_DISPLAY&apos;
    EXPORTING
      i_callback_program      = &apos;ZBCLOGSREP&apos;
      is_layout               = gs_layout
      i_grid_title            = g_title
      i_callback_user_command = &apos;5FRM_LOGDATA_COMMAND&apos;
      i_structure_name        = &apos;ZSFUNCPARAS&apos;
    TABLES
      t_outtab                = pt_para
    EXCEPTIONS
      program_error           = 1
      OTHERS                  = 2.
  IF sy-subrc &lt;&gt; 0.
* MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*         WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

ENDFORM.                    &quot; FRM_SHOW_DETIAL

*&amp;---------------------------------------------------------------------*
*&amp;      Form  FRM_USER_COMMDETIAL
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;R_UCOMM      text
*      --&gt;RS_SELFIELD  text
*----------------------------------------------------------------------*
FORM 5frm_logdata_command   USING r_ucomm     LIKE sy-ucomm
                                  rs_selfield TYPE slis_selfield.
  DATA
    : ls_para       LIKE zsfuncparas
    , ls_rlgd       LIKE ztbclogs_rlgd
    , lt_para       LIKE TABLE OF zsfuncparas
    , lt_temp       LIKE TABLE OF zsfuncparas
    , l_parameter   LIKE zsfuncparas-parameter
    .

  CASE r_ucomm.
    WHEN &apos;&amp;IC1&apos;.
      CHECK   rs_selfield-fieldname   = &apos;STRUCTURE&apos;     .
      CHECK   rs_selfield-value       = icon_icon_list  .

      READ TABLE gt_para INTO ls_para INDEX    rs_selfield-tabindex.          CHECK sy-subrc = 0.
      IF ls_para-parameter CS &apos;-&apos;.
        SPLIT ls_para-parameter AT &apos;-&apos; INTO ls_para-parameter ls_para-parameter .
        READ TABLE gt_rlgd INTO ls_rlgd WITH KEY name_feld  = ls_para-parameter .CHECK sy-subrc = 0.
      ELSE.
        READ TABLE gt_rlgd INTO ls_rlgd WITH KEY zparameter = ls_para-parameter .CHECK sy-subrc = 0.
      ENDIF.

      CASE ls_rlgd-para_kind .
        WHEN  cl_abap_typedescr=&gt;kind_table.
          PERFORM 6frm_logtable_alv   USING rs_selfield-tabindex.
        WHEN cl_abap_typedescr=&gt;kind_struct.

          PERFORM 7frm_logstruct_alv  USING rs_selfield-tabindex
                                   CHANGING lt_para.
          lt_temp = gt_para.
          gt_para = lt_para.
          PERFORM 4frm_logdata_alv    USING lt_para.
          gt_para = lt_temp.
        WHEN OTHERS.
      ENDCASE.

    WHEN OTHERS.
  ENDCASE.


ENDFORM.                    &quot;FRM_USER_COMMDETIAL
*&amp;---------------------------------------------------------------------*
*&amp;      Form  FRM_SHOW_DETIAL_DATA
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_RS_SELFIELD_TABINDEX  text
*----------------------------------------------------------------------*
FORM 6frm_logtable_alv  USING    p_tabix.

  DATA
    : ls_para       LIKE        zsfuncparas
    , ls_fupa       LIKE        fupararef
    , ls_rlgd       LIKE        ztbclogs_rlgd
    , ls_struc      TYPE REF TO data
    , lt_dyn_table  TYPE REF TO data
    , lr_typedescr  TYPE REF TO cl_abap_typedescr
    , lt_lvc_fcat   TYPE        lvc_t_fcat
    , l_stname      LIKE        dd02l-tabname
    .

  DATA
    : l_ref_tab   TYPE REF TO data
    , l_ref_wa    TYPE REF TO data
    .

  FIELD-SYMBOLS
    : &lt;fs_tab&gt; TYPE STANDARD TABLE
    , &lt;fs_wa&gt;
    , &lt;fs_val&gt;
    .

  READ TABLE gt_para INTO ls_para INDEX p_tabix.

  CHECK sy-subrc = 0.

  CONCATENATE &apos;Table Contant :&apos;
              ls_para-parameter
         INTO g_title.


  IF ls_para-parameter CS &apos;-&apos;.
    SPLIT ls_para-parameter AT &apos;-&apos; INTO ls_para-parameter ls_para-parameter.
    READ TABLE gt_rlgd INTO ls_rlgd WITH KEY name_feld  = ls_para-parameter.CHECK sy-subrc = 0.
  ELSE.
    READ TABLE gt_rlgd INTO ls_rlgd WITH KEY zparameter  = ls_para-parameter.CHECK sy-subrc = 0.
  ENDIF.

  l_stname = ls_rlgd-zreftype.

  &quot;----------------- create dyn table ----------------------------------
  DATA
    : ls_ddtypes LIKE ddtypes .

  SELECT SINGLE *
    INTO ls_ddtypes
    FROM ddtypes
   WHERE typename = l_stname
     AND state    = &apos;A&apos;
     .

  IF ls_ddtypes-typekind = &apos;TTYP&apos;.
    SELECT SINGLE rowtype
      INTO l_stname
      FROM dd40l
     WHERE typename = l_stname
       AND as4local = &apos;A&apos;.
  ENDIF.

  CALL FUNCTION &apos;LVC_FIELDCATALOG_MERGE&apos;
    EXPORTING
      i_structure_name       = l_stname
    CHANGING
      ct_fieldcat            = lt_lvc_fcat
    EXCEPTIONS
      inconsistent_interface = 1
      program_error          = 2
      OTHERS                 = 3.
  IF sy-subrc &lt;&gt; 0.

  ENDIF.

  CALL METHOD cl_alv_table_create=&gt;create_dynamic_table
    EXPORTING
      it_fieldcatalog = lt_lvc_fcat
    IMPORTING
      ep_table        = l_ref_tab.

  ASSIGN l_ref_tab-&gt;* TO &lt;fs_tab&gt;.

  CREATE DATA l_ref_wa LIKE LINE OF &lt;fs_tab&gt;.
  ASSIGN l_ref_wa-&gt;* TO &lt;fs_wa&gt;.



  &quot;----------------- fill data -------------------------------------
  DATA
    : l_zparent_ix  TYPE ztbclogs_rlgd-zparent_ix
    .

  LOOP AT gt_rlgd INTO ls_rlgd FROM ls_rlgd-zindex. &quot;WHERE zparameter = ls_fupa-parameter.

    IF ls_rlgd-name_feld IS NOT INITIAL.
      ASSIGN COMPONENT ls_rlgd-name_feld OF STRUCTURE &lt;fs_wa&gt; TO &lt;fs_val&gt;.

      IF sy-subrc = 0 .
        &lt;fs_val&gt; = ls_rlgd-value.
      ELSE.
        IF ls_rlgd-value CP &apos;%*_BEGIN%&apos;.
          CONTINUE.
        ENDIF.
      ENDIF.

    ENDIF.

    IF ls_rlgd-value = &apos;%STRUCT_END%&apos;.
      APPEND &lt;fs_wa&gt; TO &lt;fs_tab&gt;.
      CLEAR  &lt;fs_wa&gt; .
    ENDIF.

    IF ls_rlgd-value = &apos;%TABLE_END%&apos;.
      EXIT.
    ENDIF.

  ENDLOOP.

  &quot;--------------- show data --------------------------------------
  CALL FUNCTION &apos;REUSE_ALV_GRID_DISPLAY&apos;
    EXPORTING
      i_callback_program = &apos;ZBCLOGSREP&apos;
      is_layout          = gs_layout
      i_grid_title       = g_title
      i_structure_name   = l_stname
    TABLES
      t_outtab           = &lt;fs_tab&gt;
    EXCEPTIONS
      program_error      = 1
      OTHERS             = 2.
  IF sy-subrc &lt;&gt; 0.
* MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*         WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

ENDFORM.                    &quot; FRM_SHOW_DETIAL_DATA


*&amp;---------------------------------------------------------------------*
*&amp;      Form  FRM_SHOW_STRUCT_DATA
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_RS_SELFIELD_TABINDEX  text
*----------------------------------------------------------------------*
FORM 7frm_logstruct_alv USING p_tabix
                     CHANGING pt_para TYPE STANDARD TABLE.

  DATA
    : ls_para       LIKE       zsfuncparas
    , ls_fupa       LIKE       fupararef
    , ls_rlgd       LIKE       ztbclogs_rlgd
    , l_index       TYPE       i
    .


  READ TABLE gt_para INTO ls_para INDEX p_tabix.
  CHECK sy-subrc = 0.

  READ TABLE gt_fupa INTO ls_fupa WITH KEY parameter = ls_para-parameter .
  CHECK sy-subrc = 0.

  READ TABLE gt_rlgd INTO ls_rlgd WITH KEY zparameter = ls_fupa-parameter.
  CHECK sy-subrc = 0.


  CONCATENATE &apos;Structure Contant :&apos;
              ls_para-parameter
         INTO g_title.


  l_index = ls_rlgd-zindex.

  LOOP AT gt_rlgd INTO ls_rlgd WHERE zparent_ix = l_index.
    CONCATENATE ls_rlgd-zparameter &apos;-&apos;
                ls_rlgd-name_feld
           INTO ls_para-parameter .

    ls_para-paramtype    = ls_rlgd-para_kind    .

    IF ls_rlgd-value CP &apos;%*_BEGIN%&apos; OR
       ls_rlgd-value CP &apos;%*_END%&apos;   .
      ls_para-structure  = icon_icon_list.
    ELSE.
      ls_para-structure  = ls_rlgd-value.
    ENDIF.

    COLLECT ls_para INTO pt_para.
  ENDLOOP.


ENDFORM.                    &quot; FRM_SHOW_STRUCT_DATA</source>
 </PROG>
 <TABL TABNAME="ZTBCLOGS_RLGK" DDLANGUAGE="E" TABCLASS="TRANSP" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" CLIDEP="X" DDTEXT="Log General Header" AUTHCLASS="00" AS4USER="GAOWW" AS4DATE="20160602" AS4TIME="133110" CONTFLAG="A" PROZPUFF="000" EXCLASS="0">
  <dd09l TABNAME="ZTBCLOGS_RLGK" AS4LOCAL="A" AS4VERS="0000" TABKAT="7" TABART="APPL0" SCHFELDANZ="000" AS4USER="GAOWW" AS4DATE="20160602" AS4TIME="133110" BUFALLOW="N"/>
  <dd03p TABNAME="ZTBCLOGS_RLGK" FIELDNAME="MANDT" DDLANGUAGE="E" POSITION="0001" KEYFLAG="X" ROLLNAME="MANDT" ADMINFIELD="0" INTTYPE="C" INTLEN="000003" NOTNULL="X" DOMNAME="MANDT" ROUTPUTLEN="000000" HEADLEN="03" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CLNT" LENG="000003" OUTPUTLEN="000003" DECIMALS="000000" ENTITYTAB="T000" MASK="  CLNTE" MASKLEN="0000" DDTEXT="Client" REPTEXT="Cl." SCRTEXT_S="Client" SCRTEXT_M="Client" SCRTEXT_L="Client" DOMNAME3L="MANDT" DEPTH="00" COMPTYPE="E" DEFFDNAME="CLIENT" EXCLASS="0" DBPOSITION="0000"/>
  <dd03p TABNAME="ZTBCLOGS_RLGK" FIELDNAME="ZLOGSNUM" DDLANGUAGE="E" POSITION="0002" KEYFLAG="X" ROLLNAME="APB_LPD_GUID" ADMINFIELD="0" INTTYPE="C" INTLEN="000032" NOTNULL="X" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="E" DATATYPE="CHAR" LENG="000032" OUTPUTLEN="000032" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="GUID" REPTEXT="GUID" SCRTEXT_S="GUID" SCRTEXT_M="GUID" SCRTEXT_L="GUID" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000"/>
  <dd03p TABNAME="ZTBCLOGS_RLGK" FIELDNAME="PLUG_TYPE" DDLANGUAGE="E" POSITION="0003" ROLLNAME="WDY_PLUG_TYPE" ADMINFIELD="0" INTTYPE="N" INTLEN="000001" DOMNAME="WDY_PLUG_TYPE" ROUTPUTLEN="000000" HEADLEN="26" SCRLEN1="08" SCRLEN2="15" SCRLEN3="15" DTELMASTER="D" DATATYPE="NUMC" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  NUMCE" MASKLEN="0000" DDTEXT="Web Dynpro: Plug Type" REPTEXT="Web Dynpro Applic. Type" SCRTEXT_S="ApplType" SCRTEXT_M="Applic. Type" SCRTEXT_L="Applic. Type" DOMNAME3L="WDY_PLUG_TYPE" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000"/>
  <dd03p TABNAME="ZTBCLOGS_RLGK" FIELDNAME="FUNCNAME" DDLANGUAGE="E" POSITION="0004" ROLLNAME="RS38L_FNAM" ADMINFIELD="0" INTTYPE="C" INTLEN="000030" DOMNAME="FUNCNAME" ROUTPUTLEN="000000" MEMORYID="LIB" HEADLEN="55" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="TFDIR" MASK="  CHARE" MASKLEN="0000" DDTEXT="Name of Function Module" REPTEXT="Function Module Name" SCRTEXT_S="FM Name" SCRTEXT_M="Function Module" SCRTEXT_L="Function Module" DOMNAME3L="FUNCNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000"/>
  <dd03p TABNAME="ZTBCLOGS_RLGK" FIELDNAME="FINAL_STAUTS" DDLANGUAGE="E" POSITION="0005" ROLLNAME="SWFMIG_STEP_STATUS" ADMINFIELD="0" INTTYPE="C" INTLEN="000001" DOMNAME="SWFMIG_STEP_STATUS" ROUTPUTLEN="000000" HEADLEN="11" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="E" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="STEP STATUS" REPTEXT="STEP STATUS" SCRTEXT_S="STEP STAT" SCRTEXT_M="STEP STATUS" SCRTEXT_L="STEP STATUS" DOMNAME3L="SWFMIG_STEP_STATUS" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000"/>
  <dd03p TABNAME="ZTBCLOGS_RLGK" FIELDNAME="DESTINATION" DDLANGUAGE="E" POSITION="0006" ROLLNAME="RFCDEST" ADMINFIELD="0" INTTYPE="C" INTLEN="000032" DOMNAME="RFCDEST" ROUTPUTLEN="000000" MEMORYID="RFC" HEADLEN="15" SCRLEN1="05" SCRLEN2="11" SCRLEN3="15" DTELMASTER="D" DATATYPE="CHAR" LENG="000032" OUTPUTLEN="000032" DECIMALS="000000" LOWERCASE="X" ENTITYTAB="RFCDES" MASK="  CHARE" MASKLEN="0000" DDTEXT="Logical Destination (Specified in Function Call)" REPTEXT="RFC Destination" SCRTEXT_S="Dest." SCRTEXT_M="Destination" SCRTEXT_L="RFC Destination" DOMNAME3L="RFCDEST" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000"/>
  <dd03p TABNAME="ZTBCLOGS_RLGK" FIELDNAME="EXTERNALID" DDLANGUAGE="E" POSITION="0007" ROLLNAME="COMT_SCE_GUID_EXTERN_MD" ADMINFIELD="0" INTTYPE="C" INTLEN="000032" DOMNAME="SYSUUID_C" ROUTPUTLEN="000000" HEADLEN="35" SCRLEN1="06" SCRLEN2="09" SCRLEN3="11" DTELMASTER="D" DATATYPE="CHAR" LENG="000032" OUTPUTLEN="000032" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="External 32 Digit GUID" REPTEXT="32 Digit Representation of GUID" SCRTEXT_S="SCEG32" SCRTEXT_M="SCEGUID32" SCRTEXT_L="SCE_GUID_32" DOMNAME3L="SYSUUID_C" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000"/>
  <dd03p TABNAME="ZTBCLOGS_RLGK" FIELDNAME="OUT_URL" DDLANGUAGE="E" POSITION="0008" ROLLNAME="URL" ADMINFIELD="0" INTTYPE="C" INTLEN="000132" DOMNAME="TEXT132" ROUTPUTLEN="000000" LOGFLAG="X" HEADLEN="03" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000132" OUTPUTLEN="000132" DECIMALS="000000" LOWERCASE="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Uniform resource locator" REPTEXT="URL" SCRTEXT_S="URL" SCRTEXT_M="URL" SCRTEXT_L="URL" DOMNAME3L="TEXT132" DEPTH="00" COMPTYPE="E" DEFFDNAME="URL" EXCLASS="0" DBPOSITION="0000"/>
  <dd03p TABNAME="ZTBCLOGS_RLGK" FIELDNAME="ERDAT" DDLANGUAGE="E" POSITION="0009" ROLLNAME="ERDAT" ADMINFIELD="0" INTTYPE="D" INTLEN="000008" DOMNAME="DATUM" ROUTPUTLEN="000000" HEADLEN="10" SCRLEN1="05" SCRLEN2="13" SCRLEN3="20" DTELMASTER="D" DATATYPE="DATS" LENG="000008" OUTPUTLEN="000010" DECIMALS="000000" MASK="  DATSE" MASKLEN="0000" DDTEXT="Date on which the record was created" REPTEXT="Created on" SCRTEXT_S="On" SCRTEXT_M="Created on" SCRTEXT_L="Created on" DOMNAME3L="DATUM" SHLPORIGIN="T" DEPTH="00" COMPTYPE="E" DEFFDNAME="CR_ON" EXCLASS="0" DBPOSITION="0000"/>
  <dd03p TABNAME="ZTBCLOGS_RLGK" FIELDNAME="ERZET" DDLANGUAGE="E" POSITION="0010" ROLLNAME="UZEIT" ADMINFIELD="0" INTTYPE="T" INTLEN="000006" DOMNAME="UZEIT" ROUTPUTLEN="000000" HEADLEN="08" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DATATYPE="TIMS" LENG="000006" OUTPUTLEN="000008" DECIMALS="000000" MASK="  TIMSE" MASKLEN="0000" DDTEXT="Time" REPTEXT="Time" SCRTEXT_S="Time" SCRTEXT_M="Time" SCRTEXT_L="Time" DOMNAME3L="UZEIT" SHLPORIGIN="T" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000"/>
  <dd03p TABNAME="ZTBCLOGS_RLGK" FIELDNAME="ERNAM" DDLANGUAGE="E" POSITION="0011" ROLLNAME="ERNAM" ADMINFIELD="0" INTTYPE="C" INTLEN="000012" DOMNAME="USNAM" ROUTPUTLEN="000000" HEADLEN="12" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000012" OUTPUTLEN="000012" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Name of Person who Created the Object" REPTEXT="Created by" SCRTEXT_S="Created" SCRTEXT_M="Created by" SCRTEXT_L="Created by" DOMNAME3L="USNAM" DEPTH="00" COMPTYPE="E" DEFFDNAME="CREATED_BY" EXCLASS="0" DBPOSITION="0000"/>
 </TABL>
 <TABL TABNAME="ZTBCLOGS_RLGD" DDLANGUAGE="E" TABCLASS="TRANSP" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" CLIDEP="X" DDTEXT="Detial Data for Log" AUTHCLASS="00" AS4USER="GAOWW" AS4DATE="20160602" AS4TIME="133117" CONTFLAG="A" PROZPUFF="000" EXCLASS="0">
  <dd09l TABNAME="ZTBCLOGS_RLGD" AS4LOCAL="A" AS4VERS="0000" TABKAT="8" TABART="APPL0" SCHFELDANZ="000" AS4USER="GAOWW" AS4DATE="20160602" AS4TIME="133117" BUFALLOW="N"/>
  <dd03p TABNAME="ZTBCLOGS_RLGD" FIELDNAME="MANDT" DDLANGUAGE="E" POSITION="0001" KEYFLAG="X" ROLLNAME="MANDT" ADMINFIELD="0" INTTYPE="C" INTLEN="000003" NOTNULL="X" DOMNAME="MANDT" ROUTPUTLEN="000000" HEADLEN="03" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CLNT" LENG="000003" OUTPUTLEN="000003" DECIMALS="000000" ENTITYTAB="T000" MASK="  CLNTE" MASKLEN="0000" DDTEXT="Client" REPTEXT="Cl." SCRTEXT_S="Client" SCRTEXT_M="Client" SCRTEXT_L="Client" DOMNAME3L="MANDT" DEPTH="00" COMPTYPE="E" DEFFDNAME="CLIENT" EXCLASS="0" DBPOSITION="0000"/>
  <dd03p TABNAME="ZTBCLOGS_RLGD" FIELDNAME="ZLOGSNUM" DDLANGUAGE="E" POSITION="0002" KEYFLAG="X" ROLLNAME="APB_LPD_GUID" ADMINFIELD="0" INTTYPE="C" INTLEN="000032" NOTNULL="X" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="E" DATATYPE="CHAR" LENG="000032" OUTPUTLEN="000032" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="GUID" REPTEXT="GUID" SCRTEXT_S="GUID" SCRTEXT_M="GUID" SCRTEXT_L="GUID" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000"/>
  <dd03p TABNAME="ZTBCLOGS_RLGD" FIELDNAME="ZINDEX" DDLANGUAGE="E" POSITION="0003" KEYFLAG="X" ROLLNAME="SYTABIX" ADMINFIELD="0" INTTYPE="X" INTLEN="000004" NOTNULL="X" DOMNAME="SYST_LONG" ROUTPUTLEN="000000" HEADLEN="10" SCRLEN1="10" SCRLEN2="20" SCRLEN3="20" DTELMASTER="D" DATATYPE="INT4" LENG="000010" OUTPUTLEN="000011" DECIMALS="000000" SIGNFLAG="X" MASK="  INT4E" MASKLEN="0000" DDTEXT="Index of Internal Tables" REPTEXT="Row" SCRTEXT_S="Row" SCRTEXT_M="Table Row" SCRTEXT_L="Table Row" DOMNAME3L="SYST_LONG" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000"/>
  <dd03p TABNAME="ZTBCLOGS_RLGD" FIELDNAME="PARAMTYPE" DDLANGUAGE="E" POSITION="0004" ROLLNAME="RS38L_KIND" ADMINFIELD="0" INTTYPE="C" INTLEN="000001" DOMNAME="RS38L_KIND" ROUTPUTLEN="000000" HEADLEN="55" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Parameter type" REPTEXT="Parameter type" SCRTEXT_S="Par. Type" SCRTEXT_M="Parameter type" SCRTEXT_L="Parameter type" DOMNAME3L="RS38L_KIND" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000"/>
  <dd03p TABNAME="ZTBCLOGS_RLGD" FIELDNAME="ZPARAMETER" DDLANGUAGE="E" POSITION="0005" ROLLNAME="RS38L_PAR_" ADMINFIELD="0" INTTYPE="C" INTLEN="000030" DOMNAME="RS38L_PARA" ROUTPUTLEN="000000" HEADLEN="55" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Parameter name" REPTEXT="Parameter name" SCRTEXT_S="Param.name" SCRTEXT_M="Parameter Name" SCRTEXT_L="Parameter Name" DOMNAME3L="RS38L_PARA" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000"/>
  <dd03p TABNAME="ZTBCLOGS_RLGD" FIELDNAME="NAME_FELD" DDLANGUAGE="E" POSITION="0006" ROLLNAME="NAME_FELD" ADMINFIELD="0" INTTYPE="C" INTLEN="000030" DOMNAME="FDNAME" ROUTPUTLEN="000000" MEMORYID="DFD" HEADLEN="10" SCRLEN1="10" SCRLEN2="15" SCRLEN3="18" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="DD03L" MASK="  CHARE" MASKLEN="0000" DDTEXT="Field name" REPTEXT="Field name" SCRTEXT_S="Field name" SCRTEXT_M="Field name" SCRTEXT_L="Field name" DOMNAME3L="FDNAME" DEPTH="00" COMPTYPE="E" DEFFDNAME="FIELD_NAME" EXCLASS="0" DBPOSITION="0000"/>
  <dd03p TABNAME="ZTBCLOGS_RLGD" FIELDNAME="VALUE" DDLANGUAGE="E" POSITION="0007" ROLLNAME="UMGAFLDVAL" ADMINFIELD="0" INTTYPE="C" INTLEN="000100" DOMNAME="UMGOFLDVAL" ROUTPUTLEN="000000" HEADLEN="55" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="E" DATATYPE="CHAR" LENG="000100" OUTPUTLEN="000100" DECIMALS="000000" LOWERCASE="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Field value" REPTEXT="Value" SCRTEXT_S="Value" SCRTEXT_M="Field value" SCRTEXT_L="Field value" DOMNAME3L="UMGOFLDVAL" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000"/>
  <dd03p TABNAME="ZTBCLOGS_RLGD" FIELDNAME="PARA_KIND" DDLANGUAGE="E" POSITION="0008" ADMINFIELD="0" INTTYPE="C" INTLEN="000001" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000000" DECIMALS="000000" MASK="  CHAR" MASKLEN="0000" DDTEXT="S:Structure  T:Table  E:Element" DEPTH="00" EXCLASS="0" DBPOSITION="0000"/>
  <dd03p TABNAME="ZTBCLOGS_RLGD" FIELDNAME="ZREFTYPE" DDLANGUAGE="E" POSITION="0009" ROLLNAME="RS38L_TYP" ADMINFIELD="0" INTTYPE="C" INTLEN="000132" DOMNAME="RS38L_TYP" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000132" OUTPUTLEN="000132" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Associated Type of an Interface Parameter" REPTEXT="Associated Type" SCRTEXT_S="Assoc.Type" SCRTEXT_M="Associated Type" SCRTEXT_L="Associated Type" DOMNAME3L="RS38L_TYP" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000"/>
  <dd03p TABNAME="ZTBCLOGS_RLGD" FIELDNAME="ZPARENT_IX" DDLANGUAGE="E" POSITION="0010" ROLLNAME="SYTABIX" ADMINFIELD="0" INTTYPE="X" INTLEN="000004" DOMNAME="SYST_LONG" ROUTPUTLEN="000000" HEADLEN="10" SCRLEN1="10" SCRLEN2="20" SCRLEN3="20" DTELMASTER="D" DATATYPE="INT4" LENG="000010" OUTPUTLEN="000011" DECIMALS="000000" SIGNFLAG="X" MASK="  INT4E" MASKLEN="0000" DDTEXT="Index of Internal Tables" REPTEXT="Row" SCRTEXT_S="Row" SCRTEXT_M="Table Row" SCRTEXT_L="Table Row" DOMNAME3L="SYST_LONG" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000"/>
 </TABL>
 <TABL TABNAME="ZTBCLOGS_ACT" DDLANGUAGE="E" TABCLASS="TRANSP" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" CLIDEP="X" DDTEXT="Active status for logs" AUTHCLASS="00" AS4USER="GAOWW" AS4DATE="20160527" AS4TIME="100758" MAINFLAG="X" CONTFLAG="A" PROZPUFF="000" EXCLASS="0">
  <dd09l TABNAME="ZTBCLOGS_ACT" AS4LOCAL="A" AS4VERS="0000" TABKAT="0" TABART="APPL0" SCHFELDANZ="000" PROTOKOLL="X" AS4USER="GAOWW" AS4DATE="20160527" AS4TIME="100758" BUFALLOW="N"/>
  <dd03p TABNAME="ZTBCLOGS_ACT" FIELDNAME="MANDT" DDLANGUAGE="E" POSITION="0001" KEYFLAG="X" ROLLNAME="MANDT" ADMINFIELD="0" INTTYPE="C" INTLEN="000003" NOTNULL="X" DOMNAME="MANDT" ROUTPUTLEN="000000" HEADLEN="03" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CLNT" LENG="000003" OUTPUTLEN="000003" DECIMALS="000000" ENTITYTAB="T000" MASK="  CLNTE" MASKLEN="0000" DDTEXT="Client" REPTEXT="Cl." SCRTEXT_S="Client" SCRTEXT_M="Client" SCRTEXT_L="Client" DOMNAME3L="MANDT" DEPTH="00" COMPTYPE="E" DEFFDNAME="CLIENT" EXCLASS="0" DBPOSITION="0000"/>
  <dd03p TABNAME="ZTBCLOGS_ACT" FIELDNAME="NAME" DDLANGUAGE="E" POSITION="0002" KEYFLAG="X" ROLLNAME="RS38L_FNAM" ADMINFIELD="0" INTTYPE="C" INTLEN="000030" NOTNULL="X" DOMNAME="FUNCNAME" ROUTPUTLEN="000000" MEMORYID="LIB" HEADLEN="55" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="TFDIR" MASK="  CHARE" MASKLEN="0000" DDTEXT="Name of Function Module" REPTEXT="Function Module Name" SCRTEXT_S="FM Name" SCRTEXT_M="Function Module" SCRTEXT_L="Function Module" DOMNAME3L="FUNCNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000"/>
  <dd03p TABNAME="ZTBCLOGS_ACT" FIELDNAME="ACTIVE" DDLANGUAGE="E" POSITION="0003" ROLLNAME="AKTIVJN_BA" ADMINFIELD="0" INTTYPE="C" INTLEN="000001" DOMNAME="XFELD" ROUTPUTLEN="000000" HEADLEN="06" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Flag: active" REPTEXT="Active" SCRTEXT_S="active" SCRTEXT_M="Active" SCRTEXT_L="Active" DOMNAME3L="XFELD" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000"/>
 </TABL>
 <TABL TABNAME="ZSFUNCPARAS" DDLANGUAGE="E" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" DDTEXT="function parameters" AUTHCLASS="00" AS4USER="GAOWW" AS4DATE="20160527" AS4TIME="092409" PROZPUFF="000" EXCLASS="0">
  <dd09l AS4VERS="0000" SCHFELDANZ="000" AS4DATE="00000000" AS4TIME="000000"/>
  <dd03p TABNAME="ZSFUNCPARAS" FIELDNAME="PARAMETER" DDLANGUAGE="E" POSITION="0001" ROLLNAME="RS38L_PAR_" ADMINFIELD="0" INTTYPE="C" INTLEN="000030" DOMNAME="RS38L_PARA" ROUTPUTLEN="000000" HEADLEN="55" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Parameter name" REPTEXT="Parameter name" SCRTEXT_S="Param.name" SCRTEXT_M="Parameter Name" SCRTEXT_L="Parameter Name" DOMNAME3L="RS38L_PARA" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000"/>
  <dd03p TABNAME="ZSFUNCPARAS" FIELDNAME="PARAMTYPE" DDLANGUAGE="E" POSITION="0002" ROLLNAME="RS38L_KIND" ADMINFIELD="0" INTTYPE="C" INTLEN="000001" DOMNAME="RS38L_KIND" ROUTPUTLEN="000000" HEADLEN="55" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Parameter type" REPTEXT="Parameter type" SCRTEXT_S="Par. Type" SCRTEXT_M="Parameter type" SCRTEXT_L="Parameter type" DOMNAME3L="RS38L_KIND" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000"/>
  <dd03p TABNAME="ZSFUNCPARAS" FIELDNAME="STRUCTURE" DDLANGUAGE="E" POSITION="0003" ROLLNAME="RS38L_TYP" ADMINFIELD="0" INTTYPE="C" INTLEN="000132" DOMNAME="RS38L_TYP" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000132" OUTPUTLEN="000132" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Associated Type of an Interface Parameter" REPTEXT="Associated Type" SCRTEXT_S="Assoc.Type" SCRTEXT_M="Associated Type" SCRTEXT_L="Associated Type" DOMNAME3L="RS38L_TYP" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000"/>
 </TABL>
</nugget>
